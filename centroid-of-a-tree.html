<!DOCTYPE html><meta charset='UTF-8'><html><head><link rel='alternate' type='application/rss+xml' href='feed.rss' title='A universe of sorts'/><link rel='stylesheet' href='katex/katex.min.css'    integrity='sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X'    crossorigin='anonymous'><!-- The loading of KaTeX is deferred to speed up page rendering --><link rel='stylesheet' href='prism/prism.css'><title> A Universe of Sorts </title><style>@font-face {font-family: 'Blog Mono'; src: url('/static/iosevka-fixed-extended.ttf');}@font-face {font-family: 'Blog Sans'; src: url('/static/Exo2-Regular.ttf');}@font-face {font-family: 'Blog Serif'; src: url('/static/Revans-Regular.ttf');}html { font-size: 100%; }html,body { text-size-adjust: none; -webkit-text-size-adjust: none; -moz-text-size-adjust: none; -ms-text-size-adjust: none; } body { background: linear-gradient(to right, #1565C0 1%, #FFFFFF 1%, #FFFFFF 99%, #E91E63 99%);  color: #000000;  font-family: 'Blog Serif', sans-serif;  font-size: 18px; line-height: 1.4em;  margin-top: 0px;  max-width: 100%; overflow-x: hidden; }
h1, h2, h3, h4, h5 { font-family: 'Blog Sans' }img { display:block; width: 100%; max-width: 800px; height: auto }.container { overflow-x: auto; overflow-y: hidden;  max-width: 80ex; text-align: justify;              margin-top: 0px; height: 100%; min-height: 100%;             padding-left: 50px; padding-right: 50px; background: #FFFFFF;}@media (max-width: 480px) {   .container { margin-left: 1%; margin-right: 1%; }  body { font-size: 30px; }  } @media (max-width: 1024px) {  .container { margin-left: 1%; margin-right: 1%; }  body { font-size: 30px; }}@media (min-width: 1024px) { .container { margin-left: 25%; margin-right: 20%; } }.image { }
a:hover { color: #1a73e8; text-decoration: underline;  }
a { color: #1a73e8; text-decoration: none; }
a:visited { color: #1a73e8; text-decoration: none; }
a:active { color: #1a73e8; text-decoration: none; }

blockquote { margin-left: 0px; margin-right: 0px; } pre, .latexblock, blockquote { border-left-color:#BBB;  border-left-style: solid;      border-left-width: 5px; }pre, blockquote { padding-left: 10px; }
pre { font-family: 'Blog Mono', monospace; font-size: 90%;  }pre {  overflow-x: auto; }.latexblock, blockquote, pre { margin-top: 10px; margin-bottom: 10px; padding-bottom: 5px; padding-top: 5px; background-color: #FFFFFF; }.latexblock { line-height: 1em }
pre, kbd, samp, tt{ font-family:'Blog Mono',monospace; }.inline { white-space: nowrap; background:#efefef; }ul, ol { list-style-position: inside; padding-left: 0; }ul { list-style-type: disclosure-closed; }</style></head><body><div class='container'><h2><a id=centroid-of-a-tree href='#centroid-of-a-tree'> § </a><span class='centered'> Centroid of a tree </h2> 
 <ul><li><span class='centered'><span class='centered'> A centroid is a node which upon removal creates subtrees of size at most  <code class='inline'>ceil(n/2)</code>. </li></ul> 
 <h4><a id=existence-of-centroid-for-rooted-tree-algorithm-to-compute-centroid href='#existence-of-centroid-for-rooted-tree-algorithm-to-compute-centroid'> § </a><span class='centered'> Existence of centroid for rooted tree (algorithm to compute centroid) </h4> 
 <ul><li><span class='centered'><span class='centered'> If tree has exactly one node, we are done, the centroid is the root. </li><li><span class='centered'><span class='centered'> Suppose for induction a centroid exists for trees of size  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span>. We will now prove the existence of a centroid for tree of size  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span></span>. </li><li><span class='centered'><span class='centered'> Otherwise, if the root has all children whose subtree sizes are at most  <code class='inline'>ceil(n/2)</code>, the root is the centroid and we are done. </li><li><span class='centered'><span class='centered'> Otherwise, the root has  <i><span class='centered'>one </i> child with subtree size  <i><span class='centered'>strictly greater than </i>  <code class='inline'>ceil(n/2)</code>. There can't be two such children, because their <span class='centered'>combined size would be  <code class='inline'>2*ceil(n/2) >= n</code>. This is nonsensical, as the size of the subtrees plus the root node would mean the tree <span class='centered'>has  <code class='inline'>2*ceil(n/2) + 1 >= n+1</code> nodes, a contradiction. </li><li><span class='centered'><span class='centered'> We recurse into the subtree. The size of the subtree of the child is at least one less than the size of the root, thus we are decreasing on the size of the tree. </li><li><span class='centered'><span class='centered'> By recursion, we must terminate this process and find a centroid. </li></ul> 
 <h4><a id=centroid-decomposition href='#centroid-decomposition'> § </a><span class='centered'> Centroid decomposition </h4> 
 <ul><li><span class='centered'><span class='centered'> Once we find the centroid of a tree, we see that all of its subtrees has size less than  <code class='inline'>ceil(n/2)</code>. </li><li><span class='centered'><span class='centered'> We can now recurse, and find sizes of centroids of these subtrees. </li><li><span class='centered'><span class='centered'> These subtrees are disjoint, so we will take at most  <code class='inline'>O(n)</code> to compute sizes and whatnot.  </li><li><span class='centered'><span class='centered'> We can do this  <code class='inline'>log(n)</code> many steps since we're halving the size of the subtree each time.  </li><li><span class='centered'><span class='centered'> In total, this implies that we can recursively find centroids to arrive at a "centroid decomposition" of a tree. </li><li><span class='centered'><span class='centered'> Note that the centroid decomposition of the tree constructs a new tree, which is different from the original tree, sorta how the dominator tree <span class='centered'>is a different tree from the original tree. </li></ul> 
 <script src="https://utteranc.es/client.js"        repo="bollu/bollu.github.io"        issue-term="pathname"        label="question"        theme="github-light"        crossorigin="anonymous"        async></script></container></body></html>