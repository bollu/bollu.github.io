<!DOCTYPE html><meta charset='UTF-8'><html><head><link rel='alternate' type='application/rss+xml' href='feed.rss' title='A universe of sorts'/><link rel='stylesheet' href='katex/katex.min.css'    integrity='sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X'    crossorigin='anonymous'><!-- The loading of KaTeX is deferred to speed up page rendering --><link rel='stylesheet' href='prism/prism.css'><title> A Universe of Sorts </title><style>@font-face {font-family: 'Blog Mono'; src: url('/static/iosevka-fixed-extended.ttf');}@font-face {font-family: 'Blog Sans'; src: url('/static/Exo2-Regular.ttf');}@font-face {font-family: 'Blog Serif'; src: url('/static/Revans-Regular.ttf');}html { font-size: 100%; }html,body { text-size-adjust: none; -webkit-text-size-adjust: none; -moz-text-size-adjust: none; -ms-text-size-adjust: none; } body { background: linear-gradient(to right, #1565C0 0%, #1565C0 50%, #E91E63 50%,   #E91E63 99%);  color: #000000;  font-family: Tahoma, 'Blog Serif', serif;  font-size: 14px;  margin-top: 0px;  max-width: 100%; overflow-x: hidden; }
h1, h2, h3, h4, h5 { font-family: Tahoma, 'Blog Mono', monospace; }img { display:block; width: 100%; max-width: 800px; height: auto }.container { overflow-x: auto; overflow-y: hidden;  max-width: 80ex; text-align: justify;              margin-top: 0px; height: 100%; min-height: 100%;             padding-left: 50px; padding-right: 50px; background: #FFFFFF;}@media (max-width: 480px) {   .container { margin-left: 1%; margin-right: 1%; }  body { font-size: 30px; }  } @media (max-width: 1024px) {  .container { margin-left: 1%; margin-right: 1%; }  body { font-size: 30px; }}@media (min-width: 1024px) { .container { margin-left: 25%; margin-right: 20%; } }.image { }
a:hover { color: #1a73e8; text-decoration: underline;  }
a { color: #1a73e8; text-decoration: none; }
a:visited { color: #1a73e8; text-decoration: none; }
a:active { color: #1a73e8; text-decoration: none; }

blockquote { margin-left: 0px; margin-right: 0px; } pre, .latexblock, blockquote { border-left-color:#BBB;  border-left-style: solid;      border-left-width: 5px; }pre, blockquote { padding-left: 10px; }
pre { font-family: 'Blog Mono', monospace; font-size: 90%;  }pre {  overflow-x: auto; }.latexblock, blockquote, pre { margin-top: 10px; margin-bottom: 10px; padding-bottom: 5px; padding-top: 5px; background-color: #FFFFFF; }.latexblock { line-height: 1em }
pre, kbd, samp, tt{ font-family:'Blog Mono',monospace; }.inline { white-space: nowrap; background:#efefef; }ul, ol { list-style-position: inside; padding-left: 0; }ul { list-style-type: disclosure-closed; }</style></head><body><div class='container'><h2><a id=semidirect-product-panning-and-zooming href='#semidirect-product-panning-and-zooming'> § </a><span class='centered'> Semidirect product: Panning and Zooming </h2> 
 <ul><li><span class='centered'><span class='centered'> I think I finally have an example of a semidirect product that I understand well enough I'd dare to teach a friend. </li><li><span class='centered'><span class='centered'> Take the real line. We can move points on it by adding them (panning). Viewed differently, we can  <i><span class='centered'>pan </i> the real line left and right, <span class='centered'>by the action of the real line on itself. This is a group  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>≃</mo><mo stretchy="false">(</mo><mi mathvariant="double-struck">R</mi><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mo>+</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P \simeq (\mathbb R, 0, +)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathbb">R</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">+</span><span class="mclose">)</span></span></span></span></span> ( <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></span> for pan). <span class='centered'>I'll draw the line as follows: </li></ul> 
 <pre><code>  ^
  |
  |
  0
  |
  |
  v
</code></pre> <span class='centered'> - Next, we can  <i><span class='centered'>zoom </i> the real line by multiplication: So given a number, I can scale the entire real line by this number.  
 <span class='centered'>    This group of zoom operations is  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi><mo>≃</mo><mo stretchy="false">(</mo><mi mathvariant="double-struck">R</mi><mo separator="true">,</mo><mo>×</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Z \simeq (\mathbb R, \times 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathbb">R</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">×</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>.I'll show this by stacking copies of the real line next to each other:  
 <pre><code>    ^
    |       ^
    |       |        ^
Z---[z=1]---[z=1/2]--[z=1/4]----...
    |       |        V
    |       V        P
    v       P
    P
</code></pre> 
 <ul><li><span class='centered'><span class='centered'> So we show the group  <code class='inline'>Z</code> on the horizontal axis, which zooms the real line. We "attach" a copy of  <code class='inline'>P</code> to each element  <code class='inline'>z</code> of  <code class='inline'>Z</code>, <span class='centered'>appropriately scaled. </li></ul> 
 <ul><li><span class='centered'><span class='centered'> How should I write the pan-and-zoom operation as a single unit? I'll denote by  <code class='inline'>(z, p)</code> the operation of panning by  <code class='inline'>p</code> and then  <span class='centered'>zooming by  <code class='inline'>z</code>. Why not the other order? Well, if I zoom first by  <code class='inline'>z</code> and then pan by  <code class='inline'>p</code>, the pan  <code class='inline'>p</code> gets "disturbed" by the zoom, <span class='centered'>since the pan would like to talk about the  <i><span class='centered'>initial </i> state of the world, but we now need to pan with respect to the world  <i><span class='centered'>after </i> zooming. <span class='centered'>So we prefer the order where we can pan first (with no zoom interfering with our affairs), and then zoom.  </li><li><span class='centered'><span class='centered'> How do these combine? If we have  <code class='inline'>(1, p) . (1, p')</code> we get  <code class='inline'>(1, p + p')</code> since combining pans at zoom level  <code class='inline'>1x</code> is like <span class='centered'>us not having zooming. Similarly, combining  <code class='inline'>(z, 0) . (z', 0)</code> is  <code class='inline'>(zz', 0)</code>, since zooming by  <code class='inline'>z</code> with no pan followed by  <code class='inline'>z'</code> is the same <span class='centered'>as zooming in one shot by  <code class='inline'>zz'</code>. </li><li><span class='centered'><span class='centered'> What about  <code class='inline'>(z, p). (z', p')</code>? What does it mean? It means we should (a) pan by  <code class='inline'>p</code>, (b) zoom  <code class='inline'>z</code>, (c) pan by  <code class='inline'>p'</code>, (d) zoom  <code class='inline'>z'</code>. <span class='centered'>See that the total zoom will be  <code class='inline'>zz'</code> at the end of this operation. What about the total pan? the second pan by  <code class='inline'>p'</code> happens  <i><span class='centered'>after </i> we <span class='centered'>have already zoomed by  <code class='inline'>z</code>. So relative to  <i><span class='centered'>no </i> zoom, this is a pan by  <code class='inline'>zp'</code>. So in total, we can replace by an operation which (1) <span class='centered'>pans by  <code class='inline'>p + zp'</code>, and then (2) zooms by  <code class='inline'>zz'</code>. So we have that  <code class='inline'>(z, p).(z', p') = (zz', zp + p')</code>. This is a  <i><span class='centered'>semidirect </i> product. </li><li><span class='centered'><span class='centered'> If we stare at the picture above, we see that we have many copies of  <code class='inline'>p</code>, one for each  <code class='inline'>z</code>. So the full group is like  <code class='inline'>Z x P</code>. </li><li><span class='centered'><span class='centered'> It's hopefully clear that if we "squish" the  <code class='inline'>P</code>s, (ie, quotient by  <code class='inline'>P</code>) down towards the  <code class='inline'>Z</code>, we'll still have a fully functioning  <code class='inline'>Z</code> group. </li><li><span class='centered'><span class='centered'> On the other hand, if we attempt to "squish" the  <code class='inline'>Z</code>s(ie, quotient by  <code class='inline'>Z</code>) down towards a single  <code class='inline'>P</code>, we'll be left with  <i><span class='centered'>incompatible </i> copies <span class='centered'>of  <code class='inline'>P</code>, each at different scales! This tells us that we  <i><span class='centered'>can </i> quotient by  <code class='inline'>P</code> (so  <code class='inline'>P</code> is normal), but  <i><span class='centered'>not </i> by  <code class='inline'>Z</code> (so  <code class='inline'>Z</code> is not normal). </li><li><span class='centered'><span class='centered'> So, this is sort of like a vector bundle  <code class='inline'>P -> Z |x P -> Z</code> where the fibers are  <code class='inline'>P</code> and the base space is  <code class='inline'>Z</code>. We can remove the fibers  <span class='centered'>to recover the base space. You can't delete the base space, since there's no way to make the fibers "compatible". </li></ul> 
 <script src="https://utteranc.es/client.js"        repo="bollu/bollu.github.io"        issue-term="pathname"        label="question"        theme="github-light"        crossorigin="anonymous"        async></script></container></body></html>