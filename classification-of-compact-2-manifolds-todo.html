<!DOCTYPE html><meta charset='UTF-8'><html><head><link rel='alternate' type='application/rss+xml' href='feed.rss' title='A universe of sorts'/><link rel='stylesheet' href='katex/katex.min.css'    integrity='sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X'    crossorigin='anonymous'><!-- The loading of KaTeX is deferred to speed up page rendering --><link rel='stylesheet' href='prism/prism.css'><title> A Universe of Sorts </title><style>@font-face {font-family: 'Blog Mono'; src: url('/static/iosevka-fixed-extended.ttf');}@font-face {font-family: 'Blog Sans'; src: url('/static/Exo2-Regular.ttf');}@font-face {font-family: 'Blog Serif'; src: url('/static/Revans-Regular.ttf');}html { font-size: 100%; }html,body { text-size-adjust: none; -webkit-text-size-adjust: none; -moz-text-size-adjust: none; -ms-text-size-adjust: none; } body { background: linear-gradient(to right, #1565C0 0%, #1565C0 50%, #E91E63 50%,   #E91E63 99%);  color: #000000;  font-family: Tahoma, 'Blog Serif', serif;  font-size: 14px;  margin-top: 0px;  max-width: 100%; overflow-x: hidden; }
h1, h2, h3, h4, h5 { font-family: Tahoma, 'Blog Mono', monospace; }img { display:block; width: 100%; max-width: 800px; height: auto }.container { overflow-x: auto; overflow-y: hidden;  max-width: 80ex; text-align: justify;              margin-top: 0px; height: 100%; min-height: 100%;             padding-left: 50px; padding-right: 50px; background: #FFFFFF;}@media (max-width: 480px) {   .container { margin-left: 1%; margin-right: 1%; }  body { font-size: 30px; }  } @media (max-width: 1024px) {  .container { margin-left: 1%; margin-right: 1%; }  body { font-size: 30px; }}@media (min-width: 1024px) { .container { margin-left: 25%; margin-right: 20%; } }.image { }
a:hover { color: #1a73e8; text-decoration: underline;  }
a { color: #1a73e8; text-decoration: none; }
a:visited { color: #1a73e8; text-decoration: none; }
a:active { color: #1a73e8; text-decoration: none; }

blockquote { margin-left: 0px; margin-right: 0px; } pre, .latexblock, blockquote { border-left-color:#BBB;  border-left-style: solid;      border-left-width: 5px; }pre, blockquote { padding-left: 10px; }
pre { font-family: 'Blog Mono', monospace; font-size: 90%;  }pre {  overflow-x: auto; }.latexblock, blockquote, pre { margin-top: 10px; margin-bottom: 10px; padding-bottom: 5px; padding-top: 5px; background-color: #FFFFFF; }.latexblock { line-height: 1em }
pre, kbd, samp, tt{ font-family:'Blog Mono',monospace; }.inline { white-space: nowrap; background:#efefef; }ul, ol { list-style-position: inside; padding-left: 0; }ul { list-style-type: disclosure-closed; }</style></head><body><div class='container'><h2><a id=classification-of-compact-2-manifolds-todo href='#classification-of-compact-2-manifolds-todo'> § </a><span class='centered'> Classification of compact 2-manifolds  [TODO ] </h2> 
 <ul><li><span class='centered'><span class='centered'> Oriented compact 2-surfaces: sphere, torus, 2 holed torus, etc. </li><li><span class='centered'><span class='centered'> have euler characteristic  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>−</mo><mi>E</mi><mo>+</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">V - E + F </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span></span> as  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>−</mo><mn>2</mn><mi>g</mi></mrow><annotation encoding="application/x-tex">2 - 2g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span></span></li><li><span class='centered'><span class='centered'> Strategy: cut surface into polygonal pieces. Use oriented edges to know cutting. Lay them down on the surface such that the "top part" or <span class='centered'>"painted surface" will be up  [so we retain orientation ]. </li><li><span class='centered'><span class='centered'> Attach all the polygons into one big polygon on the plane. </li><li><span class='centered'><span class='centered'> For each edge on boundary of the big polygon, it must attach to some other boundary of the big poygon  [since the manifold is compact ]. <span class='centered'>Furthermore, this edge must occur in the  <i><span class='centered'>opposite direction </i> to make the surface orientable. Otherwise we could pass through the side <span class='centered'>and flip orientation. Consider: </li></ul> 
 <pre><code>>>>>
|  |
>>>>
</code></pre> 
 <ul><li><span class='centered'><span class='centered'> When I appear from the "other side", my direction wil have flipped.  [TODO ] </li></ul> 
 <ul><li><span class='centered'><span class='centered'> So far, we know the edges. What about identifying vertices? </li></ul> 
 <ul><li><span class='centered'><span class='centered'> Next, we need to group vertices together on the big polygon. We can find this by going  <i><span class='centered'>around the edges incident at the vertex </i><span class='centered'>on the  <i><span class='centered'>manifold surface </i>. </li></ul> 
 <ul><li><span class='centered'><span class='centered'> The next step is to reduce the number of vertices to exactly one. We can cut the current polygon and re-paste it as long as we preserve <span class='centered'>all cutting/pasting relations. </li></ul> 
 <ul><li><span class='centered'><span class='centered'> Suppose I glue all the B vertices to a single vertex. Then, the edges emenating from this B vertex  <i><span class='centered'>must necessarily be the same </i>. <span class='centered'>If not, then the edge emenating would need a complementary edge somewhere else, which would give me another "copy" of the B vertex. </li></ul> 
 <ul><li><span class='centered'><span class='centered'> I can imagine such a B vertex as being "pushed inside the polygon" and then "glued over itself", thereby making it part of the  <i><span class='centered'>interior </i><span class='centered'>of the polygon. </li></ul> 
 <ul><li><span class='centered'><span class='centered'> We can repeat this till there is only one type of vertex (possibly multiple copies). </li><li><span class='centered'><span class='centered'> If we only had two adjacent edges  [edges incident against the same vertices ], then we are done, since we get a sphere. </li><li><span class='centered'><span class='centered'> We can always remove adjacent pairs of edges. What about non-adjacent pairs? </li><li><span class='centered'><span class='centered'> Take a non adjacent pair. think of these as "left" and "right". We claim that for each edge at the "top", there is a corresponding <span class='centered'>edge at the "bottom". So we have left and right identified, and top identified with a continugous segment in the bottom. If there  wasn't, <span class='centered'>then we would need another vertex! </li><li><span class='centered'><span class='centered'> This lets me create a commutator on the boundary, of the form <span class='centered'><span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>d</mi><msup><mi>c</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msup><mi>d</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>x</mi></mrow><annotation encoding="application/x-tex">cdc^{-1}d^{-1}x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">x</span></span></span></span></span>. Topologically, this is a handle, since if it were "full" <span class='centered'>[without the extra  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span></span>], then we would have a torus. Since we do have the <span class='centered'><span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span></span>, we have a "hole on the torus" which is a handle. </li><li><span class='centered'><span class='centered'> We keep removing hanldes till we are done. </li></ul> 
 <h4><a id=why-does-euler-characteristic-become-2-2g href='#why-does-euler-characteristic-become-2-2g'> § </a><span class='centered'> Why does euler characteristic become  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>−</mo><mn>2</mn><mi>g</mi></mrow><annotation encoding="application/x-tex">2-2g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span></span>? </h4>
 <ul><li><span class='centered'><span class='centered'> If we add a vertex on an edge, we add a vertex and subrtact the (new) edge we have created. Thus  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ξ</mi></mrow><annotation encoding="application/x-tex">\xi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.04601em;">ξ</span></span></span></span></span> is unchanged on adding a vertex on an edge. </li><li><span class='centered'><span class='centered'> Joining two vertices on a face also does not change  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ξ</mi></mrow><annotation encoding="application/x-tex">\xi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.04601em;">ξ</span></span></span></span></span>, since we add an edge and a face. </li><li><span class='centered'><span class='centered'> Given any two subdivisios, we find a common finer subdivision by these steps. Since the steps we use retain the euler characteristic, <span class='centered'>finally my original subdiv = common subdiv = friend subdiv. </li><li><span class='centered'><span class='centered'> Key idea: at each crossing between our subdivsion and the other subdivision, make a new vertex at every crossing. Then "trace over" the <span class='centered'>other subdivision to make our subdivision agree on the other subdivision on the inside. </li></ul> 
 <span class='centered'>https://www.youtube.com/watch?v=dUOmU-0t2Nc&list=PLIljB45xT85DWUiFYYGqJVtfnkUFWkKtP&index=27  
 <script src="https://utteranc.es/client.js"        repo="bollu/bollu.github.io"        issue-term="pathname"        label="question"        theme="github-light"        crossorigin="anonymous"        async></script></container></body></html>