<!DOCTYPE html><meta charset='UTF-8'><html><head><link rel='alternate' type='application/rss+xml' href='feed.rss' title='A universe of sorts'/><link rel='stylesheet' href='katex/katex.min.css'    integrity='sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X'    crossorigin='anonymous'><!-- The loading of KaTeX is deferred to speed up page rendering --><link rel='stylesheet' href='prism/prism.css'><title> A Universe of Sorts </title><style>@font-face {font-family: 'Blog Mono'; src: url('/static/iosevka-fixed-extended.ttf');}@font-face {font-family: 'Blog Sans'; src: url('/static/Exo2-Regular.ttf');}@font-face {font-family: 'Blog Serif'; src: url('/static/Revans-Regular.ttf');}html { font-size: 100%; }html,body { text-size-adjust: none; -webkit-text-size-adjust: none; -moz-text-size-adjust: none; -ms-text-size-adjust: none; } body { background: linear-gradient(to right, #1565C0 0%, #1565C0 50%, #E91E63 50%,   #E91E63 99%);  color: #000000;  font-family: Tahoma, 'Blog Serif', serif;  font-size: 14px;  margin-top: 0px;  max-width: 100%; overflow-x: hidden; }
h1, h2, h3, h4, h5 { font-family: Tahoma, 'Blog Mono', monospace; }img { display:block; width: 100%; max-width: 800px; height: auto }.container { overflow-x: auto; overflow-y: hidden;  max-width: 80ex; text-align: justify;              margin-top: 0px; height: 100%; min-height: 100%;             padding-left: 50px; padding-right: 50px; background: #FFFFFF;}@media (max-width: 480px) {   .container { margin-left: 1%; margin-right: 1%; }  body { font-size: 30px; }  } @media (max-width: 1024px) {  .container { margin-left: 1%; margin-right: 1%; }  body { font-size: 30px; }}@media (min-width: 1024px) { .container { margin-left: 25%; margin-right: 20%; } }.image { }
a:hover { color: #1a73e8; text-decoration: underline;  }
a { color: #1a73e8; text-decoration: none; }
a:visited { color: #1a73e8; text-decoration: none; }
a:active { color: #1a73e8; text-decoration: none; }

blockquote { margin-left: 0px; margin-right: 0px; } pre, .latexblock, blockquote { border-left-color:#BBB;  border-left-style: solid;      border-left-width: 5px; }pre, blockquote { padding-left: 10px; }
pre { font-family: 'Blog Mono', monospace; font-size: 90%;  }pre {  overflow-x: auto; }.latexblock, blockquote, pre { margin-top: 10px; margin-bottom: 10px; padding-bottom: 5px; padding-top: 5px; background-color: #FFFFFF; }.latexblock { line-height: 1em }
pre, kbd, samp, tt{ font-family:'Blog Mono',monospace; }.inline { white-space: nowrap; background:#efefef; }ul, ol { list-style-position: inside; padding-left: 0; }ul { list-style-type: disclosure-closed; }</style></head><body><div class='container'><h2><a id=cartesian-trees href='#cartesian-trees'> § </a><span class='centered'> Cartesian Trees </h2> 
 <span class='centered'>Cartesian trees construct a tree  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mi>C</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T = C(A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span></span> given an array  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span></span>, such that 
 <span class='centered'>range minimum query (RMQ) on the array  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span></span> is equivalent to the lowest common ancestor (LCA) 
 <span class='centered'>of the nodes of the tree  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></span>.  
 <span class='centered'><img src="./static/cartesian-tree.svg">  
 <span class='centered'>Note that the tree looks like a  <i><span class='centered'>min-heap </i>.  
 <span class='centered'>To see the connection to LCA, if we want to find the range minimum in the range containing the 
 <span class='centered'>elements  <code class='inline'>[12, 10, 20, 15, 18]</code> of the array, the minimum is  <code class='inline'>10</code>, which is 
 <span class='centered'>indeed the lowest common ancestor of the nodes of  <code class='inline'>12</code> and  <code class='inline'>18</code> in the tree.  
 <h4><a id=building-a-cartesian-tree-in-linear-time href='#building-a-cartesian-tree-in-linear-time'> § </a><span class='centered'> Building a Cartesian tree in linear time: </h4> 
 <h4><a id=converting-lca-to-rmq href='#converting-lca-to-rmq'> § </a><span class='centered'> Converting LCA to RMQ </h4> 
 <span class='centered'>We can go the other way, and convert an LCA problem into a RMQ problem. We 
 <span class='centered'>perform an inorder traversal of the nodes, scribbling down the 
 <span class='centered'>depth of the node ( <a href=https://youtu.be/0rCFkuQS968?t=934><span class='centered'>Link to lecture at 15:30 </a>). 
 <span class='centered'>We ask for the  <i><span class='centered'>argmin </i> version of RMQ, that gives us the  <i><span class='centered'>index </i> of 
 <span class='centered'>the node with the lowest depth. This gives us the index of where the node lives.  
 <h4><a id=universe-reduction-in-rmq href='#universe-reduction-in-rmq'> § </a><span class='centered'> Universe reduction in RMQ </h4> 
 <span class='centered'>We can have an arbitrary ordered universe, on which we want to perform RMQ. 
 <span class='centered'>We can convert this to LCA by using a cartesian tree, and then convert to 
 <span class='centered'>a "clean" RMQ (by using the LCA -> RMQ using depth conversion). This now 
 <span class='centered'>will give us way faster operations (since we now have integers).  
 <h4><a id=-1-rmq href='#-1-rmq'> § </a><span class='centered'>  <code class='inline'>+-1</code> RMQ: </h4> 
 <span class='centered'>We want the differences between nodes to have a difference of only  <code class='inline'>+-1</code>. We 
 <span class='centered'>had a much wider gap. Here, we perform an Euler tour (walk the tree DFS search order), 
 <span class='centered'>and sribble down every vertex we visit.  
 <span class='centered'>To find the LCA, we perform the RMQ on the locations of the  <i><span class='centered'>first </i> occurence 
 <span class='centered'>of the node. (I think we don't actually need the first occurence, any 
 <span class='centered'>occurence will do).  
 <h4><a id=references href='#references'> § </a><span class='centered'> References </h4> 
 <ul><li><span class='centered'><span class='centered'> Material shamelessly written down from <span class='centered'><a href=https://www.youtube.com/watch?v=0rCFkuQS968><span class='centered'>Eric Demaine's excellent (MIT 6.851 Advanced Data Structures): Lecture 15 </a></li><li><span class='centered'><span class='centered'> Image of the tree  <a href=https://upload.wikimedia.org/wikipedia/commons/d/d5/Cartesian_tree.svg><span class='centered'>taken from WikiMedia </a></li></ul> 
 <script src="https://utteranc.es/client.js"        repo="bollu/bollu.github.io"        issue-term="pathname"        label="question"        theme="github-light"        crossorigin="anonymous"        async></script></container></body></html>