<!DOCTYPE html><meta charset='UTF-8'><html><head><link rel='alternate' type='application/rss+xml' href='feed.rss' title='A universe of sorts'/><link rel='stylesheet' href='katex/katex.min.css'    integrity='sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X'    crossorigin='anonymous'><!-- The loading of KaTeX is deferred to speed up page rendering --><link rel='stylesheet' href='prism/prism.css'><title> A Universe of Sorts </title><style>@font-face {font-family: 'Blog Mono'; src: url('/static/iosevka-fixed-extended.ttf');}@font-face {font-family: 'Blog Sans'; src: url('/static/Exo2-Regular.ttf');}@font-face {font-family: 'Blog Serif'; src: url('/static/Revans-Regular.ttf');}html { font-size: 100%; }html,body { text-size-adjust: none; -webkit-text-size-adjust: none; -moz-text-size-adjust: none; -ms-text-size-adjust: none; } body { line-height: 1.5em;  color: #000000;  font-family: serif;  font-size: 12px;  margin-top: 0px;  max-width: 100%; overflow-x: hidden; }
h1, h2, h3, h4, h5 { font-family: 'Blog Mono', monospace; }h1, h2 { column-span: all; }img { display:block; width: 100%; max-width: 800px; height: auto }.container { overflow-x: auto; overflow-y: hidden;              margin-top: 0px; height: 100%; min-height: 100%;             max-width: 100%;              font-size: 18px; line-height: 1.5em;              column-count: auto; column-width: 25em; column-fill: auto;              padding-left: 30px; padding-right: 30px; background: #FFFFFF;}@media (max-width: 480px) {   .container { margin-left: 1%; margin-right: 1%; }  body { font-size: 30px; }  } @media (max-width: 1024px) {  .container { margin-left: 1%; margin-right: 1%; }  body { font-size: 30px; }}@media (min-width: 1024px) { .container { margin-left: 1%; margin-right: 1%; } }.image { }
a:hover { color: #1a73e8; text-decoration: underline;  }
a { color: #1a73e8; text-decoration: none; }
a:visited { color: #1a73e8; text-decoration: none; }
a:active { color: #1a73e8; text-decoration: none; }

blockquote { margin-left: 0px; margin-right: 0px; } pre, .latexblock, blockquote { border-left-color:#BBB;  border-left-style: solid;      border-left-width: 5px; }pre, blockquote { padding-left: 10px; }
pre { font-family: 'Blog Mono', monospace; font-size: 90%;  }pre {  overflow-x: auto; }.latexblock, blockquote, pre { margin-top: 10px; margin-bottom: 10px; padding-bottom: 5px; padding-top: 5px; background-color: #FFFFFF; }.latexblock { line-height: 1em }
pre, kbd, samp, tt{ font-family:'Blog Mono',monospace; }.inline { white-space: nowrap; background:#efefef; }ul, ol { list-style-position: inside; padding-left: 0; }ul { list-style-type: disclosure-closed; }</style></head><body><div class='container'><h2><a id=laziness-for-c-programmers href='#laziness-for-c-programmers'> § </a><span class='centered'> Laziness for C programmers </h2> 
 <h4><a id=side-node-nonsrict-versus-lazy-this-section-can-be-skipped href='#side-node-nonsrict-versus-lazy-this-section-can-be-skipped'> § </a><span class='centered'> Side node: nonsrict versus lazy (This section can be skipped) </h4> 
 <span class='centered'>I will use the word  <code class='inline'>non-strict</code> throughout, and not  <code class='inline'>lazy</code>. 
 <span class='centered'>Roughly speaking,  <code class='inline'>lazy</code> is more of an implementation detail that guarantees 
 <span class='centered'>that a value that is once computed is cached. (operational semantics)  
 <span class='centered'><code class='inline'>non-strict</code> is a evaluation order detail that guarantees that values are 
 <span class='centered'>not evaluated until there are truly required. (denotational semantics).  
 <span class='centered'><code class='inline'>lazy</code> is one way to  <i><span class='centered'>implement </i>  <code class='inline'>non-strict</code>.  
 <span class='centered'>This is pure pedantry, but I'd like to keep it straight, since there seems to be 
 <span class='centered'>a lot of confusion involving the two words in general.  
 <h4><a id=showing-off-non-strictness href='#showing-off-non-strictness'> § </a><span class='centered'> Showing off non-strictness: </h4>
 <span class='centered'>We first need a toy example to work with to explain the fundamentals of 
 <span class='centered'>non-strict evaluation, so let's consider the example below. I'll explain the  <code class='inline'>case</code> construct which is explained below. Don't worry if ato lazy evaluation "looks weird", it feels that way to everyone till one plays around with it for a while!  
 <span class='centered'>We will interpret this example as both a strict program and a non-strict program. 
 <span class='centered'>This will show us that we obtain different outputs on applying different 
 <span class='centered'>interpretations.  
 <span class='centered'>We distinguish between primitive values (integers such as  <code class='inline'>1</code>,  <code class='inline'>2</code>,  <code class='inline'>3</code>) and boxed values 
 <span class='centered'>(functions, data structures). Boxed values can be evaluated non-stricly. Primitive values 
 <span class='centered'>do not need evaluation: they are primitive.  
 <h4><a id=code href='#code'> § </a><span class='centered'> Code </h4> 
 <pre><code><span class="token comment">-- Lines starting with a `--` are comments.</span>
<span class="token comment">-- K is a function that takes two arguments, `x` and `y`, that are both boxed values.</span>
<span class="token comment">-- K returns the first argument, `x`, ignoring the second argument, `y`.</span>
<span class="token comment">-- Fun fact: K comes for the K combinator in lambda calculus.</span>
<span class="token hvariable">kCombinator</span> <span class="token operator">::</span> <span class="token constant">Boxed</span> <span class="token operator">-></span> <span class="token constant">Boxed</span> <span class="token operator">-></span> <span class="token constant">Boxed</span>
<span class="token hvariable">kCombinator</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token hvariable">x</span>

<span class="token comment">-- one is a function that returns the value 1# (primitive 1)</span>
<span class="token hvariable">one</span> <span class="token operator">::</span> <span class="token constant">PrimInt</span>
<span class="token hvariable">one</span> <span class="token operator">=</span> <span class="token number">1</span>

<span class="token comment">-- Loopy is a function that takes zero arguments, and tries to return a boxed value.</span>
<span class="token comment">-- Loopy invokes itself, resulting in an infinite loop, so it does not actually return.</span>
<span class="token hvariable">loopy</span> <span class="token operator">::</span> <span class="token constant">Boxed</span>
<span class="token hvariable">loopy</span> <span class="token operator">=</span> <span class="token hvariable">loopy</span>

<span class="token comment">-- main is our program entry point.</span>
<span class="token comment">-- main takes no arguments, and returns nothing</span>
<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">Void</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">case</span> <span class="token hvariable">kCombinator</span> <span class="token hvariable">one</span> <span class="token hvariable">loopy</span> <span class="token keyword">of</span> <span class="token comment">-- force K to be evaluated with a `case`</span>
            <span class="token hvariable">kret</span> <span class="token operator">-></span> <span class="token keyword">case</span> <span class="token hvariable">kret</span> <span class="token keyword">of</span>  <span class="token comment">-- Force evaluation</span>
                    <span class="token hvariable">i</span> <span class="token operator">-></span> <span class="token hvariable">printPrimInt</span> <span class="token hvariable">i</span> <span class="token comment">-- Call the forced value of `kret` as `i` and then print it.</span>
</code></pre> 
 <h4><a id=a-quick-explanation-about-case href='#a-quick-explanation-about-case'> § </a><span class='centered'> A quick explanation about  <code class='inline'>case</code>: </h4>
 <span class='centered'><code class='inline'>case</code> is a language construct that  <i><span class='centered'>forces </i> evaluation. In general, no value 
 <span class='centered'>is evaluated unless it is  <i><span class='centered'>forced </i> by a case.  
 <h4><a id=analysing-the-example-the-strict-interpretation href='#analysing-the-example-the-strict-interpretation'> § </a><span class='centered'> Analysing the example: The strict interpretation </h4> 
 <span class='centered'>If we were coming from a strict world, we would have assumed that the expression 
 <span class='centered'><code class='inline'>K one loopy</code> would first try to evaluate the arguments,  <code class='inline'>one</code> and  <code class='inline'>loopy</code>. 
 <span class='centered'>Evaluating  <code class='inline'>one</code> would return the primitive value  <code class='inline'>1</code>, so this has no problem.  
 <span class='centered'>On trying to evaluate  <code class='inline'>loopy</code>, we would need to re-evaluate  <code class='inline'>loopy</code>, and so on 
 <span class='centered'>ad infitum, which would cause this program to never halt.  
 <span class='centered'>This is because, as programmers coming from a strict world, we assume that 
 <span class='centered'><i><span class='centered'>values are evaluated as soon as possible </i>.  
 <span class='centered'>So, the output of this program is to have the program infinite-loop for ever, 
 <span class='centered'>under the strict interpretation.  
 <h4><a id=analysing-the-example-the-non-strict-interpretation href='#analysing-the-example-the-non-strict-interpretation'> § </a><span class='centered'> Analysing the example: The non-strict interpretation: </h4> 
 <span class='centered'>In the non-strict world, we try to evaluate  <code class='inline'>K(1, loopy)</code> since we are asked the result 
 <span class='centered'>of it by the  <code class='inline'>case</code> expression. However, we do not try to evaluate  <code class='inline'>loopy</code>, since 
 <span class='centered'>no one has asked what it's value is!  
 <span class='centered'>Now, we know that  
 <pre><code><span class="token hvariable">kCombinator</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token hvariable">x</span>
</code></pre> 
 <span class='centered'>Therefore,  
 <pre><code><span class="token hvariable">kCombinator</span> <span class="token hvariable">one</span> <span class="token hvariable">loopy</span> <span class="token operator">=</span> <span class="token hvariable">one</span>
</code></pre> 
 <span class='centered'>regardless of what value  <code class='inline'>loopy</code> held.  
 <span class='centered'>So, at the case expression: 
 <pre><code><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">case</span> <span class="token constant">K</span><span class="token punctuation">(</span><span class="token hvariable">one</span><span class="token punctuation">,</span> <span class="token hvariable">loopy</span><span class="token punctuation">)</span> <span class="token keyword">of</span> <span class="token comment">-- force K to be evaluated with a `case`</span>
<span class="token operator">>>></span>         <span class="token hvariable">kret</span> <span class="token operator">-></span> <span class="token operator">...</span>
</code></pre> 
 <span class='centered'><code class='inline'>kret = one</code>, we can continue with the computation.  
 <pre><code><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token constant">Void</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">case</span> <span class="token hvariable">kCombinator</span> <span class="token hvariable">one</span> <span class="token hvariable">loopy</span> <span class="token keyword">of</span> <span class="token comment">-- force K to be evaluated with a `case`</span>
            <span class="token hvariable">kret</span> <span class="token operator">-></span> <span class="token keyword">case</span> <span class="token hvariable">kret</span> <span class="token keyword">of</span>  <span class="token comment">-- Call the return value of K as `x`, and force evaluation.</span>
                       <span class="token hvariable">i</span> <span class="token operator">-></span> <span class="token hvariable">printPrimInt</span> <span class="token hvariable">i</span> <span class="token comment">-- Call the vreturn value of `x` as `primx` and then print it.</span>
</code></pre> 
 <span class='centered'>Here, we force  <code class='inline'>kret</code> (which has value  <code class='inline'>one</code>) to be evaluated with  <code class='inline'>case kret of...</code>. 
 <span class='centered'>since  <code class='inline'>one = 1</code>,  <code class='inline'>i</code> is bound to the value  <code class='inline'>1</code>. 
 <span class='centered'>Once  <code class='inline'>i</code> is returned, we print it out with  <code class='inline'>printPrimInt(primx)</code>.  
 <span class='centered'>The output of the program under non-strict interpretation is for it to print out  <code class='inline'>1</code>.  
 <h4><a id=where-does-the-difference-come-from href='#where-does-the-difference-come-from'> § </a><span class='centered'> Where does the difference come from? </h4> 
 <span class='centered'>Clearly, there is a divide: strict evaluation tells us that this program should 
 <span class='centered'>never halt. Non-strict evaluation tells us that this program will print an output!  
 <span class='centered'>To formalize a notion of strictness, we need a notion of  <code class='inline'>bottom</code> ( <code class='inline'>_|_</code>).  
 <span class='centered'>A value is said to be  <code class='inline'>bottom</code> if in trying to evaluate it, we reach an 
 <span class='centered'>undefined state.  
 <span class='centered'>Now, if a function is  <i><span class='centered'>strict </i>, it would first evaluate its arguments and then 
 <span class='centered'>compute the result. So, if a strict function is given a value that is  <code class='inline'>bottom</code>, 
 <span class='centered'>the function will try to evaluate the argument, resulting in the computation 
 <span class='centered'>screwing up, causing the output of the whole function to be  <code class='inline'>bottom</code>.  
 <span class='centered'>Formally, a function  <code class='inline'>f</code> is strict iff (if and only if)  <code class='inline'>f(bottom) = bottom</code>.  
 <span class='centered'>Conversely, a  <i><span class='centered'>non-strict </i> function does not need to evaluate its arguments if it 
 <span class='centered'>does not use them, as in the case of  <code class='inline'>K 1 loopy</code>. In this case,  <code class='inline'>f(bottom)</code> need 
 <span class='centered'>not be equal to bottom.  
 <span class='centered'>Formally, a function  <code class='inline'>f</code> is non-strict iff (if and only if)  <code class='inline'>f(bottom) /= bottom</code>.  
 <span class='centered'>As Paul Halmos says  
 <blockquote><span class='centered'> "A good stack of examples, as large as possible, is indispensable for a <span class='centered'> thorough understanding of any concept, and when I want to learn something <span class='centered'> new, I make it my first job to build one.". Let us consider some examples. </blockquote> 
 <ul><li><span class='centered'><span class='centered'>  <code class='inline'>id</code></li></ul> 
 <pre><code><span class="token builtin">id</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">x</span>

<span class="token builtin">id</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token builtin">id</span> <span class="token punctuation">(</span><span class="token hvariable">bottom</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">bottom</span>
</code></pre> 
 <span class='centered'><code class='inline'>id</code> is strict, since  <code class='inline'>id(bottom) = bottom</code>.  
 <ul><li><span class='centered'><span class='centered'>  <code class='inline'>const</code></li></ul> 
 <pre><code><span class="token hvariable">const_one</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token number">1</span>

<span class="token hvariable">const_one</span><span class="token punctuation">(</span><span class="token hvariable">bottom</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token hvariable">const_one</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span>
</code></pre> 
 <span class='centered'><code class='inline'>const_one</code> is not strict, as  <code class='inline'>const_one(bottom) /= bottom</code>.  
 <ul><li><span class='centered'><span class='centered'>  <code class='inline'>K</code></li></ul> 
 <pre><code><span class="token constant">K</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token hvariable">x</span>

<span class="token constant">K</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token constant">K</span> <span class="token number">1</span> <span class="token hvariable">bottom</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token constant">K</span> <span class="token hvariable">bottom</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token hvariable">bottom</span>
</code></pre> 
 <span class='centered'>Note that  <code class='inline'>K(bottom, y) = bottom</code>, so K is  <i><span class='centered'>strict in its first argument </i>, and 
 <span class='centered'><code class='inline'>K(x, bottom) /= bottom</code>, so K is  <i><span class='centered'>non-strict in its second argument </i>.  
 <span class='centered'>This is a neat example showing how a function can be strict and lazy in different 
 <span class='centered'>arguments of the function.  
 <h4><a id=compiling-non-strictness-v1 href='#compiling-non-strictness-v1'> § </a><span class='centered'> Compiling non-strictness, v1: </h4> 
 <h4><a id=how-does-ghc-compile-non-strictness href='#how-does-ghc-compile-non-strictness'> § </a><span class='centered'> How does GHC compile non-strictness? </h4> 
 <span class='centered'><code class='inline'>GHC</code> (the Glasgow haskell compiler) internally uses multiple intermediate 
 <span class='centered'>representations, in order of original, to what is finally produced:  
 <ul><li><span class='centered'><span class='centered'> Haskell (the source language) </li><li><span class='centered'><span class='centered'> Core (a minimal set of constructs to represent the source language) </li><li><span class='centered'><span class='centered'> STG (Spineless tagless G-machine, a low-level intermediate representation that accurately captures non-strict evaluation) </li><li><span class='centered'><span class='centered'> C-- (A C-like language with GHC-specific customization to support platform <span class='centered'>independent code generation). </li><li><span class='centered'><span class='centered'> Assembly </li></ul> 
 <span class='centered'>Here, I will show how to lower simple non-strict programs from a  <i><span class='centered'><i><span class='centered'>fictitous </i></i>  <code class='inline'>Core</code> like language down to  <code class='inline'>C</code> , while skipping  <code class='inline'>STG</code>, since it doesn't 
 <span class='centered'>really add anything to the high-level discussion at this point.  
 <h4><a id=our-example-of-compiling-non-strictness href='#our-example-of-compiling-non-strictness'> § </a><span class='centered'> Our example of compiling non-strictness </h4> 
 <span class='centered'>Now, we need a  <i><span class='centered'>strategy </i> to compile the non-strict version of our program. 
 <span class='centered'>Clearly,  <code class='inline'>C</code> cannot express laziness directly, so we need some other 
 <span class='centered'>mechanism to implement this. I will first code-dump, and then explain as we go along.  
 <h4><a id=executable-replit href='#executable-replit'> § </a><span class='centered'> Executable  <code class='inline'>repl.it</code>: </h4>
 <span class='centered'><iframe height="400px" width="100%" src="https://repl.it/@bollu/Compiling-non-strict-programs-on-the-call-stack?lite=true" scrolling="no" frameborder="no" allowtransparency="true" allowfullscreen="true" sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals"></iframe>  
 <h4><a id=source-code href='#source-code'> § </a><span class='centered'> Source code </h4>
 <pre><code>#include <assert.h>
#include <stdio.h>

/* a boxed value is a function that can be executed to compute something.
* We make the return value `void` on purpose. This needs to be typecast to a concrete
* Boxed type to get a value out of it: eg, typecast to BoxedInt.
*/
typedef void (*Boxed)();

/* A boxed int, that on evaluation yields an int*/
typedef int (*BoxedInt)();

/* one = 1# */
int one() {
    return 1;
}

/* bottom = bottom */
void bottom() {
    printf("in function: %s\n", __FUNCTION__);
    bottom();
}

/* K x y = x */
Boxed K(Boxed x, Boxed y) {
  return x;
}

/*
main :: () -> Void
main = case K(one, loopy) of -- force K to be evaluated with a `case`
            kret -> case kret of  -- Call the return value of K as `x`, and force evaluation.
                    i -> printPrimInt(i) -- Call the vreturn value of `x` as `primx` and then print it.
*/
int main() {
    Boxed kret = K((Boxed)one, (Boxed)bottom);
    int i = (*(BoxedInt)kret)();
    printf("%d", i);
    return 1;
}

</code></pre> 
 <span class='centered'>We convert every possibly lazy value into a  <code class='inline'>Boxed</code> value, which is a function pointer that knows how to compute the 
 <span class='centered'>underlying value. When the lazy value is forced by a  <code class='inline'>case</code>, we call the  <code class='inline'>Boxed</code> function to compute the output.  
 <span class='centered'>This is a straightforward way to encode non-strictness in C. However, do note that this is not  <i><span class='centered'>lazy </i>, because a value could get 
 <span class='centered'>recomputed many times.  <i><span class='centered'>Laziness </i> guarantees that a value is only computed once and is later memoized.  
 <h4><a id=compiling-with-a-custom-call-stack-continuations href='#compiling-with-a-custom-call-stack-continuations'> § </a><span class='centered'> Compiling with a custom call stack / continuations </h4> 
 <span class='centered'>As one may notice, we currenly use the native call stack every time we  <i><span class='centered'>force </i>
 <span class='centered'>a lazy value. However, in doing  so, we might actually run out of stack space, 
 <span class='centered'>which is undesirable. Haskell programs like to have "deep" chains of values 
 <span class='centered'>being forced, so we would quite likely run out of stack space.  
 <span class='centered'>Therefore, GHC opts to manage its own call stack on the heap. The generated 
 <span class='centered'>code looks as you would imagine: we maintain a stack of function pointers + 
 <span class='centered'>auxiliary data ( stack saved values), and we push and pop over this "stack". 
 <span class='centered'>When we run out of space, we  <code class='inline'><find correct way to use mmap></code> to increase our 
 <span class='centered'>"stack" size.  
 <span class='centered'>I've played around with this value a little bit, and have found that the modern 
 <span class='centered'>stack size is quite large: IIRC, It allowed me to allocate ~ <code class='inline'>26 GB</code>. I believe 
 <span class='centered'>that the amount it lets you allocate is tied directly to the amount of physical 
 <span class='centered'>memory + swap you have. I'm not too sure, however. So,  <a href=https://github.com/bollu/simplexhc-cpp.git><span class='centered'>for my haskell compiler,  <code class='inline'>sxhc</code></a>, I am considering 
 <span class='centered'>cheating and just using the stack directly.  
 <span class='centered'>Code for the same example (with the K combinator) is provided here.  
 <h4><a id=executable-replit href='#executable-replit'> § </a><span class='centered'> Executable  <code class='inline'>repl.it</code>: </h4>
 <span class='centered'><iframe height="1000px" width="100%" src="https://repl.it/@bollu/Compiling-programs-with-continuations?lite=true" scrolling="no" frameborder="no" allowtransparency="true" allowfullscreen="true" sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals"></iframe>  
 <h4><a id=source-code href='#source-code'> § </a><span class='centered'> Source code </h4> 
 <pre><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">STACK_SIZE <span class="token number">50000</span></span></span>

<span class="token comment">/* a boxed value is a function that can be executed to compute something. */</span>
<span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>Boxed<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/* a return continuation that receives a boxed value. */</span>
<span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>BoxedContinuation<span class="token punctuation">)</span><span class="token punctuation">(</span>Boxed<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/* A return continuation that receives an int value. */</span>
<span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>IntContinuation<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/* Custom stack allocated on the .data section*/</span>
<span class="token keyword">void</span> <span class="token operator">*</span>stack<span class="token punctuation">[</span>STACK_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">/* Stack pointer */</span>
<span class="token keyword">int</span> sp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token comment">/* Push a continuation `cont` */</span>
<span class="token keyword">void</span> <span class="token function">pushContinuation</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>cont<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>sp <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>sp <span class="token operator">&lt;</span> STACK_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    stack<span class="token punctuation">[</span>sp<span class="token punctuation">]</span> <span class="token operator">=</span> cont<span class="token punctuation">;</span>
    sp<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* Pop a continuation frame. */</span>
<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">popContinuation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>sp <span class="token operator">&lt;</span> STACK_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>sp <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    sp<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>cont <span class="token operator">=</span> stack<span class="token punctuation">[</span>sp<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> cont<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* one = 1# */</span>
<span class="token keyword">void</span> <span class="token function">one</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"in function: %s\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>f <span class="token operator">=</span> <span class="token function">popContinuation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>IntContinuation<span class="token punctuation">)</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* bottom = bottom */</span>
<span class="token keyword">void</span> <span class="token function">bottom</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"in function: %s\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">bottom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* K x y = x */</span>
<span class="token keyword">void</span> <span class="token function">K</span><span class="token punctuation">(</span>Boxed x<span class="token punctuation">,</span> Boxed y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"in function: %s\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>f <span class="token operator">=</span> <span class="token function">popContinuation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>BoxedContinuation<span class="token punctuation">)</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">XForceContinuation</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"in function: %s\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">KContinuation</span><span class="token punctuation">(</span>Boxed x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"in function: %s\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pushContinuation</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>XForceContinuation<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"in function: %s\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pushContinuation</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>KContinuation<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">K</span><span class="token punctuation">(</span>one<span class="token punctuation">,</span> bottom<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
 <span class='centered'>we maintain our own "call stack" of continuations. These continuations are precisely the 
 <span class='centered'>parts of the code that deal with the return value of a case. ever  
 <pre><code><span class="token keyword">case</span> <span class="token hvariable">x</span> <span class="token keyword">of</span>
    <span class="token hvariable">xeval</span> <span class="token operator">-></span> <span class="token hvariable">expr</span>
</code></pre> 
 <span class='centered'>compiles to:  
 <pre><code><span class="token function">pushContinuation</span><span class="token punctuation">(</span>XEvalContinuation<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
 <span class='centered'>That is, push a continuation, and then "enter" into  <code class='inline'>x</code>.  
 <span class='centered'>One might have a question: does this still not use the call stack? There is a 
 <span class='centered'>function call at the end of most functions in the source code, so in theory, we 
 <span class='centered'><i><span class='centered'>are </i> using the call stack, right? The answer is no. It's thanks to a neat 
 <span class='centered'>optimisation technique called  <i><span class='centered'>tail call elimination </i>. The observation is that 
 <span class='centered'><i><span class='centered'>after the call </i>, there is no more code to execute in the caller. So, by 
 <span class='centered'>playing some stack tricks, one can convert a  <i><span class='centered'>call </i> to a  <i><span class='centered'>jump </i>.  
 <span class='centered'>Remember, a  <i><span class='centered'><code class='inline'>call</code></i> instruction uses the stack to setup a stack frame, under 
 <span class='centered'>the assumption that we will  <i><span class='centered'><code class='inline'>ret</code></i> at some point.  But, clearly, under our 
 <span class='centered'>compilation model, we will never  <code class='inline'>ret</code>, simply call more functions. So, we 
 <span class='centered'>don't  <i><span class='centered'>need </i> the state maintained by a  <code class='inline'>call</code>. We can simply  <code class='inline'>jmp</code>.  
 <h4><a id=wrapping-up href='#wrapping-up'> § </a><span class='centered'> Wrapping up </h4> 
 <span class='centered'>I hope I've managed to convey the  <i><span class='centered'>essence </i> of how to compile Haskell. I skipped a couple of things: 
 <ul><li><span class='centered'><span class='centered'> haskell data types: sum and product types. These are straightforward, they just compiled to tagged structs. </li><li><span class='centered'><span class='centered'>  <code class='inline'>let</code> bindings: These too are straightforward, but come with certain retrictions in STG. It's nothing groundbreaking,and <span class='centered'>is well written in the paper. </li><li><span class='centered'><span class='centered'> Black holes: Currently, we are not truly  <i><span class='centered'>lazy </i>, in that we do not update values once they are computed. </li><li><span class='centered'><span class='centered'> GC: how to weave the GC through the computation is somewhat non-trivial. </li></ul> 
 <span class='centered'>All of this is documented in the excellent paper: 
 <span class='centered'><a href=https://www.dcc.fc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf><span class='centered'>Implementing lazy languages on stock hardware </a>.  
 <span class='centered'>I am considering extending this blog post that expands on these ideas. If there 
 <span class='centered'>is interest, please do e-mail me at  <code class='inline'>siddu.druid@gmail.com</code>.  
 <script src="https://utteranc.es/client.js"        repo="bollu/bollu.github.io"        issue-term="pathname"        label="question"        theme="github-light"        crossorigin="anonymous"        async></script></container></body></html>