<!DOCTYPE html><meta charset='UTF-8'><html><head><link rel='alternate' type='application/rss+xml' href='feed.rss' title='A universe of sorts'/><link rel='stylesheet' href='katex/katex.min.css'    integrity='sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X'    crossorigin='anonymous'><!-- The loading of KaTeX is deferred to speed up page rendering --><link rel='stylesheet' href='prism/prism.css'><title> A Universe of Sorts </title><style>@font-face {font-family: 'Blog Mono'; src: url('/static/iosevka-fixed-extended.ttf');}@font-face {font-family: 'Blog Sans'; src: url('/static/Exo2-Regular.ttf');}@font-face {font-family: 'Blog Serif'; src: url('/static/Revans-Regular.ttf');}html { font-size: 100%; }html,body { text-size-adjust: none; -webkit-text-size-adjust: none; -moz-text-size-adjust: none; -ms-text-size-adjust: none; } body { line-height: 1.5em;  color: #000000;  font-family: serif;  font-size: 12px;  margin-top: 0px;  max-width: 100%; overflow-x: hidden; }
h1, h2, h3, h4, h5 { font-family: 'Blog Mono', monospace; }h1, h2 { column-span: all; }img { display:block; width: 100%; max-width: 800px; height: auto }.container { overflow-x: auto; overflow-y: hidden;              margin-top: 0px; height: 100%; min-height: 100%;             max-width: 100%;              font-size: 18px; line-height: 1.5em;              column-count: auto; column-width: 25em; column-fill: auto;              padding-left: 30px; padding-right: 30px; background: #FFFFFF;}@media (max-width: 480px) {   .container { margin-left: 1%; margin-right: 1%; }  body { font-size: 30px; }  } @media (max-width: 1024px) {  .container { margin-left: 1%; margin-right: 1%; }  body { font-size: 30px; }}@media (min-width: 1024px) { .container { margin-left: 1%; margin-right: 1%; } }.image { }
a:hover { color: #1a73e8; text-decoration: underline;  }
a { color: #1a73e8; text-decoration: none; }
a:visited { color: #1a73e8; text-decoration: none; }
a:active { color: #1a73e8; text-decoration: none; }

blockquote { margin-left: 0px; margin-right: 0px; } pre, .latexblock, blockquote { border-left-color:#BBB;  border-left-style: solid;      border-left-width: 5px; }pre, blockquote { padding-left: 10px; }
pre { font-family: 'Blog Mono', monospace; font-size: 90%;  }pre {  overflow-x: auto; }.latexblock, blockquote, pre { margin-top: 10px; margin-bottom: 10px; padding-bottom: 5px; padding-top: 5px; background-color: #FFFFFF; }.latexblock { line-height: 1em }
pre, kbd, samp, tt{ font-family:'Blog Mono',monospace; }.inline { white-space: nowrap; background:#efefef; }ul, ol { list-style-position: inside; padding-left: 0; }ul { list-style-type: disclosure-closed; }</style></head><body><div class='container'><h2><a id=weighted-limits-via-collages href='#weighted-limits-via-collages'> § </a><span class='centered'> Weighted limits via collages </h2> 
 <h4><a id=collage-of-a-profunctor href='#collage-of-a-profunctor'> § </a><span class='centered'> Collage of a profunctor. </h4>
 <ul><li><span class='centered'><span class='centered'> more explicitly, for  <code class='inline'>P : C -|-> D</code>, define  <code class='inline'>Collage(P)</code> as the category where  <code class='inline'>Obj(Collage(P)) = Obj(D) + Obj(C)</code>,  <code class='inline'>Collage(P)(inl x, inl y) = D(x,y)</code>,  <code class='inline'>Collage(P)(inr x, inr y) = C(x,y)</code>,  <code class='inline'>Collage(P)(inl x, inr y) = P(x,y)</code>,  <code class='inline'>Collage(P)(inr x, inl y) = 0</code></li><li><span class='centered'><span class='centered'> It is the categorification of a cograph. A graph is where we take the product  <code class='inline'>A \times B</code> and then take a subset of it where  <code class='inline'>f(x) = y</code> (equalizer). </li><li><span class='centered'><span class='centered'> A cograph is where we take the union  <code class='inline'>A \cup B</code> and then impose a quotient  <code class='inline'>f(x) ~ y</code> (coequalizer). </li><li><span class='centered'><span class='centered'> When we categorify this, we don't coequalize, but we setup arrows that capture the morphisms. </li></ul> 
 <h4><a id=quick-intro-to-enriched-profunctors href='#quick-intro-to-enriched-profunctors'> § </a><span class='centered'> Quick intro to enriched (pro)functors. </h4> 
 <ul><li><span class='centered'><span class='centered'> In an enriched category, we replace hom sets by hom objects which live in some suitable category  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span>. </li><li><span class='centered'><span class='centered'> The category must be monoidal, so we can define composition as  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∘</mo><mo>:</mo><mi>h</mi><mi>o</mi><mi>m</mi><mo stretchy="false">(</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo><mo>⊗</mo><mi>h</mi><mi>o</mi><mi>m</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>→</mo><mi>h</mi><mi>o</mi><mi>m</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\circ: hom(y, z) \otimes hom(x, y) \to hom(x, z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord">∘</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span></span>. </li></ul> 
 <h4><a id=weighted-limits-via-collages href='#weighted-limits-via-collages'> § </a><span class='centered'> Weighted Limits via collages </h4> 
 <ul><li><span class='centered'><span class='centered'> Let  <code class='inline'>1</code> be the terminal enriched category, having 1 object  <code class='inline'>*</code> and  <code class='inline'>Hom(*,*) = I</code>, and  <code class='inline'>I</code> is the unit of the monoidal structure  <code class='inline'>(V, (x), I)</code> of the enrichment. </li><li><span class='centered'><span class='centered'> A weighted cone over  <code class='inline'>D : J -> C</code> with weight  <code class='inline'>W : J -|-> 1</code> (where  <code class='inline'>I</code> is the terminal enriched category over  <code class='inline'>V</code>), <span class='centered'>is a functor  <code class='inline'>G</code> from the collage of  <code class='inline'>W: J -|-> 1</code> to  <code class='inline'>C</code> that agrees with  <code class='inline'>F</code> on the copy of  <code class='inline'>J</code> in the collage. <span class='centered'>So,  <code class='inline'>G: Col(W) -> C</code>, or  <code class='inline'>G: J+* -> C</code> where  <code class='inline'>G(J) = D</code>. </li><li><span class='centered'><span class='centered'> Unravelling this, construct the category  <code class='inline'>Col(W) = J+*</code> with the morphisms in  <code class='inline'>J</code>, morphism  <code class='inline'>I: * -> *</code>, and a bunch of arrow  <code class='inline'>J -> *</code>. So we are adding an "enriched point", <span class='centered'>with an arrow  <code class='inline'>I: * -> *</code>. </li><li><span class='centered'><span class='centered'> What does a weighted cone  <code class='inline'>G: Col(W) -> C</code> have that doesn't just come from  <code class='inline'>F: J -> C</code>?  Well, it has an object  <code class='inline'>X</code> (for apeX) to be the image of  <code class='inline'>(inr *): J+*</code>, <span class='centered'>and it has the collage maps  <code class='inline'>W(inl j -> inr *) -> C(j -> X)</code> for all  <code class='inline'>j</code> in  <code class='inline'>Obj(J)</code>, and these maps commute with the base maps of  <code class='inline'>F</code>. <span class='centered'>So far, this looks like a cone. However, note that the collage maps are enriched maps! </li><li><span class='centered'><span class='centered'>  The natural transformations can only choose to move where  <code class='inline'>*</code> goes, since that's the only freedom two functors  <code class='inline'>G, G:':J+* -> C</code> have, <span class='centered'>since they must agree with  <code class='inline'>F</code> on  <code class='inline'>J</code>:  <code class='inline'>G(J) = G'(J) = F(J)</code>. <span class='centered'>This is akin to moving the nadir, plus commutation conditions to ensure that this is indeed a cone morphism. </li></ul> 
 <ul><li><span class='centered'><span class='centered'> Maps of these weighted cones are natural transformations that are identity on the copy of  <code class='inline'>J</code></li><li><span class='centered'><span class='centered'> Terminal means what it usually does. A terminal weighted cone is a weighted limit. </li></ul> 
 <pre><code>15:51 <xplat> *C(X,F(j))
How does this look in our ordinary Set-enriched world?  a `W`-weighted cone has its ape`X` and for each `j` in `J`
  it has a `W(*,j)`-tuple of arrows `x_j,k : X -> F(j)` in `C` and for each `g : j -> j'` we have equations `x_j,k . F(g) = x_j',W(*,g)(k)`
15:57 <xplat> both correct
15:57 <xplat> wait, no
15:58 <xplat> first correct
15:58 <xplat> maps of weighted cones are natural transformations `eta : F => F' : Collage(W) -> C` that are identity on the copy of J in Collage(W)
16:04 <xplat> in the `Set`-enriched world, a map of `W`-weighted cones is a map `f : X -> X'` in `C` and for each `j` in `Obj(J)` and `k` in `W(*,j)` we have equations `x_j,k = x'_j,k . f`
16:08 <xplat> so you can take a simple example, the second power.  For this example, `J = 1`, `W(*,*) = 2`, `F` picks out some object `c`, so each weighted cone consists of `X` and `x_*,0 : X -> c` and `x_*,1 : X -> c` and no equations
16:09 <xplat> what does the terminal weighted cone look like in this example?
</code></pre> 
 <h4><a id=weighted-limit-via-nlab href='#weighted-limit-via-nlab'> § </a><span class='centered'> Weighted limit via  <code class='inline'>nlab</code></h4> 
 <ul><li><span class='centered'><span class='centered'> Let  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></span> be a small category, which is the diagram. </li><li><span class='centered'><span class='centered'> Suppose  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mi>K</mi><mo>→</mo><mrow><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">e</mi><mi mathvariant="sans-serif">t</mi></mrow></mrow><annotation encoding="application/x-tex">F: K \to \mathsf{Set}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">S</span><span class="mord mathsf">e</span><span class="mord mathsf">t</span></span></span></span></span></span>. </li><li><span class='centered'><span class='centered'> See that cones of  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span></span> corresond to natural transformations  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>K</mi><mo separator="true">,</mo><mrow><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">e</mi><mi mathvariant="sans-serif">t</mi></mrow><mo stretchy="false">]</mo><mo stretchy="false">(</mo><mi mathvariant="normal">Δ</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>F</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[K, \mathsf{Set}](\Delta(p), F)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathsf">S</span><span class="mord mathsf">e</span><span class="mord mathsf">t</span></span><span class="mclose">]</span><span class="mopen">(</span><span class="mord">Δ</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mclose">)</span></span></span></span></span> for  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>∈</mo><mrow><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">e</mi><mi mathvariant="sans-serif">t</mi></mrow></mrow><annotation encoding="application/x-tex">p \in \mathsf{Set}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">S</span><span class="mord mathsf">e</span><span class="mord mathsf">t</span></span></span></span></span></span>. </li><li><span class='centered'><span class='centered'> See that the limit represents cones:  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">e</mi><mi mathvariant="sans-serif">t</mi></mrow><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mtext mathvariant="monospace">Lim</mtext><mi>F</mi><mo stretchy="false">)</mo><mo>≃</mo><mo stretchy="false">[</mo><mi>K</mi><mo separator="true">,</mo><mrow><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">e</mi><mi mathvariant="sans-serif">t</mi></mrow><mo stretchy="false">]</mo><mo stretchy="false">(</mo><mi mathvariant="normal">Δ</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>F</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathsf{Set}(p, \texttt{Lim} F) \simeq [K, \mathsf{Set}](\Delta(p), F)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">S</span><span class="mord mathsf">e</span><span class="mord mathsf">t</span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord texttt">Lim</span></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathsf">S</span><span class="mord mathsf">e</span><span class="mord mathsf">t</span></span><span class="mclose">]</span><span class="mopen">(</span><span class="mord">Δ</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mclose">)</span></span></span></span></span>, natural in  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span></span></li><li><span class='centered'><span class='centered'> Generalizing this to arbitrary category  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span></span>, we can write </li></ul> 
 <ul><li><span class='centered'><span class='centered'>  <a href=https://ncatlab.org/nlab/show/weighted+limit><span class='centered'>Ref: nlab </a></li></ul> 
 <script src="https://utteranc.es/client.js"        repo="bollu/bollu.github.io"        issue-term="pathname"        label="question"        theme="github-light"        crossorigin="anonymous"        async></script></container></body></html>