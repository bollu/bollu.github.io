<!DOCTYPE html><meta charset='UTF-8'><html><head><link rel='alternate' type='application/rss+xml' href='feed.rss' title='A universe of sorts'/><link rel='stylesheet' href='katex/katex.min.css'    integrity='sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X'    crossorigin='anonymous'><!-- The loading of KaTeX is deferred to speed up page rendering --><link rel='stylesheet' href='prism/prism.css'><title> A Universe of Sorts </title><style>@font-face {font-family: 'Blog Mono'; src: url('/static/iosevka-fixed-extended.ttf');}@font-face {font-family: 'Blog Sans'; src: url('/static/Exo2-Regular.ttf');}@font-face {font-family: 'Blog Serif'; src: url('/static/Revans-Regular.ttf');}html { font-size: 100%; }html,body { text-size-adjust: none; -webkit-text-size-adjust: none; -moz-text-size-adjust: none; -ms-text-size-adjust: none; } body { line-height: 1.5em;  color: #000000;  font-family: serif;  font-size: 12px;  margin-top: 0px;  max-width: 100%; overflow-x: hidden; }
h1, h2, h3, h4, h5 { font-family: 'Blog Mono', monospace; }h1, h2 { column-span: all; }img { display:block; width: 100%; max-width: 800px; height: auto }.container { overflow-x: auto; overflow-y: hidden;              margin-top: 0px; height: 100%; min-height: 100%;             max-width: 100%;              font-size: 18px; line-height: 1.5em;              column-count: auto; column-width: 25em; column-fill: auto;              padding-left: 30px; padding-right: 30px; background: #FFFFFF;}@media (max-width: 480px) {   .container { margin-left: 1%; margin-right: 1%; }  body { font-size: 30px; }  } @media (max-width: 1024px) {  .container { margin-left: 1%; margin-right: 1%; }  body { font-size: 30px; }}@media (min-width: 1024px) { .container { margin-left: 1%; margin-right: 1%; } }.image { }
a:hover { color: #1a73e8; text-decoration: underline;  }
a { color: #1a73e8; text-decoration: none; }
a:visited { color: #1a73e8; text-decoration: none; }
a:active { color: #1a73e8; text-decoration: none; }

blockquote { margin-left: 0px; margin-right: 0px; } pre, .latexblock, blockquote { border-left-color:#BBB;  border-left-style: solid;      border-left-width: 5px; }pre, blockquote { padding-left: 10px; }
pre { font-family: 'Blog Mono', monospace; font-size: 90%;  }pre {  overflow-x: auto; }.latexblock, blockquote, pre { margin-top: 10px; margin-bottom: 10px; padding-bottom: 5px; padding-top: 5px; background-color: #FFFFFF; }.latexblock { line-height: 1em }
pre, kbd, samp, tt{ font-family:'Blog Mono',monospace; }.inline { white-space: nowrap; background:#efefef; }ul, ol { list-style-position: inside; padding-left: 0; }ul { list-style-type: disclosure-closed; }</style></head><body><div class='container'><h2><a id=mutual-recursion-elaboration-in-lean href='#mutual-recursion-elaboration-in-lean'> ยง </a><span class='centered'> Mutual recursion elaboration in Lean </h2> 
 <span class='centered'>Lean has four backends for elaborating mutual definitions.  
 <ul><li><span class='centered'><span class='centered'>   Lean, given a mutual def block, can compile to (1) partial, which is <span class='centered'>just an opaque blob in the kernel, (2) primitive recursion on an <span class='centered'>inductive type via  <code class='inline'>recOn</code>, (3) well founded induction via  <code class='inline'>WF</code>, <span class='centered'>and (4)  <code class='inline'>brecOn</code> +  <code class='inline'>casesOn</code>, which allows us to split the recursion <span class='centered'>into the pattern matching part (casesOn) and the recursion part <span class='centered'>(brecOn). </li></ul> 
 <ul><li><span class='centered'><span class='centered'>   (2)  <code class='inline'>recOn</code> is primitive recursion, and is synthesized by the <span class='centered'>kernel for every inductive declaration. It is often complicated to <span class='centered'>elaborate pattern matching syntax into a primitive recursor, and is <span class='centered'>a research question for the mathematically correct, complete <span class='centered'>solution which handles all cases. This is the lowest level of <span class='centered'>recursion in Lean, and supports good definitional equality. However, <span class='centered'>the code generator does not currently generate code for  <code class='inline'>recOn</code> of <span class='centered'>mutal inductives, and thus cannot be executed. When working with <span class='centered'>objects that live in  <code class='inline'>Type</code>, it is a good idea to use  <code class='inline'>recOn</code> right <span class='centered'>now, since (a) it reduces correctly, and (b) has no computational <span class='centered'>content. </li></ul> 
 <ul><li><span class='centered'><span class='centered'>   (3)  <code class='inline'>WF</code> is well founded recursion on a terminating metric, which <span class='centered'>allows one to express functions more easily than primitive <span class='centered'>recursion. Currently, mutual recursion elaborates into  <code class='inline'>WF</code>. The <span class='centered'>drawback is that it has poor definitional equality, and thus breaks <span class='centered'>a lot of convenient reasoning. It has support in the code generator, <span class='centered'>since the code generator supports evaluating  <code class='inline'>recOn</code> of non-mutual <span class='centered'>definitions (which  <code class='inline'>WF</code> is). </li></ul> 
 <ul><li><span class='centered'><span class='centered'>   As an example of where  <code class='inline'>WF</code> is more convenient than  <code class='inline'>recOn</code>, think <span class='centered'>of ackermann in first order logic. It's not primitive recursive, but <span class='centered'>does terminate by well founded induction on the lexicographic metric <span class='centered'>of the naturals. Another example is the hydra tree, which is a crazy <span class='centered'>game which is known to be finite, but any proof system that can <span class='centered'>prove the game is finite has at least as much proof strength as PA <span class='centered'>(Kirby and Paris). </li></ul> 
 <ul><li><span class='centered'><span class='centered'>   (4)  <code class='inline'>brec</code> +  <code class='inline'>casesOn</code> which is used to elaborate inductive <span class='centered'>predicates.  <code class='inline'>brec</code> is bounded recursion, which allows using <span class='centered'><span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></span>-inductoin: using inductive hypothesis upto  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></span> children behind <span class='centered'>you. Useful for encoding things like fibonacci, where for a <span class='centered'><span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(S(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span> depends on  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> and  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span></span> (2-induction). This way of <span class='centered'>elaborating mutual inductives splits the matching part ( <code class='inline'>casesOn</code>) <span class='centered'>from the indction part ( <code class='inline'>brecOn</code>), and is thus more convenient to <span class='centered'>elaborate into than a lower level  <code class='inline'>recOn</code>. There are some bugs <span class='centered'>luring in the lean elaborator for inductive predicates, so this is <span class='centered'>not fully figured out. </li></ul> 
 <ul><li><span class='centered'><span class='centered'>   Coq gets away with this stuff, because coq has  <code class='inline'>fix</code> +  <code class='inline'>match</code> in <span class='centered'>the kernel, and they have guardedness checks  <i><span class='centered'>in the kernel </i> which <span class='centered'>checks that the fix is structurally decreasing or whatever. This is <span class='centered'>complicated, and has led to many soundness bugs in the kernel. Thus, <span class='centered'>Lean wishes to avoid this. </li></ul> 
 <ul><li><span class='centered'><span class='centered'>   Thus, in an ideal world, we would improve the elaborator to <span class='centered'>elaborate everything into  <code class='inline'>rec</code>, and would teach the code generator <span class='centered'>how to code generate mutual  <code class='inline'>rec</code>. </li></ul> 
 <h4><a id=simp-bottlenecks href='#simp-bottlenecks'> ยง </a><span class='centered'> Simp Bottlenecks </h4> 
 <span class='centered'>Benchmarking simp with perf showed us that the bottleneck in one example 
 <span class='centered'>was in  <code class='inline'>congr</code>, which recursively calls  <code class='inline'>simp</code> and  <code class='inline'>dsimp</code> (dsimp is a 
 <span class='centered'>variant of simp which preserves definitional equality). This needs to be 
 <span class='centered'>investigated further.  
 <span class='centered'>Another bottleneck could be that simp processes bottom-up. This can lead 
 <span class='centered'>to quadratic behaviour on certain tests. For example, consider:  
 <pre><code>(not (and A  B) = (or (not A) (not B)
</code></pre> 
 <span class='centered'>We denote the currently processed node with square brackets  <code class='inline'>[.]</code> If we 
 <span class='centered'>proceed top-down, see that we would need a quadratic number of steps, 
 <span class='centered'>because we need a linear number of steps to reach the top from the 
 <span class='centered'>bottom, where we push down the  <code class='inline'>not</code>. We must repeat this till fixpoint.  
 <pre><code>(not (and (and  a   b )  c ))
(not (and (and  a   b ) [c]))
(not (and (and  a  [b])  c))
(not (and (and [a]  b)   c))
(not (and [and  a   b]   c))
(not [and (and  a   b)   c])
[not (and (and  a   b)   c]
;; TRANSFORM=>
(or (not  (and a b) (not c))
;; ...
</code></pre> 
 <h4><a id=simp-lemma-generation href='#simp-lemma-generation'> ยง </a><span class='centered'> Simp lemma generation </h4> 
 <span class='centered'>If we define functions in a mutual def block, and we tag these functions 
 <span class='centered'>as  <code class='inline'>simp</code>, then simp must generate simp lemmas. If we have a definition 
 <span class='centered'>of the form:  
 <pre><code>inductive X where
| X1 | X2 .. | Xn

def foo: X -> X -> Bool
| X1, _ => True
| _, X2 => False
</code></pre> 
 <span class='centered'>the theorems will be:  
 <pre><code>theorem foo.simp1 (x x': X) (h: x = X1): foo x x' = True.
theorem foo.simp2 (x x': X) (h: x /= X1) (h': x' = X2): foo x x' = False.
</code></pre> 
 <span class='centered'>This could be very expensive in case we have complicated mutual 
 <span class='centered'>definitions, since Lean can blow up if we have many inductives.  
 <script src="https://utteranc.es/client.js"        repo="bollu/bollu.github.io"        issue-term="pathname"        label="question"        theme="github-light"        crossorigin="anonymous"        async></script></container></body></html>