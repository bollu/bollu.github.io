<!DOCTYPE html><meta charset='UTF-8'><html><head><link rel='alternate' type='application/rss+xml' href='feed.rss' title='A universe of sorts'/><link rel='stylesheet' href='katex/katex.min.css'    integrity='sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X'    crossorigin='anonymous'><!-- The loading of KaTeX is deferred to speed up page rendering --><link rel='stylesheet' href='prism/prism.css'><title> A Universe of Sorts </title><style>@font-face {font-family: 'Blog Mono'; src: url('/static/iosevka-fixed-extended.ttf');}@font-face {font-family: 'Blog Sans'; src: url('/static/Exo2-Regular.ttf');}@font-face {font-family: 'Blog Serif'; src: url('/static/Revans-Regular.ttf');}html { font-size: 100%; }html,body { text-size-adjust: none; -webkit-text-size-adjust: none; -moz-text-size-adjust: none; -ms-text-size-adjust: none; } body { line-height: 1.5em;  color: #000000;  font-family: serif;  font-size: 12px;  margin-top: 0px;  max-width: 100%; overflow-x: hidden; }
h1, h2, h3, h4, h5 { font-family: 'Blog Mono', monospace; }h1, h2 { column-span: all; }img { display:block; width: 100%; max-width: 800px; height: auto }.container { overflow-x: auto; overflow-y: hidden;              margin-top: 0px; height: 100%; min-height: 100%;             max-width: 100%;              font-size: 18px; line-height: 1.5em;              column-count: auto; column-width: 25em; column-fill: auto;              padding-left: 30px; padding-right: 30px; background: #FFFFFF;}@media (max-width: 480px) {   .container { margin-left: 1%; margin-right: 1%; }  body { font-size: 30px; }  } @media (max-width: 1024px) {  .container { margin-left: 1%; margin-right: 1%; }  body { font-size: 30px; }}@media (min-width: 1024px) { .container { margin-left: 1%; margin-right: 1%; } }.image { }
a:hover { color: #1a73e8; text-decoration: underline;  }
a { color: #1a73e8; text-decoration: none; }
a:visited { color: #1a73e8; text-decoration: none; }
a:active { color: #1a73e8; text-decoration: none; }

blockquote { margin-left: 0px; margin-right: 0px; } pre, .latexblock, blockquote { border-left-color:#BBB;  border-left-style: solid;      border-left-width: 5px; }pre, blockquote { padding-left: 10px; }
pre { font-family: 'Blog Mono', monospace; font-size: 90%;  }pre {  overflow-x: auto; }.latexblock, blockquote, pre { margin-top: 10px; margin-bottom: 10px; padding-bottom: 5px; padding-top: 5px; background-color: #FFFFFF; }.latexblock { line-height: 1em }
pre, kbd, samp, tt{ font-family:'Blog Mono',monospace; }.inline { white-space: nowrap; background:#efefef; }ul, ol { list-style-position: inside; padding-left: 0; }ul { list-style-type: disclosure-closed; }</style></head><body><div class='container'><h2><a id=a-quick-look-at-impredicativity href='#a-quick-look-at-impredicativity'> ยง </a><span class='centered'> A quick look at impredicativity </h2> 
 <span class='centered'>I found this video very helpful, since I was indeed confused about the two 
 <span class='centered'>meanings of impredicativity that I had seen floating around. One used by haskellers, 
 <span class='centered'>which was that you can't instantiate a type variable  <code class='inline'>a</code> with a  ( <code class='inline'>forall t</code>). 
 <span class='centered'>Impredicative in Coq means having  <code class='inline'>(Type : Type)</code>.  
 <ul><li><span class='centered'><span class='centered'> polymorphic types: </li></ul> 
 <pre><code><span class="token hvariable">forall</span> <span class="token hvariable">p</span><span class="token punctuation">.</span> <span class="token punctuation">[</span><span class="token hvariable">p</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token hvariable">p</span><span class="token punctuation">]</span> <span class="token comment">-- LEGAL</span>
<span class="token constant">Int</span> <span class="token operator">-></span> <span class="token punctuation">(</span><span class="token hvariable">forall</span> <span class="token hvariable">p</span><span class="token punctuation">.</span> <span class="token punctuation">[</span><span class="token hvariable">p</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token hvariable">p</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">-- ILLEGAL</span>
<span class="token punctuation">(</span><span class="token hvariable">forall</span> <span class="token hvariable">p</span><span class="token punctuation">.</span> <span class="token punctuation">[</span><span class="token hvariable">p</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token hvariable">p</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token operator">-></span> <span class="token constant">Int</span> <span class="token comment">-- ILLEGAL</span>
<span class="token punctuation">[</span><span class="token hvariable">forall</span> <span class="token hvariable">a</span><span class="token punctuation">.</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token comment">-- ILLEGAL</span>
</code></pre> 
 <ul><li><span class='centered'><span class='centered'> Higher rank types:  <code class='inline'>forall</code> at the outermost level of a let-bound function, <span class='centered'>and to the left and right of arrows! </li></ul> 
 <pre><code><span class="token constant">Int</span> <span class="token operator">-></span> <span class="token punctuation">(</span><span class="token hvariable">forall</span> <span class="token hvariable">p</span><span class="token punctuation">.</span> <span class="token punctuation">[</span><span class="token hvariable">p</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token hvariable">p</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">-- LEGAL</span>
<span class="token punctuation">(</span><span class="token hvariable">forall</span> <span class="token hvariable">p</span><span class="token punctuation">.</span> <span class="token punctuation">[</span><span class="token hvariable">p</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token hvariable">p</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token operator">-></span> <span class="token constant">Int</span> <span class="token comment">-- LEGAL</span>
<span class="token hvariable">runST</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">forall</span> <span class="token hvariable">s</span><span class="token punctuation">.</span> <span class="token constant">ST</span> <span class="token hvariable">s</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token hvariable">a</span> <span class="token comment">-- LEGAL</span>
<span class="token punctuation">[</span><span class="token hvariable">forall</span> <span class="token hvariable">a</span><span class="token punctuation">.</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token comment">-- ILLEGAL</span>
</code></pre> 
 <ul><li><span class='centered'><span class='centered'> Impredicative type: </li></ul> 
 <pre><code><span class="token punctuation">[</span><span class="token hvariable">forall</span> <span class="token hvariable">a</span><span class="token punctuation">.</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">a</span><span class="token punctuation">]</span>
</code></pre> 
 <ul><li><span class='centered'><span class='centered'> We can't type  <code class='inline'>runST</code> because of impredicativity: </li></ul> 
 <pre><code><span class="token punctuation">(</span><span class="token operator">$</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">forall</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">forall</span> <span class="token hvariable">b</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">b</span>
<span class="token hvariable">runST</span> <span class="token operator">::</span> <span class="token hvariable">forall</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token hvariable">forall</span> <span class="token hvariable">s</span><span class="token punctuation">,</span> <span class="token constant">ST</span> <span class="token hvariable">s</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token hvariable">a</span> <span class="token comment">-- LEGAL</span>
<span class="token hvariable">st</span> <span class="token operator">::</span> <span class="token hvariable">forall</span> <span class="token hvariable">s</span><span class="token punctuation">.</span> <span class="token constant">ST</span> <span class="token hvariable">s</span> <span class="token constant">Int</span>
<span class="token hvariable">runST</span> <span class="token hvariable">st</span> <span class="token comment">-- YES</span>
<span class="token hvariable">runST</span> <span class="token operator">$</span> <span class="token hvariable">st</span> <span class="token comment">-- NO</span>
</code></pre> 
 <ul><li><span class='centered'><span class='centered'> Expanding out the example: </li></ul> 
 <pre><code><span class="token punctuation">(</span><span class="token operator">$</span><span class="token punctuation">)</span> <span class="token hvariable">runST</span> <span class="token hvariable">st</span>
<span class="token punctuation">(</span><span class="token operator">$</span><span class="token punctuation">)</span> <span class="token operator">@</span> <span class="token punctuation">(</span><span class="token hvariable">forall</span> <span class="token hvariable">s</span><span class="token punctuation">.</span> <span class="token constant">ST</span> <span class="token hvariable">s</span> <span class="token constant">Int</span><span class="token punctuation">)</span> <span class="token operator">@</span><span class="token constant">Int</span>  <span class="token punctuation">(</span><span class="token hvariable">runST</span> <span class="token operator">@</span> <span class="token constant">Int</span><span class="token punctuation">)</span> <span class="token hvariable">st</span>
</code></pre> 
 <ul><li><span class='centered'><span class='centered'> Data structures of higher kinded things. For example. we might want to have  <code class='inline'>[โ a, a -> a]</code></li><li><span class='centered'><span class='centered'> We have  <code class='inline'>ids :: [โ a, a -> a]</code>. I also have the function  <code class='inline'>id :: โ a, a -> a</code>. I want <span class='centered'>to build  <code class='inline'>ids' = (:) id ids</code>. That is, I want to cons an  <code class='inline'>id</code> onto my list  <code class='inline'>ids</code>. </li><li><span class='centered'><span class='centered'> How do we type infer this? </li></ul> 
 <h4><a id=how-does-ordinary-type-inference-work href='#how-does-ordinary-type-inference-work'> ยง </a><span class='centered'> How does ordinary type inference work? </h4> 
 <pre><code><span class="token builtin">reverse</span> <span class="token operator">::</span> โ <span class="token hvariable">a</span><span class="token punctuation">.</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token builtin">and</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Bool</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token constant">Bool</span>
<span class="token hvariable">foo</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">xs</span> <span class="token operator">-></span> <span class="token punctuation">(</span><span class="token builtin">reverse</span> <span class="token hvariable">xs</span><span class="token punctuation">,</span> <span class="token builtin">and</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>
</code></pre> 
 <ul><li><span class='centered'><span class='centered'> Start with  <code class='inline'>xs :: ฮฑ</code> where  <code class='inline'>ฮฑ</code> is a type variable. </li><li><span class='centered'><span class='centered'> Typecheck  <code class='inline'>reverse xs</code>. We need to instantiate  <code class='inline'>reverse</code>. With what type? <span class='centered'><i><span class='centered'><i><span class='centered'>that's what we need to figure out! </i></i></li><li><span class='centered'><span class='centered'> (1) Instantiate: Use variable  <code class='inline'>ฮฒ</code>. So we have that our occurence of  <code class='inline'>reverse</code> has type <span class='centered'><code class='inline'>reverse :: [ฮฒ] -> [ฮฒ]</code>. </li><li><span class='centered'><span class='centered'> (2) Constrain: We know that  <code class='inline'>xs :: ฮฑ</code> and  <code class='inline'>reverse</code> expects an input argument of <span class='centered'>type  <code class='inline'>[ฮฒ]</code>, so we set  <code class='inline'>ฮฑ ~ [ฮฒ]</code> due to the call  <code class='inline'>reverse xs</code>. </li><li><span class='centered'><span class='centered'> We now need to do  <code class='inline'>and xs</code>. (1)  <code class='inline'>and</code> doesn't have any type variables, so we don't need <span class='centered'>to perform instantiation. (2) We can constrain the type, because  <code class='inline'>and :: [Bool] -> Bool</code>, <span class='centered'>we can infer from  <code class='inline'>and xs</code> that  <code class='inline'>ฮฑ ~ [Bool]</code></li><li><span class='centered'><span class='centered'> We solve using  <a href=https://en.wikipedia.org/wiki/Robinson%27s_unification_algorithm><span class='centered'><i><span class='centered'><i><span class='centered'>Robinson unification </i></i></a>. <span class='centered'>We get  <code class='inline'>[ฮฒ] ~ ฮฑ ~ [Bool]</code> or  <code class='inline'>ฮฒ = Bool</code></li></ul> 
 <h4><a id=where-does-this-fail-for-polytypes href='#where-does-this-fail-for-polytypes'> ยง </a><span class='centered'> Where does this fail for polytypes? </h4> 
 <ul><li><span class='centered'><span class='centered'> The above works because  <code class='inline'>ฮฑ</code> and  <code class='inline'>ฮ</code> only stand for  <i><span class='centered'><i><span class='centered'>monotypes </i></i>. </li><li><span class='centered'><span class='centered'> Our constraints are  <i><span class='centered'><i><span class='centered'>equality constraints </i></i>, which can be solved by <span class='centered'><i><span class='centered'><i><span class='centered'>Robinson unification </i></i></li><li><span class='centered'><span class='centered'> And we have only  <i><span class='centered'><i><span class='centered'>one solution </i></i> (principal solution) </li><li><span class='centered'><span class='centered'> When trying to instantiate reverse, how do we instantiate it? </li><li><span class='centered'><span class='centered'> Constraints become subsumption constraints </li><li><span class='centered'><span class='centered'> Solving is harder </li><li><span class='centered'><span class='centered'> No principal solution </li><li><span class='centered'><span class='centered'> Consider  <code class='inline'>incs :: [Int -> Int]</code>, and  <code class='inline'>(:) id incs</code> versus  <code class='inline'>(:) id ids</code>. </li></ul> 
 <h4><a id=but-it-looks-so-easy href='#but-it-looks-so-easy'> ยง </a><span class='centered'> But it looks so easy! </h4> 
 <ul><li><span class='centered'><span class='centered'> We want to infer  <code class='inline'>(:) id ids</code></li><li><span class='centered'><span class='centered'> We know that the second argument  <code class='inline'>ids</code> had type  <code class='inline'>[โ a, a -> a]</code></li><li><span class='centered'><span class='centered'> we need a type  <code class='inline'>[p]</code> for the second argument, because  <code class='inline'>(:) :: p -> [p] -> [p]</code></li><li><span class='centered'><span class='centered'> Thus we must have  <code class='inline'>p ~ (โ a, a -> a)</code></li><li><span class='centered'><span class='centered'> We got this information  <i><span class='centered'><i><span class='centered'>from the second argument </i></i></li><li><span class='centered'><span class='centered'> So let's try to treat an application  <code class='inline'>(f e1 e2 ... en)</code> as a whole. </li></ul> 
 <h4><a id=new-plan href='#new-plan'> ยง </a><span class='centered'> New plan </h4> 
 <ul><li><span class='centered'><span class='centered'> Assume we want to figure out  <code class='inline'>filter g ids</code>. </li><li><span class='centered'><span class='centered'> start with  <code class='inline'>filter :: โ p, (p -> Bool) -> [p] -> Bool</code></li><li><span class='centered'><span class='centered'> Instatiate  <code class='inline'>filter</code> with  <i><span class='centered'><i><span class='centered'>instantiation variables </i></i>  <code class='inline'>ฮบ</code> to get <span class='centered'><code class='inline'>(ฮบ -> Bool) -> [ฮบ] -> Bool</code></li><li><span class='centered'><span class='centered'> Take a "quick look" at  <code class='inline'>e1, e2</code> to see if we know that  <code class='inline'>ฮบ</code> should be </li><li><span class='centered'><span class='centered'> We get from  <code class='inline'>filter g ids</code> that  <code class='inline'>ฮบ := (โ a, a -> a)</code>. </li><li><span class='centered'><span class='centered'> Substitute for  <code class='inline'>ฮบ</code>  (1) the type that "quick look" learnt, if any, and <span class='centered'>(2) A  <i><span class='centered'><i><span class='centered'>monomorphic </i></i> unification variable otherwise. </li><li><span class='centered'><span class='centered'> Typecheck against the type. In this case, we learnt that  <code class='inline'>ฮบ := (โ a, a -> a)</code>, <span class='centered'>so we replace  <code class='inline'>ฮบ</code> with  <code class='inline'>(โ a, a -> a)</code>. </li><li><span class='centered'><span class='centered'> Note that this happens at each  <i><span class='centered'><i><span class='centered'>call site </i></i>! </li></ul> 
 <h4><a id=the-big-picture href='#the-big-picture'> ยง </a><span class='centered'> The big picture </h4> 
 <span class='centered'>Replace the idea of: 
 <ul><li><span class='centered'><span class='centered'> instantate function with unficiation variables, with the idea. </li><li><span class='centered'><span class='centered'> instantiate function with a quick look at the calling context. </li><li><span class='centered'><span class='centered'> We don't need fully saturated calls. We take a look at whatever we can see! </li><li><span class='centered'><span class='centered'> Everything else is completely unchanged. </li></ul> 
 <h4><a id=what-can-quicklook-learn href='#what-can-quicklook-learn'> ยง </a><span class='centered'> What can QuickLook learn? </h4> 
 <ul><li><span class='centered'><span class='centered'>  <a href=https://www.youtube.com/watch?v=ZuNMo136QqI><span class='centered'>Video </a></li></ul> 
 <script src="https://utteranc.es/client.js"        repo="bollu/bollu.github.io"        issue-term="pathname"        label="question"        theme="github-light"        crossorigin="anonymous"        async></script></container></body></html>