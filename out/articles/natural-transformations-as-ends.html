<!DOCTYPE html><meta charset='UTF-8'><html><head><link rel='alternate' type='application/rss+xml' href='feed.rss' title='A universe of sorts'/><link rel='stylesheet' href='/katex/katex.min.css'    integrity='sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X'    crossorigin='anonymous'><!-- The loading of KaTeX is deferred to speed up page rendering --><link rel='stylesheet' href='/prism/prism.css'><title> A Universe of Sorts </title><style>@font-face {font-family: 'Blog Mono'; src: url('/static/iosevka-fixed-extended.ttf');}@font-face {font-family: 'Blog Sans'; src: url('/static/Exo2-Regular.ttf');}@font-face {font-family: 'Blog Serif'; src: url('/static/Revans-Regular.ttf');}html { font-size: 100%; min-height: 100% }html,body { text-size-adjust: none; -webkit-text-size-adjust: none; -moz-text-size-adjust: none; -ms-text-size-adjust: none; } body { min-height: 100vh;  line-height: 1.5em;  color: #000000;  font-family: serif;  font-size: 12px;  margin-top: 0px;  max-width: 100%; overflow-x: hidden; }
h1, h2, h3, h4, h5 { font-family: 'Blog Mono', monospace; }h1, h2 { column-span: all; }img { display:block; width: 100%; max-width: 800px; height: auto }.container { overflow-x: auto; overflow-y: hidden;              margin-top: 0px; height: 100%; min-height: 100%;             max-width: 100%;              font-size: 18px; line-height: 1.5em;              column-count: auto; column-width: 25em; column-fill: auto;              padding-left: 30px; padding-right: 30px; background: #FFFFFF;}@media (max-width: 480px) {   .container { margin-left: 1%; margin-right: 1%; }  body { font-size: 30px; }  } @media (max-width: 1024px) {  .container { margin-left: 1%; margin-right: 1%; }  body { font-size: 30px; }}@media (min-width: 1024px) { .container { margin-left: 1%; margin-right: 1%; } }.image { }
a:hover { color: #1a73e8; text-decoration: underline;  }
a { color: #1a73e8; text-decoration: none; }
a:visited { color: #1a73e8; text-decoration: none; }
a:active { color: #1a73e8; text-decoration: none; }

blockquote { margin-left: 0px; margin-right: 0px; } pre, .latexblock, blockquote { border-left-color:#BBB;  border-left-style: solid;      border-left-width: 5px; }pre, blockquote { padding-left: 10px; }
pre { font-family: 'Blog Mono', monospace; font-size: 90%;  }pre {  overflow-x: auto; }.latexblock, blockquote, pre { margin-top: 10px; margin-bottom: 10px; padding-bottom: 5px; padding-top: 5px; background-color: #FFFFFF; }.latexblock { line-height: 1em }
pre, kbd, samp, tt{ font-family:'Blog Mono',monospace; }.inline { white-space: nowrap; background:#efefef; }ul, ol { list-style-position: inside; padding-left: 0; }ul { list-style-type: disclosure-closed; }</style></head><body><div class='container'><h2><a id=articles/natural-transformations-as-ends href='#articles/natural-transformations-as-ends'> § </a><span class='centered'> Natural Transformations as ends </h2>
 <ul><li><span class='centered'><span class='centered'>  <a href=https://www.youtube.com/watch?v=DseY4qIGZV4&list=PLbgaMIhjbmEn64WVX4B08B4h2rOtueWIL&index=13><span class='centered'>Bartosz: Natural transformations as ends </a></li><li><span class='centered'><span class='centered'> Ends generalize the notion of product/limit. It's sort of like an infinite product plus the wedge condition. </li><li><span class='centered'><span class='centered'>  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∫</mo><mi>X</mi></msub><mi>p</mi><mi>x</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\int_X p x x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1608200000000002em;vertical-align:-0.35582em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.12251099999999993em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35582em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">x</span><span class="mord mathnormal">x</span></span></span></span></span> is the notation for ends, where  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span></span> is a profunctor. </li><li><span class='centered'><span class='centered'> Remember  <code class='inline'>dimap :: (a' -> a) -> (b -> b') -> p a b -> p a' b'</code>. Think of this as: </li></ul> 
 <pre><code>-----p a' b'-------
a' -> [a -> b] -> b'
       --pab---
</code></pre> 
 <ul><li><span class='centered'><span class='centered'> The set of natural transformations is an end. </li><li><span class='centered'><span class='centered'> Haskell:  <code class='inline'>type Nat f g = forall x. f x -> g x</code>. </li><li><span class='centered'><span class='centered'> We can think of this as the "diagonal" of some end  <code class='inline'>p x x</code> for some profunctor  <code class='inline'>p</code> we need to cook up. </li><li><span class='centered'><span class='centered'>  <code class='inline'>type p f g a b = f a -> g b</code>. Is  <code class='inline'>p f g</code> a profunctor? </li></ul> 
 <pre><code>dimap :: (a' -> a) -> (b -> b') -> (f a -> g b) -> (f a' -> g b')
dimap a'2a b2b' fa2gb = \fa' ->
  let fa = fmap a'2a fa'
  let gb = fa2gb fa
  let gb' - fmap b2b' gb
  in gb'
dimap a'2a b2b' fa2gb = (@fmap g b2b')  . fa2gb  . (@fmap f a'2a)
</code></pre> 
 <ul><li><span class='centered'><span class='centered'> Clearly, from the above implementation, we have a profunctor. </li><li><span class='centered'><span class='centered'> So we have a profunctor  <code class='inline'>P(a, b) = C(Fa, Gb)</code>. </li><li><span class='centered'><span class='centered'> In haskell, the end is  <code class='inline'>End p = forall a. p a a</code>. </li><li><span class='centered'><span class='centered'> In our notation, it's  <code class='inline'>\int_x C(Fx, Gx)</code>. </li><li><span class='centered'><span class='centered'> Recall the wedge condition. For a profunctor  <code class='inline'>p: Cop x C -> C</code>, and any morphism  <code class='inline'>k: a -> b</code> for  <code class='inline'>a, b ∈ C</code>, <span class='centered'>the following diagram commutes for the end  <code class='inline'>\int_X p(X,X)</code>: </li></ul> 
 <pre><code> (p x x, p y y, p z z, ... infinite product)
\int_x p(x,x)
 /[πa]  [πb]\
v            v
p(a,a)       p(b,b)
 \            /
[p(id, k)]  [p(k,id)]
   \        /
    v      v
     p a b
</code></pre> 
 <ul><li><span class='centered'><span class='centered'> If we replace  <code class='inline'>p x x</code> with with our concrete  <code class='inline'>p a b = C(fa, gb)</code>, we get: </li></ul> 
 <pre><code>    (forall x. f x -> g x)
    /               \
  [@ a]            [@ b]
   v                v
 τa:(f a -> g a)     τb:(f b -> g b)
   \                  /
dimap id(a) k τa    dimap k id(b) τb
   \                 /
    \               τb.(@fmap f k): (f a-> g b)
     \              /
     \           COMMUTES?
     \            /
    (@fmap g k).τa(f a -> g b)

</code></pre> 
 <ul><li><span class='centered'><span class='centered'> This says that  <code class='inline'>gk . τa = τb . fk</code></li><li><span class='centered'><span class='centered'> But this is a naturality condition for  <code class='inline'>τ</code>! </li><li><span class='centered'><span class='centered'> So every end corresponds to a natural transformation, and  <code class='inline'>τ</code> lives in  <code class='inline'>[C, D](f, g)</code>. </li><li><span class='centered'><span class='centered'> This shows us that the set of natural transformations can be seen as an end (?) </li><li><span class='centered'><span class='centered'> I can write  <code class='inline'>\int_a D(fa, ga) ~= [C, D](f, g)</code></li></ul> 
 <h4><a id=articles/invoking-yoneda href='#articles/invoking-yoneda'> § </a><span class='centered'> Invoking Yoneda </h4> 
 <ul><li><span class='centered'><span class='centered'> Now, yoneda tells us that  <code class='inline'>[C, Set](C(a, -), f(-)) ~= f(a)</code>. </li><li><span class='centered'><span class='centered'> Now I write the above in terms of ends as  <code class='inline'>\int_x Set(C(a, (x)), f(x)) ~= f(a)</code>. </li><li><span class='centered'><span class='centered'> So we can write this as a "point-full" notation! </li><li><span class='centered'><span class='centered'> In haskell, this would be  <code class='inline'>forall x. (a -> x) -> f x ~= f a</code>. </li></ul> 
 <script src="https://utteranc.es/client.js"        repo="bollu/bollu.github.io"        issue-term="pathname"        label="question"        theme="github-light"        crossorigin="anonymous"        async></script></container></body></html>