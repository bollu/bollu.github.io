<!DOCTYPE html><meta charset='UTF-8'><html><head><link rel='alternate' type='application/rss+xml' href='feed.rss' title='A universe of sorts'/><link rel='stylesheet' href='katex/katex.min.css'    integrity='sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X'    crossorigin='anonymous'><!-- The loading of KaTeX is deferred to speed up page rendering --><link rel='stylesheet' href='prism/prism.css'><title> A Universe of Sorts </title><style>@font-face {font-family: 'Blog Mono'; src: url('/static/iosevka-fixed-extended.ttf');}@font-face {font-family: 'Blog Sans'; src: url('/static/Exo2-Regular.ttf');}@font-face {font-family: 'Blog Serif'; src: url('/static/Revans-Regular.ttf');}html { font-size: 100%; }html,body { text-size-adjust: none; -webkit-text-size-adjust: none; -moz-text-size-adjust: none; -ms-text-size-adjust: none; } body { line-height: 1.5em;  color: #000000;  font-family: serif;  font-size: 12px;  margin-top: 0px;  max-width: 100%; overflow-x: hidden; }
h1, h2, h3, h4, h5 { font-family: 'Blog Mono', monospace; }h1, h2 { column-span: all; }img { display:block; width: 100%; max-width: 800px; height: auto }.container { overflow-x: auto; overflow-y: hidden;              margin-top: 0px; height: 100%; min-height: 100%;             max-width: 100%;              font-size: 18px; line-height: 1.5em;              column-count: auto; column-width: 25em; column-fill: auto;              padding-left: 30px; padding-right: 30px; background: #FFFFFF;}@media (max-width: 480px) {   .container { margin-left: 1%; margin-right: 1%; }  body { font-size: 30px; }  } @media (max-width: 1024px) {  .container { margin-left: 1%; margin-right: 1%; }  body { font-size: 30px; }}@media (min-width: 1024px) { .container { margin-left: 1%; margin-right: 1%; } }.image { }
a:hover { color: #1a73e8; text-decoration: underline;  }
a { color: #1a73e8; text-decoration: none; }
a:visited { color: #1a73e8; text-decoration: none; }
a:active { color: #1a73e8; text-decoration: none; }

blockquote { margin-left: 0px; margin-right: 0px; } pre, .latexblock, blockquote { border-left-color:#BBB;  border-left-style: solid;      border-left-width: 5px; }pre, blockquote { padding-left: 10px; }
pre { font-family: 'Blog Mono', monospace; font-size: 90%;  }pre {  overflow-x: auto; }.latexblock, blockquote, pre { margin-top: 10px; margin-bottom: 10px; padding-bottom: 5px; padding-top: 5px; background-color: #FFFFFF; }.latexblock { line-height: 1em }
pre, kbd, samp, tt{ font-family:'Blog Mono',monospace; }.inline { white-space: nowrap; background:#efefef; }ul, ol { list-style-position: inside; padding-left: 0; }ul { list-style-type: disclosure-closed; }</style></head><body><div class='container'><h2><a id=a5-is-not-solvable href='#a5-is-not-solvable'> § </a><span class='centered'> A5 is not solvable </h2> 
 <span class='centered'>There are many accounts of why A5 is not solvable on the internet. I'm recording my 
 <span class='centered'>version here, because the proof involves certain ad-hoc choices which I want 
 <span class='centered'>to make sure I can find off-hand in the future. 
 <span class='centered'>We'll show that  <code class='inline'>[A5, A5] = A5</code>, thereby proving that  <code class='inline'>A5</code> not solvable. 
 <span class='centered'>This is useful for Galois theory, where we want to show tha  <code class='inline'>A5</code> cannot be 
 <span class='centered'>built as extensions of smaller cyclic groups.  
 <h4><a id=notation href='#notation'> § </a><span class='centered'> Notation </h4> 
 <span class='centered'>I'll be using non-standard notation:  <code class='inline'>(12);(34)</code> means 'perform  <code class='inline'>(12)</code> then perform  <code class='inline'>(34)</code>'. 
 <span class='centered'>I find this notation makes permutation composition intuitive for me. The  <code class='inline'>;</code>
 <span class='centered'>is evocative of C-style languages, where we are ending a statement. I will 
 <span class='centered'>be consistently using  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>g</mi><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">]</mo><mo>≡</mo><mi>g</mi><mi>h</mi><msup><mi>g</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msup><mi>h</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">[g, h] \equiv ghg^{-1}h^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">h</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span> to denote the commutator.  
 <h4><a id=permutations-in-a5 href='#permutations-in-a5'> § </a><span class='centered'> permutations in A5 </h4> 
 <span class='centered'>First, recall that  <code class='inline'>A5</code> only has the  <i><span class='centered'>even </i> permutations in  <code class='inline'>S5</code>. So it can 
 <span class='centered'>have zero, two, four, involutions that build it up. There can't be more after 
 <span class='centered'>simplification, since  <code class='inline'>S5</code> ony has  <code class='inline'>5</code> elements --- the largest sequence 
 <span class='centered'>of transpositions we can do is  <code class='inline'>(12)(23)(34)(45)</code>. So, in  <code class='inline'>A5</code>, we have:  
 <ul><li><span class='centered'><span class='centered'> The identity permutation  <code class='inline'>()</code>. </li><li><span class='centered'><span class='centered'> The transpositions  <code class='inline'>(ij)(kl)</code> where  <code class='inline'>{i, j}</code> and  <code class='inline'>{k, l}</code> do not overlap. <span class='centered'>From these, we get the 2-cycles. </li><li><span class='centered'><span class='centered'> The transpositions  <code class='inline'>(ij)(kl)</code> where  <code class='inline'>{i, j}</code> and  <code class='inline'>{k, l}</code> overlap. Here we <span class='centered'>cannot have  <code class='inline'>{i, j} = {k, l}</code> since then we will just have a single transposition. <span class='centered'>So, let us assume that we have  <code class='inline'>j = k</code>. If we have any other equality, we <span class='centered'>can always flip the transpositions around to get to the normal form  <code class='inline'>j = k</code>: </li></ul> 
 <pre><code>(23);(12)
= (32);(12) [(23) = (32)]
= (32);(21) [(12) = (21)]
</code></pre> 
 <ul><li><span class='centered'><span class='centered'> In this case, we can show that such a transposition  <i><span class='centered'>must </i> be a cycle: </li></ul> 
 <pre><code>[a b c] -(32)->
[a c b] -(21)->
[c a b]
</code></pre> 
 <ul><li><span class='centered'><span class='centered'> Intuitively, we are pushing the element  <code class='inline'>c</code> backward, and allowing the <span class='centered'>other elements to take its place using the permutation  <code class='inline'>(23);(12)</code>. </li></ul> 
 <ul><li><span class='centered'><span class='centered'> So, from the transpositions of the form  <code class='inline'>(ij)(kl)</code> where  <code class='inline'>{i, j}</code> and <span class='centered'><code class='inline'>{k, l}</code> intersect, we get the 3-cycles. </li></ul> 
 <ul><li><span class='centered'><span class='centered'> Finally, we can have the transpositions of the form  <code class='inline'>(12)(23)(34)(45)</code>. <span class='centered'>It must be of this form, or some permutation of this form. Otherwise, <span class='centered'>we would have repeated elements, since these transpositions are packed <span class='centered'>"as close as possible". These generate the 5-cycles. </li></ul> 
 <h4><a id=a5-is-generated-by-3-cycles href='#a5-is-generated-by-3-cycles'> § </a><span class='centered'> A5 is generated by 3-cycles. </h4> 
 <span class='centered'>We claim that we can write any element of  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">A5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mord">5</span></span></span></span></span> in terms of 3-cycles.  
 <ul><li><span class='centered'><span class='centered'> The disjoint transpositions of the type  <code class='inline'>(34)(12)</code> can be written as <span class='centered'><code class='inline'>(34)(23)(23)(12)</code>, because  <code class='inline'>(23)(23) = e</code>. This can be further <span class='centered'>broken down into  <code class='inline'>((34)(23)) ((23)(12))</code> which is two 2-cycles: <span class='centered'><code class='inline'>(234); (123)</code>. </li></ul> 
 <ul><li><span class='centered'><span class='centered'> The non-disjoint transpositions of the type  <code class='inline'>(32)(21)</code>  <i><span class='centered'>are </i> 3-cycles: <span class='centered'><code class='inline'>(32)(21) = (123)</code>. </li></ul> 
 <ul><li><span class='centered'><span class='centered'> 3-cycles are 3-cycles. </li></ul> 
 <ul><li><span class='centered'><span class='centered'> Any 5-cycle an be written as two 3-cycles:  <code class='inline'>(45)(34)(23)(12)</code> can be written <span class='centered'>as  <code class='inline'>((45)(34))((23)(12))</code> which is two 3-cycles:  <code class='inline'>(345); (123)</code>. </li></ul> 
 <span class='centered'>So, if we figure out how to write 3-cycles in terms of commutators, we win. 
 <span class='centered'>Because the commutator subgroup of  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">A_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> is generated by elements that 
 <span class='centered'>can be written as  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>g</mi><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[g, h]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">h</span><span class="mclose">]</span></span></span></span></span>. If we can show that 3-cycles can be written 
 <span class='centered'>as  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>g</mi><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[g, h]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">h</span><span class="mclose">]</span></span></span></span></span>, then every other element has a representation in terms of 
 <span class='centered'>these 3-cycles, and are therefore elements of the commutator subgroup.  
 <h4><a id=3-cycles-can-be-generated-as-commutators-of-2-cycles href='#3-cycles-can-be-generated-as-commutators-of-2-cycles'> § </a><span class='centered'> 3-cycles can be generated as commutators of 2-cycles: </h4> 
 <ul><li><span class='centered'><span class='centered'> We saw how we can write a 3-cycle of the form  <code class='inline'>C = (123)</code> as  <code class='inline'>(32)(21)</code>. <span class='centered'>We wish to write this as the commutator of two elements  <code class='inline'>g, h</code>:  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>=</mo><mo stretchy="false">[</mo><mi>g</mi><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">C = [g, h]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">h</span><span class="mclose">]</span></span></span></span></span>. </li></ul> 
 <ul><li><span class='centered'><span class='centered'> The idea is that we have the leftover elements  <code class='inline'>4, 5</code> that are unsused by  <code class='inline'>C</code> in  <code class='inline'>A5</code><span class='centered'>[here is where  <code class='inline'>5</code> is important:  <code class='inline'>3 + 2 = 5</code>, and we need two leftover elements ]. </li></ul> 
 <ul><li><span class='centered'><span class='centered'> We can use these two leftover elements  <code class='inline'>4, 5</code> to build elements  <code class='inline'>g, h</code><span class='centered'>which cancel off, leaving us with  <code class='inline'>(32)(21)</code>. We start with  <code class='inline'>g = (32)___</code>, <span class='centered'><code class='inline'>h = (21)___</code> where the  <code class='inline'>___</code> is to be determined: </li></ul> 
 <pre><code>(32)___||(21)___||___(32)||___(21)
  g        h        g^-1    h^-1
</code></pre> 
 <ul><li><span class='centered'><span class='centered'> It is important that  <code class='inline'>g</code> and  <code class='inline'>h</code> contain another tuple, because they are <span class='centered'>members of  <code class='inline'>A5</code>! We need them to be permutations having  <code class='inline'>2, 4, 6</code> transpositions. </li><li><span class='centered'><span class='centered'> We insert  <code class='inline'>(4 5)</code> everywhere. These  <code class='inline'>(4 5)</code> can slide over the  <code class='inline'>(2 1)</code> and thereby <span class='centered'>harmlessly cancel: </li></ul> 
 <pre><code>(32)(45)||(21)(45)||(45)(32)||(45)(21)
  g        h           g^-1       h^-1
</code></pre> 
 <ul><li><span class='centered'><span class='centered'> Simplify the above expression by moving the  <code class='inline'>(45)</code> over  <code class='inline'>(21), (32)</code>: </li></ul> 
 <pre><code>(32)||(21)(45)(45)||(32)||(45)(45)(21)
  g      h          g^-1    h^-1
</code></pre> 
 <ul><li><span class='centered'><span class='centered'> cancel the  <code class='inline'>(45)(45) = e</code>: </li></ul> 
 <pre><code>(32)||(21)||(32)||(21)
  g   h    g^-1   h^-1
</code></pre> 
 <span class='centered'>So we are left with  <code class='inline'>(32);(21);(32);(21)</code>. This is the  <i><span class='centered'>square </i> of what 
 <span class='centered'>we really wanted,  <code class='inline'>C = (32);(21)</code>. However, since  <code class='inline'>C</code> is a 3-cycle, we know 
 <span class='centered'>that  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>=</mo><msup><mi>C</mi><mrow><mo>−</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">C = C^{-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span>. So, we can start with  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>C</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">C^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span>, use our trick to generate 
 <span class='centered'><span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>C</mi><mrow><mo>−</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">C^{-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span> which is equal to  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span></span>. Since this works for any  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span></span>, we have shown 
 <span class='centered'>that we can generate 3-cycles from commutators of  <code class='inline'>A5</code>.  
 <h4><a id=alternate-viewpoint-on-above-proof href='#alternate-viewpoint-on-above-proof'> § </a><span class='centered'> Alternate viewpoint on above proof </h4> 
 <span class='centered'>We have a 3-cycle  <code class='inline'>s = (a b c)</code>. We first first a square root  <code class='inline'>t</code> such 
 <span class='centered'>that  <code class='inline'>t*t=s</code>. To do this, we make  <code class='inline'>t</code> have the cycles of  <code class='inline'>s</code> spread out 
 <span class='centered'>in gaps of 2:  
 <pre><code>t = (a _ _)
t = (a _ b) [+2]
t = (a c b) [+2, modulo]
</code></pre> 
 <span class='centered'>It is hopefully clear that  <code class='inline'>t*t = s</code>:  
 <pre><code>t = (a c b)
t*t: apply the cycle twice.
t*t = a -(skip c) -> b
      b -(skip a) -> c
      c ->(skip b) -> a
    = (a b c) = s
</code></pre> 
 <span class='centered'>Now, we will write  <code class='inline'>s = t*t</code> and then find the commutator decomposition from 
 <span class='centered'>it:  
 <pre><code>s = t*t
  = (abc)(abc)
  = (cb)(ba)(cb)(ba)
  = (cb)|(ba)|(cb)|(ba)
  = (cb)|(ba)|(cb)|(ba)
     g     h   g-1   h-1
</code></pre> 
 <span class='centered'>But there's a problem: this  <code class='inline'>g</code> and  <code class='inline'>h</code> do not belong to  <code class='inline'>A5</code>, they belong 
 <span class='centered'>to  <code class='inline'>S5</code>. This is fixed by using a random  <code class='inline'>(pq)</code> which we know  <i><span class='centered'>will exist </i>.  
 <h4><a id=recap-how-have-we-shown-that-a5-is-not-solvable href='#recap-how-have-we-shown-that-a5-is-not-solvable'> § </a><span class='centered'> Recap: How have we shown that A5 is not solvable? </h4> 
 <span class='centered'>what have we shown?  
 <ul><li><span class='centered'><span class='centered'> 3-cycles can be written as  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>g</mi><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[g, h]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">h</span><span class="mclose">]</span></span></span></span></span> for  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo separator="true">,</mo><mi>h</mi><mo>∈</mo><msub><mi>A</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">g, h \in A_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>. Alternatively, <span class='centered'>we can say that 3-cycles belong to the commutator subgroup of  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">A_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>, <span class='centered'>since they can be written as commutators. </li><li><span class='centered'><span class='centered'> any element in  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">A5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mord">5</span></span></span></span></span> can be written as the composition of 3-cycles. </li><li><span class='centered'><span class='centered'> Hence, any element in  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">A5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mord">5</span></span></span></span></span> can be written as the composition of commutators. </li></ul> 
 <span class='centered'>In my mind, I think of it as:  
 <pre><code>arbitrary g
= (3-cycle-1)(3-cycle-2)....(3-cycle-n)
= [g, h][g2, h2]....[gn, hn]
= member of [A5, A5]
</code></pre> 
 <span class='centered'>Recall that  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>A</mi><mn>5</mn><mo separator="true">,</mo><mi>A</mi><mn>5</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[A5, A5]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">A</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">A</span><span class="mord">5</span><span class="mclose">]</span></span></span></span></span> is  <i><span class='centered'><i><span class='centered'>generated </i></i> by commutators. It not only contains 
 <span class='centered'>elements of the form  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>g</mi><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[g, h]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">h</span><span class="mclose">]</span></span></span></span></span>, but also all products of the form  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>g</mi><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><msup><mi>g</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><msup><mi>h</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[g, h][g&#x27;, h&#x27;]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">h</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></span>. 
 <span class='centered'>So we don't need to exhibit how to write a 5-cycle as some  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>g</mi><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[g, h]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">h</span><span class="mclose">]</span></span></span></span></span>. We just 
 <span class='centered'>need to exhibit how to write as the product of commutators, which we have 
 <span class='centered'>now shown.  
 <h4><a id=solvable-implies-simple href='#solvable-implies-simple'> § </a><span class='centered'> Solvable implies simple </h4> 
 <span class='centered'>We can consider the other definition of simple. Let there be a 
 <span class='centered'>chain of normal subgroups  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mi>N</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>≤</mo><mi>N</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>≤</mo><mi>N</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>≤</mo><mo>⋯</mo><mo>≤</mo><mi>N</mi><mo stretchy="false">[</mo><mi>m</mi><mo stretchy="false">]</mo><mo>=</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">G = N[0] \leq N[1] \leq N[1] \leq \dots \leq N[m] = e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">[</span><span class="mord mathnormal">m</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span></span>, 
 <span class='centered'>such that each quotient  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mi mathvariant="normal">/</mi><mi>N</mi><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">N[i] / N[i+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span> is abelian. Then, if  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span></span> is 
 <span class='centered'>simple, this chain can only be  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mi>N</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>≤</mo><mi>N</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">G = N[0] \leq N[1] = e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span></span>.  
 <ul><li><span class='centered'><span class='centered'> If we want the quotient  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi mathvariant="normal">/</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">G/N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span> to be abelian, then we need the commutator <span class='centered'>subgroup  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>G</mi><mo separator="true">,</mo><mi>G</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[G, G]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">G</span><span class="mclose">]</span></span></span></span></span> to be a a subset of  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span>. </li></ul> 
 <ul><li><span class='centered'><span class='centered'> In our case,  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msub><mi>A</mi><mn>5</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>5</mn></msub><mo stretchy="false">]</mo><mo>=</mo><msub><mi>A</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">[A_5, A_5] = A_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>. So if we want to remove the non-abelian-ness <span class='centered'>of A5, we need to quotient by the  <i><span class='centered'>whole </i> of  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">A5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mord">5</span></span></span></span></span>. </li></ul> 
 <ul><li><span class='centered'><span class='centered'> This means that any such chain will immediately collapse to  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span></span>. </li></ul> 
 <ul><li><span class='centered'><span class='centered'> So, it's impossible to build  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">A5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mord">5</span></span></span></span></span> using 'cycling components' starting from  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>e</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{e\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">e</span><span class="mclose">}</span></span></span></span></span>. <span class='centered'>Viewed from the field theoretic perspective, this means that it's impossible <span class='centered'>to reach a polynomial whose splitting field has galois group A5 by simply <span class='centered'>appending cycles. </li></ul> 
 <h4><a id=nagging-doubt-did-we-depend-on-our-numbering-of-cycles href='#nagging-doubt-did-we-depend-on-our-numbering-of-cycles'> § </a><span class='centered'> Nagging doubt: Did we depend on our numbering of cycles? </h4> 
 <span class='centered'>In all my proofs, I had used  <i><span class='centered'>one </i> 3-cycle, or 5-cycle, or 2-cycle to 
 <span class='centered'>argue that it all works out. Is this really legal? Perhaps the argument 
 <span class='centered'>written for the 3-cycle  <code class='inline'>C = (123)</code> will break down for  <code class='inline'>D = (321)</code>. Fear not!  
 <ul><li><span class='centered'><span class='centered'> We will show that all 3-cycles are conjugate to each other. So, we can always <span class='centered'>relabel a 3-cycle within A5. </li><li><span class='centered'><span class='centered'> It is easy to note that  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo stretchy="false">[</mo><mi>k</mi><mo separator="true">,</mo><mi>l</mi><mo stretchy="false">]</mo><msup><mi>g</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><mo stretchy="false">[</mo><mi>g</mi><mi>k</mi><msup><mi>g</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo separator="true">,</mo><mi>g</mi><mi>l</mi><msup><mi>g</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">g[k, l]g^{-1} = [gkg^{-1}, glg^{-1}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></span>. This shows <span class='centered'>that the commutator subgroup is closed under conjugation. It better be, <span class='centered'>because it ought to be normal for us to take quotients from it. </li><li><span class='centered'><span class='centered'> Combining these facts, if we show that  <code class='inline'>(123)</code> is in  <code class='inline'>[A5, A5]</code>, then some <span class='centered'>other cycle  <code class='inline'>(ijk)</code> can be conjugated to  <code class='inline'>(123)</code>. Since the commutator <span class='centered'>subgroup is closed under conjugation, we have that  <code class='inline'>(ijk)</code> is a member <span class='centered'>of  <code class='inline'>[A5, A5]</code>. </li></ul> 
 <h4><a id=all-3-cycles-are-conjugate-to-each-other-in-a5 href='#all-3-cycles-are-conjugate-to-each-other-in-a5'> § </a><span class='centered'> All 3-cycles are conjugate to each other in A5. </h4> 
 <ul><li><span class='centered'><span class='centered'> Given two 3-cycles  <code class='inline'>C=(abc)</code> and  <code class='inline'>D=(pqr)</code>, at least one of  <code class='inline'>a, b, c</code> must <span class='centered'>be equal to one of  <code class='inline'>p, q, r</code>. Since each  <code class='inline'>a, b, c</code> is unique, and each <span class='centered'><code class='inline'>p, q, r</code> is unique, for them to not overlap, we would need 6 elements. <span class='centered'>But we only have 5, so there must be some overlap: </li></ul> 
 <pre><code>a   b   c
1 2 3 4 5
  p   q r
</code></pre> 
 <span class='centered'>So, we will perform our proof assuming there is 1 overlap, 2 overlap, 3 overlap. 
 <span class='centered'>Recall that if  <code class='inline'>C = (a b c)</code> is a cycle and  <code class='inline'>s</code> is a permutation, then the action 
 <span class='centered'>of conjugating  <code class='inline'>C</code> with  <code class='inline'>s</code> produces a permutation  <code class='inline'>(s(a) s(b) s(c))</code>. We will 
 <span class='centered'>prove our results by finding an  <code class='inline'>s</code>, and then  <i><span class='centered'><i><span class='centered'>making  <code class='inline'>s</code> even </i></i>. This is 
 <span class='centered'>the difficult part of the proof, since we need to show that all 3-cycles are 
 <span class='centered'>conjugate  <i><span class='centered'>in A5 </i>. We will write  <code class='inline'>s</code> as two distinct transpositions, which will 
 <span class='centered'>guarantee that it belongs to  <code class='inline'>A5</code>.  
 <ul><li><span class='centered'><span class='centered'> Case 1:  <code class='inline'>(abx)</code> and  <code class='inline'>(pqx)</code> have a single element  <code class='inline'>x</code> in common: </li></ul> 
 <pre><code>C = (abx)
D = (pqx)

s: send a to p, b to q
s = (ap)(bq)
C = (abx) -conj s-> (pqx) = D
</code></pre> 
 <ul><li><span class='centered'><span class='centered'> Case 2:  <code class='inline'>(axy)</code> and  <code class='inline'>(pxy)</code> have two elements in common,  <code class='inline'>x</code> and  <code class='inline'>y</code>. Naively, <span class='centered'>we would pick  <code class='inline'>s: send x to y</code>. But this is odd, so this isn't a member of <span class='centered'><code class='inline'>A5</code>. To make it even, we rearrange  <code class='inline'>D = (pxy)</code> as  <code class='inline'>D = (yxp)</code>. This lets us <span class='centered'>go from  <code class='inline'>C</code> to  <code class='inline'>D</code> by relabelling  <code class='inline'>a</code> to  <code class='inline'>y</code>,  <code class='inline'>y</code> to  <code class='inline'>p</code>. This permutation <span class='centered'>is even since it has two distinct transpositions. </li></ul> 
 <pre><code>C = (axy)
D = (pxy) = (yxp) [cyclic property]

s: send a to y, y to p
s = (ay)(yp)

C = (axy) -conj s-> (yxp) = D
</code></pre> 
 <ul><li><span class='centered'><span class='centered'> Case 3:  <code class='inline'>(xyz)</code> and  <code class='inline'>(xyz)</code> have all three elements in common,  <code class='inline'>x</code>,  <code class='inline'>y</code>,  <code class='inline'>z</code>. <span class='centered'>Here we can conjugate by identity and we are done. </li></ul> 
 <h4><a id=why-do-we-care-about-solvable href='#why-do-we-care-about-solvable'> § </a><span class='centered'> Why do we care about solvable? </h4> 
 <ul><li><span class='centered'><span class='centered'> Roughly, we can look at the solvability criterion as giving us a way to build <span class='centered'>our group  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span></span> from a series of extensions  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>N</mi><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">N[1], N[2], \dots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span></span>. This extension <span class='centered'>is special, because at each step, we are adding a cyclic group. </li></ul> 
 <ul><li><span class='centered'><span class='centered'> When we want to write a solution using nth roots, we can only add the <span class='centered'>nth roots of unity, a "cyclic" component. So, any element we can reach <span class='centered'>by using nth roots ought to be able to be written down as an extension of <span class='centered'>cyclic elements. </li></ul> 
 <h4><a id=sage-code-to-play-around-with-commutators-of-a5 href='#sage-code-to-play-around-with-commutators-of-a5'> § </a><span class='centered'> SAGE code to play around with commutators of  <code class='inline'>A5</code>: </h4> 
 <ul><li><span class='centered'><span class='centered'> Create a dictionary  <code class='inline'>m</code> which maps each element of  <code class='inline'>A5</code> to the commutators <span class='centered'>that create it. </li></ul> 
 <pre><code><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict
m <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span><span class="token builtin">set</span><span class="token punctuation">)</span>
A5 <span class="token operator">=</span> AlternatingGroup<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
S5 <span class="token operator">=</span> SymmetricGroup<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token comment"># if necessary</span>
<span class="token keyword">for</span> g <span class="token keyword">in</span> A5<span class="token punctuation">:</span>
    <span class="token keyword">for</span> h <span class="token keyword">in</span> A5<span class="token punctuation">:</span>
        m<span class="token punctuation">[</span>g <span class="token operator">*</span> h <span class="token operator">*</span> g<span class="token operator">^</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> h<span class="token operator">^</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>g<span class="token punctuation">,</span> h<span class="token punctuation">)</span> <span class="token punctuation">}</span>

<span class="token comment"># all 60 elem can be written in terms of commutators</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"number of elem generated as commutator: "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># Show how to access elements of A5 and their commutator representation</span>
cyc5 <span class="token operator">=</span> A5<span class="token punctuation">(</span><span class="token string">"(1, 2, 3, 4, 5)"</span><span class="token punctuation">)</span>
cyc3 <span class="token operator">=</span> A5<span class="token punctuation">(</span><span class="token string">"(1, 2, 3)"</span><span class="token punctuation">)</span>
cyc2disj <span class="token operator">=</span> A5<span class="token punctuation">(</span><span class="token string">"(1, 2) (3, 4)"</span><span class="token punctuation">)</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>m<span class="token punctuation">[</span>cyc5<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>m<span class="token punctuation">[</span>cyc3<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>m<span class="token punctuation">[</span>cyc2disj<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre> 
 <h4><a id=writing-each-element-in-a5-directly-as-a-commutator href='#writing-each-element-in-a5-directly-as-a-commutator'> § </a><span class='centered'> Writing each element in  <code class='inline'>A5</code> directly as a commutator </h4> 
 <span class='centered'>We have shown how to write 3-cycles as the commutator of 2-cycles. We will now 
 <span class='centered'>show how to do this for disjoint 2-cycles and 5-cycles as a matter of 
 <span class='centered'>enlightenment.  
 <h4><a id=writing-disjoint-2-cycles-as-commutator href='#writing-disjoint-2-cycles-as-commutator'> § </a><span class='centered'> Writing disjoint 2-cycles as commutator </h4> 
 <span class='centered'>First, we will write a two disjoint two cycles as the square root of 
 <span class='centered'>a 4-cycle. We will then show how to write this 4-cycle as two 
 <span class='centered'>3-cycles.  
 <pre><code>s = (12)(34)
</code></pre> 
 <span class='centered'>Note that if we choose  <code class='inline'>t = (abcd)</code>, then  <code class='inline'>t*t</code> will exchange the first 
 <span class='centered'>and third elements  <code class='inline'>a <-> c</code>, and the second and fourth elements  <code class='inline'>b <-> d</code>. 
 <span class='centered'>So, if we choose:  
 <pre><code>t = (1324)
t*t = (12) (34)
</code></pre> 
 <span class='centered'>Next, we need to write this  <code class='inline'>t*t</code> as  <code class='inline'>[g, h]</code> for  <code class='inline'>g, h</code> from  <code class='inline'>A5</code>.  
 <pre><code>t*t = (1324)(1324)
    = (42)(23)(31);(42)(23)(31)
    = (42)(23)(31);(42)(23)(31)
    = (42)(23)(31);(23)(23);(42)(23)(31)
                   ^^^^^^^^ inserted
    = (42)(23)|(31)(23)|(23)(42)|(23)(31)
          g   |    h   |   g'   |   h'

    = [(42)(23), (31)(23)]
</code></pre> 
 <span class='centered'>Where both  <code class='inline'>(42)(23)</code>, and  <code class='inline'>(31)(23)</code> are members of  <code class='inline'>A5</code>.  
 <h4><a id=writing-3-cycle-as-commutator href='#writing-3-cycle-as-commutator'> § </a><span class='centered'> Writing 3-cycle as commutator </h4> 
 <span class='centered'>In the description of showing how to generate 3-cycles, we do this 
 <span class='centered'>explicitly.  
 <h4><a id=writing-5-cycle-as-commutator href='#writing-5-cycle-as-commutator'> § </a><span class='centered'> Writing 5-cycle as commutator </h4> 
 <span class='centered'>Let  <code class='inline'>s = (1 2 3 4 5)</code>. we once again find a square root of  <code class='inline'>s</code>. To build 
 <span class='centered'>this, we will build an element with the elements of  <code class='inline'>s</code> written with 
 <span class='centered'>gaps of  <code class='inline'>2</code>:  
 <pre><code>t = (1 _ _ _ _)
  = (1 _ 2 _ _)  [+2 index]
  = (1 _ 2 _ 3)  [+2 index, wrap]
  = (1 4 2 _ 3)  [+2 index, wrap]
  = (1 4 2 5 3)  [+2 index, wrap]
</code></pre> 
 <span class='centered'>It should be clear how  <code class='inline'>t*t = s</code>: When we take  <code class='inline'>s = t*t</code>, the resulting permutation  <code class='inline'>s</code>
 <span class='centered'>will move an element  <code class='inline'>j = t[i]</code> to  <code class='inline'>k = t[i+2]</code>. But we have built  <code class='inline'>t</code> such 
 <span class='centered'>that  <code class='inline'>t[i+2] = s[i+1]</code>. So we will move the element according to how  <code class='inline'>s</code> pleases:  
 <pre><code>t = (1 4 2 5 3)
t*t = 1 -> (4 skip) -> 2
      2 -> (5 skip) -> 3
      3 -> (1 skip) -> 4
      3 -> (2 skip) -> 5
      5 -> (3 skip) -> 1
t*t = (1 2 3 4 5) = s
</code></pre> 
 <span class='centered'>We will now use  <code class='inline'>t*t</code> to write the commutator:  
 <pre><code>s = t*t
  = (35)(52)(24)(41);(35)(52)(24)(41)
  =
  =
  =
  = (1, 2)(3, 5)|(1, 5)(2, 4)|(3, 5)(1, 2)|(2, 4)(1, 5)

  = (1, 2)(3, 5)|(1, 5)(2, 4)|(3, 5)(1, 2)|(2, 4)(1, 5)
         g             h          g^{-1}       h^{-1}
</code></pre> 
 <h4><a id=to-think-relationship-between-square-roots-and-commutators href='#to-think-relationship-between-square-roots-and-commutators'> § </a><span class='centered'> To think: relationship between square roots and commutators? </h4> 
 <script src="https://utteranc.es/client.js"        repo="bollu/bollu.github.io"        issue-term="pathname"        label="question"        theme="github-light"        crossorigin="anonymous"        async></script></container></body></html>