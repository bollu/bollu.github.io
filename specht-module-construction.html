<!DOCTYPE html><meta charset='UTF-8'><html><head><link rel='alternate' type='application/rss+xml' href='feed.rss' title='A universe of sorts'/><link rel='stylesheet' href='katex/katex.min.css'    integrity='sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X'    crossorigin='anonymous'><!-- The loading of KaTeX is deferred to speed up page rendering --><link rel='stylesheet' href='prism/prism.css'><title> A Universe of Sorts </title><style>@font-face {font-family: 'Blog Mono'; src: url('/static/iosevka-fixed-extended.ttf');}@font-face {font-family: 'Blog Sans'; src: url('/static/Exo2-Regular.ttf');}@font-face {font-family: 'Blog Serif'; src: url('/static/Revans-Regular.ttf');}html { font-size: 100%; }html,body { text-size-adjust: none; -webkit-text-size-adjust: none; -moz-text-size-adjust: none; -ms-text-size-adjust: none; } body { background: linear-gradient(to right, #2693f5 50%, #e81d66 50%); color: #000000;  font-family: 'Blog Serif', sans-serif;  font-size: 18px; line-height: 1.4em;  margin-top: 0px;  max-width: 100%; overflow-x: hidden; }
h1, h2, h3, h4, h5 { font-family: 'Blog Sans' }img { display:block; width: 100%; max-width: 800px; height: auto }.container { overflow-x: auto; overflow-y: hidden;  max-width: 80ex; text-align: justify;              margin-top: 0px; height: 100%; min-height: 100%;             padding-left: 50px; padding-right: 50px; background: #FFFFFF;}@media (max-width: 480px) {   .container { margin-left: 1%; margin-right: 1%; }  body { font-size: 30px; }  } @media (max-width: 1024px) {  .container { margin-left: 1%; margin-right: 1%; }  body { font-size: 30px; }}@media (min-width: 1024px) { .container { margin-left: 25%; margin-right: 20%; } }.image { }
a:hover { color: #1a73e8; text-decoration: underline;  }
a { color: #1a73e8; text-decoration: none; }
a:visited { color: #1a73e8; text-decoration: none; }
a:active { color: #1a73e8; text-decoration: none; }

blockquote { margin-left: 0px; margin-right: 0px; } pre, .latexblock, blockquote { border-left-color:#BBB;  border-left-style: solid;      border-left-width: 5px; }pre, blockquote { padding-left: 10px; }
pre { font-family: 'Blog Mono', monospace; font-size: 90%;  }pre {  overflow-x: auto; }.latexblock, blockquote, pre { margin-top: 10px; margin-bottom: 10px; padding-bottom: 5px; padding-top: 5px; background-color: #FFFFFF; }.latexblock { line-height: 1em }
pre, kbd, samp, tt{ font-family:'Blog Mono',monospace; }.inline { white-space: nowrap; background:#efefef; }ul, ol { list-style-position: inside; padding-left: 0; }ul { list-style-type: disclosure-closed; }</style></head><body><div class='container'><h2><a id=specht-module-construction href='#specht-module-construction'> § </a><span class='centered'> Specht module construction</h2>
<ol><li><span class='centered'><span class='centered'> <code class='inline'>Slambda</code> is invariant under Sn.  U is invariant under Sn by assumption.</li><li><span class='centered'><span class='centered'> <code class='inline'>{At}</code> span Slambda.</li><li><span class='centered'><span class='centered'> <code class='inline'>{At}</code> is generated by action of Sn on a single <code class='inline'>Ax</code> for any tableaux <code class='inline'>x</code>.</li><li><span class='centered'><span class='centered'> Consider <code class='inline'>{ At U }</code>. If it's all zero, then <code class='inline'>U subset Slambda_perp</code>.</li><li><span class='centered'><span class='centered'> If {At U} is non-zero, then some e[t] in U. Since U in invariant under Sn, all Sn (e[t]) ~= Sn(At) ~= { At } are in U. Hence Slambda subset U.</li></ol>
<h4><a id=working-it-out-for-s3 href='#working-it-out-for-s3'> § </a><span class='centered'> Working it out for S3</h4>
<h4><a id=tabloid3 href='#tabloid3'> § </a><span class='centered'> <code class='inline'>Tabloid(3)</code></h4>
<span class='centered'>There's only one tabloid of shape <code class='inline'>3</code>, which is <code class='inline'>{1 2 3}</code>. Thus we get a 1D complex vector space with
<span class='centered'>basis vector <code class='inline'>b{1, 2, 3}</code>. Every permutation maps <code class='inline'>b{1, 2, 3}</code> onto itself, so we get the trivial
<span class='centered'>representation where each element of <code class='inline'>S3</code> is the identity map.
<h4><a id=tabloid2-1 href='#tabloid2-1'> § </a><span class='centered'> <code class='inline'>Tabloid(2, 1)</code></h4>
<span class='centered'>There are three tabloids of shape <code class='inline'>(2, 1)</code>, one for each unique value at the bottom. The top row can be
<span class='centered'>permuted freely, so the only choice is in how we choose the bottom. We get the tableaux
<span class='centered'><code class='inline'>{1 2}{3}</code> = <code class='inline'>[1 2][3]</code> =  <code class='inline'>[2 1][3]</code>, drawn as:
<pre><code>[1 2] = [2 1] = {1 2}
[3]     [3      {3}
</code></pre>
<span class='centered'>And similarly we get <code class='inline'>{1 3}{2}</code> and <code class='inline'>{1 2}{3}</code>. So we have a three dimensional vector space.
<span class='centered'>Now let's look at the action of the <code class='inline'>A</code> operator <code class='inline'>A: Tableaux -> GL(V(Tabloid(mu))</code>. First of all,
<span class='centered'>we see that the <code class='inline'>A</code> operator uses <i><span class='centered'>tableaux</i> and not <i><span class='centered'>tabloids</i> (because we
<span class='centered'>need to know which elements are in the same column).
<span class='centered'>Recall that the action of <code class='inline'>A(t)</code> on a tabloid <code class='inline'>x</code> is to sum up linear combinations of <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>g</mi><mi>n</mi><mo stretchy="false">(</mo><mi>π</mi><mo stretchy="false">)</mo><mi>π</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">sgn(\pi)\pi(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span>,
<span class='centered'>where <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span></span> is from the column stabilier of <code class='inline'>t</code>. 
<div class='latexblock'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≡</mo><munder><mo>∑</mo><mrow><mi>π</mi><mo>∈</mo><mtext mathvariant="monospace">col-stab</mtext><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow></munder><mi>s</mi><mi>g</mi><mi>n</mi><mo stretchy="false">(</mo><mi>π</mi><mo stretchy="false">)</mo><mi>π</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
A(t)(x) \equiv \sum_{\pi \in \texttt{col-stab}(t)} sgn(\pi) \pi(x)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.5660100000000003em;vertical-align:-1.516005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="mrel mtight">∈</span><span class="mord text mtight"><span class="mord texttt mtight">col-stab</span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">t</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span></div>
<span class='centered'>So let's find the action! The tableaux <code class='inline'>[1 2][3]</code>, ie:
<pre><code>[1 2]
[3]
</code></pre>
<span class='centered'>has as column stabilizers the identity permutation, and the
<span class='centered'>permutation <code class='inline'>(1 3)</code> obtained by swapping the elements of the columns <code class='inline'>[1..][3]</code>
<span class='centered'>Thus, the action of <code class='inline'>A([1 2][3])</code> on a tabloid <code class='inline'>{k l}{m}</code> 
<span class='centered'>is the signed linear combination of the action
<span class='centered'>of the identity and the swap on <code class='inline'>{k l}{m}</code>:
<div class='latexblock'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mo stretchy="false">[</mo><mn>12</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>3</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>k</mi><mi>l</mi><mo stretchy="false">}</mo><mo stretchy="false">{</mo><mi>m</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>⋅</mo><mo stretchy="false">{</mo><mi>k</mi><mi>l</mi><mo stretchy="false">}</mo><mo stretchy="false">{</mo><mi>m</mi><mo stretchy="false">}</mo><mo>+</mo><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>⋅</mo><mrow><mi>m</mi><mi>l</mi></mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">A([1 2][3])(\{ k l \}\{m \}) = 1 \cdot \{k l\}\{m\} + (-1) \cdot {m l}{k} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mopen">[</span><span class="mord">1</span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">3</span><span class="mclose">]</span><span class="mclose">)</span><span class="mopen">(</span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">}</span><span class="mopen">{</span><span class="mord mathnormal">m</span><span class="mclose">}</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">}</span><span class="mopen">{</span><span class="mord mathnormal">m</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></span></span></div>
<span class='centered'>Recall that the basis of the Specht module is given by <code class='inline'>A([t])({t})</code>, where we have the tableaux <code class='inline'>t</code>
<span class='centered'>act on its own tabloid. In the case where <code class='inline'>t = [1 2][3]</code> we get the output 
<pre><code>A([1 2][3])({1 2}{3}) = {1 2}{3} - {3 1}{2}
</code></pre>
<span class='centered'>Similarly, we tabulate all of the actions of <code class='inline'>A(x)({x})</code> below, where we 
<span class='centered'>pick the equivalence class representative of tabloids as the tabloid whose
<span class='centered'>row entries are in ascending order.
<pre><code>A([1 2][3])({1 2}{3})
  = (id - (1, 3))({1 2}{3})
  = {1 2}{3} - {3 1}{2}
  = {1 2}{3} - {1 3}{2}
</code></pre>
<pre><code>A([2 1][3])({2 1}{3}) 
  = A([2 1][3])({2 1}{3})
  = A([2 1][3])({1 2}{3})
  = (id - (2, 3))({1 2}{3})
  = {1 2}{3} - {1 3}{2}
</code></pre>
<pre><code>A([1 3][2])({1 3}{2}) 
  = (id - (1, 2))({1 3}{2})
  = {1 3}{2} - {2 3}{1}
</code></pre>
<pre><code>A([3 1][2])({3 1}{2}) 
  = (id - (3, 2))({3 1}{2})
  = (id - (3, 2))({1 3}{2})
  = {1 3}{2} - {1 2}{3}
</code></pre>
<pre><code>A([1 2][3])({1 2}{3}) 
  = (id - (1, 3))({1 2}{3})
  = {1 2}{3} - {3 2}{1}
  = {1 2}{3} - {2 3}{1}
</code></pre>
<pre><code>A([2 1][3])({2 1}{3}) 
  = (id - (2, 3))({2 1}{3})
  = (id - (2, 3))({1, 2}{3})
  = {1 2}{3} - {1 3}{2}
</code></pre>
<span class='centered'>If we now label the vector as <code class='inline'>{2 3}{1} = a</code>, <code class='inline'>{1 3}{2} = b</code>, <code class='inline'>{1 2}{3} = c</code>, written
<span class='centered'>in ascending order of the element of their final row, we find that <code class='inline'>A(x)(x)</code> gave us the vectors:
<pre><code>A([1 2][3])({1 2}{3})
  = {1 2}{3} - {1 3}{2} = c - b
A([2 1][3])({2 1}{3}) 
  = {1 2}{3} - {1 3}{2} = c - b
A([1 3][2])({1 3}{2}) 
  = {1 3}{2} - {2 3}{1} = b - a
A([3 1][2])({3 1}{2}) 
  = {1 3}{2} - {1 2}{3} = b - c = -(c-b)
A([1 2][3])({1 2}{3}) 
  = {1 2}{3} - {2 3}{1} = c - a
A([2 1][3])({2 1}{3}) 
  = {1 2}{3} - {1 3}{2} = c - b
</code></pre>
<span class='centered'>where the subspace spanned by the vectors <code class='inline'>(a-b)</code>, <code class='inline'>(b-c)</code>, <code class='inline'>(c-a)</code> is
<span class='centered'>two dimensional, because there a one-dimensional redundancy <code class='inline'>(a-b) + (b-c) + (c-a) = 0</code>
<span class='centered'>between them. Furthermore, the basis vectors <code class='inline'>(a - b)</code>, <code class='inline'>(b - c)</code>, <code class='inline'>(c - a)</code> are invariant
<span class='centered'>under all swaps, and are thus invariant under all permutations, since all permutations can be
<span class='centered'>written as a composition of swaps. So we have found a two-subspace of a three-dimensional
<span class='centered'>representation of <code class='inline'>S3</code>. To see that this subspace is irreducible, notice that given any permutation
<span class='centered'>of the form <code class='inline'>k - l</code>, we can swap the letters <code class='inline'>k, l</code> and the third letter <code class='inline'>m</code> to obtain the entire
<span class='centered'>basis. Hence, this subspace is indeed irreducible, and the representation of <code class='inline'>Sn</code> that we have
<span class='centered'>is indeed an irreducible representation.
<h4><a id=tabloid1-1-1 href='#tabloid1-1-1'> § </a><span class='centered'> <code class='inline'>Tabloid(1, 1, 1)</code></h4>
<span class='centered'>There are 6 tabloids of shape <code class='inline'>(1, 1, 1)</code>, given by the permutations of the numbers <code class='inline'>{1, 2, 3}</code>.
<span class='centered'>If we write them down, they're going to be (a) <code class='inline'>{1}{2}{3}</code>, (b) <code class='inline'>{1}{3}{2}</code>, (c) <code class='inline'>{2}{1}{3}</code>,
<span class='centered'>(d) <code class='inline'>{2}{3}{1}</code>, (e) <code class='inline'>{3}{1}{2}</code>, (f)<code class='inline'>{3}{2}{1}</code>. This gives us a 6 dimensional vector
<span class='centered'>space spanned by these basis vectors. 
<span class='centered'>Let's now find out the value of <code class='inline'>A([1][2][3])({1}{2}{3})</code> recall that we need to act
<span class='centered'>on <code class='inline'>{1}{2}{3}</code> with all column stabilizers of <code class='inline'>A([1][2][3])</code>.
<h4><a id=a-on-tabloid-instead-of-tableaux href='#a-on-tabloid-instead-of-tableaux'> § </a><span class='centered'> <code class='inline'>A</code> on tabloid instead of tableaux</h4>
<span class='centered'>I claim that the different <code class='inline'>A_t</code> and <code class='inline'>A_s</code> for <code class='inline'>{t} = {s}</code> differ only by sign [Why?
<span class='centered'>Because we can reorder the elments of <code class='inline'>t</code> and <code class='inline'>s</code> to suffer a sign]. Thus, we can
<span class='centered'>directly define <code class='inline'>A_{t}</code> on the <i><span class='centered'>tabloids</i>, by defining it as first sorting the rows of <code class='inline'>t</code>
<span class='centered'>and then using <code class='inline'>A_t</code>. 
<script src="https://utteranc.es/client.js"        repo="bollu/bollu.github.io"        issue-term="pathname"        label="question"        theme="github-light"        crossorigin="anonymous"        async></script></container></body></html>