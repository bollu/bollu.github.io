<!DOCTYPE html><meta charset='UTF-8'><html><head><link rel='alternate' type='application/rss+xml' href='feed.rss' title='A universe of sorts'/><link rel='stylesheet' href='katex/katex.min.css'    integrity='sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X'    crossorigin='anonymous'><!-- The loading of KaTeX is deferred to speed up page rendering --><link rel='stylesheet' href='prism/prism.css'><title> A Universe of Sorts </title><style>@font-face {font-family: 'Blog Mono'; src: url('/static/iosevka-fixed-extended.ttf');}@font-face {font-family: 'Blog Sans'; src: url('/static/Exo2-Regular.ttf');}@font-face {font-family: 'Blog Serif'; src: url('/static/Revans-Regular.ttf');}html { font-size: 100%; }html,body { text-size-adjust: none; -webkit-text-size-adjust: none; -moz-text-size-adjust: none; -ms-text-size-adjust: none; } body { background: linear-gradient(to right, #1565C0 0%, #1565C0 50%, #E91E63 50%,   #E91E63 99%);  color: #000000;  font-family: Tahoma, 'Blog Serif', serif;  font-size: 14px;  margin-top: 0px;  max-width: 100%; overflow-x: hidden; }
h1, h2, h3, h4, h5 { font-family: Tahoma, 'Blog Mono', monospace; }img { display:block; width: 100%; max-width: 800px; height: auto }.container { overflow-x: auto; overflow-y: hidden;  max-width: 80ex; text-align: justify;              margin-top: 0px; height: 100%; min-height: 100%;             padding-left: 50px; padding-right: 50px; background: #FFFFFF;}@media (max-width: 480px) {   .container { margin-left: 1%; margin-right: 1%; }  body { font-size: 30px; }  } @media (max-width: 1024px) {  .container { margin-left: 1%; margin-right: 1%; }  body { font-size: 30px; }}@media (min-width: 1024px) { .container { margin-left: 25%; margin-right: 20%; } }.image { }
a:hover { color: #1a73e8; text-decoration: underline;  }
a { color: #1a73e8; text-decoration: none; }
a:visited { color: #1a73e8; text-decoration: none; }
a:active { color: #1a73e8; text-decoration: none; }

blockquote { margin-left: 0px; margin-right: 0px; } pre, .latexblock, blockquote { border-left-color:#BBB;  border-left-style: solid;      border-left-width: 5px; }pre, blockquote { padding-left: 10px; }
pre { font-family: 'Blog Mono', monospace; font-size: 90%;  }pre {  overflow-x: auto; }.latexblock, blockquote, pre { margin-top: 10px; margin-bottom: 10px; padding-bottom: 5px; padding-top: 5px; background-color: #FFFFFF; }.latexblock { line-height: 1em }
pre, kbd, samp, tt{ font-family:'Blog Mono',monospace; }.inline { white-space: nowrap; background:#efefef; }ul, ol { list-style-position: inside; padding-left: 0; }ul { list-style-type: disclosure-closed; }</style></head><body><div class='container'><h2><a id=ends-and-diagonals href='#ends-and-diagonals'> § </a><span class='centered'> Ends and diagonals </h2> 
 <ul><li><span class='centered'><span class='centered'>  <a href=https://www.youtube.com/watch?v=TAPxt26YyEI><span class='centered'>Bartosz: Wedges </a></li><li><span class='centered'><span class='centered'> Let's think of  <code class='inline'>Cop x C</code>, and an element on the diagonal  <code class='inline'>(a, a)</code>, and a function  <code class='inline'>f: a -> b</code>. </li><li><span class='centered'><span class='centered'> Using the morphism  <code class='inline'>(id, f)</code>, I can go from  <code class='inline'>(a, a)</code> to  <code class='inline'>(a, b)</code>. </li><li><span class='centered'><span class='centered'> If we have  <code class='inline'>(b, b)</code>, I can once again use  <code class='inline'>f</code> to go fo  <code class='inline'>(a, b)</code>. </li><li><span class='centered'><span class='centered'> So we have maps: </li></ul> 
 <pre><code>     b,b
    / |
   /  |
  /   |
 /    v
a,a-->a,b
</code></pre> 
 <ul><li><span class='centered'><span class='centered'> This tells us that if we have something defined on the diagonal for a profunctor  <code class='inline'>p a a</code>, we can "extrapolate" <span class='centered'>to get data everywhere! </li><li><span class='centered'><span class='centered'> How do we get the information about the diagonal? Well, I'm going to create a product of all the diagonal elements of the profunctor. </li><li><span class='centered'><span class='centered'> so we need a limit  <code class='inline'>L</code>, along with maps  <code class='inline'>L -> p c c</code> for each  <code class='inline'>c</code>. This kind of infinite product is called a wedge (not yet,  but soon). </li><li><span class='centered'><span class='centered'> The terminal object in the category of wedges is the end. </li><li><span class='centered'><span class='centered'> But our cone is "under-determined". We need more data at the bottom of the cone for things to cohere. </li><li><span class='centered'><span class='centered'> suppose at the bottom of the cone, we want to go from  <code class='inline'>p a a</code> to  <code class='inline'>p b b</code>. for this, I need morphisms  <code class='inline'>(f: b -> a, g: a -> b)</code> to lift <span class='centered'>into the profunctor with  <code class='inline'>dimap</code>. </li><li><span class='centered'><span class='centered'> We might want to impose this as coherence condition. But the problem is that <span class='centered'>there are categories where we don't have arrows going both ways (eg. partial orders). </li><li><span class='centered'><span class='centered'> So instead, we need a different coherence condition. If we had a morphism from  <code class='inline'>a -> b</code>, then we can get from  <code class='inline'>p a a --(id, f)-->p a b</code>. <span class='centered'>Or, I can go from  <code class='inline'>p b b --(f, id)-->p a b</code>. The wedge condition says that these commute. So we need  <code class='inline'>p id f . pi_1 = p f id . pi_2</code></li></ul> 
 <h4><a id=relationship-to-haskell href='#relationship-to-haskell'> § </a><span class='centered'> Relationship to haskell </h4> 
 <ul><li><span class='centered'><span class='centered'> How would we define this wedge condition in haskell?  </li><li><span class='centered'><span class='centered'> Because of parametricity, haskell gives us naturality for free. </li><li><span class='centered'><span class='centered'> How do we define an infinite product? By propositions as types, this is the same as providing  <code class='inline'>∀x.</code>. </li><li><span class='centered'><span class='centered'>  <code class='inline'>End p = forall a. p a a</code></li><li><span class='centered'><span class='centered'> We can define a cone with apex  <code class='inline'>A</code> of a diagram  <code class='inline'>D: J -> C</code> as a natural transformation  <code class='inline'>cone(A): Const(A) => D</code>. What's the version for a profunctor? </li><li><span class='centered'><span class='centered'> Suppose we have a profunctor diagram  <code class='inline'>P: J^op x J -> C</code>. Then we have a constant profunctor  <code class='inline'>Const(c) = \j j' -> c</code>. <span class='centered'>Then the wedge condition  (analogue of the cone condition) is to ask that we need a  <i><span class='centered'><i><span class='centered'>dinatural transformation </i></i>  <code class='inline'>cone': Const(A) => P</code>. </li><li><span class='centered'><span class='centered'> NOTE: a dinatural transformation is STRICTLY WEAKER than a natural transformation from  <code class='inline'>J^opxJ -> C</code>. </li><li><span class='centered'><span class='centered'> Suppose we have transformation that is natural in both components. That is to say, it is a natural transfrmation <span class='centered'>of functors of the type  <code class='inline'>[J^op x J -> C]</code>. This means that we have naturality arrows  <code class='inline'>α(a,b): p(a,b) -> q(a,b)</code>. Then the following must commute, for any  <code class='inline'>f: a -> b</code> by <span class='centered'>naturality of  <code class='inline'>α</code>: </li></ul> 
 <pre><code>      p(b,a)
    /    |
[p(f,id)]|
  /      |
p(a,a)  [α(b,a)]
 |       |
[α(a,a)] |
 |       |
 |    q(b,a)
 |     /
 |  [q(f,id)]
 |   /
q(a,a)
</code></pre> 
 <ul><li><span class='centered'><span class='centered'> Similarly, other side must commute: </li></ul> 
 <pre><code>      p b a
    /   |  \
[p f id]|   [p id f]
  /     |     \
p a a  [α b a] p b b
 |      |        |
[α a a] |      [α b b]
 |      |        |
 |    q b a      |
 |     /   \     |
 |  [q f id]\    |
 |   /  [q id f] |
 |  /          \ |
q a a         q b b
</code></pre> 
 <ul><li><span class='centered'><span class='centered'> I can join the two sides back together into a  <code class='inline'>q a b</code> by using  <code class='inline'>[q id f]</code> and  <code class='inline'>[q f id]</code>. The bottom square <span class='centered'>commutes because we are applying  <code class='inline'>[q f id]</code> and  <code class='inline'>[q id f]</code> in two different orders. By functoriality, <span class='centered'>this is true because to  <code class='inline'>q(f.id, id.f) = q(f,f) = q(id.f, f.id)</code>. </li></ul> 
 <pre><code>      p b a
    /   |  \
[p f id]|   [p id f]
  /     |     \
p a a  [α b a] p b b
 |      |        |
[α a a] |      [α b b]
 |      |        |
 |    q b a      |
 |     /   \     |
 |  [q f id]\    |
 |   /  [q id f] |
 |  /          \ |
q a a         q b b
  \             /
 [q id f]      /
    \        [q f id]
     \      /
     q a b
</code></pre> 
 <ul><li><span class='centered'><span class='centered'> If we erase the central node  <code class='inline'>[q b a]</code> and keep the boundary conditions, we arrive at a diagram: </li></ul> 
 <pre><code>      p b a
    /      \
[p f id]    [p id f]
  /           \
p a a          p b b
 |               |
[α a a]        [α b b]
 |               |
 |               |
 |               |
 |               |
 |               |
 |               |
q a a         q b b
  \             /
 [q id f]      /
    \        [q f id]
     \      /
     q a b
</code></pre> 
 <ul><li><span class='centered'><span class='centered'> Any transformation  <code class='inline'>α</code> that obeys the above diagram is called as a  <i><span class='centered'>dinatural transformation </i>. </li><li><span class='centered'><span class='centered'> From the above, we have proven that any honest natural transformation is a dinatural transformation, since the <span class='centered'>natural transformation obeys the diagram with the middle node. </li><li><span class='centered'><span class='centered'> In this diagram, see that we only ever use  <code class='inline'>α a a</code> and  <code class='inline'>α b b</code>. </li><li><span class='centered'><span class='centered'> So for well behavedness, we only need to check a dinatural transformation at the diagonal. (diagonal natural transformation?) </li><li><span class='centered'><span class='centered'> so really, all I need are the diagonal maps whoch I will call  <code class='inline'>α' k = α a a</code>. </li><li><span class='centered'><span class='centered'> Now, a wedge is a dinatural transformation from constant functor to this new thingie. </li></ul> 
 <script src="https://utteranc.es/client.js"        repo="bollu/bollu.github.io"        issue-term="pathname"        label="question"        theme="github-light"        crossorigin="anonymous"        async></script></container></body></html>