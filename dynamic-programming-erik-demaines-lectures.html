<!DOCTYPE html><meta charset='UTF-8'><html><head><link rel='alternate' type='application/rss+xml' href='feed.rss' title='A universe of sorts'/><link rel='stylesheet' href='katex/katex.min.css'    integrity='sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X'    crossorigin='anonymous'><!-- The loading of KaTeX is deferred to speed up page rendering --><link rel='stylesheet' href='prism/prism.css'><title> A Universe of Sorts </title><style>@font-face {font-family: 'Blog Mono'; src: url('/static/iosevka-fixed-extended.ttf');}@font-face {font-family: 'Blog Sans'; src: url('/static/Exo2-Regular.ttf');}@font-face {font-family: 'Blog Serif'; src: url('/static/Revans-Regular.ttf');}html { font-size: 100%; }html,body { text-size-adjust: none; -webkit-text-size-adjust: none; -moz-text-size-adjust: none; -ms-text-size-adjust: none; } body { background: linear-gradient(to right, #1565C0 1%, #FFF4DD 1%, #FFF4DD 99%, #E91E63 99%);  color: #000000;  font-family: 'Blog Serif', sans-serif;  font-size: 18px; line-height: 1.4em;  margin-top: 0px;  max-width: 100%; overflow-x: hidden; }
h1, h2, h3, h4, h5 { font-family: 'Blog Sans' }img { display:block; width: 100%; max-width: 800px; height: auto }.container { overflow-x: auto; overflow-y: hidden;  max-width: 80ex; text-align: justify;              margin-top: 0px; height: 100%; min-height: 100%;             padding-left: 50px; padding-right: 50px; background: #FFFFFF;}@media (max-width: 480px) {   .container { margin-left: 1%; margin-right: 1%; }  body { font-size: 30px; }  } @media (max-width: 1024px) {  .container { margin-left: 1%; margin-right: 1%; }  body { font-size: 30px; }}@media (min-width: 1024px) { .container { margin-left: 25%; margin-right: 20%; } }.image { }
a:hover { color: #1a73e8; text-decoration: underline;  }
a { color: #1a73e8; text-decoration: none; }
a:visited { color: #1a73e8; text-decoration: none; }
a:active { color: #1a73e8; text-decoration: none; }

blockquote { margin-left: 0px; margin-right: 0px; } pre, .latexblock, blockquote { border-left-color:#BBB;  border-left-style: solid;      border-left-width: 5px; }pre, blockquote { padding-left: 10px; }
pre { font-family: 'Blog Mono', monospace; font-size: 90%;  }pre {  overflow-x: auto; }.latexblock, blockquote, pre { margin-top: 10px; margin-bottom: 10px; padding-bottom: 5px; padding-top: 5px; background-color: #FFFFFF; }.latexblock { line-height: 1em }
pre, kbd, samp, tt{ font-family:'Blog Mono',monospace; }.inline { white-space: nowrap; background:#efefef; }ul, ol { list-style-position: inside; padding-left: 0; }ul { list-style-type: disclosure-closed; }</style></head><body><div class='container'><h2><a id=dynamic-programming-erik-demaines-lectures href='#dynamic-programming-erik-demaines-lectures'> § </a><span class='centered'> Dynamic Programming: Erik Demaine's lectures </h2> 
 <span class='centered'>I realized I'd never bothered to ever formally learn dynamic programming, 
 <span class='centered'>so I'm watching Erik Demaine's lectures and taking down notes here.  
 <h3><a id=dp-1-fibonacci-shortest-paths href='#dp-1-fibonacci-shortest-paths'> § </a><span class='centered'> DP 1: Fibonacci, shortest paths </h3> 
 <ul><li><span class='centered'><span class='centered'>  <a href=https://www.youtube.com/watch?v=OQ5jsbhAv_M&list=PLcDimPvbmfT8qAxD6JH_kmXiQwTNcoK78><span class='centered'>Video lecture here </a></li></ul> 
 <ol><li><span class='centered'><span class='centered'> DP ~= careful brute force. </li><li><span class='centered'><span class='centered'> DP ~= subproblems + "recurse" </li></ol> 
 <h4><a id=fibonacci href='#fibonacci'> § </a><span class='centered'> Fibonacci </h4> 
 <pre><code>F(1) = F(2) = 1; F(n) = F(n-1) + F(n-2)
</code></pre> 
 <h4><a id=naive href='#naive'> § </a><span class='centered'> Naive:  </h4> 
 <pre><code>fib<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">if</span> n <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">:</span> f <span class="token operator">=</span> <span class="token number">1</span>
  <span class="token keyword">else</span> f <span class="token operator">=</span> fib<span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> fib<span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> f
</code></pre> 
 <span class='centered'>EXPONENTIAL time!  <code class='inline'>T(n) = T(n-1) + T(n-2) + O(1)</code>. Since it's the fibonacci 
 <span class='centered'>recurrence, the solution is rougly  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>ϕ</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\phi^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span> where  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">ϕ</span></span></span></span></span> is the golden 
 <span class='centered'>ratio. Alternate,  <code class='inline'>T(n) >= 2T(n-2) ~ 2^(n/2)</code> 
 <h4><a id=memoized-dp href='#memoized-dp'> § </a><span class='centered'> Memoized DP: </h4> 
 <pre><code>memo <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
fib<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token comment"># vvv </span>
  <span class="token keyword">if</span> n <span class="token keyword">in</span> memo<span class="token punctuation">:</span> <span class="token keyword">return</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span>
  <span class="token keyword">if</span> n <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">:</span> f <span class="token operator">=</span> <span class="token number">1</span>
  <span class="token keyword">else</span> f <span class="token operator">=</span> fib<span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> fib<span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span>
  <span class="token comment"># ^^^</span>
  memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> f
  <span class="token keyword">return</span> f
</code></pre> 
 <ul><li><span class='centered'><span class='centered'> We can think about it in terms of the recursion tree, where this allows <span class='centered'>us to not have to recompute some of the data. </li><li><span class='centered'><span class='centered'> The alternative way of thinking about it is that there are  <i><span class='centered'><i><span class='centered'>two ways </i></i><span class='centered'>of calling  <code class='inline'>fib</code>: the first time, it's non-memoized, which recurses. Every <span class='centered'>other time, we're doing  <i><span class='centered'><i><span class='centered'>memoized calls </i></i> that are constant time. </li><li><span class='centered'><span class='centered'> The number of non memoized calls in  <code class='inline'>n</code>. These we have to pay for. The non <span class='centered'>recursive work per call is constant. </li><li><span class='centered'><span class='centered'> Therefore, the running time is linear! Linear because there are  <code class='inline'>n</code> non <span class='centered'>memoized calls, and each of them cost  <i><span class='centered'><i><span class='centered'>constant time </i></i>. </li><li><span class='centered'><span class='centered'> In general, in DP, we  <i><span class='centered'>memoize </i>  (remember) solutions to  <i><span class='centered'><i><span class='centered'>subproblems </i></i> that <span class='centered'>help us solve the actual problem. So,  <code class='inline'>DP = recursion + memo</code>. </li><li><span class='centered'><span class='centered'>  <code class='inline'>Running time = number of different subproblems x time per subproblem</code>. <span class='centered'>When we measure  <i><span class='centered'><i><span class='centered'>time per subproblem </i></i>, we ignore recursive calls! <span class='centered'>(don't count recursions).  </li></ul> 
 <h4><a id=bottom-up-dp-algorithm href='#bottom-up-dp-algorithm'> § </a><span class='centered'> Bottom up DP algorithm </h4> 
 <pre><code>fib <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
 <span class="token operator">-</span><span class="token operator">-</span> <span class="token operator">|</span> some thought <span class="token keyword">for</span> the loop
<span class="token keyword">for</span> k <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span> 
  <span class="token keyword">if</span> k <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">:</span> f <span class="token operator">=</span> <span class="token number">1</span>
  <span class="token keyword">else</span><span class="token punctuation">:</span> f <span class="token operator">=</span> fib<span class="token punctuation">[</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> fib<span class="token punctuation">[</span>k<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span>
  fib<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> f
</code></pre> 
 <span class='centered'>Order based on any topo sort of dependency DAG. From the bottom up perspective, 
 <span class='centered'>we can decide how much we need to store based on how much state we need.  
 <pre><code>  *------------*
  |            v
f(n-2) f(n-1) f(n)
          |    ^
          *----*
</code></pre> 
 <h4><a id=single-source-shortest-paths-s-v-path href='#single-source-shortest-paths-s-v-path'> § </a><span class='centered'> Single Source Shortest paths ( <code class='inline'>s-v</code> path) </h4> 
 <ul><li><span class='centered'><span class='centered'> Tool to find answers:  <i><span class='centered'>guessing </i>. Suppose you don't know it. how do you find the <span class='centered'>answer? guess! Don't try any guess, try  <i><span class='centered'>all </i> guesses! (then take the best one). </li><li><span class='centered'><span class='centered'> DP = recursion + memoization + guessing. </li></ul> 
 <span class='centered'>There is some hypothetical path from  <code class='inline'>s</code> to  <code class='inline'>v</code>. We don't know what the first 
 <span class='centered'>edge of this hypothetical path is, so we guess. We try all of the paths from 
 <span class='centered'><code class='inline'>s->s'</code>. This changes  <code class='inline'>s</code>, but we really care about  <i><span class='centered'><i><span class='centered'>single source </i></i> shortest 
 <span class='centered'>path. So rather, we choose to guess  <code class='inline'>v</code>. We guess the last edge  <code class='inline'>u? -> v</code>. 
 <span class='centered'>Recursively compute the path from  <code class='inline'>s</code> to  <code class='inline'>u?</code>, and then add the path to  <code class='inline'>v</code>.  
 <pre><code>\delta(s, v) = \min_{(u,v) \in E} \delta(s, u) + w(u, v)
</code></pre> 
 <span class='centered'>Subpaths of shortest paths are shortest paths! Memoize to make it fast? Why 
 <span class='centered'>is it faster on memoization?  
 <pre><code>*---a----*
v   ^    v
s   |    w
|   |    |
*-->b<---*
</code></pre> 
 <pre><code>δ(s, w) 
  δ(s, a)
     δ(s, b)
       δ(s, s)
       δ(s, w) <- INFINITE
</code></pre> 
 <ul><li><span class='centered'><span class='centered'> Infinite time on graphs with cycles. </li><li><span class='centered'><span class='centered'> For a DAG, it runs on V+E. Number of subproblems =  <code class='inline'>V</code>. Time we spend per <span class='centered'>subproblem at a vertex is the number of incoming edges. <span class='centered'>we can't take product, because the time per subproblem can vary wildly. So we restate our "time formula" as </li></ul> 
 <pre><code>total time = sum over times of all subproblems (modulo recursion)
</code></pre> 
 <span class='centered'>This gives us:  
 <pre><code>total time = sum indeg(v) + O(1) = O(E) + O(1)
</code></pre> 
 <ul><li><span class='centered'><span class='centered'>  <i><span class='centered'><i><span class='centered'>LESSON LEARNT: subproblem dependencies should be acyclic! </i></i></li></ul> 
 <ul><li><span class='centered'><span class='centered'> Claim: can use same approach for graphs! Explode a cycle over time. This makes <span class='centered'>any graph acyclic. </li></ul> 
 <blockquote><span class='centered'>  <i><span class='centered'><i><span class='centered'>Sid question </i></i>: Can we derive Djikstras using the same "cycle explosion" <span class='centered'> trick? </blockquote> 
 <span class='centered'>We define  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mi>k</mi></msub><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\delta_k(s, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></span> to be weight of shortest path that uses at most  <code class='inline'>k</code> edges.  
 <pre><code>\delta_k(s, v) = \min_{(u, v) \in E} \delta_{k-1}(s, u) + w(u, v)
</code></pre> 
 <span class='centered'>We've increased the number of subproblems. We know that the longest path 
 <span class='centered'>possible can have  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">|V| - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span> edges. So the  <code class='inline'>k</code> parameter goes from  <code class='inline'>[0..|V|-1]</code>
 <span class='centered'>while the vertex  <code class='inline'>v</code> can be any vertex. Per vertex  <code class='inline'>v</code> we spend  <code class='inline'>indeg(v)</code> time. 
 <span class='centered'>So we get the total recurrence as:  
 <div class='latexblock'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><munder><mo>∑</mo><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>∈</mo><mo stretchy="false">[</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>v</mi><mo>∈</mo><mi>V</mi><mo stretchy="false">)</mo></mrow></munder><mi>T</mi><mo stretchy="false">(</mo><mi>k</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><munder><mo>∑</mo><mrow><mi>k</mi><mo>∈</mo><mo stretchy="false">[</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></munder><munder><mo>∑</mo><mi>v</mi></munder><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>g</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∑</mo><mrow><mi>k</mi><mo>∈</mo><mo stretchy="false">[</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></munder><mi>E</mi><mo>=</mo><mi>V</mi><mi>E</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
&amp;\sum_{(k \in [|V|-1], v \in V)} T(k, v) =  \\
&amp;\sum_{k \in [|V|-1]} \sum_v indeg(v) = \sum_{k \in [|V|-1]} E = VE
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.73202em;vertical-align:-2.61601em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.11601em;"><span style="top:-5.11601em;"><span class="pstrut" style="height:3.050005em;"></span><span class="mord"></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.050005em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.61601em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.11601em;"><span style="top:-5.11601em;"><span class="pstrut" style="height:3.050005em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">∈</span><span class="mopen mtight">[</span><span class="mord mtight">∣</span><span class="mord mathnormal mtight" style="margin-right:0.22222em;">V</span><span class="mord mtight">∣</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">]</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.22222em;">V</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.050005em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">∈</span><span class="mopen mtight">[</span><span class="mord mtight">∣</span><span class="mord mathnormal mtight" style="margin-right:0.22222em;">V</span><span class="mord mtight">∣</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">]</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8999949999999999em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">∈</span><span class="mopen mtight">[</span><span class="mord mtight">∣</span><span class="mord mathnormal mtight" style="margin-right:0.22222em;">V</span><span class="mord mtight">∣</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">]</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.61601em;"><span></span></span></span></span></span></span></span></span></span></span></span></div> 
 <h3><a id=dp-2-text-justification-blackjack href='#dp-2-text-justification-blackjack'> § </a><span class='centered'>  DP 2: Text Justification, Blackjack </h3> 
 <ul><li><span class='centered'><span class='centered'>  <a href=https://www.youtube.com/watch?v=ENyox7kNKeY&list=PLcDimPvbmfT8qAxD6JH_kmXiQwTNcoK78&index=2><span class='centered'>Video Lecture </a></li></ul> 
 <h4><a id=5-easy-steps-to-a-dp href='#5-easy-steps-to-a-dp'> § </a><span class='centered'> 5 "easy" steps to a DP </h4> 
 <ol><li><span class='centered'><span class='centered'> Define subproblems; analysis - number of subproblems </li><li><span class='centered'><span class='centered'> Guess (part of solution); analysis - number of choices for the guess </li><li><span class='centered'><span class='centered'> Relate subproblem solutions  [with a recurrence ]; analysis - time per subproblem (ignoring recursion) </li><li><span class='centered'><span class='centered'> Build an algorithm:  [recursion/memo, or tabling ]; check recurrence is acyclic  </li><li><span class='centered'><span class='centered'> solve original problem;  total time: total time across all subproblems (ignoring recursion). <span class='centered'>In simple cases, total time = number of subproblems x time per subproblem. </li><li><span class='centered'><span class='centered'> Check that the original problem actually gets solved! </li></ol> 
 <h4><a id=recap-fibonacci href='#recap-fibonacci'> § </a><span class='centered'> Recap: Fibonacci </h4>
 <ol><li><span class='centered'><span class='centered'> subproblems:  <code class='inline'>F(1)...F(n)</code></li><li><span class='centered'><span class='centered'> guess: nothing </li><li><span class='centered'><span class='centered'> relate:  <code class='inline'>F(n) = F(n-1) + F(n-2)</code>;  <code class='inline'>O(1)</code> time </li><li><span class='centered'><span class='centered'> F(n). constant time to find  </li></ol> 
 <h4><a id=recap-shortest-path href='#recap-shortest-path'> § </a><span class='centered'> Recap: Shortest path </h4>
 <ol><li><span class='centered'><span class='centered'> subproblems:  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mi>k</mi></msub><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\delta_k(s, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></span>.  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>V</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">V^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> subproblems. </li><li><span class='centered'><span class='centered'> guess: last edge; edge into  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></span>. </li><li><span class='centered'><span class='centered'> relate:  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mi>k</mi></msub><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo><mi>min</mi><mo>⁡</mo></mo><mi>u</mi></msub><msub><mi>δ</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo>+</mo><mi>w</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\delta_k(s, v) = \min_u \delta_{k-1}(s, u) + w(u, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">min</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">u</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></span>;  <code class='inline'>indegree(v)</code> time </li><li><span class='centered'><span class='centered'> <blank> </li><li><span class='centered'><span class='centered'>  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mrow><mi>v</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\delta_{v-1}(s, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></span> for all  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></span>. This takes  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span></span>. </li></ol> 
 <h4><a id=text-justification href='#text-justification'> § </a><span class='centered'> Text Justification </h4> 
 <span class='centered'>split text into "good lines". can only cut between word boundaries. Text is 
 <span class='centered'>a list of words.  <code class='inline'>badness(i, j)</code>: how bad is it to use  <code class='inline'>words[i:j]</code> in a line. 
 <span class='centered'>They may fit, or they may not fit. If they don't fit, then badness is  <code class='inline'>∞</code>. 
 <span class='centered'>Otherwise, it's going to be  <code class='inline'>(pagewidth - total width)^3</code>. 
 <span class='centered'>We want to minimize the sum of badnesses of the lines.  
 <ol><li><span class='centered'><span class='centered'> subproblems: the hard part! exponential: Guess for every word, whether a line <span class='centered'>begins or not. What is the natural thing to guess? guess how long the first <span class='centered'>line is / guess where the second line begins. After I guess where the second line <span class='centered'>is, I now have the remaining words to text justify. So the subproblems are <span class='centered'>going to be suffixes of the array:  <code class='inline'>words[i:]</code>. If we have  <code class='inline'>n</code> words, we have <span class='centered'><code class='inline'>n</code> suffixes. We're going to only remember  <i><span class='centered'>one line </i>  [forget the past! ], <span class='centered'>not  <i><span class='centered'>all the lines! </i>  [this is exponential! ] </li><li><span class='centered'><span class='centered'> Guess: where to start the second line. If we are at location  <code class='inline'>i</code>, there are  <code class='inline'>n-i</code><span class='centered'>choices which we will think of as  <code class='inline'>O(n)</code>. </li><li><span class='centered'><span class='centered'> Recurrence:  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>min</mi><mo>⁡</mo><mrow><mi>i</mi><mo>+</mo><mn>1</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>n</mi></mrow><mtext mathvariant="monospace">badness</mtext><mo stretchy="false">(</mo><mtext mathvariant="monospace">words[i:j]</mtext><mo stretchy="false">)</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i] = \min{i+1 \leq j \leq n} \texttt{badness}(\texttt{words[i:j]}) + dp[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">n</span></span><span class="mord text"><span class="mord texttt">badness</span></span><span class="mopen">(</span><span class="mord text"><span class="mord texttt">words[i:j]</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></span>. <span class='centered'>Time per subproblem is  <code class='inline'>constant x [i+1..n]</code> which is  <code class='inline'>O(n)</code>. </li><li><span class='centered'><span class='centered'> Check recurrence is acyclic/topo order:  <code class='inline'>n, n-1, ... 1</code></li><li><span class='centered'><span class='centered'> Total time:  <code class='inline'>number of subproblems x time per subproblem = O(n^2)</code></li><li><span class='centered'><span class='centered'> Original problem:  <code class='inline'>dp[0]</code>. </li></ol> 
 <h4><a id=parent-pointers href='#parent-pointers'> § </a><span class='centered'> Parent pointers </h4> 
 <span class='centered'>Remember which guess was best. Find actual solution, not just the cost of the  
 <h4><a id=fiat href='#fiat'> § </a><span class='centered'> fiat </h4> 
 <blockquote><span class='centered'> fiat lux. </blockquote> 
 <span class='centered'>Let there be light 
 <span class='centered'>solution.  
 <span class='centered'>n suffixes | exp many sybsets. dont need to know history!  
 <h4><a id=blackjack href='#blackjack'> § </a><span class='centered'> Blackjack </h4> 
 <blockquote><span class='centered'> whatever, I don't particularly care about the game </blockquote> 
 <h3><a id=dp-3-paranthesization-edit-distance-knapsack href='#dp-3-paranthesization-edit-distance-knapsack'> § </a><span class='centered'> DP 3: Paranthesization, Edit distance,  knapsack </h3> 
 <h4><a id=sequences href='#sequences'> § </a><span class='centered'> Sequences </h4> 
 <span class='centered'>Good choices of objects to perform DP on:  
 <ul><li><span class='centered'><span class='centered'> Suffixes:  <code class='inline'>x[i:]</code> for all  <code class='inline'>i</code>.  <code class='inline'>O(n)</code>. </li><li><span class='centered'><span class='centered'> Prefixes:  <code class='inline'>x[:j]</code> for all  <code class='inline'>j</code>.  <code class='inline'>O(n)</code>. </li><li><span class='centered'><span class='centered'> Substrings:  <code class='inline'>x[i:j]</code> for all  <code class='inline'>i</code> and  <code class='inline'>j</code>.  <code class='inline'>O(n^2)</code>. </li></ul> 
 <h4><a id=parenthesiztion href='#parenthesiztion'> § </a><span class='centered'> Parenthesiztion </h4> 
 <span class='centered'>optimal order of associative expression.:  <code class='inline'>A[0] . A[1] ... A[n-1]</code>. Order 
 <span class='centered'>matters for matmul! 
 <ul><li><span class='centered'><span class='centered'> What should we guess? There are exponentially many parenthesizations! <span class='centered'>Guess the outermost/last multiplication. Ie, we want to know: </li></ul> 
 <pre><code>(A[0] ... A[k-1]) * (A[k] ... A[n-1])`
</code></pre> 
 <ul><li><span class='centered'><span class='centered'> We can't just use prefixes and suffies, because when we recurse into <span class='centered'><code class='inline'>A[0]...A[k-1]</code>, we're going to get splits of the form  <code class='inline'>A[0]...A[k']</code><span class='centered'>and  <code class='inline'>A[k']...A[k-1]</code>. In general, if we feel we need  <i><span class='centered'>both </i> prefixes AND suffixes, we likely <span class='centered'>need the full power of substrings. </li><li><span class='centered'><span class='centered'> So our choice of subproblem is:  <code class='inline'>dp[i][j]</code> is the optimal outermost split for <span class='centered'><code class='inline'>A[i]...A[j-1]</code> The number of choices is  <code class='inline'>O(j-i+1) = O(n)</code>. </li></ul> 
 <pre><code>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">{</span>
  <span class="token keyword">for</span> k <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">:</span>
    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> cost of <span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">:</span>k<span class="token punctuation">]</span> <span class="token operator">*</span> A<span class="token punctuation">[</span>k<span class="token punctuation">:</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
 <ul><li><span class='centered'><span class='centered'> Time is polynomial.  <code class='inline'>O(n)</code> time for subproblem ignoring recursions.  <span class='centered'>We have  <code class='inline'>O(n^2)</code> subproblems (substrings). So the running time is  <code class='inline'>O(n^3)</code>. </li><li><span class='centered'><span class='centered'> Topological order: in general, if we have prefixes, we go left to right. <span class='centered'>have suffixes, we go right to left. If we have substrings, we <span class='centered'>evaluate based on  <i><span class='centered'><i><span class='centered'>increasing substring lengths </i></i>, since when we split, <span class='centered'>we get substrings with smaller lengths. </li></ul> 
 <h4><a id=edit-distance href='#edit-distance'> § </a><span class='centered'> Edit distance </h4>
 <span class='centered'>Given two strngs  <code class='inline'>x</code> and  <code class='inline'>y</code>. Find the cheapest way to convert  <code class='inline'>x</code> into  <code class='inline'>y</code>.  
 <span class='centered'>We allow  <i><span class='centered'>character edits </i> to turn  <code class='inline'>x</code> into  <code class='inline'>y</code>: We can (1) insert a character  
 <span class='centered'>anywhere in  <code class='inline'>x</code>, (2) delete a character anywhere in  <code class='inline'>x</code>, (3) edit any character in  <code class='inline'>x</code>. 
 <span class='centered'>We have custom costs for each insert and delete.  
 <ul><li><span class='centered'><span class='centered'> Can also solve longest common subsequence.  <code class='inline'>HIEROGLYPOHOLOGY</code>,  <code class='inline'>MICHAELANGELO</code>. <span class='centered'>Drop any set of letters from x and y, we want them to be equal. Model it as <span class='centered'>edit distance. Cost of insert/delete is  <code class='inline'>1</code>, cost of replacement is  <code class='inline'>0</code> if <span class='centered'>characters are equal,  <code class='inline'>∞</code> otherwise. </li><li><span class='centered'><span class='centered'> We will look at suffixes of  <code class='inline'>x</code> and  <code class='inline'>y</code> at the subproblem. Subproblem is <span class='centered'>edit distance on  <code class='inline'>x[i:]</code> AND  <code class='inline'>y[j:]</code>. Number of subproblems is  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>x</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>y</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|x| |y|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span></span>. </li><li><span class='centered'><span class='centered'> We need to guess! Not so obvious. Look at the first characters. What can I  <span class='centered'>do with the first character of  <code class='inline'>x</code>? (1) I can replace the first characters. <span class='centered'>(2) I can insert the character  <code class='inline'>y[j]</code> into  <code class='inline'>x</code>. <span class='centered'>(3) I can delete the character  <code class='inline'>x[i]</code>. So we have: </li></ul> 
 <ol><li><span class='centered'><span class='centered'> Replace  <code class='inline'>x[i]</code> with  <code class='inline'>y[j]</code>. </li><li><span class='centered'><span class='centered'> Insert  <code class='inline'>y[j]</code>. </li><li><span class='centered'><span class='centered'> Delete  <code class='inline'>x[i]</code>. </li></ol> 
 <pre><code>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">{</span>
  cost of replace x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">with</span> y<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  cost of insert y<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  cost of delete x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre> 
 <span class='centered'>The topological order is going to have smaller to larger suffixes.  
 <blockquote><span class='centered'> What I found really interesting is the offhand remark that longest common <span class='centered'> substring is  <i><span class='centered'><i><span class='centered'>just edit distance </i></i> where we are allowed to only delete <span class='centered'> or keep characters. </blockquote> 
 <h4><a id=knapsack href='#knapsack'> § </a><span class='centered'> Knapsack </h4> 
 <span class='centered'>List of items, each of size  <code class='inline'>s[i]</code> and a desire/value  <code class='inline'>v[i]</code>.  The sizes 
 <span class='centered'>are integers. We have a backpack of total size  <code class='inline'>S</code>. We want to choose a subset 
 <span class='centered'>of the items which maximize the value, and also fit into the backpack:  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>≤</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">\sum s[i] \leq S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></span>.  
 <ul><li><span class='centered'><span class='centered'> Even though it seems like we don't have a sequence, we have a set of items <span class='centered'>we can put in  <i><span class='centered'>any </i> sequence. We can look at sequences of items.  At the item <span class='centered'><code class='inline'>i</code>, we should guess if item  <code class='inline'>i</code> is included or not. </li></ul> 
 <pre><code><span class="token comment"># v WRONG</span>
dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token builtin">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>`
</code></pre> 
 <span class='centered'>We don't keep track of the sizes! Rather, we choose our subproblem to be the suffix 
 <span class='centered'>AND the remaining capacity  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≤</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">x \leq S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></span>. We have  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span></span> subproblems  
 <pre><code><span class="token comment"># v correct</span>
dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token operator">-</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre> 
 <span class='centered'>To be polynomial in the input, it would have to be  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\theta(n \log S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span></span> because 
 <span class='centered'><span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></span> is given as a number. It would not be  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">nS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></span>;  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></span> is exponential in the  
 <span class='centered'>input encoding  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">\log S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></span>.  
 <h3><a id=r21-dp-knapsack href='#r21-dp-knapsack'> § </a><span class='centered'> R21: DP: Knapsack </h3> 
 <span class='centered'>We have  <code class='inline'>n</code> decisions:  <code class='inline'>d[i]</code> is do I take item  <code class='inline'>i</code>. What do we need to keep 
 <span class='centered'>track of? I need to know how much weight I have left. This is equivalent to 
 <span class='centered'>knowing the sum of the items. The edge is an arbitrary item, the weight is  <code class='inline'>-v[i]</code>
 <span class='centered'>since we're trying to phrase the problem in terms of shortest path. The state 
 <span class='centered'>in the node is item I'm looking at, and weight of the items I've taken so far.  
 <div class='latexblock'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.15999999999999992em" columnspacing="1em"></mtable><annotation encoding="application/x-tex">
\begin{matrix}
\end{matrix}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord"><span class="mtable"></span></span></span></span></span></span></div> 
 <h4><a id=dp4-guitar-fingering-tetris-super-mario-bros href='#dp4-guitar-fingering-tetris-super-mario-bros'> § </a><span class='centered'> DP4: Guitar fingering, tetris, super mario bros </h4> 
 <span class='centered'>A second kind of guessing. Guessing usually which subproblem to use to solve 
 <span class='centered'>a bigger subproblem. Another way of guessing is to add more subproblems to guess 
 <span class='centered'>or remember more features of the solution.   
 <h4><a id=mapping-to-knapsack href='#mapping-to-knapsack'> § </a><span class='centered'> Mapping to knapsack </h4> 
 <span class='centered'>obvious solution was suffix in knapsack. So we needed to know how many units 
 <span class='centered'>of the knapsack we've used up; we're remembering something about the  <i><span class='centered'>prefix </i>
 <span class='centered'>(but not the full prefix itself). On the other hand, in the forward direction, 
 <span class='centered'>we were solving more  <i><span class='centered'>types </i> of subproblems, for varying sizes of knapsacks.  
 <h4><a id=piano-and-guitar-fingering-take-1 href='#piano-and-guitar-fingering-take-1'> § </a><span class='centered'> Piano and guitar fingering: Take 1 </h4> 
 <span class='centered'>Given some musical piece to play: a sequence of  <code class='inline'>n</code> notes we want to play. 
 <span class='centered'>We want to find a fingering for each note. We have fingers  <code class='inline'>1</code> upto  <code class='inline'>f</code>. We want 
 <span class='centered'>to assign a finger to each note. We have a difficulty measure  <code class='inline'>d(p, f, p', f')</code>: 
 <span class='centered'>how hard is to transition from note  <code class='inline'>p</code> (p for pitch) with finger  <code class='inline'>f</code> to note 
 <span class='centered'><code class='inline'>p'</code> with finger  <code class='inline'>f'</code>?  
 <ul><li><span class='centered'><span class='centered'> Subproblems: prefixes? suffixes? substrings? Suffixes are kind of fine. How to <span class='centered'>play notes  <code class='inline'>n[i:]</code>. </li><li><span class='centered'><span class='centered'> Guess: Which finger to put on note  <code class='inline'>i</code>? </li><li><span class='centered'><span class='centered'> Recurrence:  </li></ul> 
 <pre><code>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span><span class="token punctuation">{</span> 
   <span class="token keyword">for</span> f <span class="token keyword">in</span> fingers<span class="token punctuation">:</span>
      dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> d<span class="token punctuation">(</span>i<span class="token punctuation">,</span> f<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> ?<span class="token punctuation">)</span> <span class="token comment"># WRONG: don't know ?</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
 <ul><li><span class='centered'><span class='centered'> Add more subproblems! how to play  <code class='inline'>notes[i:]</code> when using finger  <code class='inline'>f</code> for  <code class='inline'>notes[i]</code>. </li><li><span class='centered'><span class='centered'> What to guess? finger  <code class='inline'>g</code> for note  <code class='inline'>(i+1)</code></li></ul> 
 <pre><code>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>f<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token keyword">for</span> g <span class="token keyword">in</span> fingers<span class="token punctuation">:</span>
      dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>g<span class="token punctuation">]</span> <span class="token operator">+</span> d<span class="token punctuation">[</span>notes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">,</span> notes<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> g<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> 
 <ul><li><span class='centered'><span class='centered'> Topological order:  </li></ul> 
 <pre><code><span class="token keyword">for</span> i <span class="token builtin">reversed</span><span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
   <span class="token keyword">for</span> f <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>F<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre> 
 <ul><li><span class='centered'><span class='centered'> Original problem: we don't know what finger to use for  <code class='inline'>dp[0]</code>. So we can take <span class='centered'>a  <code class='inline'>min</code> over all fingers.  <code class='inline'>min([ dp[0][f] for f in range(F)])</code></li></ul> 
 <h4><a id=guitar-chords href='#guitar-chords'> § </a><span class='centered'> guitar chords: </h4> 
 <span class='centered'>Generalize the notion of "finger" to "finger(F) + string(S)". This gives 
 <span class='centered'>us  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>F</mi><mo>+</mo><mi>S</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><msup><mi>F</mi><mn>2</mn></msup><msup><mi>S</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N((F+S)^2)) = O(NF^2S^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>.  Multiple notes:  <code class='inline'>notes[i] = list of F notes</code> for 
 <span class='centered'>a piano.  
 <ul><li><span class='centered'><span class='centered'> state: we need to know about the assignment of fingers to notes (or no note). <span class='centered'>So that's  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>N</mi><mo>+</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mi>F</mi></msup></mrow><annotation encoding="application/x-tex">(N+1)^F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span></span></span></span></span></span></span></span></span>. Generalize the rest. </li></ul> 
 <h4><a id=tetris href='#tetris'> § </a><span class='centered'> Tetris </h4> 
 <span class='centered'>We know the entire sequence of pieces that's going to fall. For each, we must 
 <span class='centered'>drop the piece from the top. Also, full rows don't clear.  
 <span class='centered'>The width of the board is small. The board is initially emoty. 
 <span class='centered'>Can you survive?  
 <span class='centered'>The subproblems are how to play suffixes of  <code class='inline'>pieces[i:]</code>. We need to know 
 <span class='centered'>what the board looks like. If the board doesn't clear and we always drop from 
 <span class='centered'>the top, then all we need to know is the skyline.  
 <pre><code>

1| ###
2| #
3|####
4|####
5|####
</code></pre> 
 <ul><li><span class='centered'><span class='centered'> So we also store the board skyline. We have  <code class='inline'>h</code> different choices for each <span class='centered'>column. There are  <code class='inline'>w</code> columns. So we have  <code class='inline'>(h+1)^w</code> number of choices for <span class='centered'>skylines. Total number of subproblems is  <code class='inline'>n.(h+1)^w</code>. </li><li><span class='centered'><span class='centered'> Guess: what do I do with piece  <code class='inline'>i</code>? I can rotate it  <code class='inline'>0, 1, 2, 3</code> times, and the <span class='centered'>where to drop it. I can guess where to drop the piece. This is  <code class='inline'>4w</code> choices --- <span class='centered'><code class='inline'>4</code> for rotation,  <code class='inline'>w</code> for where we drop. </li></ul> 
 <ul><li><span class='centered'><span class='centered'> Here the answer is a boolean: survive (1) or not (0). we want to survive, so <span class='centered'>we can just use  <code class='inline'>max</code> on a boolean. </li></ul> 
 <h4><a id=super-mario-bros href='#super-mario-bros'> § </a><span class='centered'> Super Mario Bros </h4> 
 <span class='centered'>Recall that in the original super mario bros, if something moves out of the 
 <span class='centered'>screen it's lost forever; We can't move back in the old mario. We're given 
 <span class='centered'>the level, and a small  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>×</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">w\times h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span></span> screen. The configuration of the game is 
 <span class='centered'>everything on the screen! Total info is going to be  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>c</mi><mrow><mi>w</mi><mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">c^{wh}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span></span></span></span></span></span> where  <code class='inline'>c</code> is some 
 <span class='centered'>constant. We also need Mario's velocity, the score, and time. score can be S 
 <span class='centered'>big, time can be T big. The number of configurations is the product of all of 
 <span class='centered'>these. We also need to know how far to the right we have gone, which is another 
 <span class='centered'><code class='inline'>W</code>. Draw a graph of all configurations, and then use DP  
 <h3><a id=lecture-10-advanced-dp-by-srinivas href='#lecture-10-advanced-dp-by-srinivas'> § </a><span class='centered'> Lecture 10: Advanced DP by Srinivas </h3> 
 <ul><li><span class='centered'><span class='centered'>  <a href=https://www.youtube.com/watch?v=Tw1k46ywN6E&list=PLcDimPvbmfT8qAxD6JH_kmXiQwTNcoK78&index=10><span class='centered'>Video </a></li></ul> 
 <h4><a id=longest-palindromic-sequence href='#longest-palindromic-sequence'> § </a><span class='centered'> Longest palindromic sequence </h4> 
 <span class='centered'>Find palindrome inside longer word. Given a string  <code class='inline'>X[1..n]</code>. Find longest 
 <span class='centered'>palindrome that is a subsequence.  
 <pre><code>character
c arac
</code></pre> 
 <span class='centered'>answer will be greater than or equal to 1 in length because a single letter 
 <span class='centered'>is a palindrome.  
 <pre><code>turboventilator
  r o   t  ator
</code></pre> 
 <ul><li><span class='centered'><span class='centered'>  <code class='inline'>L[i, j]</code>: length of longest palindromic subsequence in string  <code class='inline'>xs[i:j]</code> where  <code class='inline'>i<=j</code>. </li></ul> 
 <pre><code><span class="token keyword">def</span> <span class="token function">L</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># closed interval</span>
  <span class="token keyword">if</span> i <span class="token operator">></span> j<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span> <span class="token comment"># no letters</span>
  <span class="token keyword">if</span> i <span class="token operator">==</span> j<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">1</span> <span class="token comment"># single letter palindrome</span>
  <span class="token keyword">if</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> x<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span> 
    <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">+</span> l<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token builtin">max</span><span class="token punctuation">(</span>L<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">,</span> L<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
 <ul><li><span class='centered'><span class='centered'> number of subpbroblems:  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>. Time per subproblem assuming recursion is free:  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>. <span class='centered'>Hence, total time is  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>. </li></ul> 
 <h4><a id=optimal-binary-search-trees href='#optimal-binary-search-trees'> § </a><span class='centered'> Optimal binary search trees </h4> 
 <span class='centered'>Find most balanced BST for a set of keys. We have weights for the keys, which 
 <span class='centered'>are search probabilities. Find a BST T (there are exponential number of BSTs) 
 <span class='centered'>that minimizes  <span class='latexinline'><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mi>i</mi></msub><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><msub><mi>h</mi><mi>T</mi></msub><mo stretchy="false">(</mo><msub><mi>k</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_i w_i (depth_T(k_i) + 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0497100000000001em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16195399999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal">p</span><span class="mord mathnormal">t</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>. Depth of root is 0. Depth 
 <span class='centered'>of a node is distance from the root. This minimizes expected search cost.  
 <h4><a id=enumeration href='#enumeration'> § </a><span class='centered'> Enumeration </h4> 
 <span class='centered'>We have exponentially many trees.   
 <h4><a id=greedy-soltution-why-doesnt-greedy-work href='#greedy-soltution-why-doesnt-greedy-work'> § </a><span class='centered'> Greedy soltution / Why doesn't greedy work? </h4> 
 <span class='centered'>Assume the keys are sorted. 
 <span class='centered'>Pick  <code class='inline'>K[i]</code> in some greedy fashion (max.weight). 
 <span class='centered'>This immediately splits the set of keys into the left and right. 
 <span class='centered'>If we define  <code class='inline'>e(i, j)</code> to be the cost of the optimal BST on keys  <code class='inline'>k[i], ..., k[j]</code> .  
 <pre><code>greedy:
-------
        2|w=10
1|w=1           4|w=9
           3|w=8
</code></pre> 
 <pre><code>optimal:
-------
         3|w=8
    2|w=10    4|w=9
1|w=1         
</code></pre> 
 <h4><a id=dp href='#dp'> § </a><span class='centered'> DP </h4> 
 <ul><li><span class='centered'><span class='centered'> Guess all possible root nodes. The greedy algorithm doesn't try to guess the <span class='centered'>root node, that's the only difference. </li></ul> 
 <pre><code><span class="token operator">-</span><span class="token operator">-</span> e<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">:</span> cost of tree <span class="token keyword">with</span> keys k<span class="token punctuation">:</span> i <span class="token operator">&lt;=</span> k <span class="token operator">&lt;=</span> j
<span class="token keyword">def</span> <span class="token function">e</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">if</span> i <span class="token operator">==</span> j<span class="token punctuation">:</span> <span class="token keyword">return</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
  <span class="token comment"># | WRONG</span>
  <span class="token keyword">return</span> <span class="token builtin">min</span><span class="token punctuation">(</span><span class="token punctuation">[</span>e<span class="token punctuation">(</span>i<span class="token punctuation">,</span> r<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> e<span class="token punctuation">(</span>r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token operator">+</span> w<span class="token punctuation">[</span>r<span class="token punctuation">]</span> 
              <span class="token keyword">for</span> k <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre> 
 <span class='centered'>The weights are going to change when we increase depth, so we actually need 
 <span class='centered'>to add all the weights from  <code class='inline'>i</code> to  <code class='inline'>j</code>! So we write:  
 <pre><code><span class="token operator">-</span><span class="token operator">-</span> e<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">:</span> cost of tree <span class="token keyword">with</span> keys k<span class="token punctuation">:</span> i <span class="token operator">&lt;=</span> k <span class="token operator">&lt;=</span> j
<span class="token keyword">def</span> <span class="token function">e</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">if</span> i <span class="token operator">==</span> j<span class="token punctuation">:</span> <span class="token keyword">return</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
  <span class="token comment"># | WRONG</span>
  <span class="token keyword">return</span> <span class="token builtin">min</span><span class="token punctuation">(</span><span class="token punctuation">[</span>e<span class="token punctuation">(</span>i<span class="token punctuation">,</span> r<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> e<span class="token punctuation">(</span>r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token operator">+</span> weight<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span>
                 <span class="token keyword">for</span> k <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre> 
 <h4><a id=alternating-coins href='#alternating-coins'> § </a><span class='centered'> Alternating coins </h4>
 <span class='centered'>Have a list of coins. We have an even number of coins. 
 <span class='centered'>Can only pick coins from the outside.  
 <span class='centered'>First player can always not lose in the game.  What the first player does 
 <span class='centered'>is compute  <code class='inline'>v[1] + v[3] + ... v[n-1]</code> versus  <code class='inline'>v[2] + v[4] + ...</code> which is even. 
 <span class='centered'>If the odd values win, the he picks  <code class='inline'>v[1]</code>. P2 can pick  <code class='inline'>v[2]</code> or  <code class='inline'>v[n]</code>.  
 <span class='centered'>P1 can pick either  <code class='inline'>v[3]</code> or  <code class='inline'>v[n-1]</code> depending on if P2 picked  <code class='inline'>v[2]</code> or  <code class='inline'>v[n]</code>.  
 <ul><li><span class='centered'><span class='centered'> We now want to  <i><span class='centered'><i><span class='centered'>maximize </i></i> the amount of money. </li></ul> 
 <pre><code>v<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token builtin">range</span> <span class="token keyword">is</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token keyword">with</span> P2 <span class="token operator">+</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>
                <span class="token builtin">range</span> <span class="token keyword">is</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">with</span> P2 <span class="token operator">+</span> v<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre> 
 <span class='centered'>If we have  <code class='inline'>v(i+1, j)</code> subproblem with the opponent picking, we are guaranteed 
 <span class='centered'>that the opponent plays  <code class='inline'>min(v(i+1, j-1), v(i+2, j))</code>. So we can unfold this, 
 <span class='centered'>to get the full DP:  
 <pre><code>v<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span><span class="token punctuation">[</span>  <span class="token builtin">min</span><span class="token punctuation">(</span>v<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>
                  <span class="token builtin">min</span><span class="token punctuation">(</span>v<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> v<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>
</code></pre> 
 <h4><a id=dp-all-pairs-shortest-paths href='#dp-all-pairs-shortest-paths'> § </a><span class='centered'> DP: All pairs shortest paths. </h4> 
 <script src="https://utteranc.es/client.js"        repo="bollu/bollu.github.io"        issue-term="pathname"        label="question"        theme="github-light"        crossorigin="anonymous"        async></script></container></body></html>