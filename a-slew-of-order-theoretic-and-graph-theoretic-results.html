<!DOCTYPE html><meta charset='UTF-8'><html><head><link rel='stylesheet' href='katex/katex.min.css'    integrity='sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X'    crossorigin='anonymous'><!-- The loading of KaTeX is deferred to speed up page rendering --><link rel='stylesheet' href='prism/prism.css'><title> A Universe of Sorts </title><style>@font-face {font-family: 'Blog Mono'; src: url('/static/iosevka-fixed-extended.ttf');}@font-face {font-family: 'Blog Text'; src: url('/static/Exo2-Regular.ttf');}html { font-size: 100%; }html,body { text-size-adjust: none; -webkit-text-size-adjust: none; -moz-text-size-adjust: none; -ms-text-size-adjust: none; } body { background-color: #FFFFFF; color: #000000;  font-family: 'Blog Text', sans-serif; font-size: 18px; line-height: 1.4em;  max-width: 100%; overflow-x: hidden; }
img { display:block; width: 100%; max-width: 800px; height: auto }.container { overflow-x: auto; overflow-y: hidden;  max-width:100%; }@media (max-width: 480px) { .container { margin-left: 5%; margin-right: 5%; } body { font-size: 30px; } }@media (max-width: 1024px) { .container { margin-left: 5%; margin-right: 5%; } body { font-size: 30px; } }@media (min-width: 1024px) { .container { margin-left: 25%; margin-right: 20%; } }.image { }
a:hover { color: #1a73e8; text-decoration: underline;  }
a { color: #1a73e8; text-decoration: none; }
a:visited { color: #1a73e8; text-decoration: none; }
a:active { color: #1a73e8; text-decoration: none; }

blockquote { margin-left: 0px; margin-right: 0px; } pre, .latexblock, blockquote { border-left-color:#BBB;  border-left-style: solid;      border-left-width: 1px; }pre, blockquote { padding-left: 10px; }
pre { font-family: 'Blog Mono', monospace; font-size: 90%;  }pre {  overflow-x: auto; }.latexblock, blockquote, pre { margin-top: 10px; margin-bottom: 10px; padding-bottom: 5px; padding-top: 5px; background-color: #FFFFFF; }.latexblock { line-height: 1em }
pre, kbd, samp, tt{ font-family:'Blog Mono',monospace; }ul, ol { list-style-position: inside; padding-left: 0; }</style></head><body><div class='container'><h2><a id=a-slew-of-order-theoretic-and-graph-theoretic-results href='#a-slew-of-order-theoretic-and-graph-theoretic-results'> § </a><span class='centered'> A slew of order theoretic and graph theoretic results</h2>
I've been trying to abstract out the <a href=https://en.wikipedia.org/wiki/Activity_selection_problem><span class='centered'>activity selection problem</a>
from the lens of order theory. For this, I plan on studying the following
theorems/algebraic structures:
<ul><li><span class='centered'> Intransitive indifference with unequal indifference intervals</li><li><span class='centered'> Mirsky's theorem</li><li><span class='centered'> Dilworth's theorem</li><li><span class='centered'> Gallai–Hasse–Roy–Vitaver theorem</li><li><span class='centered'> Dirac's theorem</li><li><span class='centered'> Ore's theorem</li><li><span class='centered'> <a href=https://www.coursera.org/learn/discrete-mathematics#syllabus><span class='centered'>Course on discrete math</a></li><li><span class='centered'> <a href=https://cs.stackexchange.com/questions/67847/finding-longest-chain-in-poset-in-subquadratic-time><span class='centered'><code>cs.stackexchange</code>: Finding longest chain in poset in sub-quadratic time</a></li></ul>
Naively, the solution goes as follows, which can be tested against 
<a href=https://cses.fi/problemset/task/1629><span class='centered'>CSES' movie festival question</a>
<pre><code><span class="token comment">// https://cses.fi/problemset/task/1629</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">ms</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cin <span class="token operator">>></span> ms<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>first <span class="token operator">>></span> ms<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    std<span class="token operator">::</span><span class="token function">sort</span><span class="token punctuation">(</span>ms<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ms<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> p1<span class="token punctuation">,</span> pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> p2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>p1<span class="token punctuation">.</span>second <span class="token operator">&lt;</span> p2<span class="token punctuation">.</span>second<span class="token punctuation">)</span> <span class="token operator">||</span>
               <span class="token punctuation">(</span>p1<span class="token punctuation">.</span>second <span class="token operator">==</span> p2<span class="token punctuation">.</span>second <span class="token operator">&amp;&amp;</span> p1<span class="token punctuation">.</span>first <span class="token operator">&lt;</span> p2<span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> njobs <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> cur_end <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur_end <span class="token operator">&lt;=</span> ms<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>first<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            cur_end <span class="token operator">=</span> ms<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>
            njobs<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> njobs <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h4><a id=explanation-1-exchange-argument href='#explanation-1-exchange-argument'> § </a><span class='centered'> Explanation 1: exchange argument</h4>
<ul><li><span class='centered'> The idea is to pick jobs <i><span class='centered'>greedily</i>, based on <i><span class='centered'>quickest finishing time</i>.</li><li><span class='centered'> The argument of optimality is strategy stealing. Think of the first job
  in our ordering <code>O</code> versus the optimal ordering <code>O*</code>.</li><li><span class='centered'> If we both use the same job, ie, <code>O[1] = O*[1]</code>, recurse into the second job.</li><li><span class='centered'> If we use different jobs then <code>O[1] != O*[1]</code>.</li><li><span class='centered'> Since  <code>O[1]</code> ends <i><span class='centered'>quickest</i> [acc to our algorithm],
  we will have that <code>end(O[1]) < end(all other jobs)</code>, hence
  <code>end(O[1]) < end(O*[1])</code>.</li><li><span class='centered'> Since <code>O*</code> is a <i><span class='centered'>correct</i> job schedule, we have that <code>end(O*[1]) < start(O*[2])</code>.</li><li><span class='centered'> Chaining inequalities, we get that <code>end(O[1]) < end(O*[1]) < start(O*[2])</code>.</li><li><span class='centered'> Thus, we can create <code>O~</code> which has <code>O~[1] = O[1]</code> and <code>O~[rest] = O*[rest]</code>.
  (<code>~</code> for "modified").</li><li><span class='centered'> Now recurse into <code>O~</code> to continue aligning <code>O*</code> with <code>O</code>. We continue to have the
  same length between <code>O~</code>, <code>O</code> and <code>O*</code>.</li></ul>
<h4><a id=explanation-2-posets-and-interval-orders href='#explanation-2-posets-and-interval-orders'> § </a><span class='centered'> Explanation 2: posets and interval orders</h4>
</container></body></html>