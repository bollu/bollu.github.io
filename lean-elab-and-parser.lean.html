<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<!-- Created by htmlize-1.56 in css mode. -->
<html>
  <head>
    <title>elab-and-parser.lean</title>
    <style type="text/css">
    <!--
      body {
        color: #000000;
        background-color: #ffffff;
      }
      .comment {
        /* font-lock-comment-face */
        color: #888888;
        font-style: italic;
      }
      .comment-delimiter {
        /* font-lock-comment-delimiter-face */
        color: #888888;
        font-style: italic;
      }
      .constant {
        /* font-lock-constant-face */
        font-weight: bold;
        font-style: italic;
      }
      .doc {
        /* font-lock-doc-face */
        color: #888888;
        font-style: italic;
      }
      .function-name {
        /* font-lock-function-name-face */
        font-weight: bold;
      }
      .keyword {
        /* font-lock-keyword-face */
        font-weight: bold;
      }
      .preprocessor {
        /* font-lock-preprocessor-face */
        font-style: italic;
      }
      .string {
        /* font-lock-string-face */
        color: #3c5e2b;
      }
      .type {
        /* font-lock-type-face */
        font-style: italic;
      }
      .warning {
        /* font-lock-warning-face */
        color: #000000;
        text-decoration: underline;
      }

      a {
        color: inherit;
        background-color: inherit;
        font: inherit;
        text-decoration: inherit;
      }
      a:hover {
        text-decoration: underline;
      }
    -->
    </style>
  </head>
  <body>
    <pre>
    1 ::::::::::::::
    2 Elab.lean
    3 ::::::::::::::
<span class="comment-delimiter">    4 /-</span><span class="comment">
    5 Copyright (c) 2019 Microsoft Corporation. All rights reserved.
    6 Released under Apache 2.0 license as described in the file LICENSE.
    7 Authors: Leonardo de Moura
    8 -/</span>
<span class="keyword">   9  import</span> Lean.Elab.Import
<span class="keyword">  10  import</span> Lean.Elab.Exception
<span class="keyword">  11  import</span> Lean.Elab.Command
<span class="keyword">  12  import</span> Lean.Elab.Term
<span class="keyword">  13  import</span> Lean.Elab.App
<span class="keyword">  14  import</span> Lean.Elab.Binders
<span class="keyword">  15  import</span> Lean.Elab.LetRec
<span class="keyword">  16  import</span> Lean.Elab.Frontend
<span class="keyword">  17  import</span> Lean.Elab.BuiltinNotation
<span class="keyword">  18  import</span> Lean.Elab.Declaration
<span class="keyword">  19  import</span> Lean.Elab.Tactic
<span class="keyword">  20  import</span> Lean.Elab.Match
<span class="comment-delimiter">  21  -- </span><span class="comment">HACK: must come after `Match` because builtin elaborators (for `match` in this case) do not take priorities
</span><span class="keyword">  22  import</span> Lean.Elab.Quotation
<span class="keyword">  23  import</span> Lean.Elab.Syntax
<span class="keyword">  24  import</span> Lean.Elab.Do
<span class="keyword">  25  import</span> Lean.Elab.StructInst
<span class="keyword">  26  import</span> Lean.Elab.Inductive
<span class="keyword">  27  import</span> Lean.Elab.Structure
<span class="keyword">  28  import</span> Lean.Elab.Print
<span class="keyword">  29  import</span> Lean.Elab.MutualDef
<span class="keyword">  30  import</span> Lean.Elab.PreDefinition
<span class="keyword">  31  import</span> Lean.Elab.Deriving
<span class="keyword">  32  import</span> Lean.Elab.DeclarationRange
<span class="keyword">  33  import</span> Lean.Elab.Extra
  34  ::::::::::::::
  35  Elab<span class="constant">/</span>App.lean
  36  ::::::::::::::
<span class="comment-delimiter">  37  /-</span><span class="comment">
  38  Copyright (c) 2019 Microsoft Corporation. All rights reserved.
  39  Released under Apache 2.0 license as described in the file LICENSE.
  40  Authors: Leonardo de Moura
  41 -/</span>
<span class="keyword">  42 import</span> Lean.Util.FindMVar
<span class="keyword">  43 import</span> Lean.Parser.Term
<span class="keyword">  44 import</span> Lean.Elab.Term
<span class="keyword">  45 import</span> Lean.Elab.Binders
<span class="keyword">  46 import</span> Lean.Elab.SyntheticMVars
  47 
<span class="keyword">  48 namespace</span> Lean.Elab.Term
<span class="keyword">  49 open</span> Meta
  50 
<span class="keyword">  51 builtin_initialize</span> elabWithoutExpectedTypeAttr : TagAttribute &#8592;
  52   registerTagAttribute `elabWithoutExpectedType <span class="string">"mark that applications of the given declaration should be elaborated without the expected type"</span>
  53 
<span class="keyword">  54 def</span> <span class="function-name">hasElabWithoutExpectedType</span> (env : Environment) (declName : Name) : Bool <span class="constant">:=</span>
  55   elabWithoutExpectedTypeAttr.hasTag env declName
  56 
<span class="comment-delimiter">  57 /-</span><span class="comment">-
  58   Auxiliary inductive datatype for combining unelaborated syntax
  59   and already elaborated expressions. It is used to elaborate applications. -/</span>
<span class="keyword">  60 inductive</span> <span class="function-name">Arg</span> <span class="keyword">where</span>
  61   | stx  (val : Syntax)
  62   | expr (val : Expr)
  63   <span class="keyword">deriving</span> Inhabited
  64 
<span class="keyword">  65 instance</span> <span class="function-name">:</span> ToString Arg <span class="constant">:=</span> &#10216;<span class="keyword">fun</span>
  66   | Arg.stx  val <span class="constant">=&gt;</span> toString val
  67   | Arg.expr val <span class="constant">=&gt;</span> toString val&#10217;
  68 
<span class="comment-delimiter">  69 /-</span><span class="comment">- Named arguments created using the notation `(x := val)` -/</span>
<span class="keyword">  70 structure</span> <span class="function-name">NamedArg</span> <span class="keyword">where</span>
  71   ref  : Syntax <span class="constant">:=</span> Syntax.missing
  72   name : Name
  73   val  : Arg
  74   <span class="keyword">deriving</span> Inhabited
  75 
<span class="keyword">  76 instance</span> <span class="function-name">:</span> ToString NamedArg <span class="keyword">where</span>
  77   toString s <span class="constant">:=</span> <span class="string">"("</span> <span class="constant">++</span> toString s.name <span class="constant">++</span> <span class="string">" := "</span> <span class="constant">++</span> toString s.val <span class="constant">++</span> <span class="string">")"</span>
  78 
<span class="keyword">  79 def</span> <span class="function-name">throwInvalidNamedArg</span> {&#945;} (namedArg : NamedArg) (fn? : Option Name) : TermElabM &#945; <span class="constant">:=</span>
  80   withRef namedArg.ref <span class="constant">&lt;</span>| <span class="keyword">match</span> fn? <span class="keyword">with</span>
  81     | some fn <span class="constant">=&gt;</span> throwError <span class="string">"invalid argument name '{namedArg.name}' for function '{fn}'"</span>
  82     | none    <span class="constant">=&gt;</span> throwError <span class="string">"invalid argument name '{namedArg.name}' for function"</span>
  83 
<span class="comment-delimiter">  84 /-</span><span class="comment">-
  85   Add a new named argument to `namedArgs`, and throw an error if it already contains a named argument
  86   with the same name. -/</span>
<span class="keyword">  87 def</span> <span class="function-name">addNamedArg</span> (namedArgs : Array NamedArg) (namedArg : NamedArg) : TermElabM (Array NamedArg) <span class="constant">:=</span> <span class="keyword">do</span>
  88   <span class="keyword">if</span> namedArgs.any (namedArg.name <span class="constant">==</span> &#183;.name) <span class="keyword">then</span>
  89     throwError <span class="string">"argument '{namedArg.name}' was already set"</span>
  90   <span class="keyword">return</span> namedArgs.push namedArg
  91 
<span class="keyword">  92 private</span> <span class="keyword">def</span> <span class="function-name">ensureArgType</span> (f : Expr) (arg : Expr) (expectedType : Expr) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
  93   <span class="keyword">let</span> argType &#8592; inferType arg
  94   ensureHasTypeAux expectedType argType arg f
  95 
<span class="comment-delimiter">  96 /-</span><span class="comment">
  97   Relevant definitions:
  98   ```
  99   class CoeFun (&#945; : Sort u) (&#947; : &#945; &#8594; outParam (Sort v))
 100   abbrev coeFun {&#945; : Sort u} {&#947; : &#945; &#8594; Sort v} (a : &#945;) [CoeFun &#945; &#947;] : &#947; a
 101   ```
 102 -/</span>
<span class="keyword"> 103 private</span> <span class="keyword">def</span> <span class="function-name">tryCoeFun?</span> (&#945; : Expr) (a : Expr) : TermElabM (Option Expr) <span class="constant">:=</span> <span class="keyword">do</span>
 104   <span class="keyword">let</span> v &#8592; mkFreshLevelMVar
 105   <span class="keyword">let</span> type &#8592; mkArrow &#945; (mkSort v)
 106   <span class="keyword">let</span> &#947; &#8592; mkFreshExprMVar type
 107   <span class="keyword">let</span> u &#8592; getLevel &#945;
 108   <span class="keyword">let</span> coeFunInstType <span class="constant">:=</span> mkAppN (Lean.mkConst ``CoeFun [u, v]) <span class="constant">#</span>[&#945;, &#947;]
 109   <span class="keyword">let</span> mvar &#8592; mkFreshExprMVar coeFunInstType MetavarKind.synthetic
 110   <span class="keyword">let</span> mvarId <span class="constant">:=</span> mvar.mvarId<span class="constant">!</span>
 111   <span class="keyword">try</span>
 112     <span class="keyword">if</span> (&#8592; synthesizeCoeInstMVarCore mvarId) <span class="keyword">then</span>
 113       expandCoe <span class="constant">&lt;</span>| mkAppN (Lean.mkConst ``coeFun [u, v]) <span class="constant">#</span>[&#945;, &#947;, a, mvar]
 114     <span class="keyword">else</span>
 115       <span class="keyword">return</span> none
 116   <span class="keyword">catch</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
 117     <span class="keyword">return</span> none
 118 
<span class="keyword"> 119 def</span> <span class="function-name">synthesizeAppInstMVars</span> (instMVars : Array MVarId) : TermElabM Unit <span class="constant">:=</span>
 120   <span class="keyword">for</span> mvarId <span class="keyword">in</span> instMVars <span class="keyword">do</span>
 121     <span class="keyword">unless</span> (&#8592; synthesizeInstMVarCore mvarId) <span class="keyword">do</span>
 122       registerSyntheticMVarWithCurrRef mvarId SyntheticMVarKind.typeClass
 123 
<span class="keyword"> 124 namespace</span> ElabAppArgs
 125 
<span class="comment-delimiter"> 126 /- </span><span class="comment">Auxiliary structure for elaborating the application `f args namedArgs`. -/</span>
<span class="keyword"> 127 structure</span> <span class="function-name">State</span> <span class="keyword">where</span>
 128   explicit          : Bool <span class="comment-delimiter">-- </span><span class="comment">true if `@` modifier was used
</span> 129   f                 : Expr
 130   fType             : Expr
 131   args              : List Arg            <span class="comment-delimiter">-- </span><span class="comment">remaining regular arguments
</span> 132   namedArgs         : List NamedArg       <span class="comment-delimiter">-- </span><span class="comment">remaining named arguments to be processed
</span> 133   ellipsis          : Bool <span class="constant">:=</span> false
 134   expectedType?     : Option Expr
 135   etaArgs           : Array Expr   <span class="constant">:=</span> <span class="constant">#</span>[]
 136   toSetErrorCtx     : Array MVarId <span class="constant">:=</span> <span class="constant">#</span>[] <span class="comment-delimiter">-- </span><span class="comment">metavariables that we need the set the error context using the application being built
</span> 137   instMVars         : Array MVarId <span class="constant">:=</span> <span class="constant">#</span>[] <span class="comment-delimiter">-- </span><span class="comment">metavariables for the instance implicit arguments that have already been processed
</span> 138   <span class="comment-delimiter">-- </span><span class="comment">The following field is used to implement the `propagateExpectedType` heuristic.
</span> 139   propagateExpected : Bool  <span class="comment-delimiter">-- </span><span class="comment">true when expectedType has not been propagated yet
</span> 140 
<span class="keyword"> 141 abbrev</span> M <span class="constant">:=</span> StateRefT State TermElabM
 142 
<span class="comment-delimiter"> 143 /- </span><span class="comment">Add the given metavariable to the collection of metavariables associated with instance-implicit arguments. -/</span>
<span class="keyword"> 144 private</span> <span class="keyword">def</span> <span class="function-name">addInstMVar</span> (mvarId : MVarId) : M Unit <span class="constant">:=</span>
 145   modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> instMVars <span class="constant">:=</span> s.instMVars.push mvarId }
 146 
<span class="comment-delimiter"> 147 /-</span><span class="comment">
 148   Try to synthesize metavariables are `instMVars` using type class resolution.
 149   The ones that cannot be synthesized yet are registered.
 150   Remark: we use this method before trying to apply coercions to function. -/</span>
<span class="keyword"> 151 def</span> <span class="function-name">synthesizeAppInstMVars</span> : M Unit <span class="constant">:=</span> <span class="keyword">do</span>
 152   <span class="keyword">let</span> s &#8592; get
 153   <span class="keyword">let</span> instMVars <span class="constant">:=</span> s.instMVars
 154   modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> instMVars <span class="constant">:=</span> <span class="constant">#</span>[] }
 155   Lean.Elab.Term.synthesizeAppInstMVars instMVars
 156 
<span class="comment-delimiter"> 157 /- </span><span class="comment">fType may become a forallE after we synthesize pending metavariables. -/</span>
<span class="keyword"> 158 private</span> <span class="keyword">def</span> <span class="function-name">synthesizePendingAndNormalizeFunType</span> : M Unit <span class="constant">:=</span> <span class="keyword">do</span>
 159   synthesizeAppInstMVars
 160   synthesizeSyntheticMVars
 161   <span class="keyword">let</span> s &#8592; get
 162   <span class="keyword">let</span> fType &#8592; whnfForall s.fType
 163   <span class="keyword">if</span> fType.isForall <span class="keyword">then</span>
 164     modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> fType <span class="constant">:=</span> fType }
 165   <span class="keyword">else</span>
 166     <span class="keyword">match</span> (&#8592; tryCoeFun? fType s.f) <span class="keyword">with</span>
 167     | some f <span class="constant">=&gt;</span>
 168       <span class="keyword">let</span> fType &#8592; inferType f
 169       modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> f <span class="constant">:=</span> f, fType <span class="constant">:=</span> fType }
 170     | none <span class="constant">=&gt;</span>
 171       <span class="keyword">for</span> namedArg <span class="keyword">in</span> s.namedArgs <span class="keyword">do</span>
 172         <span class="keyword">let</span> f <span class="constant">:=</span> s.f.getAppFn
 173         <span class="keyword">if</span> f.isConst <span class="keyword">then</span>
 174           throwInvalidNamedArg namedArg f.constName<span class="constant">!</span>
 175         <span class="keyword">else</span>
 176           throwInvalidNamedArg namedArg none
 177       throwError <span class="string">"function expected at{indentExpr s.f}\nterm has type{indentExpr fType}"</span>
 178 
<span class="comment-delimiter"> 179 /- </span><span class="comment">Normalize and return the function type. -/</span>
<span class="keyword"> 180 private</span> <span class="keyword">def</span> <span class="function-name">normalizeFunType</span> : M Expr <span class="constant">:=</span> <span class="keyword">do</span>
 181   <span class="keyword">let</span> s &#8592; get
 182   <span class="keyword">let</span> fType &#8592; whnfForall s.fType
 183   modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> fType <span class="constant">:=</span> fType }
 184   pure fType
 185 
<span class="comment-delimiter"> 186 /- </span><span class="comment">Return the binder name at `fType`. This method assumes `fType` is a function type. -/</span>
<span class="keyword"> 187 private</span> <span class="keyword">def</span> <span class="function-name">getBindingName</span> : M Name <span class="constant">:=</span> <span class="keyword">return</span> (&#8592; get).fType.bindingName<span class="constant">!</span>
 188 
<span class="comment-delimiter"> 189 /- </span><span class="comment">Return the next argument expected type. This method assumes `fType` is a function type. -/</span>
<span class="keyword"> 190 private</span> <span class="keyword">def</span> <span class="function-name">getArgExpectedType</span> : M Expr <span class="constant">:=</span> <span class="keyword">return</span> (&#8592; get).fType.bindingDomain<span class="constant">!</span>
 191 
<span class="keyword"> 192 def</span> <span class="function-name">eraseNamedArgCore</span> (namedArgs : List NamedArg) (binderName : Name) : List NamedArg <span class="constant">:=</span>
 193   namedArgs.filter (&#183;.name <span class="constant">!=</span> binderName)
 194 
<span class="comment-delimiter"> 195 /- </span><span class="comment">Remove named argument with name `binderName` from `namedArgs`. -/</span>
<span class="keyword"> 196 def</span> <span class="function-name">eraseNamedArg</span> (binderName : Name) : M Unit <span class="constant">:=</span>
 197   modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> namedArgs <span class="constant">:=</span> eraseNamedArgCore s.namedArgs binderName }
 198 
<span class="comment-delimiter"> 199 /-</span><span class="comment">
 200   Add a new argument to the result. That is, `f := f arg`, update `fType`.
 201   This method assumes `fType` is a function type. -/</span>
<span class="keyword"> 202 private</span> <span class="keyword">def</span> <span class="function-name">addNewArg</span> (arg : Expr) : M Unit <span class="constant">:=</span>
 203   modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> f <span class="constant">:=</span> mkApp s.f arg, fType <span class="constant">:=</span> s.fType.bindingBody<span class="constant">!</span>.instantiate1 arg }
 204 
<span class="comment-delimiter"> 205 /-</span><span class="comment">
 206   Elaborate the given `Arg` and add it to the result. See `addNewArg`.
 207   Recall that, `Arg` may be wrapping an already elaborated `Expr`. -/</span>
<span class="keyword"> 208 private</span> <span class="keyword">def</span> <span class="function-name">elabAndAddNewArg</span> (arg : Arg) : M Unit <span class="constant">:=</span> <span class="keyword">do</span>
 209   <span class="keyword">let</span> s &#8592; get
 210   <span class="keyword">let</span> expectedType &#8592; getArgExpectedType
 211   <span class="keyword">match</span> arg <span class="keyword">with</span>
 212   | Arg.expr val <span class="constant">=&gt;</span>
 213     <span class="keyword">let</span> arg &#8592; ensureArgType s.f val expectedType
 214     addNewArg arg
 215   | Arg.stx val  <span class="constant">=&gt;</span>
 216     <span class="keyword">let</span> val &#8592; elabTerm val expectedType
 217     <span class="keyword">let</span> arg &#8592; ensureArgType s.f val expectedType
 218     addNewArg arg
 219 
<span class="comment-delimiter"> 220 /- </span><span class="comment">Return true if the given type contains `OptParam` or `AutoParams` -/</span>
<span class="keyword"> 221 private</span> <span class="keyword">def</span> <span class="function-name">hasOptAutoParams</span> (type : Expr) : M Bool <span class="constant">:=</span> <span class="keyword">do</span>
 222   forallTelescopeReducing type <span class="keyword">fun</span> xs type <span class="constant">=&gt;</span>
 223     xs.anyM <span class="keyword">fun</span> x <span class="constant">=&gt;</span> <span class="keyword">do</span>
 224       <span class="keyword">let</span> xType &#8592; inferType x
 225       <span class="keyword">return</span> xType.getOptParamDefault?.isSome <span class="constant">||</span> xType.getAutoParamTactic?.isSome
 226 
<span class="comment-delimiter"> 227 /- </span><span class="comment">Return true if `fType` contains `OptParam` or `AutoParams` -/</span>
<span class="keyword"> 228 private</span> <span class="keyword">def</span> <span class="function-name">fTypeHasOptAutoParams</span> : M Bool <span class="constant">:=</span> <span class="keyword">do</span>
 229   hasOptAutoParams (&#8592; get).fType
 230 
<span class="comment-delimiter"> 231 /- </span><span class="comment">Auxiliary function for retrieving the resulting type of a function application.
 232    See `propagateExpectedType`.
 233 
 234    Remark: `(explicit : Bool) == true` when `@` modifier is used. -/</span>
<span class="keyword"> 235 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">getForallBody</span> (explicit : Bool) : Nat <span class="constant">&#8594;</span> List NamedArg <span class="constant">&#8594;</span> Expr <span class="constant">&#8594;</span> Option Expr
 236   | i, namedArgs, type<span class="constant">@</span>(Expr.forallE n d b c) <span class="constant">=&gt;</span>
 237     <span class="keyword">match</span> namedArgs.find? <span class="keyword">fun</span> (namedArg : NamedArg) <span class="constant">=&gt;</span> namedArg.name <span class="constant">==</span> n <span class="keyword">with</span>
 238     | some <span class="preprocessor">_</span> <span class="constant">=&gt;</span> getForallBody explicit i (eraseNamedArgCore namedArgs n) b
 239     | none <span class="constant">=&gt;</span>
 240       <span class="keyword">if</span> <span class="constant">!</span>explicit <span class="constant">&amp;&amp;</span> <span class="constant">!</span>c.binderInfo.isExplicit <span class="keyword">then</span>
 241         getForallBody explicit i namedArgs b
 242       <span class="keyword">else</span> <span class="keyword">if</span> i <span class="constant">&gt;</span> <span class="constant">0</span> <span class="keyword">then</span>
 243         getForallBody explicit (i<span class="constant">-1</span>) namedArgs b
 244       <span class="keyword">else</span> <span class="keyword">if</span> d.isAutoParam <span class="constant">||</span> d.isOptParam <span class="keyword">then</span>
 245         getForallBody explicit i namedArgs b
 246       <span class="keyword">else</span>
 247         some type
 248   | <span class="constant">0</span>, [], type <span class="constant">=&gt;</span> some type
 249   | <span class="preprocessor">_</span>, <span class="preprocessor">_</span>,  <span class="preprocessor">_</span>    <span class="constant">=&gt;</span> none
 250 
<span class="keyword"> 251 private</span> <span class="keyword">def</span> <span class="function-name">shouldPropagateExpectedTypeFor</span> (nextArg : Arg) : Bool <span class="constant">:=</span>
 252   <span class="keyword">match</span> nextArg <span class="keyword">with</span>
 253   | Arg.expr <span class="preprocessor">_</span>  <span class="constant">=&gt;</span> false <span class="comment-delimiter">-- </span><span class="comment">it has already been elaborated
</span> 254   | Arg.stx stx <span class="constant">=&gt;</span>
 255     <span class="comment-delimiter">-- </span><span class="comment">TODO: make this configurable?
</span> 256     stx.getKind <span class="constant">!=</span> ``Lean.Parser.Term.hole <span class="constant">&amp;&amp;</span>
 257     stx.getKind <span class="constant">!=</span> ``Lean.Parser.Term.syntheticHole <span class="constant">&amp;&amp;</span>
 258     stx.getKind <span class="constant">!=</span> ``Lean.Parser.Term.byTactic
 259 
<span class="comment-delimiter"> 260 /-</span><span class="comment">
 261   Auxiliary method for propagating the expected type. We call it as soon as we find the first explict
 262   argument. The goal is to propagate the expected type in applications of functions such as
 263   ```lean
 264   Add.add {&#945; : Type u} : &#945; &#8594; &#945; &#8594; &#945;
 265   List.cons {&#945; : Type u} : &#945; &#8594; List &#945; &#8594; List &#945;
 266   ```
 267   This is particularly useful when there applicable coercions. For example,
 268   assume we have a coercion from `Nat` to `Int`, and we have
 269   `(x : Nat)` and the expected type is `List Int`. Then, if we don't use this function,
 270   the elaborator will fail to elaborate
 271   ```
 272   List.cons x []
 273   ```
 274   First, the elaborator creates a new metavariable `?&#945;` for the implicit argument `{&#945; : Type u}`.
 275   Then, when it processes `x`, it assigns `?&#945; := Nat`, and then obtain the
 276   resultant type `List Nat` which is **not** definitionally equal to `List Int`.
 277   We solve the problem by executing this method before we elaborate the first explicit argument (`x` in this example).
 278   This method infers that the resultant type is `List ?&#945;` and unifies it with `List Int`.
 279   Then, when we elaborate `x`, the elaborate realizes the coercion from `Nat` to `Int` must be used, and the
 280   term
 281   ```
 282   @List.cons Int (coe x) (@List.nil Int)
 283   ```
 284   is produced.
 285 
 286   The method will do nothing if
 287   1- The resultant type depends on the remaining arguments (i.e., `!eTypeBody.hasLooseBVars`).
 288   2- The resultant type contains optional/auto params.
 289 
 290   We have considered adding the following extra conditions
 291     a) The resultant type does not contain any type metavariable.
 292     b) The resultant type contains a nontype metavariable.
 293 
 294     These two conditions would restrict the method to simple functions that are "morally" in
 295     the Hindley&amp;Milner fragment.
 296     If users need to disable expected type propagation, we can add an attribute `[elabWithoutExpectedType]`.
 297 -/</span>
<span class="keyword"> 298 private</span> <span class="keyword">def</span> <span class="function-name">propagateExpectedType</span> (arg : Arg) : M Unit <span class="constant">:=</span> <span class="keyword">do</span>
 299   <span class="keyword">if</span> shouldPropagateExpectedTypeFor arg <span class="keyword">then</span>
 300     <span class="keyword">let</span> s &#8592; get
 301     <span class="comment-delimiter">-- </span><span class="comment">TODO: handle s.etaArgs.size &gt; 0
</span> 302     <span class="keyword">unless</span> <span class="constant">!</span>s.etaArgs.isEmpty <span class="constant">||</span> <span class="constant">!</span>s.propagateExpected <span class="keyword">do</span>
 303       <span class="keyword">match</span> s.expectedType? <span class="keyword">with</span>
 304       | none              <span class="constant">=&gt;</span> pure ()
 305       | some expectedType <span class="constant">=&gt;</span>
 306         <span class="comment-delimiter">/- </span><span class="comment">We don't propagate `Prop` because we often use `Prop` as a more general "Bool" (e.g., `if-then-else`).
 307            If we propagate `expectedType == Prop` in the following examples, the elaborator would fail
 308            ```
 309            def f1 (s : Nat &#215; Bool) : Bool := if s.2 then false else true
 310 
 311            def f2 (s : List Bool) : Bool := if s.head! then false else true
 312 
 313            def f3 (s : List Bool) : Bool := if List.head! (s.map not) then false else true
 314            ```
 315            They would all fail for the same reason. So, let's focus on the first one.
 316            We would elaborate `s.2` with `expectedType == Prop`.
 317            Before we elaborate `s`, this method would be invoked, and `s.fType` is `?&#945; &#215; ?&#946; &#8594; ?&#946;` and after
 318            propagation we would have `?&#945; &#215; Prop &#8594; Prop`. Then, when we would try to elaborate `s`, and
 319            get a type error because `?&#945; &#215; Prop` cannot be unified with `Nat &#215; Bool`
 320            Most users would have a hard time trying to understand why these examples failed.
 321 
 322            Here is a possible alternative workarounds. We give up the idea of using `Prop` at `if-then-else`.
 323            Drawback: users use `if-then-else` with conditions that are not Decidable.
 324            So, users would have to embrace `propDecidable` and `choice`.
 325            This may not be that bad since the developers and users don't seem to care about constructivism.
 326 
 327            We currently use a different workaround, we just don't propagate the expected type when it is `Prop`. -/</span>
 328         <span class="keyword">if</span> expectedType.isProp <span class="keyword">then</span>
 329           modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> propagateExpected <span class="constant">:=</span> false }
 330         <span class="keyword">else</span>
 331           <span class="keyword">let</span> numRemainingArgs <span class="constant">:=</span> s.args.length
 332           trace[Elab.app.propagateExpectedType] <span class="string">"etaArgs.size: {s.etaArgs.size}, numRemainingArgs: {numRemainingArgs}, fType: {s.fType}"</span>
 333           <span class="keyword">match</span> getForallBody s.explicit numRemainingArgs s.namedArgs s.fType <span class="keyword">with</span>
 334           | none           <span class="constant">=&gt;</span> pure ()
 335           | some fTypeBody <span class="constant">=&gt;</span>
 336             <span class="keyword">unless</span> fTypeBody.hasLooseBVars <span class="keyword">do</span>
 337               <span class="keyword">unless</span> (&#8592; hasOptAutoParams fTypeBody) <span class="keyword">do</span>
 338                 trace[Elab.app.propagateExpectedType] <span class="string">"{expectedType} =?= {fTypeBody}"</span>
 339                 <span class="keyword">if</span> (&#8592; isDefEq expectedType fTypeBody) <span class="keyword">then</span>
 340                   <span class="comment-delimiter">/- </span><span class="comment">Note that we only set `propagateExpected := false` when propagation has succeeded. -/</span>
 341                   modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> propagateExpected <span class="constant">:=</span> false }
 342 
<span class="comment-delimiter"> 343 /-</span><span class="comment">
 344   Create a fresh local variable with the current binder name and argument type, add it to `etaArgs` and `f`,
 345   and then execute the continuation `k`.-/</span>
<span class="keyword"> 346 private</span> <span class="keyword">def</span> <span class="function-name">addEtaArg</span> (k : M Expr) : M Expr <span class="constant">:=</span> <span class="keyword">do</span>
 347   <span class="keyword">let</span> n    &#8592; getBindingName
 348   <span class="keyword">let</span> type &#8592; getArgExpectedType
 349   withLocalDeclD n type <span class="keyword">fun</span> x <span class="constant">=&gt;</span> <span class="keyword">do</span>
 350     modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> etaArgs <span class="constant">:=</span> s.etaArgs.push x }
 351     addNewArg x
 352     k
 353 
<span class="comment-delimiter"> 354 /- </span><span class="comment">This method execute after all application arguments have been processed. -/</span>
<span class="keyword"> 355 private</span> <span class="keyword">def</span> <span class="function-name">finalize</span> : M Expr <span class="constant">:=</span> <span class="keyword">do</span>
 356   <span class="keyword">let</span> s &#8592; get
 357   <span class="keyword">let</span> <span class="keyword">mut</span> e <span class="constant">:=</span> s.f
 358   <span class="comment-delimiter">-- </span><span class="comment">all user explicit arguments have been consumed
</span> 359   trace[Elab.app.finalize] e
 360   <span class="keyword">let</span> ref &#8592; getRef
 361   <span class="comment-delimiter">-- </span><span class="comment">Register the error context of implicits
</span> 362   <span class="keyword">for</span> mvarId <span class="keyword">in</span> s.toSetErrorCtx <span class="keyword">do</span>
 363     registerMVarErrorImplicitArgInfo mvarId ref e
 364   <span class="keyword">if</span> <span class="constant">!</span>s.etaArgs.isEmpty <span class="keyword">then</span>
 365     e &#8592; mkLambdaFVars s.etaArgs e
 366   <span class="comment-delimiter">/-</span><span class="comment">
 367     Remark: we should not use `s.fType` as `eType` even when
 368     `s.etaArgs.isEmpty`. Reason: it may have been unfolded.
 369   -/</span>
 370   <span class="keyword">let</span> eType &#8592; inferType e
 371   trace[Elab.app.finalize] <span class="string">"after etaArgs, {e} : {eType}"</span>
 372   <span class="keyword">match</span> s.expectedType? <span class="keyword">with</span>
 373   | none              <span class="constant">=&gt;</span> pure ()
 374   | some expectedType <span class="constant">=&gt;</span>
 375      trace[Elab.app.finalize] <span class="string">"expected type: {expectedType}"</span>
 376      <span class="comment-delimiter">-- </span><span class="comment">Try to propagate expected type. Ignore if types are not definitionally equal, caller must handle it.
</span> 377      discard <span class="constant">&lt;</span>| isDefEq expectedType eType
 378   synthesizeAppInstMVars
 379   pure e
 380 
<span class="keyword"> 381 private</span> <span class="keyword">def</span> <span class="function-name">addImplicitArg</span> (k : M Expr) : M Expr <span class="constant">:=</span> <span class="keyword">do</span>
 382   <span class="keyword">let</span> argType &#8592; getArgExpectedType
 383   <span class="keyword">let</span> arg &#8592; mkFreshExprMVar argType
 384   modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> toSetErrorCtx <span class="constant">:=</span> s.toSetErrorCtx.push arg.mvarId<span class="constant">!</span> }
 385   addNewArg arg
 386   k
 387 
<span class="comment-delimiter"> 388 /- </span><span class="comment">Return true if there is a named argument that depends on the next argument. -/</span>
<span class="keyword"> 389 private</span> <span class="keyword">def</span> <span class="function-name">anyNamedArgDependsOnCurrent</span> : M Bool <span class="constant">:=</span> <span class="keyword">do</span>
 390   <span class="keyword">let</span> s &#8592; get
 391   <span class="keyword">if</span> s.namedArgs.isEmpty <span class="keyword">then</span>
 392     <span class="keyword">return</span> false
 393   <span class="keyword">else</span>
 394     forallTelescopeReducing s.fType <span class="keyword">fun</span> xs <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">do</span>
 395       <span class="keyword">let</span> curr <span class="constant">:=</span> xs[<span class="constant">0</span>]
 396       <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="constant">1</span>:xs.size] <span class="keyword">do</span>
 397         <span class="keyword">let</span> xDecl &#8592; getLocalDecl xs[i].fvarId<span class="constant">!</span>
 398         <span class="keyword">if</span> s.namedArgs.any <span class="keyword">fun</span> arg <span class="constant">=&gt;</span> arg.name <span class="constant">==</span> xDecl.userName <span class="keyword">then</span>
 399           <span class="keyword">if</span> (&#8592; getMCtx).localDeclDependsOn xDecl curr.fvarId<span class="constant">!</span> <span class="keyword">then</span>
 400             <span class="keyword">return</span> true
 401       <span class="keyword">return</span> false
 402 
<span class="comment-delimiter"> 403 /-</span><span class="comment">
 404   Process a `fType` of the form `(x : A) &#8594; B x`.
 405   This method assume `fType` is a function type -/</span>
<span class="keyword"> 406 private</span> <span class="keyword">def</span> <span class="function-name">processExplictArg</span> (k : M Expr) : M Expr <span class="constant">:=</span> <span class="keyword">do</span>
 407   <span class="keyword">let</span> s &#8592; get
 408   <span class="keyword">match</span> s.args <span class="keyword">with</span>
 409   | arg::args <span class="constant">=&gt;</span>
 410     propagateExpectedType arg
 411     modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> args <span class="constant">:=</span> args }
 412     elabAndAddNewArg arg
 413     k
 414   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
 415     <span class="keyword">let</span> argType &#8592; getArgExpectedType
 416     <span class="keyword">match</span> s.explicit, argType.getOptParamDefault?, argType.getAutoParamTactic? <span class="keyword">with</span>
 417     | false, some defVal, <span class="preprocessor">_</span>  <span class="constant">=&gt;</span> addNewArg defVal; k
 418     | false, <span class="preprocessor">_</span>, some (Expr.const tacticDecl <span class="preprocessor">_</span> <span class="preprocessor">_</span>) <span class="constant">=&gt;</span>
 419       <span class="keyword">let</span> env &#8592; getEnv
 420       <span class="keyword">let</span> opts &#8592; getOptions
 421       <span class="keyword">match</span> evalSyntaxConstant env opts tacticDecl <span class="keyword">with</span>
 422       | Except.error err       <span class="constant">=&gt;</span> throwError err
 423       | Except.ok tacticSyntax <span class="constant">=&gt;</span>
 424         <span class="comment-delimiter">-- </span><span class="comment">TODO(Leo): does this work correctly for tactic sequences?
</span> 425         <span class="keyword">let</span> tacticBlock &#8592; `(<span class="keyword">by</span> <span class="constant">$</span>tacticSyntax)
 426         <span class="keyword">let</span> argType     <span class="constant">:=</span> argType.getArg<span class="constant">!</span> <span class="constant">0</span> <span class="comment-delimiter">-- </span><span class="comment">`autoParam type := by tactic` ==&gt; `type`
</span> 427         <span class="keyword">let</span> argNew <span class="constant">:=</span> Arg.stx tacticBlock
 428         propagateExpectedType argNew
 429         elabAndAddNewArg argNew
 430         k
 431     | false, <span class="preprocessor">_</span>, some <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
 432       throwError <span class="string">"invalid autoParam, argument must be a constant"</span>
 433     | <span class="preprocessor">_</span>, <span class="preprocessor">_</span>, <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
 434       <span class="keyword">if</span> <span class="constant">!</span>s.namedArgs.isEmpty <span class="keyword">then</span>
 435         <span class="keyword">if</span> (&#8592; anyNamedArgDependsOnCurrent) <span class="keyword">then</span>
 436           addImplicitArg k
 437         <span class="keyword">else</span>
 438           addEtaArg k
 439       <span class="keyword">else</span> <span class="keyword">if</span> <span class="constant">!</span>s.explicit <span class="keyword">then</span>
 440         <span class="keyword">if</span> (&#8592; fTypeHasOptAutoParams) <span class="keyword">then</span>
 441           addEtaArg k
 442         <span class="keyword">else</span> <span class="keyword">if</span> (&#8592; get).ellipsis <span class="keyword">then</span>
 443           addImplicitArg k
 444         <span class="keyword">else</span>
 445           finalize
 446       <span class="keyword">else</span>
 447         finalize
 448 
<span class="comment-delimiter"> 449 /-</span><span class="comment">
 450   Process a `fType` of the form `{x : A} &#8594; B x`.
 451   This method assume `fType` is a function type -/</span>
<span class="keyword"> 452 private</span> <span class="keyword">def</span> <span class="function-name">processImplicitArg</span> (k : M Expr) : M Expr <span class="constant">:=</span> <span class="keyword">do</span>
 453   <span class="keyword">if</span> (&#8592; get).explicit <span class="keyword">then</span>
 454     processExplictArg k
 455   <span class="keyword">else</span>
 456     addImplicitArg k
 457 
<span class="comment-delimiter"> 458 /- </span><span class="comment">Return true if the next argument at `args` is of the form `_` -/</span>
<span class="keyword"> 459 private</span> <span class="keyword">def</span> <span class="function-name">isNextArgHole</span> : M Bool <span class="constant">:=</span> <span class="keyword">do</span>
 460   <span class="keyword">match</span> (&#8592; get).args <span class="keyword">with</span>
 461   | Arg.stx (Syntax.node ``Lean.Parser.Term.hole <span class="preprocessor">_</span>) :: <span class="preprocessor">_</span> <span class="constant">=&gt;</span> pure true
 462   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> pure false
 463 
<span class="comment-delimiter"> 464 /-</span><span class="comment">
 465   Process a `fType` of the form `[x : A] &#8594; B x`.
 466   This method assume `fType` is a function type -/</span>
<span class="keyword"> 467 private</span> <span class="keyword">def</span> <span class="function-name">processInstImplicitArg</span> (k : M Expr) : M Expr <span class="constant">:=</span> <span class="keyword">do</span>
 468   <span class="keyword">if</span> (&#8592; get).explicit <span class="keyword">then</span>
 469     <span class="keyword">if</span> (&#8592; isNextArgHole) <span class="keyword">then</span>
 470       <span class="comment-delimiter">/- </span><span class="comment">Recall that if '@' has been used, and the argument is '_', then we still use type class resolution -/</span>
 471       <span class="keyword">let</span> arg &#8592; mkFreshExprMVar (&#8592; getArgExpectedType) MetavarKind.synthetic
 472       modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> args <span class="constant">:=</span> s.args.tail<span class="constant">!</span> }
 473       addInstMVar arg.mvarId<span class="constant">!</span>
 474       addNewArg arg
 475       k
 476     <span class="keyword">else</span>
 477       processExplictArg k
 478   <span class="keyword">else</span>
 479     <span class="keyword">let</span> arg &#8592; mkFreshExprMVar (&#8592; getArgExpectedType) MetavarKind.synthetic
 480     addInstMVar arg.mvarId<span class="constant">!</span>
 481     addNewArg arg
 482     k
 483 
<span class="comment-delimiter"> 484 /- </span><span class="comment">Return true if there are regular or named arguments to be processed. -/</span>
<span class="keyword"> 485 private</span> <span class="keyword">def</span> <span class="function-name">hasArgsToProcess</span> : M Bool <span class="constant">:=</span> <span class="keyword">do</span>
 486   <span class="keyword">let</span> s &#8592; get
 487   pure <span class="constant">$</span> <span class="constant">!</span>s.args.isEmpty <span class="constant">||</span> <span class="constant">!</span>s.namedArgs.isEmpty
 488 
<span class="comment-delimiter"> 489 /- </span><span class="comment">Elaborate function application arguments. -/</span>
<span class="keyword"> 490 partial</span> <span class="keyword">def</span> <span class="function-name">main</span> : M Expr <span class="constant">:=</span> <span class="keyword">do</span>
 491   <span class="keyword">let</span> s &#8592; get
 492   <span class="keyword">let</span> fType &#8592; normalizeFunType
 493   <span class="keyword">if</span> fType.isForall <span class="keyword">then</span>
 494     <span class="keyword">let</span> binderName <span class="constant">:=</span> fType.bindingName<span class="constant">!</span>
 495     <span class="keyword">let</span> binfo <span class="constant">:=</span> fType.bindingInfo<span class="constant">!</span>
 496     <span class="keyword">let</span> s &#8592; get
 497     <span class="keyword">match</span> s.namedArgs.find? <span class="keyword">fun</span> (namedArg : NamedArg) <span class="constant">=&gt;</span> namedArg.name <span class="constant">==</span> binderName <span class="keyword">with</span>
 498     | some namedArg <span class="constant">=&gt;</span>
 499       propagateExpectedType namedArg.val
 500       eraseNamedArg binderName
 501       elabAndAddNewArg namedArg.val
 502       main
 503     | none          <span class="constant">=&gt;</span>
 504       <span class="keyword">match</span> binfo <span class="keyword">with</span>
 505       | BinderInfo.implicit     <span class="constant">=&gt;</span> processImplicitArg main
 506       | BinderInfo.instImplicit <span class="constant">=&gt;</span> processInstImplicitArg main
 507       | <span class="preprocessor">_</span>                       <span class="constant">=&gt;</span> processExplictArg main
 508   <span class="keyword">else</span> <span class="keyword">if</span> (&#8592; hasArgsToProcess) <span class="keyword">then</span>
 509     synthesizePendingAndNormalizeFunType
 510     main
 511   <span class="keyword">else</span>
 512     finalize
 513 
<span class="keyword"> 514 end</span> ElabAppArgs
 515 
<span class="keyword"> 516 private</span> <span class="keyword">def</span> <span class="function-name">propagateExpectedTypeFor</span> (f : Expr) : TermElabM Bool <span class="constant">:=</span>
 517   <span class="keyword">match</span> f.getAppFn.constName? <span class="keyword">with</span>
 518   | some declName <span class="constant">=&gt;</span> <span class="keyword">return</span> <span class="constant">!</span>hasElabWithoutExpectedType (&#8592; getEnv) declName
 519   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">return</span> true
 520 
<span class="keyword"> 521 def</span> <span class="function-name">elabAppArgs</span> (f : Expr) (namedArgs : Array NamedArg) (args : Array Arg)
 522     (expectedType? : Option Expr) (explicit ellipsis : Bool) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
 523   <span class="keyword">let</span> fType &#8592; inferType f
 524   <span class="keyword">let</span> fType &#8592; instantiateMVars fType
 525   trace[Elab.app.args] <span class="string">"explicit: {explicit}, {f} : {fType}"</span>
 526   <span class="keyword">unless</span> namedArgs.isEmpty <span class="constant">&amp;&amp;</span> args.isEmpty <span class="keyword">do</span>
 527     tryPostponeIfMVar fType
 528   ElabAppArgs.main.run' {
 529     args <span class="constant">:=</span> args.toList,
 530     expectedType? <span class="constant">:=</span> expectedType?,
 531     explicit <span class="constant">:=</span> explicit,
 532     ellipsis <span class="constant">:=</span> ellipsis,
 533     namedArgs <span class="constant">:=</span> namedArgs.toList,
 534     f <span class="constant">:=</span> f,
 535     fType <span class="constant">:=</span> fType
 536     propagateExpected <span class="constant">:=</span> (&#8592; propagateExpectedTypeFor f)
 537   }
 538 
<span class="comment-delimiter"> 539 /-</span><span class="comment">- Auxiliary inductive datatype that represents the resolution of an `LVal`. -/</span>
<span class="keyword"> 540 inductive</span> <span class="function-name">LValResolution</span> <span class="keyword">where</span>
 541   | projFn   (baseStructName : Name) (structName : Name) (fieldName : Name)
 542   | projIdx  (structName : Name) (idx : Nat)
 543   | const    (baseStructName : Name) (structName : Name) (constName : Name)
 544   | localRec (baseName : Name) (fullName : Name) (fvar : Expr)
 545   | getOp    (fullName : Name) (idx : Syntax)
 546 
<span class="keyword"> 547 private</span> <span class="keyword">def</span> <span class="function-name">throwLValError</span> {&#945;} (e : Expr) (eType : Expr) (msg : MessageData) : TermElabM &#945; <span class="constant">:=</span>
 548   throwError <span class="string">"{msg}{indentExpr e}\nhas type{indentExpr eType}"</span>
 549 
<span class="comment-delimiter"> 550 /-</span><span class="comment">- `findMethod? env S fName`.
 551     1- If `env` contains `S ++ fName`, return `(S, S++fName)`
 552     2- Otherwise if `env` contains private name `prv` for `S ++ fName`, return `(S, prv)`, o
 553     3- Otherwise for each parent structure `S'` of  `S`, we try `findMethod? env S' fname` -/</span>
<span class="keyword"> 554 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">findMethod?</span> (env : Environment) (structName fieldName : Name) : Option (Name <span class="constant">&#215;</span> Name) <span class="constant">:=</span>
 555   <span class="keyword">let</span> fullName <span class="constant">:=</span> structName <span class="constant">++</span> fieldName
 556   <span class="keyword">match</span> env.find? fullName <span class="keyword">with</span>
 557   | some <span class="preprocessor">_</span> <span class="constant">=&gt;</span> some (structName, fullName)
 558   | none   <span class="constant">=&gt;</span>
 559     <span class="keyword">let</span> fullNamePrv <span class="constant">:=</span> mkPrivateName env fullName
 560     <span class="keyword">match</span> env.find? fullNamePrv <span class="keyword">with</span>
 561     | some <span class="preprocessor">_</span> <span class="constant">=&gt;</span> some (structName, fullNamePrv)
 562     | none   <span class="constant">=&gt;</span>
 563       <span class="keyword">if</span> isStructureLike env structName <span class="keyword">then</span>
 564         (getParentStructures env structName).findSome? <span class="keyword">fun</span> parentStructName <span class="constant">=&gt;</span> findMethod? env parentStructName fieldName
 565       <span class="keyword">else</span>
 566         none
 567 
<span class="keyword"> 568 private</span> <span class="keyword">def</span> <span class="function-name">resolveLValAux</span> (e : Expr) (eType : Expr) (lval : LVal) : TermElabM LValResolution <span class="constant">:=</span> <span class="keyword">do</span>
 569   <span class="keyword">match</span> eType.getAppFn.constName?, lval <span class="keyword">with</span>
 570   | some structName, LVal.fieldIdx <span class="preprocessor">_</span> idx <span class="constant">=&gt;</span>
 571     <span class="keyword">if</span> idx <span class="constant">==</span> <span class="constant">0</span> <span class="keyword">then</span>
 572       throwError <span class="string">"invalid projection, index must be greater than 0"</span>
 573     <span class="keyword">let</span> env &#8592; getEnv
 574     <span class="keyword">unless</span> isStructureLike env structName <span class="keyword">do</span>
 575       throwLValError e eType <span class="string">"invalid projection, structure expected"</span>
 576     <span class="keyword">let</span> fieldNames <span class="constant">:=</span> getStructureFields env structName
 577     <span class="keyword">if</span> h : idx <span class="constant">-</span> <span class="constant">1</span> <span class="constant">&lt;</span> fieldNames.size <span class="keyword">then</span>
 578       <span class="keyword">if</span> isStructure env structName <span class="keyword">then</span>
 579         <span class="keyword">return</span> LValResolution.projFn structName structName (fieldNames.get &#10216;idx <span class="constant">-</span> <span class="constant">1</span>, h&#10217;)
 580       <span class="keyword">else</span>
 581         <span class="comment-delimiter">/- </span><span class="comment">`structName` was declared using `inductive` command.
 582            So, we don't projection functions for it. Thus, we use `Expr.proj` -/</span>
 583         <span class="keyword">return</span> LValResolution.projIdx structName (idx <span class="constant">-</span> <span class="constant">1</span>)
 584     <span class="keyword">else</span>
 585       throwLValError e eType m<span class="constant">!</span><span class="string">"invalid projection, structure has only {fieldNames.size} field(s)"</span>
 586   | some structName, LVal.fieldName <span class="preprocessor">_</span> fieldName <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
 587     <span class="keyword">let</span> env &#8592; getEnv
 588     <span class="keyword">let</span> searchEnv : Unit <span class="constant">&#8594;</span> TermElabM LValResolution <span class="constant">:=</span> <span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">do</span>
 589       <span class="keyword">match</span> findMethod? env structName (Name.mkSimple fieldName) <span class="keyword">with</span>
 590       | some (baseStructName, fullName) <span class="constant">=&gt;</span> pure <span class="constant">$</span> LValResolution.const baseStructName structName fullName
 591       | none   <span class="constant">=&gt;</span>
 592         throwLValError e eType
 593           m<span class="constant">!</span><span class="string">"invalid field '{fieldName}', the environment does not contain '{Name.mkStr structName fieldName}'"</span>
 594     <span class="comment-delimiter">-- </span><span class="comment">search local context first, then environment
</span> 595     <span class="keyword">let</span> searchCtx : Unit <span class="constant">&#8594;</span> TermElabM LValResolution <span class="constant">:=</span> <span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">do</span>
 596       <span class="keyword">let</span> fullName <span class="constant">:=</span> Name.mkStr structName fieldName
 597       <span class="keyword">let</span> currNamespace &#8592; getCurrNamespace
 598       <span class="keyword">let</span> localName <span class="constant">:=</span> fullName.replacePrefix currNamespace Name.anonymous
 599       <span class="keyword">let</span> lctx &#8592; getLCtx
 600       <span class="keyword">match</span> lctx.findFromUserName? localName <span class="keyword">with</span>
 601       | some localDecl <span class="constant">=&gt;</span>
 602         <span class="keyword">if</span> localDecl.binderInfo <span class="constant">==</span> BinderInfo.auxDecl <span class="keyword">then</span>
 603           <span class="comment-delimiter">/- </span><span class="comment">LVal notation is being used to make a "local" recursive call. -/</span>
 604           pure <span class="constant">$</span> LValResolution.localRec structName fullName localDecl.toExpr
 605         <span class="keyword">else</span>
 606           searchEnv ()
 607       | none <span class="constant">=&gt;</span> searchEnv ()
 608     <span class="keyword">if</span> isStructure env structName <span class="keyword">then</span>
 609       <span class="keyword">match</span> findField? env structName (Name.mkSimple fieldName) <span class="keyword">with</span>
 610       | some baseStructName <span class="constant">=&gt;</span> pure <span class="constant">$</span> LValResolution.projFn baseStructName structName (Name.mkSimple fieldName)
 611       | none                <span class="constant">=&gt;</span> searchCtx ()
 612     <span class="keyword">else</span>
 613       searchCtx ()
 614   | some structName, LVal.getOp <span class="preprocessor">_</span> idx <span class="constant">=&gt;</span>
 615     <span class="keyword">let</span> env &#8592; getEnv
 616     <span class="keyword">let</span> fullName <span class="constant">:=</span> Name.mkStr structName <span class="string">"getOp"</span>
 617     <span class="keyword">match</span> env.find? fullName <span class="keyword">with</span>
 618     | some <span class="preprocessor">_</span> <span class="constant">=&gt;</span> pure <span class="constant">$</span> LValResolution.getOp fullName idx
 619     | none   <span class="constant">=&gt;</span> throwLValError e eType m<span class="constant">!</span><span class="string">"invalid [..] notation because environment does not contain '{fullName}'"</span>
 620   | none, LVal.fieldName <span class="preprocessor">_</span> <span class="preprocessor">_</span> (some suffix) <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
 621     <span class="keyword">if</span> e.isConst <span class="keyword">then</span>
 622       throwUnknownConstant (e.constName<span class="constant">!</span> <span class="constant">++</span> suffix)
 623     <span class="keyword">else</span>
 624       throwLValError e eType <span class="string">"invalid field notation, type is not of the form (C ...) where C is a constant"</span>
 625   | <span class="preprocessor">_</span>, LVal.getOp <span class="preprocessor">_</span> idx <span class="constant">=&gt;</span>
 626     throwLValError e eType <span class="string">"invalid [..] notation, type is not of the form (C ...) where C is a constant"</span>
 627   | <span class="preprocessor">_</span>, <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
 628     throwLValError e eType <span class="string">"invalid field notation, type is not of the form (C ...) where C is a constant"</span>
 629 
<span class="comment-delimiter"> 630 /- </span><span class="comment">whnfCore + implicit consumption.
 631    Example: given `e` with `eType := {&#945; : Type} &#8594; (fun &#946; =&gt; List &#946;) &#945; `, it produces `(e ?m, List ?m)` where `?m` is fresh metavariable. -/</span>
<span class="keyword"> 632 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">consumeImplicits</span> (stx : Syntax) (e eType : Expr) : TermElabM (Expr <span class="constant">&#215;</span> Expr) <span class="constant">:=</span> <span class="keyword">do</span>
 633   <span class="keyword">let</span> eType &#8592; whnfCore eType
 634   <span class="keyword">match</span> eType <span class="keyword">with</span>
 635   | Expr.forallE n d b c <span class="constant">=&gt;</span>
 636     <span class="keyword">if</span> c.binderInfo.isImplicit <span class="keyword">then</span>
 637       <span class="keyword">let</span> mvar &#8592; mkFreshExprMVar d
 638       registerMVarErrorHoleInfo mvar.mvarId<span class="constant">!</span> stx
 639       consumeImplicits stx (mkApp e mvar) (b.instantiate1 mvar)
 640     <span class="keyword">else</span> <span class="keyword">if</span> c.binderInfo.isInstImplicit <span class="keyword">then</span>
 641       <span class="keyword">let</span> mvar &#8592; mkInstMVar d
 642       consumeImplicits stx (mkApp e mvar) (b.instantiate1 mvar)
 643     <span class="keyword">else</span> <span class="keyword">match</span> d.getOptParamDefault? <span class="keyword">with</span>
 644       | some defVal <span class="constant">=&gt;</span> consumeImplicits stx (mkApp e defVal) (b.instantiate1 defVal)
 645       <span class="comment-delimiter">-- </span><span class="comment">TODO: we do not handle autoParams here.
</span> 646       | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> pure (e, eType)
 647   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> pure (e, eType)
 648 
<span class="keyword"> 649 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">resolveLValLoop</span> (lval : LVal) (e eType : Expr) (previousExceptions : Array Exception) : TermElabM (Expr <span class="constant">&#215;</span> LValResolution) <span class="constant">:=</span> <span class="keyword">do</span>
 650   <span class="keyword">let</span> (e, eType) &#8592; consumeImplicits lval.getRef e eType
 651   tryPostponeIfMVar eType
 652   <span class="keyword">try</span>
 653     <span class="keyword">let</span> lvalRes &#8592; resolveLValAux e eType lval
 654     pure (e, lvalRes)
 655   <span class="keyword">catch</span>
 656     | ex<span class="constant">@</span>(Exception.error <span class="preprocessor">_</span> <span class="preprocessor">_</span>) <span class="constant">=&gt;</span>
 657       <span class="keyword">let</span> eType? &#8592; unfoldDefinition? eType
 658       <span class="keyword">match</span> eType? <span class="keyword">with</span>
 659       | some eType <span class="constant">=&gt;</span> resolveLValLoop lval e eType (previousExceptions.push ex)
 660       | none       <span class="constant">=&gt;</span>
 661         previousExceptions.forM <span class="keyword">fun</span> ex <span class="constant">=&gt;</span> logException ex
 662         throw ex
 663     | ex<span class="constant">@</span>(Exception.internal <span class="preprocessor">_</span> <span class="preprocessor">_</span>) <span class="constant">=&gt;</span> throw ex
 664 
<span class="keyword"> 665 private</span> <span class="keyword">def</span> <span class="function-name">resolveLVal</span> (e : Expr) (lval : LVal) : TermElabM (Expr <span class="constant">&#215;</span> LValResolution) <span class="constant">:=</span> <span class="keyword">do</span>
 666   <span class="keyword">let</span> eType &#8592; inferType e
 667   resolveLValLoop lval e eType <span class="constant">#</span>[]
 668 
<span class="keyword"> 669 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">mkBaseProjections</span> (baseStructName : Name) (structName : Name) (e : Expr) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
 670   <span class="keyword">let</span> env &#8592; getEnv
 671   <span class="keyword">match</span> getPathToBaseStructure? env baseStructName structName <span class="keyword">with</span>
 672   | none <span class="constant">=&gt;</span> throwError <span class="string">"failed to access field in parent structure"</span>
 673   | some path <span class="constant">=&gt;</span>
 674     <span class="keyword">let</span> <span class="keyword">mut</span> e <span class="constant">:=</span> e
 675     <span class="keyword">for</span> projFunName <span class="keyword">in</span> path <span class="keyword">do</span>
 676       <span class="keyword">let</span> projFn &#8592; mkConst projFunName
 677       e &#8592; elabAppArgs projFn <span class="constant">#</span>[{ name <span class="constant">:=</span> `self, val <span class="constant">:=</span> Arg.expr e }] (args <span class="constant">:=</span> <span class="constant">#</span>[]) (expectedType? <span class="constant">:=</span> none) (explicit <span class="constant">:=</span> false) (ellipsis <span class="constant">:=</span> false)
 678     <span class="keyword">return</span> e
 679 
<span class="comment-delimiter"> 680 /- </span><span class="comment">Auxiliary method for field notation. It tries to add `e` as a new argument to `args` or `namedArgs`.
 681    This method first finds the parameter with a type of the form `(baseName ...)`.
 682    When the parameter is found, if it an explicit one and `args` is big enough, we add `e` to `args`.
 683    Otherwise, if there isn't another parameter with the same name, we add `e` to `namedArgs`.
 684 
 685    Remark: `fullName` is the name of the resolved "field" access function. It is used for reporting errors -/</span>
<span class="keyword"> 686 private</span> <span class="keyword">def</span> <span class="function-name">addLValArg</span> (baseName : Name) (fullName : Name) (e : Expr) (args : Array Arg) (namedArgs : Array NamedArg) (fType : Expr)
 687     : TermElabM (Array Arg <span class="constant">&#215;</span> Array NamedArg) <span class="constant">:=</span>
 688   forallTelescopeReducing fType <span class="keyword">fun</span> xs <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">do</span>
 689     <span class="keyword">let</span> <span class="keyword">mut</span> argIdx <span class="constant">:=</span> <span class="constant">0</span> <span class="comment-delimiter">-- </span><span class="comment">position of the next explicit argument
</span> 690     <span class="keyword">let</span> <span class="keyword">mut</span> remainingNamedArgs <span class="constant">:=</span> namedArgs
 691     <span class="keyword">for</span> i <span class="keyword">in</span> [:xs.size] <span class="keyword">do</span>
 692       <span class="keyword">let</span> x <span class="constant">:=</span> xs[i]
 693       <span class="keyword">let</span> xDecl &#8592; getLocalDecl x.fvarId<span class="constant">!</span>
 694       <span class="comment-delimiter">/- </span><span class="comment">If there is named argument with name `xDecl.userName`, then we skip it. -/</span>
 695       <span class="keyword">match</span> remainingNamedArgs.findIdx? (<span class="keyword">fun</span> namedArg <span class="constant">=&gt;</span> namedArg.name <span class="constant">==</span> xDecl.userName) <span class="keyword">with</span>
 696       | some idx <span class="constant">=&gt;</span>
 697         remainingNamedArgs <span class="constant">:=</span> remainingNamedArgs.eraseIdx idx
 698       | none <span class="constant">=&gt;</span>
 699         <span class="keyword">let</span> <span class="keyword">mut</span> foundIt <span class="constant">:=</span> false
 700         <span class="keyword">let</span> type <span class="constant">:=</span> xDecl.type
 701         <span class="keyword">if</span> type.consumeMData.isAppOf baseName <span class="keyword">then</span>
 702           foundIt <span class="constant">:=</span> true
 703         <span class="keyword">if</span> <span class="constant">!</span>foundIt <span class="keyword">then</span>
 704           <span class="comment-delimiter">/- </span><span class="comment">Normalize type and try again -/</span>
 705           <span class="keyword">let</span> type &#8592; withReducible <span class="constant">$</span> whnf type
 706           <span class="keyword">if</span> type.consumeMData.isAppOf baseName <span class="keyword">then</span>
 707             foundIt <span class="constant">:=</span> true
 708         <span class="keyword">if</span> foundIt <span class="keyword">then</span>
 709           <span class="comment-delimiter">/- </span><span class="comment">We found a type of the form (baseName ...).
 710              First, we check if the current argument is an explicit one,
 711              and the current explicit position "fits" at `args` (i.e., it must be &#8804; arg.size) -/</span>
 712           <span class="keyword">if</span> argIdx <span class="constant">&#8804;</span> args.size <span class="constant">&amp;&amp;</span> xDecl.binderInfo.isExplicit <span class="keyword">then</span>
 713             <span class="comment-delimiter">/- </span><span class="comment">We insert `e` as an explicit argument -/</span>
 714             <span class="keyword">return</span> (args.insertAt argIdx (Arg.expr e), namedArgs)
 715           <span class="comment-delimiter">/- </span><span class="comment">If we can't add `e` to `args`, we try to add it using a named argument, but this is only possible
 716              if there isn't an argument with the same name occurring before it. -/</span>
 717           <span class="keyword">for</span> j <span class="keyword">in</span> [:i] <span class="keyword">do</span>
 718             <span class="keyword">let</span> prev <span class="constant">:=</span> xs[j]
 719             <span class="keyword">let</span> prevDecl &#8592; getLocalDecl prev.fvarId<span class="constant">!</span>
 720             <span class="keyword">if</span> prevDecl.userName <span class="constant">==</span> xDecl.userName <span class="keyword">then</span>
 721               throwError <span class="string">"invalid field notation, function '{fullName}' has argument with the expected type{indentExpr type}\nbut it cannot be used"</span>
 722           <span class="keyword">return</span> (args, namedArgs.push { name <span class="constant">:=</span> xDecl.userName, val <span class="constant">:=</span> Arg.expr e })
 723         <span class="keyword">if</span> xDecl.binderInfo.isExplicit <span class="keyword">then</span>
 724           <span class="comment-delimiter">-- </span><span class="comment">advance explicit argument position
</span> 725           argIdx <span class="constant">:=</span> argIdx <span class="constant">+</span> <span class="constant">1</span>
 726     throwError <span class="string">"invalid field notation, function '{fullName}' does not have argument with type ({baseName} ...) that can be used, it must be explicit or implicit with an unique name"</span>
 727 
<span class="keyword"> 728 private</span> <span class="keyword">def</span> <span class="function-name">elabAppLValsAux</span> (namedArgs : Array NamedArg) (args : Array Arg) (expectedType? : Option Expr) (explicit ellipsis : Bool)
 729     (f : Expr) (lvals : List LVal) : TermElabM Expr <span class="constant">:=</span>
 730   <span class="keyword">let</span> <span class="keyword">rec</span> loop : Expr <span class="constant">&#8594;</span> List LVal <span class="constant">&#8594;</span> TermElabM Expr
 731   | f, []          <span class="constant">=&gt;</span> elabAppArgs f namedArgs args expectedType? explicit ellipsis
 732   | f, lval::lvals <span class="constant">=&gt;</span> <span class="keyword">do</span>
 733     <span class="keyword">if</span> <span class="keyword">let</span> LVal.fieldName (ref <span class="constant">:=</span> fieldStx) (targetStx <span class="constant">:=</span> targetStx) .. <span class="constant">:=</span> lval <span class="keyword">then</span>
 734       addDotCompletionInfo  targetStx f expectedType? fieldStx
 735     <span class="keyword">let</span> (f, lvalRes) &#8592; resolveLVal f lval
 736     <span class="keyword">match</span> lvalRes <span class="keyword">with</span>
 737     | LValResolution.projIdx structName idx <span class="constant">=&gt;</span>
 738       <span class="keyword">let</span> f <span class="constant">:=</span> mkProj structName idx f
 739       addTermInfo lval.getRef f
 740       loop f lvals
 741     | LValResolution.projFn baseStructName structName fieldName <span class="constant">=&gt;</span>
 742       <span class="keyword">let</span> f &#8592; mkBaseProjections baseStructName structName f
 743       <span class="keyword">let</span> projFn &#8592; mkConst (baseStructName <span class="constant">++</span> fieldName)
 744       addTermInfo lval.getRef projFn
 745       <span class="keyword">if</span> lvals.isEmpty <span class="keyword">then</span>
 746         <span class="keyword">let</span> namedArgs &#8592; addNamedArg namedArgs { name <span class="constant">:=</span> `self, val <span class="constant">:=</span> Arg.expr f }
 747         elabAppArgs projFn namedArgs args expectedType? explicit ellipsis
 748       <span class="keyword">else</span>
 749         <span class="keyword">let</span> f &#8592; elabAppArgs projFn <span class="constant">#</span>[{ name <span class="constant">:=</span> `self, val <span class="constant">:=</span> Arg.expr f }] <span class="constant">#</span>[] (expectedType? <span class="constant">:=</span> none) (explicit <span class="constant">:=</span> false) (ellipsis <span class="constant">:=</span> false)
 750         loop f lvals
 751     | LValResolution.const baseStructName structName constName <span class="constant">=&gt;</span>
 752       <span class="keyword">let</span> f &#8592; <span class="keyword">if</span> baseStructName <span class="constant">!=</span> structName <span class="keyword">then</span> mkBaseProjections baseStructName structName f <span class="keyword">else</span> pure f
 753       <span class="keyword">let</span> projFn &#8592; mkConst constName
 754       addTermInfo lval.getRef projFn
 755       <span class="keyword">if</span> lvals.isEmpty <span class="keyword">then</span>
 756         <span class="keyword">let</span> projFnType &#8592; inferType projFn
 757         <span class="keyword">let</span> (args, namedArgs) &#8592; addLValArg baseStructName constName f args namedArgs projFnType
 758         elabAppArgs projFn namedArgs args expectedType? explicit ellipsis
 759       <span class="keyword">else</span>
 760         <span class="keyword">let</span> f &#8592; elabAppArgs projFn <span class="constant">#</span>[] <span class="constant">#</span>[Arg.expr f] (expectedType? <span class="constant">:=</span> none) (explicit <span class="constant">:=</span> false) (ellipsis <span class="constant">:=</span> false)
 761         loop f lvals
 762     | LValResolution.localRec baseName fullName fvar <span class="constant">=&gt;</span>
 763       addTermInfo lval.getRef fvar
 764       <span class="keyword">if</span> lvals.isEmpty <span class="keyword">then</span>
 765         <span class="keyword">let</span> fvarType &#8592; inferType fvar
 766         <span class="keyword">let</span> (args, namedArgs) &#8592; addLValArg baseName fullName f args namedArgs fvarType
 767         elabAppArgs fvar namedArgs args expectedType? explicit ellipsis
 768       <span class="keyword">else</span>
 769         <span class="keyword">let</span> f &#8592; elabAppArgs fvar <span class="constant">#</span>[] <span class="constant">#</span>[Arg.expr f] (expectedType? <span class="constant">:=</span> none) (explicit <span class="constant">:=</span> false) (ellipsis <span class="constant">:=</span> false)
 770         loop f lvals
 771     | LValResolution.getOp fullName idx <span class="constant">=&gt;</span>
 772       <span class="keyword">let</span> getOpFn &#8592; mkConst fullName
 773       addTermInfo lval.getRef getOpFn
 774       <span class="keyword">if</span> lvals.isEmpty <span class="keyword">then</span>
 775         <span class="keyword">let</span> namedArgs &#8592; addNamedArg namedArgs { name <span class="constant">:=</span> `self, val <span class="constant">:=</span> Arg.expr f }
 776         <span class="keyword">let</span> namedArgs &#8592; addNamedArg namedArgs { name <span class="constant">:=</span> `idx,  val <span class="constant">:=</span> Arg.stx idx }
 777         elabAppArgs getOpFn namedArgs args expectedType? explicit ellipsis
 778       <span class="keyword">else</span>
 779         <span class="keyword">let</span> f &#8592; elabAppArgs getOpFn <span class="constant">#</span>[{ name <span class="constant">:=</span> `self, val <span class="constant">:=</span> Arg.expr f }, { name <span class="constant">:=</span> `idx, val <span class="constant">:=</span> Arg.stx idx }]
 780                             <span class="constant">#</span>[] (expectedType? <span class="constant">:=</span> none) (explicit <span class="constant">:=</span> false) (ellipsis <span class="constant">:=</span> false)
 781         loop f lvals
 782   loop f lvals
 783 
<span class="keyword"> 784 private</span> <span class="keyword">def</span> <span class="function-name">elabAppLVals</span> (f : Expr) (lvals : List LVal) (namedArgs : Array NamedArg) (args : Array Arg)
 785     (expectedType? : Option Expr) (explicit ellipsis : Bool) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
 786   <span class="keyword">if</span> <span class="constant">!</span>lvals.isEmpty <span class="constant">&amp;&amp;</span> explicit <span class="keyword">then</span>
 787     throwError <span class="string">"invalid use of field notation with `@` modifier"</span>
 788   elabAppLValsAux namedArgs args expectedType? explicit ellipsis f lvals
 789 
<span class="keyword"> 790 def</span> <span class="function-name">elabExplicitUnivs</span> (lvls : Array Syntax) : TermElabM (List Level) <span class="constant">:=</span> <span class="keyword">do</span>
 791   lvls.foldrM (<span class="keyword">fun</span> stx lvls <span class="constant">=&gt;</span> <span class="keyword">do</span> pure ((&#8592; elabLevel stx)::lvls)) []
 792 
<span class="comment-delimiter"> 793 /-</span><span class="comment">
 794 Interaction between `errToSorry` and `observing`.
 795 
 796 - The method `elabTerm` catches exceptions, log them, and returns a synthetic sorry (IF `ctx.errToSorry` == true).
 797 
 798 - When we elaborate choice nodes (and overloaded identifiers), we track multiple results using the `observing x` combinator.
 799   The `observing x` executes `x` and returns a `TermElabResult`.
 800 
 801 `observing `x does not check for synthetic sorry's, just an exception. Thus, it may think `x` worked when it didn't
 802 if a synthetic sorry was introduced. We decided that checking for synthetic sorrys at `observing` is not a good solution
 803 because it would not be clear to decide what the "main" error message for the alternative is. When the result contains
 804 a synthetic `sorry`, it is not clear which error message corresponds to the `sorry`. Moreover, while executing `x`, many
 805 error messages may have been logged. Recall that we need an error per alternative at `mergeFailures`.
 806 
 807 Thus, we decided to set `errToSorry` to `false` whenever processing choice nodes and overloaded symbols.
 808 
 809 Important: we rely on the property that after `errToSorry` is set to
 810 false, no elaboration function executed by `x` will reset it to
 811 `true`.
 812 -/</span>
 813 
<span class="keyword"> 814 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">elabAppFnId</span> (fIdent : Syntax) (fExplicitUnivs : List Level) (lvals : List LVal)
 815     (namedArgs : Array NamedArg) (args : Array Arg) (expectedType? : Option Expr) (explicit ellipsis overloaded : Bool) (acc : Array (TermElabResult Expr))
 816     : TermElabM (Array (TermElabResult Expr)) <span class="constant">:=</span> <span class="keyword">do</span>
 817   <span class="keyword">let</span> funLVals &#8592; withRef fIdent <span class="constant">&lt;</span>| resolveName' fIdent fExplicitUnivs expectedType?
 818   <span class="keyword">let</span> overloaded <span class="constant">:=</span> overloaded <span class="constant">||</span> funLVals.length <span class="constant">&gt;</span> <span class="constant">1</span>
 819   <span class="comment-delimiter">-- </span><span class="comment">Set `errToSorry` to `false` if `funLVals` &gt; 1. See comment above about the interaction between `errToSorry` and `observing`.
</span> 820   withReader (<span class="keyword">fun</span> ctx <span class="constant">=&gt;</span> { ctx <span class="keyword">with</span> errToSorry <span class="constant">:=</span> funLVals.length <span class="constant">==</span> <span class="constant">1</span> <span class="constant">&amp;&amp;</span> ctx.errToSorry }) <span class="keyword">do</span>
 821     funLVals.foldlM (init <span class="constant">:=</span> acc) <span class="keyword">fun</span> acc (f, fIdent, fields) <span class="constant">=&gt;</span> <span class="keyword">do</span>
 822       addTermInfo fIdent f
 823       <span class="keyword">let</span> lvals' <span class="constant">:=</span> toLVals fields (first <span class="constant">:=</span> true)
 824       <span class="keyword">let</span> s &#8592; observing <span class="keyword">do</span>
 825         <span class="keyword">let</span> e &#8592; elabAppLVals f (lvals' <span class="constant">++</span> lvals) namedArgs args expectedType? explicit ellipsis
 826         <span class="keyword">if</span> overloaded <span class="keyword">then</span> ensureHasType expectedType? e <span class="keyword">else</span> pure e
 827       <span class="keyword">return</span> acc.push s
<span class="keyword"> 828 where</span>
 829   toName : List Syntax <span class="constant">&#8594;</span> Name
 830     | []              <span class="constant">=&gt;</span> Name.anonymous
 831     | field :: fields <span class="constant">=&gt;</span> Name.mkStr (toName fields) field.getId.toString
 832 
 833   toLVals : List Syntax <span class="constant">&#8594;</span> (first : Bool) <span class="constant">&#8594;</span> List LVal
 834     | [],            <span class="preprocessor">_</span>     <span class="constant">=&gt;</span> []
 835     | field::fields, true  <span class="constant">=&gt;</span> LVal.fieldName field field.getId.toString (toName (field::fields)) fIdent :: toLVals fields false
 836     | field::fields, false <span class="constant">=&gt;</span> LVal.fieldName field field.getId.toString none fIdent :: toLVals fields false
 837 
<span class="keyword"> 838 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">elabAppFn</span> (f : Syntax) (lvals : List LVal) (namedArgs : Array NamedArg) (args : Array Arg)
 839     (expectedType? : Option Expr) (explicit ellipsis overloaded : Bool) (acc : Array (TermElabResult Expr)) : TermElabM (Array (TermElabResult Expr)) <span class="constant">:=</span>
 840   <span class="keyword">if</span> f.getKind <span class="constant">==</span> choiceKind <span class="keyword">then</span>
 841     <span class="comment-delimiter">-- </span><span class="comment">Set `errToSorry` to `false` when processing choice nodes. See comment above about the interaction between `errToSorry` and `observing`.
</span> 842     withReader (<span class="keyword">fun</span> ctx <span class="constant">=&gt;</span> { ctx <span class="keyword">with</span> errToSorry <span class="constant">:=</span> false }) <span class="keyword">do</span>
 843       f.getArgs.foldlM (<span class="keyword">fun</span> acc f <span class="constant">=&gt;</span> elabAppFn f lvals namedArgs args expectedType? explicit ellipsis true acc) acc
 844   <span class="keyword">else</span>
 845     <span class="keyword">let</span> elabFieldName (e field : Syntax) <span class="constant">:=</span> <span class="keyword">do</span>
 846       <span class="keyword">let</span> newLVals <span class="constant">:=</span> field.getId.eraseMacroScopes.components.map <span class="keyword">fun</span> n <span class="constant">=&gt;</span>
 847         <span class="comment-delimiter">-- </span><span class="comment">We use `none` here since `field` can't be part of a composite name
</span> 848         LVal.fieldName field (toString n) none e
 849       elabAppFn e (newLVals <span class="constant">++</span> lvals) namedArgs args expectedType? explicit ellipsis overloaded acc
 850     <span class="keyword">let</span> elabFieldIdx (e idxStx : Syntax) <span class="constant">:=</span> <span class="keyword">do</span>
 851       <span class="keyword">let</span> idx <span class="constant">:=</span> idxStx.isFieldIdx?.get<span class="constant">!</span>
 852       elabAppFn e (LVal.fieldIdx idxStx idx :: lvals) namedArgs args expectedType? explicit ellipsis overloaded acc
 853     <span class="keyword">match</span> f <span class="keyword">with</span>
 854     | `(<span class="constant">$</span>(e).<span class="constant">$</span>idx:fieldIdx) <span class="constant">=&gt;</span> elabFieldIdx e idx
 855     | `(<span class="constant">$</span>e |<span class="constant">&gt;</span>.<span class="constant">$</span>idx:fieldIdx) <span class="constant">=&gt;</span> elabFieldIdx e idx
 856     | `(<span class="constant">$</span>(e).<span class="constant">$</span>field:ident) <span class="constant">=&gt;</span> elabFieldName e field
 857     | `(<span class="constant">$</span>e |<span class="constant">&gt;</span>.<span class="constant">$</span>field:ident) <span class="constant">=&gt;</span> elabFieldName e field
 858     | `(<span class="constant">$</span>e[%<span class="constant">$</span>bracket <span class="constant">$</span>idx]) <span class="constant">=&gt;</span> elabAppFn e (LVal.getOp bracket idx :: lvals) namedArgs args expectedType? explicit ellipsis overloaded acc
 859     | `(<span class="constant">$</span>id:ident<span class="constant">@$</span>t:term) <span class="constant">=&gt;</span>
 860       throwError <span class="string">"unexpected occurrence of named pattern"</span>
 861     | `(<span class="constant">$</span>id:ident) <span class="constant">=&gt;</span> <span class="keyword">do</span>
 862       elabAppFnId id [] lvals namedArgs args expectedType? explicit ellipsis overloaded acc
 863     | `(<span class="constant">$</span>id:ident.{<span class="constant">$</span>us,<span class="constant">*</span>}) <span class="constant">=&gt;</span> <span class="keyword">do</span>
 864       <span class="keyword">let</span> us &#8592; elabExplicitUnivs us
 865       elabAppFnId id us lvals namedArgs args expectedType? explicit ellipsis overloaded acc
 866     | `(<span class="constant">@$</span>id:ident) <span class="constant">=&gt;</span>
 867       elabAppFn id lvals namedArgs args expectedType? (explicit <span class="constant">:=</span> true) ellipsis overloaded acc
 868     | `(<span class="constant">@$</span>id:ident.{<span class="constant">$</span>us,<span class="constant">*</span>}) <span class="constant">=&gt;</span>
 869       elabAppFn (f.getArg <span class="constant">1</span>) lvals namedArgs args expectedType? (explicit <span class="constant">:=</span> true) ellipsis overloaded acc
 870     | `(<span class="constant">@$</span>t)     <span class="constant">=&gt;</span> throwUnsupportedSyntax <span class="comment-delimiter">-- </span><span class="comment">invalid occurrence of `@`
</span> 871     | `(<span class="preprocessor">_</span>)       <span class="constant">=&gt;</span> throwError <span class="string">"placeholders '_' cannot be used where a function is expected"</span>
 872     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">do</span>
 873       <span class="keyword">let</span> catchPostpone <span class="constant">:=</span> <span class="constant">!</span>overloaded
 874       <span class="comment-delimiter">/- </span><span class="comment">If we are processing a choice node, then we should use `catchPostpone == false` when elaborating terms.
 875         Recall that `observing` does not catch `postponeExceptionId`. -/</span>
 876       <span class="keyword">if</span> lvals.isEmpty <span class="constant">&amp;&amp;</span> namedArgs.isEmpty <span class="constant">&amp;&amp;</span> args.isEmpty <span class="keyword">then</span>
 877         <span class="comment-delimiter">/- </span><span class="comment">Recall that elabAppFn is used for elaborating atomics terms **and** choice nodes that may contain
 878           arbitrary terms. If they are not being used as a function, we should elaborate using the expectedType. -/</span>
 879         <span class="keyword">let</span> s &#8592;
 880           <span class="keyword">if</span> overloaded <span class="keyword">then</span>
 881             observing <span class="constant">&lt;</span>| elabTermEnsuringType f expectedType? catchPostpone
 882           <span class="keyword">else</span>
 883             observing <span class="constant">&lt;</span>| elabTerm f expectedType?
 884         <span class="keyword">return</span> acc.push s
 885       <span class="keyword">else</span>
 886         <span class="keyword">let</span> s &#8592; observing <span class="keyword">do</span>
 887           <span class="keyword">let</span> f &#8592; elabTerm f none catchPostpone
 888           <span class="keyword">let</span> e &#8592; elabAppLVals f lvals namedArgs args expectedType? explicit ellipsis
 889           <span class="keyword">if</span> overloaded <span class="keyword">then</span> ensureHasType expectedType? e <span class="keyword">else</span> pure e
 890         <span class="keyword">return</span> acc.push s
 891 
<span class="keyword"> 892 private</span> <span class="keyword">def</span> <span class="function-name">isSuccess</span> (candidate : TermElabResult Expr) : Bool <span class="constant">:=</span>
 893   <span class="keyword">match</span> candidate <span class="keyword">with</span>
 894   | EStateM.Result.ok <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> true
 895   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> false
 896 
<span class="keyword"> 897 private</span> <span class="keyword">def</span> <span class="function-name">getSuccess</span> (candidates : Array (TermElabResult Expr)) : Array (TermElabResult Expr) <span class="constant">:=</span>
 898   candidates.filter isSuccess
 899 
<span class="keyword"> 900 private</span> <span class="keyword">def</span> <span class="function-name">toMessageData</span> (ex : Exception) : TermElabM MessageData <span class="constant">:=</span> <span class="keyword">do</span>
 901   <span class="keyword">let</span> pos &#8592; getRefPos
 902   <span class="keyword">match</span> ex.getRef.getPos? <span class="keyword">with</span>
 903   | none       <span class="constant">=&gt;</span> <span class="keyword">return</span> ex.toMessageData
 904   | some exPos <span class="constant">=&gt;</span>
 905     <span class="keyword">if</span> pos <span class="constant">==</span> exPos <span class="keyword">then</span>
 906       <span class="keyword">return</span> ex.toMessageData
 907     <span class="keyword">else</span>
 908       <span class="keyword">let</span> exPosition <span class="constant">:=</span> (&#8592; getFileMap).toPosition exPos
 909       <span class="keyword">return</span> m<span class="constant">!</span><span class="string">"{exPosition.line}:{exPosition.column} {ex.toMessageData}"</span>
 910 
<span class="keyword"> 911 private</span> <span class="keyword">def</span> <span class="function-name">toMessageList</span> (msgs : Array MessageData) : MessageData <span class="constant">:=</span>
 912   indentD (MessageData.joinSep msgs.toList m<span class="constant">!</span><span class="string">"\n\n"</span>)
 913 
<span class="keyword"> 914 private</span> <span class="keyword">def</span> <span class="function-name">mergeFailures</span> {&#945;} (failures : Array (TermElabResult Expr)) : TermElabM &#945; <span class="constant">:=</span> <span class="keyword">do</span>
 915   <span class="keyword">let</span> msgs &#8592; failures.mapM <span class="keyword">fun</span> failure <span class="constant">=&gt;</span>
 916     <span class="keyword">match</span> failure <span class="keyword">with</span>
 917     | EStateM.Result.ok <span class="preprocessor">_</span> <span class="preprocessor">_</span>     <span class="constant">=&gt;</span> <span class="warning">unreachable</span><span class="constant">!</span>
 918     | EStateM.Result.error ex <span class="preprocessor">_</span> <span class="constant">=&gt;</span> toMessageData ex
 919   throwError <span class="string">"overloaded, errors {toMessageList msgs}"</span>
 920 
<span class="keyword"> 921 private</span> <span class="keyword">def</span> <span class="function-name">elabAppAux</span> (f : Syntax) (namedArgs : Array NamedArg) (args : Array Arg) (ellipsis : Bool) (expectedType? : Option Expr) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
 922   <span class="keyword">let</span> candidates &#8592; elabAppFn f [] namedArgs args expectedType? (explicit <span class="constant">:=</span> false) (ellipsis <span class="constant">:=</span> ellipsis) (overloaded <span class="constant">:=</span> false) <span class="constant">#</span>[]
 923   <span class="keyword">if</span> candidates.size <span class="constant">==</span> <span class="constant">1</span> <span class="keyword">then</span>
 924     applyResult candidates[<span class="constant">0</span>]
 925   <span class="keyword">else</span>
 926     <span class="keyword">let</span> successes <span class="constant">:=</span> getSuccess candidates
 927     <span class="keyword">if</span> successes.size <span class="constant">==</span> <span class="constant">1</span> <span class="keyword">then</span>
 928       applyResult successes[<span class="constant">0</span>]
 929     <span class="keyword">else</span> <span class="keyword">if</span> successes.size <span class="constant">&gt;</span> <span class="constant">1</span> <span class="keyword">then</span>
 930       <span class="keyword">let</span> lctx &#8592; getLCtx
 931       <span class="keyword">let</span> opts &#8592; getOptions
 932       <span class="keyword">let</span> msgs : Array MessageData <span class="constant">:=</span> successes.map <span class="keyword">fun</span> success <span class="constant">=&gt;</span> <span class="keyword">match</span> success <span class="keyword">with</span>
 933         | EStateM.Result.ok e s <span class="constant">=&gt;</span> MessageData.withContext { env <span class="constant">:=</span> s.meta.core.env, mctx <span class="constant">:=</span> s.meta.meta.mctx, lctx <span class="constant">:=</span> lctx, opts <span class="constant">:=</span> opts } e
 934         | <span class="preprocessor">_</span>                     <span class="constant">=&gt;</span> <span class="warning">unreachable</span><span class="constant">!</span>
 935       throwErrorAt f <span class="string">"ambiguous, possible interpretations {toMessageList msgs}"</span>
 936     <span class="keyword">else</span>
 937       withRef f <span class="constant">&lt;</span>| mergeFailures candidates
 938 
<span class="keyword"> 939 partial</span> <span class="keyword">def</span> <span class="function-name">expandArgs</span> (args : Array Syntax) (pattern <span class="constant">:=</span> false) : TermElabM (Array NamedArg <span class="constant">&#215;</span> Array Arg <span class="constant">&#215;</span> Bool) <span class="constant">:=</span> <span class="keyword">do</span>
 940   <span class="keyword">let</span> (args, ellipsis) <span class="constant">:=</span>
 941     <span class="keyword">if</span> args.isEmpty <span class="keyword">then</span>
 942       (args, false)
 943     <span class="keyword">else</span> <span class="keyword">if</span> args.back.isOfKind ``Lean.Parser.Term.ellipsis <span class="keyword">then</span>
 944       (args.pop, true)
 945     <span class="keyword">else</span>
 946       (args, false)
 947   <span class="keyword">let</span> (namedArgs, args) &#8592; args.foldlM (init <span class="constant">:=</span> (<span class="constant">#</span>[], <span class="constant">#</span>[])) <span class="keyword">fun</span> (namedArgs, args) stx <span class="constant">=&gt;</span> <span class="keyword">do</span>
 948     <span class="keyword">if</span> stx.getKind <span class="constant">==</span> ``Lean.Parser.Term.namedArgument <span class="keyword">then</span>
 949       <span class="comment-delimiter">-- </span><span class="comment">trailing_tparser try ("(" &gt;&gt; ident &gt;&gt; " := ") &gt;&gt; termParser &gt;&gt; ")"
</span> 950       <span class="keyword">let</span> name <span class="constant">:=</span> stx[<span class="constant">1</span>].getId.eraseMacroScopes
 951       <span class="keyword">let</span> val  <span class="constant">:=</span> stx[<span class="constant">3</span>]
 952       <span class="keyword">let</span> namedArgs &#8592; addNamedArg namedArgs { ref <span class="constant">:=</span> stx, name <span class="constant">:=</span> name, val <span class="constant">:=</span> Arg.stx val }
 953       <span class="keyword">return</span> (namedArgs, args)
 954     <span class="keyword">else</span> <span class="keyword">if</span> stx.getKind <span class="constant">==</span> ``Lean.Parser.Term.ellipsis <span class="keyword">then</span>
 955       throwErrorAt stx <span class="string">"unexpected '..'"</span>
 956     <span class="keyword">else</span>
 957       <span class="keyword">return</span> (namedArgs, args.push <span class="constant">$</span> Arg.stx stx)
 958   <span class="keyword">return</span> (namedArgs, args, ellipsis)
 959 
<span class="keyword"> 960 def</span> <span class="function-name">expandApp</span> (stx : Syntax) (pattern <span class="constant">:=</span> false) : TermElabM (Syntax <span class="constant">&#215;</span> Array NamedArg <span class="constant">&#215;</span> Array Arg <span class="constant">&#215;</span> Bool) <span class="constant">:=</span> <span class="keyword">do</span>
 961   <span class="keyword">let</span> (namedArgs, args, ellipsis) &#8592; expandArgs stx[<span class="constant">1</span>].getArgs
 962   <span class="keyword">return</span> (stx[<span class="constant">0</span>], namedArgs, args, ellipsis)
 963 
<span class="doc"> 964 @[builtinTermElab app]</span> <span class="keyword">def</span> <span class="function-name">elabApp</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span>
 965   withoutPostponingUniverseConstraints <span class="keyword">do</span>
 966     <span class="keyword">let</span> (f, namedArgs, args, ellipsis) &#8592; expandApp stx
 967     elabAppAux f namedArgs args (ellipsis <span class="constant">:=</span> ellipsis) expectedType?
 968 
<span class="keyword"> 969 private</span> <span class="keyword">def</span> <span class="function-name">elabAtom</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span>
 970   elabAppAux stx <span class="constant">#</span>[] <span class="constant">#</span>[] (ellipsis <span class="constant">:=</span> false) expectedType?
 971 
<span class="doc"> 972 @[builtinTermElab ident]</span> <span class="keyword">def</span> <span class="function-name">elabIdent</span> : TermElab <span class="constant">:=</span> elabAtom
<span class="doc"> 973 @[builtinTermElab namedPattern]</span> <span class="keyword">def</span> <span class="function-name">elabNamedPattern</span> : TermElab <span class="constant">:=</span> elabAtom
<span class="doc"> 974 @[builtinTermElab explicitUniv]</span> <span class="keyword">def</span> <span class="function-name">elabExplicitUniv</span> : TermElab <span class="constant">:=</span> elabAtom
<span class="doc"> 975 @[builtinTermElab pipeProj]</span> <span class="keyword">def</span> <span class="function-name">elabPipeProj</span> : TermElab
 976   | `(<span class="constant">$</span>e |<span class="constant">&gt;</span>.<span class="constant">$</span>f <span class="constant">$</span>args<span class="constant">*</span>), expectedType? <span class="constant">=&gt;</span>
 977     withoutPostponingUniverseConstraints <span class="keyword">do</span>
 978       <span class="keyword">let</span> (namedArgs, args, ellipsis) &#8592; expandArgs args
 979       elabAppAux (&#8592; `(<span class="constant">$</span>e |<span class="constant">&gt;</span>.<span class="constant">$</span>f)) namedArgs args (ellipsis <span class="constant">:=</span> ellipsis) expectedType?
 980   | <span class="preprocessor">_</span>, <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwUnsupportedSyntax
 981 
<span class="doc"> 982 @[builtinTermElab explicit]</span> <span class="keyword">def</span> <span class="function-name">elabExplicit</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span>
 983   <span class="keyword">match</span> stx <span class="keyword">with</span>
 984   | `(<span class="constant">@$</span>id:ident)         <span class="constant">=&gt;</span> elabAtom stx expectedType?  <span class="comment-delimiter">-- </span><span class="comment">Recall that `elabApp` also has support for `@`
</span> 985   | `(<span class="constant">@$</span>id:ident.{<span class="constant">$</span>us,<span class="constant">*</span>}) <span class="constant">=&gt;</span> elabAtom stx expectedType?
 986   | `(<span class="constant">@</span>(<span class="constant">$</span>t))              <span class="constant">=&gt;</span> elabTerm t expectedType? (implicitLambda <span class="constant">:=</span> false)    <span class="comment-delimiter">-- </span><span class="comment">`@` is being used just to disable implicit lambdas
</span> 987   | `(<span class="constant">@$</span>t)                <span class="constant">=&gt;</span> elabTerm t expectedType? (implicitLambda <span class="constant">:=</span> false)   <span class="comment-delimiter">-- </span><span class="comment">`@` is being used just to disable implicit lambdas
</span> 988   | <span class="preprocessor">_</span>                     <span class="constant">=&gt;</span> throwUnsupportedSyntax
 989 
<span class="doc"> 990 @[builtinTermElab choice]</span> <span class="keyword">def</span> <span class="function-name">elabChoice</span> : TermElab <span class="constant">:=</span> elabAtom
<span class="doc"> 991 @[builtinTermElab proj]</span> <span class="keyword">def</span> <span class="function-name">elabProj</span> : TermElab <span class="constant">:=</span> elabAtom
<span class="doc"> 992 @[builtinTermElab arrayRef]</span> <span class="keyword">def</span> <span class="function-name">elabArrayRef</span> : TermElab <span class="constant">:=</span> elabAtom
 993 
<span class="keyword"> 994 builtin_initialize</span>
 995   registerTraceClass `Elab.app
 996 
<span class="keyword"> 997 end</span> Lean.Elab.Term
 998 ::::::::::::::
 999 Elab<span class="constant">/</span>Attributes.lean
1000 ::::::::::::::
<span class="comment-delimiter">1001 /-</span><span class="comment">
1002 Copyright (c) 2020 Microsoft Corporation. All rights reserved.
1003 Released under Apache 2.0 license as described in the file LICENSE.
1004 Authors: Leonardo de Moura, Sebastian Ullrich
1005 -/</span>
<span class="keyword">1006 import</span> Lean.Parser.Attr
<span class="keyword">1007 import</span> Lean.Attributes
<span class="keyword">1008 import</span> Lean.MonadEnv
<span class="keyword">1009 import</span> Lean.Elab.Util
<span class="keyword">1010 namespace</span> Lean.Elab
1011 
<span class="keyword">1012 structure</span> <span class="function-name">Attribute</span> <span class="keyword">where</span>
1013   kind  : AttributeKind <span class="constant">:=</span> AttributeKind.global
1014   name  : Name
1015   stx   : Syntax <span class="constant">:=</span> Syntax.missing
1016 
<span class="keyword">1017 instance</span> <span class="function-name">:</span> ToFormat Attribute <span class="keyword">where</span>
1018   format attr <span class="constant">:=</span>
1019    <span class="keyword">let</span> kindStr <span class="constant">:=</span> <span class="keyword">match</span> attr.kind <span class="keyword">with</span>
1020      | AttributeKind.global <span class="constant">=&gt;</span> <span class="string">""</span>
1021      | AttributeKind.<span class="keyword">local</span>  <span class="constant">=&gt;</span> <span class="string">"local "</span>
1022      | AttributeKind.<span class="keyword">scoped</span> <span class="constant">=&gt;</span> <span class="string">"scoped "</span>
1023    Format.bracket <span class="string">"@["</span> f<span class="constant">!</span><span class="string">"{kindStr}{attr.name}{toString attr.stx}"</span> <span class="string">"]"</span>
1024 
<span class="keyword">1025 instance</span> <span class="function-name">:</span> Inhabited Attribute <span class="keyword">where</span>
1026   default <span class="constant">:=</span> { name <span class="constant">:=</span> arbitrary }
1027 
<span class="comment-delimiter">1028 /-</span><span class="comment">
1029   ```
1030   attrKind := leading_parser optional (&#171;</span>scoped<span class="comment">&#187; &lt;|&gt; &#171;</span>local<span class="comment">&#187;)
1031   ```
1032 -/</span>
<span class="keyword">1033 def</span> <span class="function-name">toAttributeKind</span> [Monad m] [MonadResolveName m] [MonadError m] (attrKindStx : Syntax) : m AttributeKind <span class="constant">:=</span> <span class="keyword">do</span>
1034   <span class="keyword">if</span> attrKindStx[<span class="constant">0</span>].isNone <span class="keyword">then</span>
1035     <span class="keyword">return</span> AttributeKind.global
1036   <span class="keyword">else</span> <span class="keyword">if</span> attrKindStx[<span class="constant">0</span>][<span class="constant">0</span>].getKind <span class="constant">==</span> ``Lean.Parser.Term.<span class="keyword">scoped</span> <span class="keyword">then</span>
1037     <span class="keyword">if</span> (&#8592; getCurrNamespace).isAnonymous <span class="keyword">then</span>
1038       throwError <span class="string">"scoped attributes must be used inside namespaces"</span>
1039     <span class="keyword">return</span> AttributeKind.<span class="keyword">scoped</span>
1040   <span class="keyword">else</span>
1041     <span class="keyword">return</span> AttributeKind.<span class="keyword">local</span>
1042 
<span class="keyword">1043 def</span> <span class="function-name">mkAttrKindGlobal</span> : Syntax <span class="constant">:=</span>
1044   Syntax.node ``Lean.Parser.Term.attrKind <span class="constant">#</span>[mkNullNode]
1045 
<span class="keyword">1046 def</span> <span class="function-name">elabAttr</span> {m} [Monad m] [MonadEnv m] [MonadResolveName m] [MonadError m] [MonadMacroAdapter m] [MonadRecDepth m] (attrInstance : Syntax) : m Attribute <span class="constant">:=</span> <span class="keyword">do</span>
1047   <span class="comment-delimiter">/- </span><span class="comment">attrInstance     := ppGroup $ leading_parser attrKind &gt;&gt; attrParser -/</span>
1048   <span class="keyword">let</span> attrKind &#8592; toAttributeKind attrInstance[<span class="constant">0</span>]
1049   <span class="keyword">let</span> attr <span class="constant">:=</span> attrInstance[<span class="constant">1</span>]
1050   <span class="keyword">let</span> attr &#8592; liftMacroM <span class="constant">&lt;</span>| expandMacros attr
1051   <span class="keyword">let</span> attrName &#8592;
1052     <span class="keyword">if</span> attr.getKind <span class="constant">==</span> ``Parser.Attr.simple <span class="keyword">then</span>
1053       pure attr[<span class="constant">0</span>].getId.eraseMacroScopes
1054     <span class="keyword">else</span>
1055       <span class="keyword">match</span> attr.getKind <span class="keyword">with</span>
1056       | Name.str <span class="preprocessor">_</span> s <span class="preprocessor">_</span> <span class="constant">=&gt;</span> pure <span class="constant">&lt;</span>| Name.mkSimple s
1057       | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwErrorAt attr  <span class="string">"unknown attribute"</span>
1058   <span class="keyword">unless</span> isAttribute (&#8592; getEnv) attrName <span class="keyword">do</span>
1059     throwError <span class="string">"unknown attribute [{attrName}]"</span>
1060   <span class="comment-delimiter">/- </span><span class="comment">The `AttrM` does not have sufficient information for expanding macros in `args`.
1061      So, we expand them before here before we invoke the attributer handlers implemented using `AttrM`. -/</span>
1062   pure { kind <span class="constant">:=</span> attrKind, name <span class="constant">:=</span> attrName, stx <span class="constant">:=</span> attr }
1063 
<span class="keyword">1064 def</span> <span class="function-name">elabAttrs</span> {m} [Monad m] [MonadEnv m] [MonadResolveName m] [MonadError m] [MonadMacroAdapter m] [MonadRecDepth m] (attrInstances : Array Syntax) : m (Array Attribute) <span class="constant">:=</span> <span class="keyword">do</span>
1065   <span class="keyword">let</span> <span class="keyword">mut</span> attrs <span class="constant">:=</span> <span class="constant">#</span>[]
1066   <span class="keyword">for</span> attr <span class="keyword">in</span> attrInstances <span class="keyword">do</span>
1067     attrs <span class="constant">:=</span> attrs.push (&#8592; elabAttr attr)
1068   <span class="keyword">return</span> attrs
1069 
<span class="comment-delimiter">1070 -- </span><span class="comment">leading_parser "@[" &gt;&gt; sepBy1 attrInstance ", " &gt;&gt; "]"
</span><span class="keyword">1071 def</span> <span class="function-name">elabDeclAttrs</span> {m} [Monad m] [MonadEnv m] [MonadResolveName m] [MonadError m] [MonadMacroAdapter m] [MonadRecDepth m] (stx : Syntax) : m (Array Attribute) <span class="constant">:=</span>
1072   elabAttrs stx[<span class="constant">1</span>].getSepArgs
1073 
<span class="keyword">1074 end</span> Lean.Elab
1075 ::::::::::::::
1076 Elab<span class="constant">/</span>AutoBound.lean
1077 ::::::::::::::
<span class="comment-delimiter">1078 /-</span><span class="comment">
1079 Copyright (c) 2020 Microsoft Corporation. All rights reserved.
1080 Released under Apache 2.0 license as described in the file LICENSE.
1081 Authors: Leonardo de Moura
1082 -/</span>
<span class="keyword">1083 import</span> Lean.Data.Options
1084 
<span class="comment-delimiter">1085 /- </span><span class="comment">Basic support for auto bound implicit local names -/</span>
1086 
<span class="keyword">1087 namespace</span> Lean.Elab
1088 
<span class="keyword">1089 register_builtin_option</span> autoBoundImplicitLocal : Bool <span class="constant">:=</span> {
1090     defValue <span class="constant">:=</span> true
1091     descr    <span class="constant">:=</span> <span class="string">"Unbound local variables in declaration headers become implicit arguments if they are a lower case or greek letter followed by numeric digits. For example, `def f (x : Vector &#945; n) : Vector &#945; n :=` automatically introduces the implicit variables {&#945; n}."</span>
1092   }
1093 
<span class="keyword">1094 private</span> <span class="keyword">def</span> <span class="function-name">isValidAutoBoundSuffix</span> (s : String) : Bool <span class="constant">:=</span>
1095   s.toSubstring.drop <span class="constant">1</span> |<span class="constant">&gt;</span>.all <span class="keyword">fun</span> c <span class="constant">=&gt;</span> c.isDigit <span class="constant">||</span> isSubScriptAlnum c <span class="constant">||</span> c <span class="constant">==</span> '_' <span class="constant">||</span> c <span class="constant">==</span> '\''
1096 
<span class="comment-delimiter">1097 /-</span><span class="comment">
1098 Remark: Issue #255 exposed a nasty interaction between macro scopes and auto-bound-implicit names.
1099 ```
1100 local notation "A" =&gt; id x
1101 theorem test : A = A := sorry
1102 ```
1103 We used to use `n.eraseMacroScopes` at `isValidAutoBoundImplicitName` and `isValidAutoBoundLevelName`.
1104 Thus, in the example above, when `A` is expanded, a `x` with a fresh macro scope is created.
1105 `x`+macros-scope is not in scope and is a valid auto-bound implicit name after macro scopes are erased.
1106 So, an auto-bound exception would be thrown, and `x`+macro-scope would be added as a new implicit.
1107 When, we try again, a `x` with a new macro scope is created and this process keeps repeating.
1108 Therefore, we do consider identifier with macro scopes anymore.
1109 -/</span>
1110 
<span class="keyword">1111 def</span> <span class="function-name">isValidAutoBoundImplicitName</span> (n : Name) : Bool <span class="constant">:=</span>
1112   <span class="keyword">match</span> n <span class="keyword">with</span>
1113   | Name.str Name.anonymous s <span class="preprocessor">_</span> <span class="constant">=&gt;</span> s.length <span class="constant">&gt;</span> <span class="constant">0</span> <span class="constant">&amp;&amp;</span> (isGreek s[<span class="constant">0</span>] <span class="constant">||</span> s[<span class="constant">0</span>].isLower) <span class="constant">&amp;&amp;</span> isValidAutoBoundSuffix s
1114   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> false
1115 
<span class="keyword">1116 def</span> <span class="function-name">isValidAutoBoundLevelName</span> (n : Name) : Bool <span class="constant">:=</span>
1117   <span class="keyword">match</span> n <span class="keyword">with</span>
1118   | Name.str Name.anonymous s <span class="preprocessor">_</span> <span class="constant">=&gt;</span> s.length <span class="constant">&gt;</span> <span class="constant">0</span> <span class="constant">&amp;&amp;</span> s[<span class="constant">0</span>].isLower <span class="constant">&amp;&amp;</span> isValidAutoBoundSuffix s
1119   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> false
1120 
<span class="keyword">1121 end</span> Lean.Elab
1122 ::::::::::::::
1123 Elab<span class="constant">/</span>Binders.lean
1124 ::::::::::::::
<span class="comment-delimiter">1125 /-</span><span class="comment">
1126 Copyright (c) 2019 Microsoft Corporation. All rights reserved.
1127 Released under Apache 2.0 license as described in the file LICENSE.
1128 Authors: Leonardo de Moura
1129 -/</span>
<span class="keyword">1130 import</span> Lean.Elab.Term
<span class="keyword">1131 import</span> Lean.Parser.Term
1132 
<span class="keyword">1133 namespace</span> Lean.Elab.Term
<span class="keyword">1134 open</span> Meta
<span class="keyword">1135 open</span> Lean.Parser.Term
1136 
<span class="comment-delimiter">1137 /-</span><span class="comment">-
1138   Given syntax of the forms
1139     a) (`:` term)?
1140     b) `:` term
1141   return `term` if it is present, or a hole if not. -/</span>
<span class="keyword">1142 private</span> <span class="keyword">def</span> <span class="function-name">expandBinderType</span> (ref : Syntax) (stx : Syntax) : Syntax <span class="constant">:=</span>
1143   <span class="keyword">if</span> stx.getNumArgs <span class="constant">==</span> <span class="constant">0</span> <span class="keyword">then</span>
1144     mkHole ref
1145   <span class="keyword">else</span>
1146     stx[<span class="constant">1</span>]
1147 
<span class="comment-delimiter">1148 /-</span><span class="comment">- Given syntax of the form `ident &lt;|&gt; hole`, return `ident`. If `hole`, then we create a new anonymous name. -/</span>
<span class="keyword">1149 private</span> <span class="keyword">def</span> <span class="function-name">expandBinderIdent</span> (stx : Syntax) : TermElabM Syntax <span class="constant">:=</span>
1150   <span class="keyword">match</span> stx <span class="keyword">with</span>
1151   | `(<span class="preprocessor">_</span>) <span class="constant">=&gt;</span> mkFreshIdent stx
1152   | <span class="preprocessor">_</span>    <span class="constant">=&gt;</span> pure stx
1153 
<span class="comment-delimiter">1154 /-</span><span class="comment">- Given syntax of the form `(ident &gt;&gt; " : ")?`, return `ident`, or a new instance name. -/</span>
<span class="keyword">1155 private</span> <span class="keyword">def</span> <span class="function-name">expandOptIdent</span> (stx : Syntax) : TermElabM Syntax <span class="constant">:=</span> <span class="keyword">do</span>
1156   <span class="keyword">if</span> stx.isNone <span class="keyword">then</span>
1157     <span class="keyword">let</span> id &#8592; withFreshMacroScope <span class="constant">&lt;</span>| MonadQuotation.addMacroScope `inst
1158     <span class="keyword">return</span> mkIdentFrom stx id
1159   <span class="keyword">else</span>
1160     <span class="keyword">return</span> stx[<span class="constant">0</span>]
1161 
<span class="keyword">1162 structure</span> <span class="function-name">BinderView</span> <span class="keyword">where</span>
1163   id : Syntax
1164   type : Syntax
1165   bi : BinderInfo
1166 
<span class="keyword">1167 partial</span> <span class="keyword">def</span> <span class="function-name">quoteAutoTactic</span> : Syntax <span class="constant">&#8594;</span> TermElabM Syntax
1168   | stx<span class="constant">@</span>(Syntax.ident <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="preprocessor">_</span>) <span class="constant">=&gt;</span> throwErrorAt stx <span class="string">"invalid auto tactic, identifier is not allowed"</span>
1169   | stx<span class="constant">@</span>(Syntax.node k args)   <span class="constant">=&gt;</span> <span class="keyword">do</span>
1170     <span class="keyword">if</span> stx.isAntiquot <span class="keyword">then</span>
1171       throwErrorAt stx <span class="string">"invalid auto tactic, antiquotation is not allowed"</span>
1172     <span class="keyword">else</span>
1173       <span class="keyword">let</span> <span class="keyword">mut</span> quotedArgs &#8592; `(Array.empty)
1174       <span class="keyword">for</span> arg <span class="keyword">in</span> args <span class="keyword">do</span>
1175         <span class="keyword">if</span> k <span class="constant">==</span> nullKind <span class="constant">&amp;&amp;</span> (arg.isAntiquotSuffixSplice <span class="constant">||</span> arg.isAntiquotSplice) <span class="keyword">then</span>
1176           throwErrorAt arg <span class="string">"invalid auto tactic, antiquotation is not allowed"</span>
1177         <span class="keyword">else</span>
1178           <span class="keyword">let</span> quotedArg &#8592; quoteAutoTactic arg
1179           quotedArgs &#8592; `(Array.push <span class="constant">$</span>quotedArgs <span class="constant">$</span>quotedArg)
1180       `(Syntax.node <span class="constant">$</span>(quote k) <span class="constant">$</span>quotedArgs)
1181   | Syntax.atom info val <span class="constant">=&gt;</span> `(mkAtom <span class="constant">$</span>(quote val))
1182   | Syntax.missing       <span class="constant">=&gt;</span> <span class="warning">unreachable</span><span class="constant">!</span>
1183 
<span class="keyword">1184 def</span> <span class="function-name">declareTacticSyntax</span> (tactic : Syntax) : TermElabM Name <span class="constant">:=</span>
1185   withFreshMacroScope <span class="keyword">do</span>
1186     <span class="keyword">let</span> name &#8592; MonadQuotation.addMacroScope `_auto
1187     <span class="keyword">let</span> type <span class="constant">:=</span> Lean.mkConst `Lean.Syntax
1188     <span class="keyword">let</span> tactic &#8592; quoteAutoTactic tactic
1189     <span class="keyword">let</span> val &#8592; elabTerm tactic type
1190     <span class="keyword">let</span> val &#8592; instantiateMVars val
1191     trace[Elab.autoParam] val
1192     <span class="keyword">let</span> decl <span class="constant">:=</span> Declaration.defnDecl { name <span class="constant">:=</span> name, levelParams <span class="constant">:=</span> [], type <span class="constant">:=</span> type, value <span class="constant">:=</span> val, hints <span class="constant">:=</span> ReducibilityHints.opaque,
1193                                        safety <span class="constant">:=</span> DefinitionSafety.safe }
1194     addDecl decl
1195     compileDecl decl
1196     <span class="keyword">return</span> name
1197 
<span class="comment-delimiter">1198 /-</span><span class="comment">
1199 Expand `optional (binderTactic &lt;|&gt; binderDefault)`
1200 def binderTactic  := leading_parser " := " &gt;&gt; " by " &gt;&gt; tacticParser
1201 def binderDefault := leading_parser " := " &gt;&gt; termParser
1202 -/</span>
<span class="keyword">1203 private</span> <span class="keyword">def</span> <span class="function-name">expandBinderModifier</span> (type : Syntax) (optBinderModifier : Syntax) : TermElabM Syntax <span class="constant">:=</span> <span class="keyword">do</span>
1204   <span class="keyword">if</span> optBinderModifier.isNone <span class="keyword">then</span>
1205     <span class="keyword">return</span> type
1206   <span class="keyword">else</span>
1207     <span class="keyword">let</span> modifier <span class="constant">:=</span> optBinderModifier[<span class="constant">0</span>]
1208     <span class="keyword">let</span> kind     <span class="constant">:=</span> modifier.getKind
1209     <span class="keyword">if</span> kind <span class="constant">==</span> `Lean.Parser.Term.binderDefault <span class="keyword">then</span>
1210       <span class="keyword">let</span> defaultVal <span class="constant">:=</span> modifier[<span class="constant">1</span>]
1211       `(optParam <span class="constant">$</span>type <span class="constant">$</span>defaultVal)
1212     <span class="keyword">else</span> <span class="keyword">if</span> kind <span class="constant">==</span> `Lean.Parser.Term.binderTactic <span class="keyword">then</span>
1213       <span class="keyword">let</span> tac <span class="constant">:=</span> modifier[<span class="constant">2</span>]
1214       <span class="keyword">let</span> name &#8592; declareTacticSyntax tac
1215       `(autoParam <span class="constant">$</span>type <span class="constant">$</span>(mkIdentFrom tac name))
1216     <span class="keyword">else</span>
1217       throwUnsupportedSyntax
1218 
<span class="keyword">1219 private</span> <span class="keyword">def</span> <span class="function-name">getBinderIds</span> (ids : Syntax) : TermElabM (Array Syntax) <span class="constant">:=</span>
1220   ids.getArgs.mapM <span class="keyword">fun</span> id <span class="constant">=&gt;</span>
1221     <span class="keyword">let</span> k <span class="constant">:=</span> id.getKind
1222     <span class="keyword">if</span> k <span class="constant">==</span> identKind <span class="constant">||</span> k <span class="constant">==</span> `Lean.Parser.Term.hole <span class="keyword">then</span>
1223       <span class="keyword">return</span> id
1224     <span class="keyword">else</span>
1225       throwErrorAt id <span class="string">"identifier or `_` expected"</span>
1226 
<span class="comment-delimiter">1227 /-</span><span class="comment">
1228   Recall that
1229   ```
1230   def typeSpec := leading_parser " : " &gt;&gt; termParser
1231   def optType : Parser := optional typeSpec
1232   ```
1233 -/</span>
<span class="keyword">1234 def</span> <span class="function-name">expandOptType</span> (ref : Syntax) (optType : Syntax) : Syntax <span class="constant">:=</span>
1235   <span class="keyword">if</span> optType.isNone <span class="keyword">then</span>
1236     mkHole ref
1237   <span class="keyword">else</span>
1238     optType[<span class="constant">0</span>][<span class="constant">1</span>]
1239 
<span class="keyword">1240 private</span> <span class="keyword">def</span> <span class="function-name">matchBinder</span> (stx : Syntax) : TermElabM (Array BinderView) <span class="constant">:=</span> <span class="keyword">do</span>
1241   <span class="keyword">let</span> k <span class="constant">:=</span> stx.getKind
1242   <span class="keyword">if</span> k <span class="constant">==</span> `Lean.Parser.Term.simpleBinder <span class="keyword">then</span>
1243     <span class="comment-delimiter">-- </span><span class="comment">binderIdent+ &gt;&gt; optType
</span>1244     <span class="keyword">let</span> ids &#8592; getBinderIds stx[<span class="constant">0</span>]
1245     <span class="keyword">let</span> type <span class="constant">:=</span> expandOptType stx stx[<span class="constant">1</span>]
1246     ids.mapM <span class="keyword">fun</span> id <span class="constant">=&gt;</span> <span class="keyword">do</span> pure { id <span class="constant">:=</span> (&#8592; expandBinderIdent id), type <span class="constant">:=</span> type, bi <span class="constant">:=</span> BinderInfo.default }
1247   <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> `Lean.Parser.Term.explicitBinder <span class="keyword">then</span>
1248     <span class="comment-delimiter">-- </span><span class="comment">`(` binderIdent+ binderType (binderDefault &lt;|&gt; binderTactic)? `)`
</span>1249     <span class="keyword">let</span> ids &#8592; getBinderIds stx[<span class="constant">1</span>]
1250     <span class="keyword">let</span> type        <span class="constant">:=</span> expandBinderType stx stx[<span class="constant">2</span>]
1251     <span class="keyword">let</span> optModifier <span class="constant">:=</span> stx[<span class="constant">3</span>]
1252     <span class="keyword">let</span> type &#8592; expandBinderModifier type optModifier
1253     ids.mapM <span class="keyword">fun</span> id <span class="constant">=&gt;</span> <span class="keyword">do</span> pure { id <span class="constant">:=</span> (&#8592; expandBinderIdent id), type <span class="constant">:=</span> type, bi <span class="constant">:=</span> BinderInfo.default }
1254   <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> `Lean.Parser.Term.implicitBinder <span class="keyword">then</span>
1255     <span class="comment-delimiter">-- </span><span class="comment">`{` binderIdent+ binderType `}`
</span>1256     <span class="keyword">let</span> ids &#8592; getBinderIds stx[<span class="constant">1</span>]
1257     <span class="keyword">let</span> type <span class="constant">:=</span> expandBinderType stx stx[<span class="constant">2</span>]
1258     ids.mapM <span class="keyword">fun</span> id <span class="constant">=&gt;</span> <span class="keyword">do</span> pure { id <span class="constant">:=</span> (&#8592; expandBinderIdent id), type <span class="constant">:=</span> type, bi <span class="constant">:=</span> BinderInfo.implicit }
1259   <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> `Lean.Parser.Term.instBinder <span class="keyword">then</span>
1260     <span class="comment-delimiter">-- </span><span class="comment">`[` optIdent type `]`
</span>1261     <span class="keyword">let</span> id &#8592; expandOptIdent stx[<span class="constant">1</span>]
1262     <span class="keyword">let</span> type <span class="constant">:=</span> stx[<span class="constant">2</span>]
1263     pure <span class="constant">#</span>[ { id <span class="constant">:=</span> id, type <span class="constant">:=</span> type, bi <span class="constant">:=</span> BinderInfo.instImplicit } ]
1264   <span class="keyword">else</span>
1265     throwUnsupportedSyntax
1266 
<span class="keyword">1267 private</span> <span class="keyword">def</span> <span class="function-name">registerFailedToInferBinderTypeInfo</span> (type : Expr) (ref : Syntax) : TermElabM Unit <span class="constant">:=</span>
1268   registerCustomErrorIfMVar type ref <span class="string">"failed to infer binder type"</span>
1269 
<span class="keyword">1270 private</span> <span class="keyword">def</span> <span class="function-name">addLocalVarInfoCore</span> (lctx : LocalContext) (stx : Syntax) (fvar : Expr) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
1271   <span class="keyword">if</span> (&#8592; getInfoState).enabled <span class="keyword">then</span>
1272     pushInfoTree <span class="constant">&lt;</span>| InfoTree.node (children <span class="constant">:=</span> {}) <span class="constant">&lt;</span>| Info.ofTermInfo { lctx <span class="constant">:=</span> lctx, expr <span class="constant">:=</span> fvar, stx <span class="constant">:=</span> stx }
1273 
<span class="keyword">1274 private</span> <span class="keyword">def</span> <span class="function-name">addLocalVarInfo</span> (stx : Syntax) (fvar : Expr) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
1275   addLocalVarInfoCore (&#8592; getLCtx) stx fvar
1276 
<span class="keyword">1277 private</span> <span class="keyword">def</span> <span class="function-name">ensureAtomicBinderName</span> (binderView : BinderView) : TermElabM Unit <span class="constant">:=</span>
1278   <span class="keyword">let</span> n <span class="constant">:=</span> binderView.id.getId.eraseMacroScopes
1279   <span class="keyword">unless</span> n.isAtomic <span class="keyword">do</span>
1280     throwErrorAt binderView.id <span class="string">"invalid binder name '{n}', it must be atomic"</span>
1281 
<span class="keyword">1282 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">elabBinderViews</span> {&#945;} (binderViews : Array BinderView) (fvars : Array Expr) (k : Array Expr <span class="constant">&#8594;</span> TermElabM &#945;)
1283     : TermElabM &#945; <span class="constant">:=</span>
1284   <span class="keyword">let</span> <span class="keyword">rec</span> loop (i : Nat) (fvars : Array Expr) : TermElabM &#945; <span class="constant">:=</span> <span class="keyword">do</span>
1285     <span class="keyword">if</span> h : i <span class="constant">&lt;</span> binderViews.size <span class="keyword">then</span>
1286       <span class="keyword">let</span> binderView <span class="constant">:=</span> binderViews.get &#10216;i, h&#10217;
1287       ensureAtomicBinderName binderView
1288       <span class="keyword">let</span> type &#8592; elabType binderView.type
1289       registerFailedToInferBinderTypeInfo type binderView.type
1290       withLocalDecl binderView.id.getId binderView.bi type <span class="keyword">fun</span> fvar <span class="constant">=&gt;</span> <span class="keyword">do</span>
1291         addLocalVarInfo binderView.id fvar
1292         loop (i<span class="constant">+1</span>) (fvars.push fvar)
1293     <span class="keyword">else</span>
1294       k fvars
1295   loop <span class="constant">0</span> fvars
1296 
<span class="keyword">1297 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">elabBindersAux</span> {&#945;} (binders : Array Syntax) (k : Array Expr <span class="constant">&#8594;</span> TermElabM &#945;) : TermElabM &#945; <span class="constant">:=</span>
1298   <span class="keyword">let</span> <span class="keyword">rec</span> loop (i : Nat) (fvars : Array Expr) : TermElabM &#945; <span class="constant">:=</span> <span class="keyword">do</span>
1299     <span class="keyword">if</span> h : i <span class="constant">&lt;</span> binders.size <span class="keyword">then</span>
1300       <span class="keyword">let</span> binderViews &#8592; matchBinder (binders.get &#10216;i, h&#10217;)
1301       elabBinderViews binderViews fvars <span class="constant">&lt;</span>| loop (i<span class="constant">+1</span>)
1302     <span class="keyword">else</span>
1303       k fvars
1304   loop <span class="constant">0</span> <span class="constant">#</span>[]
1305 
<span class="comment-delimiter">1306 /-</span><span class="comment">-
1307   Elaborate the given binders (i.e., `Syntax` objects for `simpleBinder &lt;|&gt; bracketedBinder`),
1308   update the local context, set of local instances, reset instance chache (if needed), and then
1309   execute `x` with the updated context. -/</span>
<span class="keyword">1310 def</span> <span class="function-name">elabBinders</span> {&#945;} (binders : Array Syntax) (k : Array Expr <span class="constant">&#8594;</span> TermElabM &#945;) : TermElabM &#945; <span class="constant">:=</span>
1311   withoutPostponingUniverseConstraints <span class="keyword">do</span>
1312     <span class="keyword">if</span> binders.isEmpty <span class="keyword">then</span>
1313       k <span class="constant">#</span>[]
1314     <span class="keyword">else</span>
1315       elabBindersAux binders k
1316 
<span class="doc">1317 @[inline]</span> <span class="keyword">def</span> <span class="function-name">elabBinder</span> {&#945;} (binder : Syntax) (x : Expr <span class="constant">&#8594;</span> TermElabM &#945;) : TermElabM &#945; <span class="constant">:=</span>
1318   elabBinders <span class="constant">#</span>[binder] <span class="keyword">fun</span> fvars <span class="constant">=&gt;</span> x fvars[<span class="constant">0</span>]
1319 
<span class="constant">1320 @</span>[builtinTermElab <span class="comment">&#171;</span>forall<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabForall</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
1321   <span class="keyword">match</span> stx <span class="keyword">with</span>
1322   | `(<span class="keyword">forall</span> <span class="constant">$</span>binders<span class="constant">*</span>, <span class="constant">$</span>term) <span class="constant">=&gt;</span>
1323     elabBinders binders <span class="keyword">fun</span> xs <span class="constant">=&gt;</span> <span class="keyword">do</span>
1324       <span class="keyword">let</span> e &#8592; elabType term
1325       mkForallFVars xs e
1326   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwUnsupportedSyntax
1327 
<span class="doc">1328 @[builtinTermElab arrow]</span> <span class="keyword">def</span> <span class="function-name">elabArrow</span> : TermElab <span class="constant">:=</span>
1329   adaptExpander <span class="keyword">fun</span> stx <span class="constant">=&gt;</span> <span class="keyword">match</span> stx <span class="keyword">with</span>
1330   | `(<span class="constant">$</span>dom:term <span class="constant">-&gt;</span> <span class="constant">$</span>rng) <span class="constant">=&gt;</span> `(<span class="keyword">forall</span> (a : <span class="constant">$</span>dom), <span class="constant">$</span>rng)
1331   | <span class="preprocessor">_</span>                    <span class="constant">=&gt;</span> throwUnsupportedSyntax
1332 
<span class="doc">1333 @[builtinTermElab depArrow]</span> <span class="keyword">def</span> <span class="function-name">elabDepArrow</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
1334   <span class="comment-delimiter">-- </span><span class="comment">bracketedBinder `-&gt;` term
</span>1335   <span class="keyword">let</span> binder <span class="constant">:=</span> stx[<span class="constant">0</span>]
1336   <span class="keyword">let</span> term   <span class="constant">:=</span> stx[<span class="constant">2</span>]
1337   elabBinders <span class="constant">#</span>[binder] <span class="keyword">fun</span> xs <span class="constant">=&gt;</span> <span class="keyword">do</span>
1338     mkForallFVars xs (&#8592; elabType term)
1339 
<span class="comment-delimiter">1340 /-</span><span class="comment">-
1341   Auxiliary functions for converting `id_1 ... id_n` application into `#[id_1, ..., id_m]`
1342   It is used at `expandFunBinders`. -/</span>
<span class="keyword">1343 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">getFunBinderIds?</span> (stx : Syntax) : OptionT TermElabM (Array Syntax) <span class="constant">:=</span>
1344   <span class="keyword">let</span> convertElem (stx : Syntax) : OptionT TermElabM Syntax <span class="constant">:=</span>
1345     <span class="keyword">match</span> stx <span class="keyword">with</span>
1346     | `(<span class="preprocessor">_</span>) <span class="constant">=&gt;</span> <span class="keyword">do</span> <span class="keyword">let</span> ident &#8592; mkFreshIdent stx; pure ident
1347     | `(<span class="constant">$</span>id:ident) <span class="constant">=&gt;</span> <span class="keyword">return</span> id
1348     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> failure
1349   <span class="keyword">match</span> stx <span class="keyword">with</span>
1350   | `(<span class="constant">$</span>f <span class="constant">$</span>args<span class="constant">*</span>) <span class="constant">=&gt;</span> <span class="keyword">do</span>
1351      <span class="keyword">let</span> <span class="keyword">mut</span> acc <span class="constant">:=</span> <span class="constant">#</span>[].push (&#8592; convertElem f)
1352      <span class="keyword">for</span> arg <span class="keyword">in</span> args <span class="keyword">do</span>
1353        acc <span class="constant">:=</span> acc.push (&#8592; convertElem arg)
1354      <span class="keyword">return</span> acc
1355   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
1356     <span class="keyword">return</span> <span class="constant">#</span>[].push (&#8592; convertElem stx)
1357 
<span class="comment-delimiter">1358 /-</span><span class="comment">-
1359   Auxiliary function for expanding `fun` notation binders. Recall that `fun` parser is defined as
1360   ```
1361   def funBinder : Parser := implicitBinder &lt;|&gt; instBinder &lt;|&gt; termParser maxPrec
1362   leading_parser unicodeSymbol "&#955;" "fun" &gt;&gt; many1 funBinder &gt;&gt; "=&gt;" &gt;&gt; termParser
1363   ```
1364   to allow notation such as `fun (a, b) =&gt; a + b`, where `(a, b)` should be treated as a pattern.
1365   The result is a pair `(explicitBinders, newBody)`, where `explicitBinders` is syntax of the form
1366   ```
1367   `(` ident `:` term `)`
1368   ```
1369   which can be elaborated using `elabBinders`, and `newBody` is the updated `body` syntax.
1370   We update the `body` syntax when expanding the pattern notation.
1371   Example: `fun (a, b) =&gt; a + b` expands into `fun _a_1 =&gt; match _a_1 with | (a, b) =&gt; a + b`.
1372   See local function `processAsPattern` at `expandFunBindersAux`.
1373 
1374   The resulting `Bool` is true if a pattern was found. We use it "mark" a macro expansion. -/</span>
<span class="keyword">1375 partial</span> <span class="keyword">def</span> <span class="function-name">expandFunBinders</span> (binders : Array Syntax) (body : Syntax) : TermElabM (Array Syntax <span class="constant">&#215;</span> Syntax <span class="constant">&#215;</span> Bool) <span class="constant">:=</span>
1376   <span class="keyword">let</span> <span class="keyword">rec</span> loop (body : Syntax) (i : Nat) (newBinders : Array Syntax) <span class="constant">:=</span> <span class="keyword">do</span>
1377     <span class="keyword">if</span> h : i <span class="constant">&lt;</span> binders.size <span class="keyword">then</span>
1378       <span class="keyword">let</span> binder <span class="constant">:=</span> binders.get &#10216;i, h&#10217;
1379       <span class="keyword">let</span> processAsPattern : Unit <span class="constant">&#8594;</span> TermElabM (Array Syntax <span class="constant">&#215;</span> Syntax <span class="constant">&#215;</span> Bool) <span class="constant">:=</span> <span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">do</span>
1380         <span class="keyword">let</span> pattern <span class="constant">:=</span> binder
1381         <span class="keyword">let</span> major &#8592; mkFreshIdent binder
1382         <span class="keyword">let</span> (binders, newBody, <span class="preprocessor">_</span>) &#8592; loop body (i<span class="constant">+1</span>) (newBinders.push <span class="constant">$</span> mkExplicitBinder major (mkHole binder))
1383         <span class="keyword">let</span> newBody &#8592; `(<span class="keyword">match</span> <span class="constant">$</span>major:ident <span class="keyword">with</span> | <span class="constant">$</span>pattern <span class="constant">=&gt;</span> <span class="constant">$</span>newBody)
1384         pure (binders, newBody, true)
1385       <span class="keyword">match</span> binder <span class="keyword">with</span>
1386       | Syntax.node `Lean.Parser.Term.implicitBinder <span class="preprocessor">_</span> <span class="constant">=&gt;</span> loop body (i<span class="constant">+1</span>) (newBinders.push binder)
1387       | Syntax.node `Lean.Parser.Term.instBinder <span class="preprocessor">_</span>     <span class="constant">=&gt;</span> loop body (i<span class="constant">+1</span>) (newBinders.push binder)
1388       | Syntax.node `Lean.Parser.Term.explicitBinder <span class="preprocessor">_</span> <span class="constant">=&gt;</span> loop body (i<span class="constant">+1</span>) (newBinders.push binder)
1389       | Syntax.node `Lean.Parser.Term.simpleBinder <span class="preprocessor">_</span>   <span class="constant">=&gt;</span> loop body (i<span class="constant">+1</span>) (newBinders.push binder)
1390       | Syntax.node `Lean.Parser.Term.hole <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
1391         <span class="keyword">let</span> ident &#8592; mkFreshIdent binder
1392         <span class="keyword">let</span> type <span class="constant">:=</span> binder
1393         loop body (i<span class="constant">+1</span>) (newBinders.push <span class="constant">&lt;</span>| mkExplicitBinder ident type)
1394       | Syntax.node `Lean.Parser.Term.paren args <span class="constant">=&gt;</span>
1395         <span class="comment-delimiter">-- </span><span class="comment">`(` (termParser &gt;&gt; parenSpecial)? `)`
</span>1396         <span class="comment-delimiter">-- </span><span class="comment">parenSpecial := (tupleTail &lt;|&gt; typeAscription)?
</span>1397         <span class="keyword">let</span> binderBody <span class="constant">:=</span> binder[<span class="constant">1</span>]
1398         <span class="keyword">if</span> binderBody.isNone <span class="keyword">then</span>
1399           processAsPattern ()
1400         <span class="keyword">else</span>
1401           <span class="keyword">let</span> idents  <span class="constant">:=</span> binderBody[<span class="constant">0</span>]
1402           <span class="keyword">let</span> special <span class="constant">:=</span> binderBody[<span class="constant">1</span>]
1403           <span class="keyword">if</span> special.isNone <span class="keyword">then</span>
1404             processAsPattern ()
1405           <span class="keyword">else</span> <span class="keyword">if</span> special[<span class="constant">0</span>].getKind <span class="constant">!=</span> `Lean.Parser.Term.typeAscription <span class="keyword">then</span>
1406             processAsPattern ()
1407           <span class="keyword">else</span>
1408             <span class="comment-delimiter">-- </span><span class="comment">typeAscription := `:` term
</span>1409             <span class="keyword">let</span> type <span class="constant">:=</span> special[<span class="constant">0</span>][<span class="constant">1</span>]
1410             <span class="keyword">match</span> (&#8592; getFunBinderIds? idents) <span class="keyword">with</span>
1411             | some idents <span class="constant">=&gt;</span> loop body (i<span class="constant">+1</span>) (newBinders <span class="constant">++</span> idents.map (<span class="keyword">fun</span> ident <span class="constant">=&gt;</span> mkExplicitBinder ident type))
1412             | none        <span class="constant">=&gt;</span> processAsPattern ()
1413       | Syntax.ident .. <span class="constant">=&gt;</span>
1414         <span class="keyword">let</span> type  <span class="constant">:=</span> mkHole binder
1415         loop body (i<span class="constant">+1</span>) (newBinders.push <span class="constant">&lt;</span>| mkExplicitBinder binder type)
1416       | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> processAsPattern ()
1417     <span class="keyword">else</span>
1418       pure (newBinders, body, false)
1419   loop body <span class="constant">0</span> <span class="constant">#</span>[]
1420 
<span class="keyword">1421 namespace</span> FunBinders
1422 
<span class="keyword">1423 structure</span> <span class="function-name">State</span> <span class="keyword">where</span>
1424   fvars         : Array Expr <span class="constant">:=</span> <span class="constant">#</span>[]
1425   lctx          : LocalContext
1426   localInsts    : LocalInstances
1427   expectedType? : Option Expr <span class="constant">:=</span> none
1428 
<span class="keyword">1429 private</span> <span class="keyword">def</span> <span class="function-name">propagateExpectedType</span> (fvar : Expr) (fvarType : Expr) (s : State) : TermElabM State <span class="constant">:=</span> <span class="keyword">do</span>
1430   <span class="keyword">match</span> s.expectedType? <span class="keyword">with</span>
1431   | none              <span class="constant">=&gt;</span> pure s
1432   | some expectedType <span class="constant">=&gt;</span>
1433     <span class="keyword">let</span> expectedType &#8592; whnfForall expectedType
1434     <span class="keyword">match</span> expectedType <span class="keyword">with</span>
1435     | Expr.forallE <span class="preprocessor">_</span> d b <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
1436       discard <span class="constant">&lt;</span>| isDefEq fvarType d
1437       <span class="keyword">let</span> b <span class="constant">:=</span> b.instantiate1 fvar
1438       pure { s <span class="keyword">with</span> expectedType? <span class="constant">:=</span> some b }
1439     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> pure { s <span class="keyword">with</span> expectedType? <span class="constant">:=</span> none }
1440 
<span class="keyword">1441 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">elabFunBinderViews</span> (binderViews : Array BinderView) (i : Nat) (s : State) : TermElabM State <span class="constant">:=</span> <span class="keyword">do</span>
1442   <span class="keyword">if</span> h : i <span class="constant">&lt;</span> binderViews.size <span class="keyword">then</span>
1443     <span class="keyword">let</span> binderView <span class="constant">:=</span> binderViews.get &#10216;i, h&#10217;
1444     ensureAtomicBinderName binderView
1445     withRef binderView.type <span class="constant">&lt;</span>| withLCtx s.lctx s.localInsts <span class="keyword">do</span>
1446       <span class="keyword">let</span> type       &#8592; elabType binderView.type
1447       registerFailedToInferBinderTypeInfo type binderView.type
1448       <span class="keyword">let</span> fvarId &#8592; mkFreshFVarId
1449       <span class="keyword">let</span> fvar  <span class="constant">:=</span> mkFVar fvarId
1450       <span class="keyword">let</span> s     <span class="constant">:=</span> { s <span class="keyword">with</span> fvars <span class="constant">:=</span> s.fvars.push fvar }
1451       <span class="comment-delimiter">-- </span><span class="comment">dbgTrace (toString binderView.id.getId ++ " : " ++ toString type)
</span>1452       <span class="comment-delimiter">/-</span><span class="comment">
1453         We do **not** want to support default and auto arguments in lambda abstractions.
1454         Example: `fun (x : Nat := 10) =&gt; x+1`.
1455         We do not believe this is an useful feature, and it would complicate the logic here.
1456       -/</span>
1457       <span class="keyword">let</span> lctx  <span class="constant">:=</span> s.lctx.mkLocalDecl fvarId binderView.id.getId type binderView.bi
1458       addLocalVarInfoCore lctx binderView.id fvar
1459       <span class="keyword">let</span> s &#8592; withRef binderView.id <span class="constant">&lt;</span>| propagateExpectedType fvar type s
1460       <span class="keyword">let</span> s <span class="constant">:=</span> { s <span class="keyword">with</span> lctx <span class="constant">:=</span> lctx }
1461       <span class="keyword">match</span> (&#8592; isClass? type) <span class="keyword">with</span>
1462       | none           <span class="constant">=&gt;</span> elabFunBinderViews binderViews (i<span class="constant">+1</span>) s
1463       | some className <span class="constant">=&gt;</span>
1464         resettingSynthInstanceCache <span class="keyword">do</span>
1465           <span class="keyword">let</span> localInsts <span class="constant">:=</span> s.localInsts.push { className <span class="constant">:=</span> className, fvar <span class="constant">:=</span> mkFVar fvarId }
1466           elabFunBinderViews binderViews (i<span class="constant">+1</span>) { s <span class="keyword">with</span> localInsts <span class="constant">:=</span> localInsts }
1467   <span class="keyword">else</span>
1468     pure s
1469 
<span class="keyword">1470 partial</span> <span class="keyword">def</span> <span class="function-name">elabFunBindersAux</span> (binders : Array Syntax) (i : Nat) (s : State) : TermElabM State <span class="constant">:=</span> <span class="keyword">do</span>
1471   <span class="keyword">if</span> h : i <span class="constant">&lt;</span> binders.size <span class="keyword">then</span>
1472     <span class="keyword">let</span> binderViews &#8592; matchBinder (binders.get &#10216;i, h&#10217;)
1473     <span class="keyword">let</span> s &#8592; elabFunBinderViews binderViews <span class="constant">0</span> s
1474     elabFunBindersAux binders (i<span class="constant">+1</span>) s
1475   <span class="keyword">else</span>
1476     pure s
1477 
<span class="keyword">1478 end</span> FunBinders
1479 
<span class="keyword">1480 def</span> <span class="function-name">elabFunBinders</span> {&#945;} (binders : Array Syntax) (expectedType? : Option Expr) (x : Array Expr <span class="constant">&#8594;</span> Option Expr <span class="constant">&#8594;</span> TermElabM &#945;) : TermElabM &#945; <span class="constant">:=</span>
1481   <span class="keyword">if</span> binders.isEmpty <span class="keyword">then</span>
1482     x <span class="constant">#</span>[] expectedType?
1483   <span class="keyword">else</span> <span class="keyword">do</span>
1484     <span class="keyword">let</span> lctx &#8592; getLCtx
1485     <span class="keyword">let</span> localInsts &#8592; getLocalInstances
1486     <span class="keyword">let</span> s &#8592; FunBinders.elabFunBindersAux binders <span class="constant">0</span> { lctx <span class="constant">:=</span> lctx, localInsts <span class="constant">:=</span> localInsts, expectedType? <span class="constant">:=</span> expectedType? }
1487     resettingSynthInstanceCacheWhen (s.localInsts.size <span class="constant">&gt;</span> localInsts.size) <span class="constant">&lt;</span>| withLCtx s.lctx s.localInsts <span class="constant">&lt;</span>|
1488       x s.fvars s.expectedType?
1489 
<span class="comment-delimiter">1490 /- </span><span class="comment">Helper function for `expandEqnsIntoMatch` -/</span>
<span class="keyword">1491 private</span> <span class="keyword">def</span> <span class="function-name">getMatchAltsNumPatterns</span> (matchAlts : Syntax) : Nat <span class="constant">:=</span>
1492   <span class="keyword">let</span> alt0 <span class="constant">:=</span> matchAlts[<span class="constant">0</span>][<span class="constant">0</span>]
1493   <span class="keyword">let</span> pats <span class="constant">:=</span> alt0[<span class="constant">1</span>].getSepArgs
1494   pats.size
1495 
<span class="keyword">1496 def</span> <span class="function-name">expandWhereDecls</span> (whereDecls : Syntax) (body : Syntax) : MacroM Syntax <span class="constant">:=</span>
1497   <span class="keyword">match</span> whereDecls <span class="keyword">with</span>
1498   | `(whereDecls|<span class="keyword">where</span> <span class="constant">$</span>[<span class="constant">$</span>decls:letRecDecl <span class="constant">$</span>[;]?]<span class="constant">*</span>) <span class="constant">=&gt;</span> `(<span class="keyword">let</span> <span class="keyword">rec</span> <span class="constant">$</span>decls:letRecDecl,<span class="constant">*</span>; <span class="constant">$</span>body)
1499   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> Macro.throwUnsupported
1500 
<span class="keyword">1501 def</span> <span class="function-name">expandWhereDeclsOpt</span> (whereDeclsOpt : Syntax) (body : Syntax) : MacroM Syntax <span class="constant">:=</span>
1502   <span class="keyword">if</span> whereDeclsOpt.isNone <span class="keyword">then</span>
1503     body
1504   <span class="keyword">else</span>
1505     expandWhereDecls whereDeclsOpt[<span class="constant">0</span>] body
1506 
<span class="comment-delimiter">1507 /- </span><span class="comment">Helper function for `expandMatchAltsIntoMatch` -/</span>
<span class="keyword">1508 private</span> <span class="keyword">def</span> <span class="function-name">expandMatchAltsIntoMatchAux</span> (matchAlts : Syntax) (matchTactic : Bool) : Nat <span class="constant">&#8594;</span> Array Syntax <span class="constant">&#8594;</span> MacroM Syntax
1509   | <span class="constant">0</span>,   discrs <span class="constant">=&gt;</span> <span class="keyword">do</span>
1510     <span class="keyword">if</span> matchTactic <span class="keyword">then</span>
1511       `(tactic|<span class="keyword">match</span> <span class="constant">$</span>[<span class="constant">$</span>discrs:term],<span class="constant">*</span> <span class="keyword">with</span> <span class="constant">$</span>matchAlts:matchAlts)
1512     <span class="keyword">else</span>
1513       `(<span class="keyword">match</span> <span class="constant">$</span>[<span class="constant">$</span>discrs:term],<span class="constant">*</span> <span class="keyword">with</span> <span class="constant">$</span>matchAlts:matchAlts)
1514   | n<span class="constant">+1</span>, discrs <span class="constant">=&gt;</span> withFreshMacroScope <span class="keyword">do</span>
1515     <span class="keyword">let</span> x &#8592; `(x)
1516     <span class="keyword">let</span> d &#8592; `(<span class="constant">@$</span>x:ident) <span class="comment-delimiter">-- </span><span class="comment">See comment below
</span>1517     <span class="keyword">let</span> body &#8592; expandMatchAltsIntoMatchAux matchAlts matchTactic n (discrs.push d)
1518     <span class="keyword">if</span> matchTactic <span class="keyword">then</span>
1519       `(tactic| intro <span class="constant">$</span>x:term; <span class="constant">$</span>body:tactic)
1520     <span class="keyword">else</span>
1521       `(<span class="constant">@</span><span class="keyword">fun</span> <span class="constant">$</span>x <span class="constant">=&gt;</span> <span class="constant">$</span>body)
1522 
<span class="comment-delimiter">1523 /-</span><span class="comment">-
1524   Expand `matchAlts` syntax into a full `match`-expression.
1525   Example
1526     ```
1527     | 0, true =&gt; alt_1
1528     | i, _    =&gt; alt_2
1529     ```
1530     expands into (for tactic == false)
1531     ```
1532     fun x_1 x_2 =&gt;
1533     match @x_1, @x_2 with
1534     | 0, true =&gt; alt_1
1535     | i, _    =&gt; alt_2
1536     ```
1537     and (for tactic == true)
1538     ```
1539     intro x_1; intro x_2;
1540     match @x_1, @x_2 with
1541     | 0, true =&gt; alt_1
1542     | i, _    =&gt; alt_2
1543     ```
1544 
1545   Remark: we add `@` to make sure we don't consume implicit arguments, and to make the behavior consistent with `fun`.
1546   Example:
1547   ```
1548   inductive T : Type 1 :=
1549   | mkT : (forall {a : Type}, a -&gt; a) -&gt; T
1550 
1551   def makeT (f : forall {a : Type}, a -&gt; a) : T :=
1552     mkT f
1553 
1554   def makeT' : (forall {a : Type}, a -&gt; a) -&gt; T
1555   | f =&gt; mkT f
1556   ```
1557   The two definitions should be elaborated without errors and be equivalent.
1558  -/</span>
<span class="keyword">1559 def</span> <span class="function-name">expandMatchAltsIntoMatch</span> (ref : Syntax) (matchAlts : Syntax) (tactic <span class="constant">:=</span> false) : MacroM Syntax <span class="constant">:=</span>
1560   withRef ref <span class="constant">&lt;</span>| expandMatchAltsIntoMatchAux matchAlts tactic (getMatchAltsNumPatterns matchAlts) <span class="constant">#</span>[]
1561 
<span class="keyword">1562 def</span> <span class="function-name">expandMatchAltsIntoMatchTactic</span> (ref : Syntax) (matchAlts : Syntax) : MacroM Syntax <span class="constant">:=</span>
1563   withRef ref <span class="constant">&lt;</span>| expandMatchAltsIntoMatchAux matchAlts true (getMatchAltsNumPatterns matchAlts) <span class="constant">#</span>[]
1564 
<span class="comment-delimiter">1565 /-</span><span class="comment">-
1566   Similar to `expandMatchAltsIntoMatch`, but supports an optional `where` clause.
1567 
1568   Expand `matchAltsWhereDecls` into `let rec` + `match`-expression.
1569   Example
1570     ```
1571     | 0, true =&gt; ... f 0 ...
1572     | i, _    =&gt; ... f i + g i ...
1573     where
1574       f x := g x + 1
1575 
1576       g : Nat &#8594; Nat
1577         | 0   =&gt; 1
1578         | x+1 =&gt; f x
1579     ```
1580     expands into
1581     ```
1582     fux x_1 x_2 =&gt;
1583       let rec
1584         f x := g x + 1,
1585         g : Nat &#8594; Nat
1586           | 0   =&gt; 1
1587           | x+1 =&gt; f x
1588       match x_1, x_2 with
1589       | 0, true =&gt; ... f 0 ...
1590       | i, _    =&gt; ... f i + g i ...
1591     ```
1592 -/</span>
<span class="keyword">1593 def</span> <span class="function-name">expandMatchAltsWhereDecls</span> (matchAltsWhereDecls : Syntax) : MacroM Syntax <span class="constant">:=</span>
1594   <span class="keyword">let</span> matchAlts     <span class="constant">:=</span> matchAltsWhereDecls[<span class="constant">0</span>]
1595   <span class="keyword">let</span> whereDeclsOpt <span class="constant">:=</span> matchAltsWhereDecls[<span class="constant">1</span>]
1596   <span class="keyword">let</span> <span class="keyword">rec</span> loop (i : Nat) (discrs : Array Syntax) : MacroM Syntax <span class="constant">:=</span>
1597     <span class="keyword">match</span> i <span class="keyword">with</span>
1598     | <span class="constant">0</span>   <span class="constant">=&gt;</span> <span class="keyword">do</span>
1599       <span class="keyword">let</span> matchStx &#8592; `(<span class="keyword">match</span> <span class="constant">$</span>[<span class="constant">$</span>discrs:term],<span class="constant">*</span> <span class="keyword">with</span> <span class="constant">$</span>matchAlts:matchAlts)
1600       <span class="keyword">if</span> whereDeclsOpt.isNone <span class="keyword">then</span>
1601         <span class="keyword">return</span> matchStx
1602       <span class="keyword">else</span>
1603         expandWhereDeclsOpt whereDeclsOpt matchStx
1604     | n<span class="constant">+1</span> <span class="constant">=&gt;</span> withFreshMacroScope <span class="keyword">do</span>
1605       <span class="keyword">let</span> x &#8592; `(x)
1606       <span class="keyword">let</span> d &#8592; `(<span class="constant">@$</span>x:ident) <span class="comment-delimiter">-- </span><span class="comment">See comment at `expandMatchAltsIntoMatch`
</span>1607       <span class="keyword">let</span> body &#8592; loop n (discrs.push d)
1608       `(<span class="constant">@</span><span class="keyword">fun</span> <span class="constant">$</span>x <span class="constant">=&gt;</span> <span class="constant">$</span>body)
1609   loop (getMatchAltsNumPatterns matchAlts) <span class="constant">#</span>[]
1610 
<span class="constant">1611 @</span>[builtinTermElab <span class="comment">&#171;</span>fun<span class="comment">&#187;</span>] <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">elabFun</span> : TermElab <span class="constant">:=</span>
1612   <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span> loop stx expectedType?
<span class="keyword">1613 where</span>
1614   loop (stx : Syntax) (expectedType? : Option Expr) : TermElabM Expr <span class="constant">:=</span>
1615     <span class="keyword">match</span> stx <span class="keyword">with</span>
1616     | `(<span class="keyword">fun</span> <span class="constant">$</span>binders<span class="constant">*</span> <span class="constant">=&gt;</span> <span class="constant">$</span>body) <span class="constant">=&gt;</span> <span class="keyword">do</span>
1617       <span class="keyword">let</span> (binders, body, expandedPattern) &#8592; expandFunBinders binders body
1618       <span class="keyword">if</span> expandedPattern <span class="keyword">then</span>
1619         <span class="keyword">let</span> newStx &#8592; `(<span class="keyword">fun</span> <span class="constant">$</span>binders<span class="constant">*</span> <span class="constant">=&gt;</span> <span class="constant">$</span>body)
1620         loop newStx expectedType?
1621       <span class="keyword">else</span>
1622         elabFunBinders binders expectedType? <span class="keyword">fun</span> xs expectedType? <span class="constant">=&gt;</span> <span class="keyword">do</span>
1623           <span class="comment-delimiter">/- </span><span class="comment">We ensure the expectedType here since it will force coercions to be applied if needed.
1624              If we just use `elabTerm`, then we will need to a coercion `Coe (&#945; &#8594; &#946;) (&#945; &#8594; &#948;)` whenever there is a coercion `Coe &#946; &#948;`,
1625              and another instance for the dependent version. -/</span>
1626           <span class="keyword">let</span> e &#8592; elabTermEnsuringType body expectedType?
1627           mkLambdaFVars xs e
1628     | `(<span class="keyword">fun</span> <span class="constant">$</span>m:matchAlts) <span class="constant">=&gt;</span> <span class="keyword">do</span>
1629       <span class="keyword">let</span> stxNew &#8592; liftMacroM <span class="constant">$</span> expandMatchAltsIntoMatch stx m
1630       withMacroExpansion stx stxNew <span class="constant">$</span> elabTerm stxNew expectedType?
1631     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwUnsupportedSyntax
1632 
<span class="comment-delimiter">1633 /- </span><span class="comment">If `useLetExpr` is true, then a kernel let-expression `let x : type := val; body` is created.
1634    Otherwise, we create a term of the form `(fun (x : type) =&gt; body) val`
1635 
1636    The default elaboration order is `binders`, `typeStx`, `valStx`, and `body`.
1637    If `elabBodyFirst == true`, then we use the order `binders`, `typeStx`, `body`, and `valStx`. -/</span>
<span class="keyword">1638 def</span> <span class="function-name">elabLetDeclAux</span> (id : Syntax) (binders : Array Syntax) (typeStx : Syntax) (valStx : Syntax) (body : Syntax)
1639     (expectedType? : Option Expr) (useLetExpr : Bool) (elabBodyFirst : Bool) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
1640   <span class="keyword">let</span> (type, val, arity) &#8592; elabBinders binders <span class="keyword">fun</span> xs <span class="constant">=&gt;</span> <span class="keyword">do</span>
1641     <span class="keyword">let</span> type &#8592; elabType typeStx
1642     registerCustomErrorIfMVar type typeStx <span class="string">"failed to infer 'let' declaration type"</span>
1643     <span class="keyword">if</span> elabBodyFirst <span class="keyword">then</span>
1644       <span class="keyword">let</span> type &#8592; mkForallFVars xs type
1645       <span class="keyword">let</span> val  &#8592; mkFreshExprMVar type
1646       pure (type, val, xs.size)
1647     <span class="keyword">else</span>
1648       <span class="keyword">let</span> val  &#8592; elabTermEnsuringType valStx type
1649       <span class="keyword">let</span> type &#8592; mkForallFVars xs type
1650       <span class="keyword">let</span> val  &#8592; mkLambdaFVars xs val
1651       pure (type, val, xs.size)
1652   trace[Elab.<span class="keyword">let</span>.decl] <span class="string">"{id.getId} : {type} := {val}"</span>
1653   <span class="keyword">let</span> result &#8592;
1654     <span class="keyword">if</span> useLetExpr <span class="keyword">then</span>
1655       withLetDecl id.getId type val <span class="keyword">fun</span> x <span class="constant">=&gt;</span> <span class="keyword">do</span>
1656         addLocalVarInfo id x
1657         <span class="keyword">let</span> body &#8592; elabTerm body expectedType?
1658         <span class="keyword">let</span> body &#8592; instantiateMVars body
1659         mkLetFVars <span class="constant">#</span>[x] body
1660     <span class="keyword">else</span>
1661       <span class="keyword">let</span> f &#8592; withLocalDecl id.getId BinderInfo.default type <span class="keyword">fun</span> x <span class="constant">=&gt;</span> <span class="keyword">do</span>
1662         addLocalVarInfo id x
1663         <span class="keyword">let</span> body &#8592; elabTerm body expectedType?
1664         <span class="keyword">let</span> body &#8592; instantiateMVars body
1665         mkLambdaFVars <span class="constant">#</span>[x] body
1666       pure <span class="constant">&lt;</span>| mkApp f val
1667   <span class="keyword">if</span> elabBodyFirst <span class="keyword">then</span>
1668     forallBoundedTelescope type arity <span class="keyword">fun</span> xs type <span class="constant">=&gt;</span> <span class="keyword">do</span>
1669       <span class="keyword">let</span> valResult &#8592; elabTermEnsuringType valStx type
1670       <span class="keyword">let</span> valResult &#8592; mkLambdaFVars xs valResult
1671       <span class="keyword">unless</span> (&#8592; isDefEq val valResult) <span class="keyword">do</span>
1672         throwError <span class="string">"unexpected error when elaborating 'let'"</span>
1673   pure result
1674 
<span class="keyword">1675 structure</span> <span class="function-name">LetIdDeclView</span> <span class="keyword">where</span>
1676   id      : Syntax
1677   binders : Array Syntax
1678   type    : Syntax
1679   value   : Syntax
1680 
<span class="keyword">1681 def</span> <span class="function-name">mkLetIdDeclView</span> (letIdDecl : Syntax) : LetIdDeclView <span class="constant">:=</span>
1682   <span class="comment-delimiter">-- </span><span class="comment">`letIdDecl` is of the form `ident &gt;&gt; many bracketedBinder &gt;&gt; optType &gt;&gt; " := " &gt;&gt; termParser
</span>1683   <span class="keyword">let</span> id      <span class="constant">:=</span> letIdDecl[<span class="constant">0</span>]
1684   <span class="keyword">let</span> binders <span class="constant">:=</span> letIdDecl[<span class="constant">1</span>].getArgs
1685   <span class="keyword">let</span> optType <span class="constant">:=</span> letIdDecl[<span class="constant">2</span>]
1686   <span class="keyword">let</span> type    <span class="constant">:=</span> expandOptType letIdDecl optType
1687   <span class="keyword">let</span> value   <span class="constant">:=</span> letIdDecl[<span class="constant">4</span>]
1688   { id <span class="constant">:=</span> id, binders <span class="constant">:=</span> binders, type <span class="constant">:=</span> type, value <span class="constant">:=</span> value }
1689 
<span class="keyword">1690 def</span> <span class="function-name">expandLetEqnsDecl</span> (letDecl : Syntax) : MacroM Syntax <span class="constant">:=</span> <span class="keyword">do</span>
1691   <span class="keyword">let</span> ref       <span class="constant">:=</span> letDecl
1692   <span class="keyword">let</span> matchAlts <span class="constant">:=</span> letDecl[<span class="constant">3</span>]
1693   <span class="keyword">let</span> val &#8592; expandMatchAltsIntoMatch ref matchAlts
1694   <span class="keyword">return</span> Syntax.node `Lean.Parser.Term.letIdDecl <span class="constant">#</span>[letDecl[<span class="constant">0</span>], letDecl[<span class="constant">1</span>], letDecl[<span class="constant">2</span>], mkAtomFrom ref <span class="string">" := "</span>, val]
1695 
<span class="keyword">1696 def</span> <span class="function-name">elabLetDeclCore</span> (stx : Syntax) (expectedType? : Option Expr) (useLetExpr : Bool) (elabBodyFirst : Bool) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
1697   <span class="keyword">let</span> ref     <span class="constant">:=</span> stx
1698   <span class="keyword">let</span> letDecl <span class="constant">:=</span> stx[<span class="constant">1</span>][<span class="constant">0</span>]
1699   <span class="keyword">let</span> body    <span class="constant">:=</span> stx[<span class="constant">3</span>]
1700   <span class="keyword">if</span> letDecl.getKind <span class="constant">==</span> `Lean.Parser.Term.letIdDecl <span class="keyword">then</span>
1701     <span class="keyword">let</span> { id <span class="constant">:=</span> id, binders <span class="constant">:=</span> binders, type <span class="constant">:=</span> type, value <span class="constant">:=</span> val } <span class="constant">:=</span> mkLetIdDeclView letDecl
1702     elabLetDeclAux id binders type val body expectedType? useLetExpr elabBodyFirst
1703   <span class="keyword">else</span> <span class="keyword">if</span> letDecl.getKind <span class="constant">==</span> `Lean.Parser.Term.letPatDecl <span class="keyword">then</span>
1704     <span class="comment-delimiter">-- </span><span class="comment">node `Lean.Parser.Term.letPatDecl  $ try (termParser &gt;&gt; pushNone &gt;&gt; optType &gt;&gt; " := ") &gt;&gt; termParser
</span>1705     <span class="keyword">let</span> pat     <span class="constant">:=</span> letDecl[<span class="constant">0</span>]
1706     <span class="keyword">let</span> optType <span class="constant">:=</span> letDecl[<span class="constant">2</span>]
1707     <span class="keyword">let</span> type    <span class="constant">:=</span> expandOptType stx optType
1708     <span class="keyword">let</span> val     <span class="constant">:=</span> letDecl[<span class="constant">4</span>]
1709     <span class="keyword">let</span> stxNew &#8592; `(<span class="keyword">let</span> x : <span class="constant">$</span>type <span class="constant">:=</span> <span class="constant">$</span>val; <span class="keyword">match</span> x <span class="keyword">with</span> | <span class="constant">$</span>pat <span class="constant">=&gt;</span> <span class="constant">$</span>body)
1710     <span class="keyword">let</span> stxNew  <span class="constant">:=</span> <span class="keyword">match</span> useLetExpr, elabBodyFirst <span class="keyword">with</span>
1711       | true,  false <span class="constant">=&gt;</span> stxNew
1712       | true,  true  <span class="constant">=&gt;</span> stxNew.setKind `Lean.Parser.Term.<span class="comment">&#171;</span>let_delayed<span class="comment">&#187;</span>
1713       | false, true  <span class="constant">=&gt;</span> stxNew.setKind `Lean.Parser.Term.<span class="comment">&#171;</span>let_fun<span class="comment">&#187;</span>
1714       | false, false <span class="constant">=&gt;</span> <span class="warning">unreachable</span><span class="constant">!</span>
1715     withMacroExpansion stx stxNew <span class="constant">&lt;</span>| elabTerm stxNew expectedType?
1716   <span class="keyword">else</span> <span class="keyword">if</span> letDecl.getKind <span class="constant">==</span> `Lean.Parser.Term.letEqnsDecl <span class="keyword">then</span>
1717     <span class="keyword">let</span> letDeclIdNew &#8592; liftMacroM <span class="constant">&lt;</span>| expandLetEqnsDecl letDecl
1718     <span class="keyword">let</span> declNew <span class="constant">:=</span> stx[<span class="constant">1</span>].setArg <span class="constant">0</span> letDeclIdNew
1719     <span class="keyword">let</span> stxNew  <span class="constant">:=</span> stx.setArg <span class="constant">1</span> declNew
1720     withMacroExpansion stx stxNew <span class="constant">&lt;</span>| elabTerm stxNew expectedType?
1721   <span class="keyword">else</span>
1722     throwUnsupportedSyntax
1723 
<span class="constant">1724 @</span>[builtinTermElab <span class="comment">&#171;</span>let<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabLetDecl</span> : TermElab <span class="constant">:=</span>
1725   <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span> elabLetDeclCore stx expectedType? true false
1726 
<span class="constant">1727 @</span>[builtinTermElab <span class="comment">&#171;</span>let_fun<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabLetFunDecl</span> : TermElab <span class="constant">:=</span>
1728   <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span> elabLetDeclCore stx expectedType? false false
1729 
<span class="constant">1730 @</span>[builtinTermElab <span class="comment">&#171;</span>let_delayed<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabLetDelayedDecl</span> : TermElab <span class="constant">:=</span>
1731   <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span> elabLetDeclCore stx expectedType? true true
1732 
<span class="keyword">1733 builtin_initialize</span> registerTraceClass `Elab.<span class="keyword">let</span>
1734 
<span class="keyword">1735 end</span> Lean.Elab.Term
1736 ::::::::::::::
1737 Elab<span class="constant">/</span>BuiltinNotation.lean
1738 ::::::::::::::
<span class="comment-delimiter">1739 /-</span><span class="comment">
1740 Copyright (c) 2019 Microsoft Corporation. All rights reserved.
1741 Released under Apache 2.0 license as described in the file LICENSE.
1742 Authors: Leonardo de Moura
1743 -/</span>
<span class="keyword">1744 import</span> Init.Data.ToString
<span class="keyword">1745 import</span> Lean.Compiler.BorrowedAnnotation
<span class="keyword">1746 import</span> Lean.Meta.KAbstract
<span class="keyword">1747 import</span> Lean.Meta.Transform
<span class="keyword">1748 import</span> Lean.Elab.Term
<span class="keyword">1749 import</span> Lean.Elab.SyntheticMVars
1750 
<span class="keyword">1751 namespace</span> Lean.Elab.Term
<span class="keyword">1752 open</span> Meta
1753 
<span class="doc">1754 @[builtinTermElab anonymousCtor]</span> <span class="keyword">def</span> <span class="function-name">elabAnonymousCtor</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span>
1755   <span class="keyword">match</span> stx <span class="keyword">with</span>
1756   | `(&#10216;<span class="constant">$</span>args,<span class="constant">*</span>&#10217;) <span class="constant">=&gt;</span> <span class="keyword">do</span>
1757     tryPostponeIfNoneOrMVar expectedType?
1758     <span class="keyword">match</span> expectedType? <span class="keyword">with</span>
1759     | some expectedType <span class="constant">=&gt;</span>
1760       <span class="keyword">let</span> expectedType &#8592; whnf expectedType
1761       matchConstInduct expectedType.getAppFn
1762         (<span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwError <span class="string">"invalid constructor &#10216;...&#10217;, expected type must be an inductive type {indentExpr expectedType}"</span>)
1763         (<span class="keyword">fun</span> ival us <span class="constant">=&gt;</span> <span class="keyword">do</span>
1764           <span class="keyword">match</span> ival.ctors <span class="keyword">with</span>
1765           | [ctor] <span class="constant">=&gt;</span>
1766             <span class="keyword">let</span> cinfo &#8592; getConstInfoCtor ctor
1767             <span class="keyword">let</span> numExplicitFields &#8592; forallTelescopeReducing cinfo.type <span class="keyword">fun</span> xs <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">do</span>
1768               <span class="keyword">let</span> <span class="keyword">mut</span> n <span class="constant">:=</span> <span class="constant">0</span>
1769               <span class="keyword">for</span> i <span class="keyword">in</span> [cinfo.numParams:xs.size] <span class="keyword">do</span>
1770                 <span class="keyword">if</span> (&#8592; getFVarLocalDecl xs[i]).binderInfo.isExplicit <span class="keyword">then</span>
1771                   n <span class="constant">:=</span> n <span class="constant">+</span> <span class="constant">1</span>
1772               <span class="keyword">return</span> n
1773             <span class="keyword">let</span> args <span class="constant">:=</span> args.getElems
1774             <span class="keyword">if</span> args.size <span class="constant">&lt;</span> numExplicitFields <span class="keyword">then</span>
1775               throwError <span class="string">"invalid constructor &#10216;...&#10217;, insufficient number of arguments, constructs '{ctor}' has #{numExplicitFields} explicit fields, but only #{args.size} provided"</span>
1776             <span class="keyword">let</span> newStx &#8592;
1777               <span class="keyword">if</span> args.size <span class="constant">==</span> numExplicitFields <span class="keyword">then</span>
1778                 `(<span class="constant">$</span>(mkCIdentFrom stx ctor) <span class="constant">$</span>(args)<span class="constant">*</span>)
1779               <span class="keyword">else</span> <span class="keyword">if</span> numExplicitFields <span class="constant">==</span> <span class="constant">0</span> <span class="keyword">then</span>
1780                 throwError <span class="string">"invalid constructor &#10216;...&#10217;, insufficient number of arguments, constructs '{ctor}' does not have explicit fields, but #{args.size} provided"</span>
1781               <span class="keyword">else</span>
1782                 <span class="keyword">let</span> extra <span class="constant">:=</span> args[numExplicitFields<span class="constant">-1</span>:args.size]
1783                 <span class="keyword">let</span> newLast &#8592; `(&#10216;<span class="constant">$</span>[<span class="constant">$</span>extra],<span class="constant">*</span>&#10217;)
1784                 <span class="keyword">let</span> newArgs <span class="constant">:=</span> args[<span class="constant">0</span>:numExplicitFields<span class="constant">-1</span>].toArray.push newLast
1785                 `(<span class="constant">$</span>(mkCIdentFrom stx ctor) <span class="constant">$</span>(newArgs)<span class="constant">*</span>)
1786             withMacroExpansion stx newStx <span class="constant">$</span> elabTerm newStx expectedType?
1787           | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwError <span class="string">"invalid constructor &#10216;...&#10217;, expected type must be an inductive type with only one constructor {indentExpr expectedType}"</span>)
1788     | none <span class="constant">=&gt;</span> throwError <span class="string">"invalid constructor &#10216;...&#10217;, expected type must be known"</span>
1789   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwUnsupportedSyntax
1790 
<span class="doc">1791 @[builtinTermElab borrowed]</span> <span class="keyword">def</span> <span class="function-name">elabBorrowed</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span>
1792   <span class="keyword">match</span> stx <span class="keyword">with</span>
1793   | `(<span class="constant">@</span>&amp; <span class="constant">$</span>e) <span class="constant">=&gt;</span> <span class="keyword">return</span> markBorrowed (&#8592; elabTerm e expectedType?)
1794   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwUnsupportedSyntax
1795 
<span class="doc">1796 @[builtinMacro Lean.Parser.Term.show]</span> <span class="keyword">def</span> <span class="function-name">expandShow</span> : Macro <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="constant">=&gt;</span>
1797   <span class="keyword">match</span> stx <span class="keyword">with</span>
1798   | `(<span class="keyword">show</span> <span class="constant">$</span>type <span class="keyword">from</span> <span class="constant">$</span>val)         <span class="constant">=&gt;</span> <span class="keyword">let</span> thisId <span class="constant">:=</span> mkIdentFrom stx `<span class="keyword">this</span>; `(let_fun <span class="constant">$</span>thisId : <span class="constant">$</span>type <span class="constant">:=</span> <span class="constant">$</span>val; <span class="constant">$</span>thisId)
1799   | `(<span class="keyword">show</span> <span class="constant">$</span>type <span class="keyword">by</span> <span class="constant">$</span>tac:tacticSeq) <span class="constant">=&gt;</span> `(<span class="keyword">show</span> <span class="constant">$</span>type <span class="keyword">from</span> <span class="keyword">by</span> <span class="constant">$</span>tac:tacticSeq)
1800   | <span class="preprocessor">_</span>                               <span class="constant">=&gt;</span> Macro.throwUnsupported
1801 
<span class="doc">1802 @[builtinMacro Lean.Parser.Term.have]</span> <span class="keyword">def</span> <span class="function-name">expandHave</span> : Macro <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="constant">=&gt;</span>
1803   <span class="keyword">let</span> mkId (x? : Option Syntax) : Syntax <span class="constant">:=</span>
1804     x?.getD <span class="constant">&lt;</span>| mkIdentFrom stx `<span class="keyword">this</span>
1805   <span class="keyword">match</span> stx <span class="keyword">with</span>
1806   | `(<span class="keyword">have</span> <span class="constant">$</span>[<span class="constant">$</span>x :]? <span class="constant">$</span>type <span class="keyword">from</span> <span class="constant">$</span>val <span class="constant">$</span>[;]? <span class="constant">$</span>body)              <span class="constant">=&gt;</span> <span class="keyword">let</span> x <span class="constant">:=</span> mkId x; `(let_fun <span class="constant">$</span>x : <span class="constant">$</span>type <span class="constant">:=</span> <span class="constant">$</span>val; <span class="constant">$</span>body)
1807   | `(<span class="keyword">have</span> <span class="constant">$</span>[<span class="constant">$</span>x :]? <span class="constant">$</span>type <span class="constant">:=</span> <span class="constant">$</span>val <span class="constant">$</span>[;]? <span class="constant">$</span>body)                <span class="constant">=&gt;</span> <span class="keyword">let</span> x <span class="constant">:=</span> mkId x; `(let_fun <span class="constant">$</span>x : <span class="constant">$</span>type <span class="constant">:=</span> <span class="constant">$</span>val; <span class="constant">$</span>body)
1808   | `(<span class="keyword">have</span> <span class="constant">$</span>[<span class="constant">$</span>x :]? <span class="constant">$</span>type <span class="keyword">by</span> <span class="constant">$</span>tac:tacticSeq <span class="constant">$</span>[;]? <span class="constant">$</span>body)      <span class="constant">=&gt;</span> `(<span class="keyword">have</span> <span class="constant">$</span>[<span class="constant">$</span>x :]? <span class="constant">$</span>type <span class="keyword">from</span> <span class="keyword">by</span> <span class="constant">$</span>tac:tacticSeq; <span class="constant">$</span>body)
1809   | <span class="preprocessor">_</span>                                                         <span class="constant">=&gt;</span> Macro.throwUnsupported
1810 
<span class="doc">1811 @[builtinMacro Lean.Parser.Term.suffices]</span> <span class="keyword">def</span> <span class="function-name">expandSuffices</span> : Macro
1812   | `(<span class="keyword">suffices</span> <span class="constant">$</span>[<span class="constant">$</span>x :]? <span class="constant">$</span>type <span class="keyword">from</span> <span class="constant">$</span>val <span class="constant">$</span>[;]? <span class="constant">$</span>body)         <span class="constant">=&gt;</span> `(<span class="keyword">have</span> <span class="constant">$</span>[<span class="constant">$</span>x :]? <span class="constant">$</span>type <span class="keyword">from</span> <span class="constant">$</span>body; <span class="constant">$</span>val)
1813   | `(<span class="keyword">suffices</span> <span class="constant">$</span>[<span class="constant">$</span>x :]? <span class="constant">$</span>type <span class="keyword">by</span> <span class="constant">$</span>tac:tacticSeq <span class="constant">$</span>[;]? <span class="constant">$</span>body) <span class="constant">=&gt;</span> `(<span class="keyword">have</span> <span class="constant">$</span>[<span class="constant">$</span>x :]? <span class="constant">$</span>type <span class="keyword">from</span> <span class="constant">$</span>body; <span class="keyword">by</span> <span class="constant">$</span>tac:tacticSeq)
1814   | <span class="preprocessor">_</span>                                                        <span class="constant">=&gt;</span> Macro.throwUnsupported
1815 
<span class="keyword">1816 private</span> <span class="keyword">def</span> <span class="function-name">elabParserMacroAux</span> (prec : Syntax) (e : Syntax) : TermElabM Syntax <span class="constant">:=</span> <span class="keyword">do</span>
1817   <span class="keyword">let</span> (some declName) &#8592; getDeclName?
1818     | throwError <span class="string">"invalid `leading_parser` macro, it must be used in definitions"</span>
1819   <span class="keyword">match</span> extractMacroScopes declName <span class="keyword">with</span>
1820   | { name <span class="constant">:=</span> Name.str <span class="preprocessor">_</span> s <span class="preprocessor">_</span>, scopes <span class="constant">:=</span>  scps, .. } <span class="constant">=&gt;</span>
1821     <span class="keyword">let</span> kind <span class="constant">:=</span> quote declName
1822     <span class="keyword">let</span> s    <span class="constant">:=</span> quote s
1823     <span class="keyword">let</span> p &#8592; `(Lean.Parser.leadingNode <span class="constant">$</span>kind <span class="constant">$</span>prec <span class="constant">$</span>e)
1824     <span class="keyword">if</span> scps <span class="constant">==</span> [] <span class="keyword">then</span>
1825       <span class="comment-delimiter">-- </span><span class="comment">TODO simplify the following quotation as soon as we have coercions
</span>1826       `(OrElse.orElse (Lean.Parser.mkAntiquot <span class="constant">$</span>s (some <span class="constant">$</span>kind)) <span class="constant">$</span>p)
1827     <span class="keyword">else</span>
1828       <span class="comment-delimiter">-- </span><span class="comment">if the parser decl is hidden by hygiene, it doesn't make sense to provide an antiquotation kind
</span>1829       `(OrElse.orElse (Lean.Parser.mkAntiquot <span class="constant">$</span>s none) <span class="constant">$</span>p)
1830   | <span class="preprocessor">_</span>  <span class="constant">=&gt;</span> throwError <span class="string">"invalid `leading_parser` macro, unexpected declaration name"</span>
1831 
<span class="constant">1832 @</span>[builtinTermElab <span class="comment">&#171;</span>leading_parser<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabLeadingParserMacro</span> : TermElab <span class="constant">:=</span>
1833   adaptExpander <span class="keyword">fun</span> stx <span class="constant">=&gt;</span> <span class="keyword">match</span> stx <span class="keyword">with</span>
1834   | `(leading_parser <span class="constant">$</span>e)         <span class="constant">=&gt;</span> elabParserMacroAux (quote Parser.maxPrec) e
1835   | `(leading_parser : <span class="constant">$</span>prec <span class="constant">$</span>e) <span class="constant">=&gt;</span> elabParserMacroAux prec e
1836   | <span class="preprocessor">_</span>                            <span class="constant">=&gt;</span> throwUnsupportedSyntax
1837 
<span class="keyword">1838 private</span> <span class="keyword">def</span> <span class="function-name">elabTParserMacroAux</span> (prec lhsPrec : Syntax) (e : Syntax) : TermElabM Syntax <span class="constant">:=</span> <span class="keyword">do</span>
1839   <span class="keyword">let</span> declName? &#8592; getDeclName?
1840   <span class="keyword">match</span> declName? <span class="keyword">with</span>
1841   | some declName <span class="constant">=&gt;</span> <span class="keyword">let</span> kind <span class="constant">:=</span> quote declName; `(Lean.Parser.trailingNode <span class="constant">$</span>kind <span class="constant">$</span>prec <span class="constant">$</span>lhsPrec <span class="constant">$</span>e)
1842   | none          <span class="constant">=&gt;</span> throwError <span class="string">"invalid `trailing_parser` macro, it must be used in definitions"</span>
1843 
<span class="constant">1844 @</span>[builtinTermElab <span class="comment">&#171;</span>trailing_parser<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabTrailingParserMacro</span> : TermElab <span class="constant">:=</span>
1845   adaptExpander <span class="keyword">fun</span> stx <span class="constant">=&gt;</span> <span class="keyword">match</span> stx <span class="keyword">with</span>
1846   | `(trailing_parser<span class="constant">$</span>[:<span class="constant">$</span>prec?]?<span class="constant">$</span>[:<span class="constant">$</span>lhsPrec?]? <span class="constant">$</span>e) <span class="constant">=&gt;</span>
1847     elabTParserMacroAux (prec?.getD <span class="constant">&lt;</span>| quote Parser.maxPrec) (lhsPrec?.getD <span class="constant">&lt;</span>| quote <span class="constant">0</span>) e
1848   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwUnsupportedSyntax
1849 
<span class="doc">1850 @[builtinTermElab panic]</span> <span class="keyword">def</span> <span class="function-name">elabPanic</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span> <span class="keyword">do</span>
1851   <span class="keyword">let</span> arg <span class="constant">:=</span> stx[<span class="constant">1</span>]
1852   <span class="keyword">let</span> pos &#8592; getRefPosition
1853   <span class="keyword">let</span> env &#8592; getEnv
1854   <span class="keyword">let</span> stxNew &#8592; <span class="keyword">match</span> (&#8592; getDeclName?) <span class="keyword">with</span>
1855   | some declName <span class="constant">=&gt;</span> `(<span class="warning">panic</span>WithPosWithDecl <span class="constant">$</span>(quote (toString env.mainModule)) <span class="constant">$</span>(quote (toString declName)) <span class="constant">$</span>(quote pos.line) <span class="constant">$</span>(quote pos.column) <span class="constant">$</span>arg)
1856   | none <span class="constant">=&gt;</span> `(<span class="warning">panic</span>WithPos <span class="constant">$</span>(quote (toString env.mainModule)) <span class="constant">$</span>(quote pos.line) <span class="constant">$</span>(quote pos.column) <span class="constant">$</span>arg)
1857   withMacroExpansion stx stxNew <span class="constant">$</span> elabTerm stxNew expectedType?
1858 
<span class="doc">1859 @[builtinMacro Lean.Parser.Term.unreachable]</span>  <span class="keyword">def</span> <span class="function-name">expandUnreachable</span> : Macro <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="constant">=&gt;</span>
1860   `(<span class="warning">panic</span><span class="constant">!</span> <span class="string">"unreachable code has been reached"</span>)
1861 
<span class="doc">1862 @[builtinMacro Lean.Parser.Term.assert]</span>  <span class="keyword">def</span> <span class="function-name">expandAssert</span> : Macro <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="constant">=&gt;</span>
1863   <span class="comment-delimiter">-- </span><span class="comment">TODO: support for disabling runtime assertions
</span>1864   <span class="keyword">let</span> cond <span class="constant">:=</span> stx[<span class="constant">1</span>]
1865   <span class="keyword">let</span> body <span class="constant">:=</span> stx[<span class="constant">3</span>]
1866   <span class="keyword">match</span> cond.reprint <span class="keyword">with</span>
1867   | some code <span class="constant">=&gt;</span> `(<span class="keyword">if</span> <span class="constant">$</span>cond <span class="keyword">then</span> <span class="constant">$</span>body <span class="keyword">else</span> <span class="warning">panic</span><span class="constant">!</span> (<span class="string">"assertion violation: "</span> <span class="constant">++</span> <span class="constant">$</span>(quote code)))
1868   | none <span class="constant">=&gt;</span> `(<span class="keyword">if</span> <span class="constant">$</span>cond <span class="keyword">then</span> <span class="constant">$</span>body <span class="keyword">else</span> <span class="warning">panic</span><span class="constant">!</span> (<span class="string">"assertion violation"</span>))
1869 
<span class="doc">1870 @[builtinMacro Lean.Parser.Term.dbgTrace]</span>  <span class="keyword">def</span> <span class="function-name">expandDbgTrace</span> : Macro <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="constant">=&gt;</span>
1871   <span class="keyword">let</span> arg  <span class="constant">:=</span> stx[<span class="constant">1</span>]
1872   <span class="keyword">let</span> body <span class="constant">:=</span> stx[<span class="constant">3</span>]
1873   <span class="keyword">if</span> arg.getKind <span class="constant">==</span> interpolatedStrKind <span class="keyword">then</span>
1874     `(<span class="warning">dbgTrace</span> (s<span class="constant">!</span> <span class="constant">$</span>arg) <span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="constant">$</span>body)
1875   <span class="keyword">else</span>
1876     `(<span class="warning">dbgTrace</span> (toString <span class="constant">$</span>arg) <span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="constant">$</span>body)
1877 
<span class="constant">1878 @</span>[builtinTermElab <span class="comment">&#171;</span>sorry<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabSorry</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span> <span class="keyword">do</span>
1879   logWarning <span class="string">"declaration uses 'sorry'"</span>
1880   <span class="keyword">let</span> stxNew &#8592; `(sorryAx <span class="preprocessor">_</span> false)
1881   withMacroExpansion stx stxNew <span class="constant">&lt;</span>| elabTerm stxNew expectedType?
1882 
<span class="doc">1883 @[builtinTermElab emptyC]</span> <span class="keyword">def</span> <span class="function-name">expandEmptyC</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span> <span class="keyword">do</span>
1884   <span class="keyword">let</span> stxNew &#8592; `(EmptyCollection.emptyCollection)
1885   withMacroExpansion stx stxNew <span class="constant">$</span> elabTerm stxNew expectedType?
1886 
<span class="comment-delimiter">1887 /-</span><span class="comment">- Return syntax `Prod.mk elems[0] (Prod.mk elems[1] ... (Prod.mk elems[elems.size - 2] elems[elems.size - 1])))` -/</span>
<span class="keyword">1888 partial</span> <span class="keyword">def</span> <span class="function-name">mkPairs</span> (elems : Array Syntax) : MacroM Syntax <span class="constant">:=</span>
1889   <span class="keyword">let</span> <span class="keyword">rec</span> loop (i : Nat) (acc : Syntax) <span class="constant">:=</span> <span class="keyword">do</span>
1890     <span class="keyword">if</span> i <span class="constant">&gt;</span> <span class="constant">0</span> <span class="keyword">then</span>
1891       <span class="keyword">let</span> i    <span class="constant">:=</span> i <span class="constant">-</span> <span class="constant">1</span>
1892       <span class="keyword">let</span> elem <span class="constant">:=</span> elems[i]
1893       <span class="keyword">let</span> acc &#8592; `(Prod.mk <span class="constant">$</span>elem <span class="constant">$</span>acc)
1894       loop i acc
1895     <span class="keyword">else</span>
1896       pure acc
1897   loop (elems.size <span class="constant">-</span> <span class="constant">1</span>) elems.back
1898 
<span class="keyword">1899 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">hasCDot</span> : Syntax <span class="constant">&#8594;</span> Bool
1900   | Syntax.node k args <span class="constant">=&gt;</span>
1901     <span class="keyword">if</span> k <span class="constant">==</span> `Lean.Parser.Term.paren <span class="keyword">then</span> false
1902     <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> `Lean.Parser.Term.cdot <span class="keyword">then</span> true
1903     <span class="keyword">else</span> args.any hasCDot
1904   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> false
1905 
<span class="comment-delimiter">1906 /-</span><span class="comment">-
1907   Auxiliary function for expandind the `&#183;` notation.
1908   The extra state `Array Syntax` contains the new binder names.
1909   If `stx` is a `&#183;`, we create a fresh identifier, store in the
1910   extra state, and return it. Otherwise, we just return `stx`. -/</span>
<span class="keyword">1911 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">expandCDot</span> : Syntax <span class="constant">&#8594;</span> StateT (Array Syntax) MacroM Syntax
1912   | stx<span class="constant">@</span>(Syntax.node k args) <span class="constant">=&gt;</span>
1913     <span class="keyword">if</span> k <span class="constant">==</span> `Lean.Parser.Term.paren <span class="keyword">then</span> pure stx
1914     <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> `Lean.Parser.Term.cdot <span class="keyword">then</span> withFreshMacroScope <span class="keyword">do</span>
1915       <span class="keyword">let</span> id &#8592; `(a)
1916       modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> s.push id;
1917       pure id
1918     <span class="keyword">else</span> <span class="keyword">do</span>
1919       <span class="keyword">let</span> args &#8592; args.mapM expandCDot
1920       pure <span class="constant">$</span> Syntax.node k args
1921   | stx <span class="constant">=&gt;</span> pure stx
1922 
<span class="comment-delimiter">1923 /-</span><span class="comment">-
1924   Return `some` if succeeded expanding `&#183;` notation occurring in
1925   the given syntax. Otherwise, return `none`.
1926   Examples:
1927   - `&#183; + 1` =&gt; `fun _a_1 =&gt; _a_1 + 1`
1928   - `f &#183; &#183; b` =&gt; `fun _a_1 _a_2 =&gt; f _a_1 _a_2 b` -/</span>
<span class="keyword">1929 def</span> <span class="function-name">expandCDot?</span> (stx : Syntax) : MacroM (Option Syntax) <span class="constant">:=</span> <span class="keyword">do</span>
1930   <span class="keyword">if</span> hasCDot stx <span class="keyword">then</span>
1931     <span class="keyword">let</span> (newStx, binders) &#8592; (expandCDot stx).run <span class="constant">#</span>[];
1932     `(<span class="keyword">fun</span> <span class="constant">$</span>binders<span class="constant">*</span> <span class="constant">=&gt;</span> <span class="constant">$</span>newStx)
1933   <span class="keyword">else</span>
1934     pure none
1935 
<span class="comment-delimiter">1936 /-</span><span class="comment">-
1937   Try to expand `&#183;` notation, and if successful elaborate result.
1938   This method is used to elaborate the Lean parentheses notation.
1939   Recall that in Lean the `&#183;` notation must be surrounded by parentheses.
1940   We may change this is the future, but right now, here are valid examples
1941   - `(&#183; + 1)`
1942   - `(f &#10216;&#183;, 1&#10217; &#183;)`
1943   - `(&#183; + &#183;)`
1944   - `(f &#183; a b)` -/</span>
<span class="keyword">1945 private</span> <span class="keyword">def</span> <span class="function-name">elabCDot</span> (stx : Syntax) (expectedType? : Option Expr) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
1946   <span class="keyword">match</span> (&#8592; liftMacroM <span class="constant">&lt;</span>| expandCDot? stx) <span class="keyword">with</span>
1947   | some stx' <span class="constant">=&gt;</span> withMacroExpansion stx stx' (elabTerm stx' expectedType?)
1948   | none      <span class="constant">=&gt;</span> elabTerm stx expectedType?
1949 
<span class="comment-delimiter">1950 /-</span><span class="comment">-
1951   Helper method for elaborating terms such as `(.+.)` where a constant name is expected.
1952   This method is usually used to implement tactics that function names as arguments (e.g., `simp`).
1953 -/</span>
<span class="keyword">1954 def</span> <span class="function-name">elabCDotFunctionAlias?</span> (stx : Syntax) : TermElabM (Option Expr) <span class="constant">:=</span> <span class="keyword">do</span>
1955   <span class="keyword">let</span> some stx &#8592; liftMacroM <span class="constant">&lt;</span>| expandCDotArg? stx | pure none
1956   <span class="keyword">let</span> stx &#8592; liftMacroM <span class="constant">&lt;</span>| expandMacros stx
1957   <span class="keyword">match</span> stx <span class="keyword">with</span>
1958   | `(<span class="keyword">fun</span> <span class="constant">$</span>binders<span class="constant">*</span> <span class="constant">=&gt;</span> <span class="constant">$</span>f:ident <span class="constant">$</span>args<span class="constant">*</span>) <span class="constant">=&gt;</span>
1959     <span class="keyword">if</span> binders <span class="constant">==</span> args <span class="keyword">then</span>
1960       <span class="keyword">try</span> Term.resolveId? f <span class="keyword">catch</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">return</span> none
1961     <span class="keyword">else</span>
1962       <span class="keyword">return</span> none
1963   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">return</span> none
<span class="keyword">1964 where</span>
1965   expandCDotArg? (stx : Syntax) : MacroM (Option Syntax) <span class="constant">:=</span>
1966     <span class="keyword">match</span> stx <span class="keyword">with</span>
1967     | `((<span class="constant">$</span>e)) <span class="constant">=&gt;</span> Term.expandCDot? e
1968     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> Term.expandCDot? stx
1969 
1970 
<span class="doc">1971 @[builtinTermElab paren]</span> <span class="keyword">def</span> <span class="function-name">elabParen</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span> <span class="keyword">do</span>
1972   <span class="keyword">match</span> stx <span class="keyword">with</span>
1973   | `(())           <span class="constant">=&gt;</span> <span class="keyword">return</span> Lean.mkConst `Unit.unit
1974   | `((<span class="constant">$</span>e : <span class="constant">$</span>type)) <span class="constant">=&gt;</span>
1975     <span class="keyword">let</span> type &#8592; withSynthesize (mayPostpone <span class="constant">:=</span> true) <span class="constant">$</span> elabType type
1976     <span class="keyword">let</span> e &#8592; elabCDot e type
1977     ensureHasType type e
1978   | `((<span class="constant">$</span>e))         <span class="constant">=&gt;</span> elabCDot e expectedType?
1979   | `((<span class="constant">$</span>e, <span class="constant">$</span>es,<span class="constant">*</span>))  <span class="constant">=&gt;</span>
1980     <span class="keyword">let</span> pairs &#8592; liftMacroM <span class="constant">&lt;</span>| mkPairs (<span class="constant">#</span>[e] <span class="constant">++</span> es)
1981     withMacroExpansion stx pairs (elabCDot pairs expectedType?)
1982   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwError <span class="string">"unexpected parentheses notation"</span>
1983 
<span class="doc">1984 @[builtinTermElab subst]</span> <span class="keyword">def</span> <span class="function-name">elabSubst</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span> <span class="keyword">do</span>
1985   <span class="keyword">let</span> expectedType &#8592; tryPostponeIfHasMVars expectedType? <span class="string">"invalid `&#9656;` notation"</span>
1986   <span class="keyword">match</span> stx <span class="keyword">with</span>
1987   | `(<span class="constant">$</span>heq <span class="constant">&#9656;</span> <span class="constant">$</span>h) <span class="constant">=&gt;</span> <span class="keyword">do</span>
1988      <span class="keyword">let</span> <span class="keyword">mut</span> heq &#8592; elabTerm heq none
1989      <span class="keyword">let</span> heqType &#8592; inferType heq
1990      <span class="keyword">let</span> heqType &#8592; instantiateMVars heqType
1991      <span class="keyword">match</span> (&#8592; Meta.matchEq? heqType) <span class="keyword">with</span>
1992      | none <span class="constant">=&gt;</span> throwError <span class="string">"invalid `&#9656;` notation, argument{indentExpr heq}\nhas type{indentExpr heqType}\nequality expected"</span>
1993      | some (&#945;, lhs, rhs) <span class="constant">=&gt;</span>
1994        <span class="keyword">let</span> <span class="keyword">mut</span> lhs <span class="constant">:=</span> lhs
1995        <span class="keyword">let</span> <span class="keyword">mut</span> rhs <span class="constant">:=</span> rhs
1996        <span class="keyword">let</span> mkMotive (typeWithLooseBVar : Expr) <span class="constant">:=</span>
1997          withLocalDeclD (&#8592; mkFreshUserName `x) &#945; <span class="keyword">fun</span> x <span class="constant">=&gt;</span> <span class="keyword">do</span>
1998            mkLambdaFVars <span class="constant">#</span>[x] <span class="constant">$</span> typeWithLooseBVar.instantiate1 x
1999        <span class="keyword">let</span> <span class="keyword">mut</span> expectedAbst &#8592; kabstract expectedType rhs
2000        <span class="keyword">unless</span> expectedAbst.hasLooseBVars <span class="keyword">do</span>
2001          expectedAbst &#8592; kabstract expectedType lhs
2002          <span class="keyword">unless</span> expectedAbst.hasLooseBVars <span class="keyword">do</span>
2003            throwError <span class="string">"invalid `&#9656;` notation, expected type{indentExpr expectedType}\ndoes contain equation left-hand-side nor right-hand-side{indentExpr heqType}"</span>
2004          heq &#8592; mkEqSymm heq
2005          (lhs, rhs) <span class="constant">:=</span> (rhs, lhs)
2006        <span class="keyword">let</span> hExpectedType <span class="constant">:=</span> expectedAbst.instantiate1 lhs
2007        <span class="keyword">let</span> h &#8592; withRef h <span class="keyword">do</span>
2008          <span class="keyword">let</span> h &#8592; elabTerm h hExpectedType
2009          <span class="keyword">try</span>
2010            ensureHasType hExpectedType h
2011          <span class="keyword">catch</span> ex <span class="constant">=&gt;</span>
2012            <span class="comment-delimiter">-- </span><span class="comment">if `rhs` occurs in `hType`, we try to apply `heq` to `h` too
</span>2013            <span class="keyword">let</span> hType &#8592; inferType h
2014            <span class="keyword">let</span> hTypeAbst &#8592; kabstract hType rhs
2015            <span class="keyword">unless</span> hTypeAbst.hasLooseBVars <span class="keyword">do</span>
2016              throw ex
2017            <span class="keyword">let</span> hTypeNew <span class="constant">:=</span> hTypeAbst.instantiate1 lhs
2018            <span class="keyword">unless</span> (&#8592; isDefEq hExpectedType hTypeNew) <span class="keyword">do</span>
2019              throw ex
2020            mkEqNDRec (&#8592; mkMotive hTypeAbst) h (&#8592; mkEqSymm heq)
2021        mkEqNDRec (&#8592; mkMotive expectedAbst) h heq
2022   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwUnsupportedSyntax
2023 
<span class="doc">2024 @[builtinTermElab stateRefT]</span> <span class="keyword">def</span> <span class="function-name">elabStateRefT</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">do</span>
2025   <span class="keyword">let</span> &#963; &#8592; elabType stx[<span class="constant">1</span>]
2026   <span class="keyword">let</span> <span class="keyword">mut</span> m <span class="constant">:=</span> stx[<span class="constant">2</span>]
2027   <span class="keyword">if</span> m.getKind <span class="constant">==</span> `Lean.Parser.Term.macroDollarArg <span class="keyword">then</span>
2028     m <span class="constant">:=</span> m[<span class="constant">1</span>]
2029   <span class="keyword">let</span> m &#8592; elabTerm m (&#8592; mkArrow (mkSort levelOne) (mkSort levelOne))
2030   <span class="keyword">let</span> &#969; &#8592; mkFreshExprMVar (mkSort levelOne)
2031   <span class="keyword">let</span> stWorld &#8592; mkAppM `STWorld <span class="constant">#</span>[&#969;, m]
2032   discard <span class="constant">&lt;</span>| mkInstMVar stWorld
2033   mkAppM `StateRefT' <span class="constant">#</span>[&#969;, &#963;, m]
2034 
<span class="doc">2035 @[builtinTermElab noindex]</span> <span class="keyword">def</span> <span class="function-name">elabNoindex</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span> <span class="keyword">do</span>
2036   <span class="keyword">let</span> e &#8592; elabTerm stx[<span class="constant">1</span>] expectedType?
2037   <span class="keyword">return</span> DiscrTree.mkNoindexAnnotation e
2038 
<span class="keyword">2039 end</span> Lean.Elab.Term
2040 ::::::::::::::
2041 Elab<span class="constant">/</span>Command.lean
2042 ::::::::::::::
<span class="comment-delimiter">2043 /-</span><span class="comment">
2044 Copyright (c) 2019 Microsoft Corporation. All rights reserved.
2045 Released under Apache 2.0 license as described in the file LICENSE.
2046 Authors: Leonardo de Moura
2047 -/</span>
<span class="keyword">2048 import</span> Lean.Parser.Command
<span class="keyword">2049 import</span> Lean.ResolveName
<span class="keyword">2050 import</span> Lean.Meta.Reduce
<span class="keyword">2051 import</span> Lean.Elab.Log
<span class="keyword">2052 import</span> Lean.Elab.Term
<span class="keyword">2053 import</span> Lean.Elab.Binders
<span class="keyword">2054 import</span> Lean.Elab.SyntheticMVars
<span class="keyword">2055 import</span> Lean.Elab.DeclModifiers
<span class="keyword">2056 import</span> Lean.Elab.InfoTree
<span class="keyword">2057 import</span> Lean.Elab.Open
<span class="keyword">2058 import</span> Lean.Elab.SetOption
2059 
<span class="keyword">2060 namespace</span> Lean.Elab.Command
2061 
<span class="keyword">2062 structure</span> <span class="function-name">Scope</span> <span class="keyword">where</span>
2063   header        : String
2064   opts          : Options <span class="constant">:=</span> {}
2065   currNamespace : Name <span class="constant">:=</span> Name.anonymous
2066   openDecls     : List OpenDecl <span class="constant">:=</span> []
2067   levelNames    : List Name <span class="constant">:=</span> []
2068   <span class="comment-delimiter">/-</span><span class="comment">- section variables as `bracketedBinder`s -/</span>
2069   varDecls      : Array Syntax <span class="constant">:=</span> <span class="constant">#</span>[]
2070   <span class="comment-delimiter">/-</span><span class="comment">- Globally unique internal identifiers for the `varDecls` -/</span>
2071   varUIds       : Array Name <span class="constant">:=</span> <span class="constant">#</span>[]
2072   <span class="keyword">deriving</span> Inhabited
2073 
<span class="keyword">2074 structure</span> <span class="function-name">State</span> <span class="keyword">where</span>
2075   env            : Environment
2076   messages       : MessageLog <span class="constant">:=</span> {}
2077   scopes         : List Scope <span class="constant">:=</span> [{ header <span class="constant">:=</span> <span class="string">""</span> }]
2078   nextMacroScope : Nat <span class="constant">:=</span> firstFrontendMacroScope <span class="constant">+</span> <span class="constant">1</span>
2079   maxRecDepth    : Nat
2080   nextInstIdx    : Nat <span class="constant">:=</span> <span class="constant">1</span> <span class="comment-delimiter">-- </span><span class="comment">for generating anonymous instance names
</span>2081   ngen           : NameGenerator <span class="constant">:=</span> {}
2082   infoState      : InfoState <span class="constant">:=</span> {}
2083   <span class="keyword">deriving</span> Inhabited
2084 
<span class="keyword">2085 structure</span> <span class="function-name">Context</span> <span class="keyword">where</span>
2086   fileName       : String
2087   fileMap        : FileMap
2088   currRecDepth   : Nat <span class="constant">:=</span> <span class="constant">0</span>
2089   cmdPos         : String.Pos <span class="constant">:=</span> <span class="constant">0</span>
2090   macroStack     : MacroStack <span class="constant">:=</span> []
2091   currMacroScope : MacroScope <span class="constant">:=</span> firstFrontendMacroScope
2092   ref            : Syntax <span class="constant">:=</span> Syntax.missing
2093 
<span class="keyword">2094 abbrev</span> CommandElabCoreM (&#949;) <span class="constant">:=</span> ReaderT Context <span class="constant">$</span> StateRefT State <span class="constant">$</span> EIO &#949;
<span class="keyword">2095 abbrev</span> CommandElabM <span class="constant">:=</span> CommandElabCoreM Exception
<span class="keyword">2096 abbrev</span> CommandElab  <span class="constant">:=</span> Syntax <span class="constant">&#8594;</span> CommandElabM Unit
<span class="keyword">2097 abbrev</span> Linter <span class="constant">:=</span> Syntax <span class="constant">&#8594;</span> CommandElabM Unit
2098 
<span class="keyword">2099 def</span> <span class="function-name">mkState</span> (env : Environment) (messages : MessageLog <span class="constant">:=</span> {}) (opts : Options <span class="constant">:=</span> {}) : State <span class="constant">:=</span> {
2100   env         <span class="constant">:=</span> env
2101   messages    <span class="constant">:=</span> messages
2102   scopes      <span class="constant">:=</span> [{ header <span class="constant">:=</span> <span class="string">""</span>, opts <span class="constant">:=</span> opts }]
2103   maxRecDepth <span class="constant">:=</span> maxRecDepth.get opts
2104 }
2105 
<span class="comment-delimiter">2106 /- </span><span class="comment">Linters should be loadable as plugins, so store in a global IO ref instead of an attribute managed by the
2107     environment (which only contains `import`ed objects). -/</span>
<span class="keyword">2108 builtin_initialize</span> lintersRef : IO.Ref (Array Linter) &#8592; IO.mkRef <span class="constant">#</span>[]
2109 
<span class="keyword">2110 def</span> <span class="function-name">addLinter</span> (l : Linter) : IO Unit <span class="constant">:=</span> <span class="keyword">do</span>
2111   <span class="keyword">let</span> ls &#8592; lintersRef.get
2112   lintersRef.set (ls.push l)
2113 
<span class="keyword">2114 instance</span> <span class="function-name">:</span> MonadInfoTree CommandElabM <span class="keyword">where</span>
2115   getInfoState      <span class="constant">:=</span> <span class="keyword">return</span> (&#8592; get).infoState
2116   modifyInfoState f <span class="constant">:=</span> modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> infoState <span class="constant">:=</span> f s.infoState }
2117 
<span class="keyword">2118 instance</span> <span class="function-name">:</span> MonadEnv CommandElabM <span class="keyword">where</span>
2119   getEnv <span class="constant">:=</span> <span class="keyword">do</span> pure (&#8592; get).env
2120   modifyEnv f <span class="constant">:=</span> modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> env <span class="constant">:=</span> f s.env }
2121 
<span class="keyword">2122 instance</span> <span class="function-name">:</span> MonadOptions CommandElabM <span class="keyword">where</span>
2123   getOptions <span class="constant">:=</span> <span class="keyword">do</span> pure (&#8592; get).scopes.head<span class="constant">!</span>.opts
2124 
<span class="keyword">2125 protected</span> <span class="keyword">def</span> <span class="function-name">getRef</span> : CommandElabM Syntax <span class="constant">:=</span>
2126   <span class="keyword">return</span> (&#8592; read).ref
2127 
<span class="keyword">2128 instance</span> <span class="function-name">:</span> AddMessageContext CommandElabM <span class="keyword">where</span>
2129   addMessageContext <span class="constant">:=</span> addMessageContextPartial
2130 
<span class="keyword">2131 instance</span> <span class="function-name">:</span> MonadRef CommandElabM <span class="keyword">where</span>
2132   getRef <span class="constant">:=</span> Command.getRef
2133   withRef ref x <span class="constant">:=</span> withReader (<span class="keyword">fun</span> ctx <span class="constant">=&gt;</span> { ctx <span class="keyword">with</span> ref <span class="constant">:=</span> ref }) x
2134 
<span class="keyword">2135 instance</span> <span class="function-name">:</span> AddErrorMessageContext CommandElabM <span class="keyword">where</span>
2136   add ref msg <span class="constant">:=</span> <span class="keyword">do</span>
2137     <span class="keyword">let</span> ctx &#8592; read
2138     <span class="keyword">let</span> ref <span class="constant">:=</span> getBetterRef ref ctx.macroStack
2139     <span class="keyword">let</span> msg &#8592; addMessageContext msg
2140     <span class="keyword">let</span> msg &#8592; addMacroStack msg ctx.macroStack
2141     <span class="keyword">return</span> (ref, msg)
2142 
<span class="keyword">2143 def</span> <span class="function-name">mkMessageAux</span> (ctx : Context) (ref : Syntax) (msgData : MessageData) (severity : MessageSeverity) : Message <span class="constant">:=</span>
2144   mkMessageCore ctx.fileName ctx.fileMap msgData severity (ref.getPos?.getD ctx.cmdPos)
2145 
<span class="keyword">2146 private</span> <span class="keyword">def</span> <span class="function-name">mkCoreContext</span> (ctx : Context) (s : State) (heartbeats : Nat) : Core.Context <span class="constant">:=</span>
2147   <span class="keyword">let</span> scope        <span class="constant">:=</span> s.scopes.head<span class="constant">!</span>
2148   { options        <span class="constant">:=</span> scope.opts
2149     currRecDepth   <span class="constant">:=</span> ctx.currRecDepth
2150     maxRecDepth    <span class="constant">:=</span> s.maxRecDepth
2151     ref            <span class="constant">:=</span> ctx.ref
2152     currNamespace  <span class="constant">:=</span> scope.currNamespace
2153     openDecls      <span class="constant">:=</span> scope.openDecls
2154     initHeartbeats <span class="constant">:=</span> heartbeats }
2155 
<span class="keyword">2156 def</span> <span class="function-name">liftCoreM</span> {&#945;} (x : CoreM &#945;) : CommandElabM &#945; <span class="constant">:=</span> <span class="keyword">do</span>
2157   <span class="keyword">let</span> s &#8592; get
2158   <span class="keyword">let</span> ctx &#8592; read
2159   <span class="keyword">let</span> heartbeats &#8592; IO.getNumHeartbeats (&#949; <span class="constant">:=</span> Exception)
2160   <span class="keyword">let</span> E&#945; <span class="constant">:=</span> Except Exception &#945;
2161   <span class="keyword">let</span> x : CoreM E&#945; <span class="constant">:=</span> <span class="keyword">try</span> <span class="keyword">let</span> a &#8592; x; pure <span class="constant">&lt;</span>| Except.ok a <span class="keyword">catch</span> ex <span class="constant">=&gt;</span> pure <span class="constant">&lt;</span>| Except.error ex
2162   <span class="keyword">let</span> x : EIO Exception (E&#945; <span class="constant">&#215;</span> Core.State) <span class="constant">:=</span> (ReaderT.run x (mkCoreContext ctx s heartbeats)).run { env <span class="constant">:=</span> s.env, ngen <span class="constant">:=</span> s.ngen }
2163   <span class="keyword">let</span> (ea, coreS) &#8592; liftM x
2164   modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> env <span class="constant">:=</span> coreS.env, ngen <span class="constant">:=</span> coreS.ngen }
2165   <span class="keyword">match</span> ea <span class="keyword">with</span>
2166   | Except.ok a    <span class="constant">=&gt;</span> pure a
2167   | Except.error e <span class="constant">=&gt;</span> throw e
2168 
<span class="keyword">2169 private</span> <span class="keyword">def</span> <span class="function-name">ioErrorToMessage</span> (ctx : Context) (ref : Syntax) (err : IO.Error) : Message <span class="constant">:=</span>
2170   <span class="keyword">let</span> ref <span class="constant">:=</span> getBetterRef ref ctx.macroStack
2171   mkMessageAux ctx ref (toString err) MessageSeverity.error
2172 
<span class="doc">2173 @[inline]</span> <span class="keyword">def</span> <span class="function-name">liftEIO</span> {&#945;} (x : EIO Exception &#945;) : CommandElabM &#945; <span class="constant">:=</span> liftM x
2174 
<span class="doc">2175 @[inline]</span> <span class="keyword">def</span> <span class="function-name">liftIO</span> {&#945;} (x : IO &#945;) : CommandElabM &#945; <span class="constant">:=</span> <span class="keyword">do</span>
2176   <span class="keyword">let</span> ctx &#8592; read
2177   IO.toEIO (<span class="keyword">fun</span> (ex : IO.Error) <span class="constant">=&gt;</span> Exception.error ctx.ref ex.toString) x
2178 
<span class="keyword">2179 instance</span> <span class="function-name">:</span> MonadLiftT IO CommandElabM <span class="keyword">where</span>
2180   monadLift <span class="constant">:=</span> liftIO
2181 
<span class="keyword">2182 def</span> <span class="function-name">getScope</span> : CommandElabM Scope <span class="constant">:=</span> <span class="keyword">do</span> pure (&#8592; get).scopes.head<span class="constant">!</span>
2183 
<span class="keyword">2184 instance</span> <span class="function-name">:</span> MonadResolveName CommandElabM <span class="keyword">where</span>
2185   getCurrNamespace <span class="constant">:=</span> <span class="keyword">return</span> (&#8592; getScope).currNamespace
2186   getOpenDecls     <span class="constant">:=</span> <span class="keyword">return</span> (&#8592; getScope).openDecls
2187 
<span class="keyword">2188 instance</span> <span class="function-name">:</span> MonadLog CommandElabM <span class="keyword">where</span>
2189   getRef      <span class="constant">:=</span> getRef
2190   getFileMap  <span class="constant">:=</span> <span class="keyword">return</span> (&#8592; read).fileMap
2191   getFileName <span class="constant">:=</span> <span class="keyword">return</span> (&#8592; read).fileName
2192   logMessage msg <span class="constant">:=</span> <span class="keyword">do</span>
2193     <span class="keyword">let</span> currNamespace &#8592; getCurrNamespace
2194     <span class="keyword">let</span> openDecls &#8592; getOpenDecls
2195     <span class="keyword">let</span> msg <span class="constant">:=</span> { msg <span class="keyword">with</span> data <span class="constant">:=</span> MessageData.withNamingContext { currNamespace <span class="constant">:=</span> currNamespace, openDecls <span class="constant">:=</span> openDecls } msg.data }
2196     modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> messages <span class="constant">:=</span> s.messages.add msg }
2197 
<span class="keyword">2198 def</span> <span class="function-name">runLinters</span> (stx : Syntax) : CommandElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
2199   <span class="keyword">let</span> linters &#8592; lintersRef.get
2200   <span class="keyword">unless</span> linters.isEmpty <span class="keyword">do</span>
2201     <span class="keyword">for</span> linter <span class="keyword">in</span> linters <span class="keyword">do</span>
2202       <span class="keyword">let</span> savedState &#8592; get
2203       <span class="keyword">try</span>
2204         linter stx
2205       <span class="keyword">catch</span> ex <span class="constant">=&gt;</span>
2206         logException ex
2207       <span class="keyword">finally</span>
2208         modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { savedState <span class="keyword">with</span> messages <span class="constant">:=</span> s.messages }
2209 
<span class="keyword">2210 protected</span> <span class="keyword">def</span> <span class="function-name">getCurrMacroScope</span> : CommandElabM Nat  <span class="constant">:=</span> <span class="keyword">do</span> pure (&#8592; read).currMacroScope
<span class="keyword">2211 protected</span> <span class="keyword">def</span> <span class="function-name">getMainModule</span>     : CommandElabM Name <span class="constant">:=</span> <span class="keyword">do</span> pure (&#8592; getEnv).mainModule
2212 
<span class="doc">2213 @[inline]</span> <span class="keyword">protected</span> <span class="keyword">def</span> <span class="function-name">withFreshMacroScope</span> {&#945;} (x : CommandElabM &#945;) : CommandElabM &#945; <span class="constant">:=</span> <span class="keyword">do</span>
2214   <span class="keyword">let</span> fresh &#8592; modifyGet (<span class="keyword">fun</span> st <span class="constant">=&gt;</span> (st.nextMacroScope, { st <span class="keyword">with</span> nextMacroScope <span class="constant">:=</span> st.nextMacroScope <span class="constant">+</span> <span class="constant">1</span> }))
2215   withReader (<span class="keyword">fun</span> ctx <span class="constant">=&gt;</span> { ctx <span class="keyword">with</span> currMacroScope <span class="constant">:=</span> fresh }) x
2216 
<span class="keyword">2217 instance</span> <span class="function-name">:</span> MonadQuotation CommandElabM <span class="keyword">where</span>
2218   getCurrMacroScope   <span class="constant">:=</span> Command.getCurrMacroScope
2219   getMainModule       <span class="constant">:=</span> Command.getMainModule
2220   withFreshMacroScope <span class="constant">:=</span> Command.withFreshMacroScope
2221 
<span class="keyword">2222 unsafe</span> <span class="keyword">def</span> <span class="function-name">mkCommandElabAttributeUnsafe</span> : IO (KeyedDeclsAttribute CommandElab) <span class="constant">:=</span>
2223   mkElabAttribute CommandElab `Lean.Elab.Command.commandElabAttribute `builtinCommandElab `commandElab `Lean.Parser.Command `Lean.Elab.Command.CommandElab <span class="string">"command"</span>
2224 
<span class="doc">2225 @[implementedBy mkCommandElabAttributeUnsafe]</span>
<span class="keyword">2226 constant</span> <span class="function-name">mkCommandElabAttribute</span> : IO (KeyedDeclsAttribute CommandElab)
2227 
<span class="keyword">2228 builtin_initialize</span> commandElabAttribute : KeyedDeclsAttribute CommandElab &#8592; mkCommandElabAttribute
2229 
<span class="keyword">2230 private</span> <span class="keyword">def</span> <span class="function-name">elabCommandUsing</span> (s : State) (stx : Syntax) : List CommandElab <span class="constant">&#8594;</span> CommandElabM Unit
2231   | []                <span class="constant">=&gt;</span> throwError <span class="string">"unexpected syntax{indentD stx}"</span>
2232   | (elabFn::elabFns) <span class="constant">=&gt;</span>
2233     catchInternalId unsupportedSyntaxExceptionId
2234       (elabFn stx)
2235       (<span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">do</span> set s; elabCommandUsing s stx elabFns)
2236 
<span class="comment-delimiter">2237 /- </span><span class="comment">Elaborate `x` with `stx` on the macro stack -/</span>
<span class="doc">2238 @[inline]</span> <span class="keyword">def</span> <span class="function-name">withMacroExpansion</span> {&#945;} (beforeStx afterStx : Syntax) (x : CommandElabM &#945;) : CommandElabM &#945; <span class="constant">:=</span>
2239   withReader (<span class="keyword">fun</span> ctx <span class="constant">=&gt;</span> { ctx <span class="keyword">with</span> macroStack <span class="constant">:=</span> { before <span class="constant">:=</span> beforeStx, after <span class="constant">:=</span> afterStx } :: ctx.macroStack }) x
2240 
<span class="keyword">2241 instance</span> <span class="function-name">:</span> MonadMacroAdapter CommandElabM <span class="keyword">where</span>
2242   getCurrMacroScope <span class="constant">:=</span> getCurrMacroScope
2243   getNextMacroScope <span class="constant">:=</span> <span class="keyword">return</span> (&#8592; get).nextMacroScope
2244   setNextMacroScope next <span class="constant">:=</span> modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> nextMacroScope <span class="constant">:=</span> next }
2245 
<span class="keyword">2246 instance</span> <span class="function-name">:</span> MonadRecDepth CommandElabM <span class="keyword">where</span>
2247   withRecDepth d x <span class="constant">:=</span> withReader (<span class="keyword">fun</span> ctx <span class="constant">=&gt;</span> { ctx <span class="keyword">with</span> currRecDepth <span class="constant">:=</span> d }) x
2248   getRecDepth      <span class="constant">:=</span> <span class="keyword">return</span> (&#8592; read).currRecDepth
2249   getMaxRecDepth   <span class="constant">:=</span> <span class="keyword">return</span> (&#8592; get).maxRecDepth
2250 
<span class="keyword">2251 register_builtin_option</span> showPartialSyntaxErrors : Bool <span class="constant">:=</span> {
2252   defValue <span class="constant">:=</span> false
2253   descr    <span class="constant">:=</span> <span class="string">"show elaboration errors from partial syntax trees (i.e. after parser recovery)"</span>
2254 }
2255 
<span class="doc">2256 @[inline]</span> <span class="keyword">def</span> <span class="function-name">withLogging</span> (x : CommandElabM Unit) : CommandElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
2257   <span class="keyword">try</span>
2258     x
2259   <span class="keyword">catch</span> ex <span class="constant">=&gt;</span> <span class="keyword">match</span> ex <span class="keyword">with</span>
2260     | Exception.error <span class="preprocessor">_</span> <span class="preprocessor">_</span>     <span class="constant">=&gt;</span> logException ex
2261     | Exception.internal id <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
2262       <span class="keyword">if</span> isAbortExceptionId id <span class="keyword">then</span>
2263         pure ()
2264       <span class="keyword">else</span>
2265         <span class="keyword">let</span> idName &#8592; liftIO <span class="constant">&lt;</span>| id.getName;
2266         logError m<span class="constant">!</span><span class="string">"internal exception {idName}"</span>
2267 
<span class="keyword">2268 builtin_initialize</span> registerTraceClass `Elab.command
2269 
<span class="keyword">2270 partial</span> <span class="keyword">def</span> <span class="function-name">elabCommand</span> (stx : Syntax) : CommandElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
2271   <span class="keyword">let</span> mkInfoTree trees <span class="constant">:=</span> <span class="keyword">do</span>
2272     <span class="keyword">let</span> ctx &#8592; read
2273     <span class="keyword">let</span> s &#8592; get
2274     <span class="keyword">let</span> scope <span class="constant">:=</span> s.scopes.head<span class="constant">!</span>
2275     <span class="keyword">let</span> tree <span class="constant">:=</span> InfoTree.node (Info.ofCommandInfo { stx <span class="constant">:=</span> stx }) trees
2276     <span class="keyword">let</span> tree <span class="constant">:=</span> InfoTree.context {
2277       env <span class="constant">:=</span> s.env, fileMap <span class="constant">:=</span> ctx.fileMap, mctx <span class="constant">:=</span> {}, currNamespace <span class="constant">:=</span> scope.currNamespace, openDecls <span class="constant">:=</span> scope.openDecls, options <span class="constant">:=</span> scope.opts
2278     } tree
2279     <span class="keyword">if</span> checkTraceOption (&#8592; getOptions) `Elab.info <span class="keyword">then</span>
2280       logTrace `Elab.info m<span class="constant">!</span><span class="string">"{&#8592; tree.format}"</span>
2281     <span class="keyword">return</span> tree
2282   <span class="keyword">let</span> initMsgs &#8592; modifyGet <span class="keyword">fun</span> st <span class="constant">=&gt;</span> (st.messages, { st <span class="keyword">with</span> messages <span class="constant">:=</span> {} })
2283   withLogging <span class="constant">&lt;</span>| withRef stx <span class="constant">&lt;</span>| withInfoTreeContext (mkInfoTree <span class="constant">:=</span> mkInfoTree) <span class="constant">&lt;</span>| withIncRecDepth <span class="constant">&lt;</span>| withFreshMacroScope <span class="keyword">do</span>
2284     runLinters stx
2285     <span class="keyword">match</span> stx <span class="keyword">with</span>
2286     | Syntax.node k args <span class="constant">=&gt;</span>
2287       <span class="keyword">if</span> k <span class="constant">==</span> nullKind <span class="keyword">then</span>
2288         <span class="comment-delimiter">-- </span><span class="comment">list of commands =&gt; elaborate in order
</span>2289         <span class="comment-delimiter">-- </span><span class="comment">The parser will only ever return a single command at a time, but syntax quotations can return multiple ones
</span>2290         args.forM elabCommand
2291       <span class="keyword">else</span> <span class="keyword">do</span>
2292         trace `Elab.command <span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> stx;
2293         <span class="keyword">let</span> s &#8592; get
2294         <span class="keyword">let</span> stxNew? &#8592; catchInternalId unsupportedSyntaxExceptionId
2295           (<span class="keyword">do</span> <span class="keyword">let</span> newStx &#8592; adaptMacro (getMacros s.env) stx; pure (some newStx))
2296           (<span class="keyword">fun</span> ex <span class="constant">=&gt;</span> pure none)
2297         <span class="keyword">match</span> stxNew? <span class="keyword">with</span>
2298         | some stxNew <span class="constant">=&gt;</span> withMacroExpansion stx stxNew <span class="constant">&lt;</span>| elabCommand stxNew
2299         | <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
2300           <span class="keyword">let</span> table <span class="constant">:=</span> (commandElabAttribute.ext.getState s.env).table;
2301           <span class="keyword">let</span> k <span class="constant">:=</span> stx.getKind;
2302           <span class="keyword">match</span> table.find? k <span class="keyword">with</span>
2303           | some elabFns <span class="constant">=&gt;</span> elabCommandUsing s stx elabFns
2304           | none         <span class="constant">=&gt;</span> throwError <span class="string">"elaboration function for '{k}' has not been implemented"</span>
2305     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwError <span class="string">"unexpected command"</span>
2306   <span class="keyword">let</span> <span class="keyword">mut</span> msgs &#8592; (&#8592; get).messages
2307   <span class="comment-delimiter">-- </span><span class="comment">`stx.hasMissing` should imply `initMsgs.hasErrors`, but the latter should be cheaper to check in general
</span>2308   <span class="keyword">if</span> <span class="constant">!</span>showPartialSyntaxErrors.get (&#8592; getOptions) <span class="constant">&amp;&amp;</span> initMsgs.hasErrors <span class="constant">&amp;&amp;</span> stx.hasMissing <span class="keyword">then</span>
2309     <span class="comment-delimiter">-- </span><span class="comment">discard elaboration errors, except for a few important and unlikely misleading ones, on parse error
</span>2310     msgs <span class="constant">:=</span> &#10216;msgs.msgs.filter <span class="keyword">fun</span> msg <span class="constant">=&gt;</span>
2311       msg.data.hasTag `Elab.synthPlaceholder <span class="constant">||</span> msg.data.hasTag `Tactic.unsolvedGoals&#10217;
2312   modify ({ &#183; <span class="keyword">with</span> messages <span class="constant">:=</span> initMsgs <span class="constant">++</span> msgs })
2313 
<span class="comment-delimiter">2314 /-</span><span class="comment">- Adapt a syntax transformation to a regular, command-producing elaborator. -/</span>
<span class="keyword">2315 def</span> <span class="function-name">adaptExpander</span> (exp : Syntax <span class="constant">&#8594;</span> CommandElabM Syntax) : CommandElab <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="constant">=&gt;</span> <span class="keyword">do</span>
2316   <span class="keyword">let</span> stx' &#8592; exp stx
2317   withMacroExpansion stx stx' <span class="constant">&lt;</span>| elabCommand stx'
2318 
<span class="keyword">2319 private</span> <span class="keyword">def</span> <span class="function-name">getVarDecls</span> (s : State) : Array Syntax <span class="constant">:=</span>
2320   s.scopes.head<span class="constant">!</span>.varDecls
2321 
<span class="keyword">2322 instance</span> {&#945;} <span class="function-name">:</span> Inhabited (CommandElabM &#945;) <span class="keyword">where</span>
2323   default <span class="constant">:=</span> throw arbitrary
2324 
<span class="keyword">2325 private</span> <span class="keyword">def</span> <span class="function-name">mkMetaContext</span> : Meta.Context <span class="constant">:=</span> {
2326   config <span class="constant">:=</span> { foApprox <span class="constant">:=</span> true, ctxApprox <span class="constant">:=</span> true, quasiPatternApprox <span class="constant">:=</span> true }
2327 }
2328 
<span class="keyword">2329 def</span> <span class="function-name">getBracketedBinderIds</span> : Syntax <span class="constant">&#8594;</span> Array Name
2330   | `(bracketedBinder|(<span class="constant">$</span>ids<span class="constant">*</span> <span class="constant">$</span>[: <span class="constant">$</span>ty?]? <span class="constant">$</span>(annot?)?)) <span class="constant">=&gt;</span> ids.map Syntax.getId
2331   | `(bracketedBinder|{<span class="constant">$</span>ids<span class="constant">*</span> <span class="constant">$</span>[: <span class="constant">$</span>ty?]?})            <span class="constant">=&gt;</span> ids.map Syntax.getId
2332   | `(bracketedBinder|[<span class="constant">$</span>id : <span class="constant">$</span>ty])                   <span class="constant">=&gt;</span> <span class="constant">#</span>[id.getId]
2333   | `(bracketedBinder|[<span class="constant">$</span>ty])                         <span class="constant">=&gt;</span> <span class="constant">#</span>[]
2334   | <span class="preprocessor">_</span>                                                <span class="constant">=&gt;</span> <span class="constant">#</span>[]
2335 
<span class="keyword">2336 private</span> <span class="keyword">def</span> <span class="function-name">mkTermContext</span> (ctx : Context) (s : State) (declName? : Option Name) : Term.Context <span class="constant">:=</span> <span class="keyword">do</span>
2337   <span class="keyword">let</span> scope      <span class="constant">:=</span> s.scopes.head<span class="constant">!</span>
2338   <span class="keyword">let</span> <span class="keyword">mut</span> sectionVars <span class="constant">:=</span> {}
2339   <span class="keyword">for</span> id <span class="keyword">in</span> scope.varDecls.concatMap getBracketedBinderIds, uid <span class="keyword">in</span> scope.varUIds <span class="keyword">do</span>
2340     sectionVars <span class="constant">:=</span> sectionVars.insert id uid
2341   { macroStack     <span class="constant">:=</span> ctx.macroStack
2342     fileName       <span class="constant">:=</span> ctx.fileName
2343     fileMap        <span class="constant">:=</span> ctx.fileMap
2344     currMacroScope <span class="constant">:=</span> ctx.currMacroScope
2345     declName?      <span class="constant">:=</span> declName?
2346     sectionVars    <span class="constant">:=</span> sectionVars }
2347 
<span class="keyword">2348 private</span> <span class="keyword">def</span> <span class="function-name">mkTermState</span> (scope : Scope) (s : State) : Term.State <span class="constant">:=</span> {
2349   messages          <span class="constant">:=</span> {}
2350   levelNames        <span class="constant">:=</span> scope.levelNames
2351   infoState.enabled <span class="constant">:=</span> s.infoState.enabled
2352 }
2353 
<span class="keyword">2354 private</span> <span class="keyword">def</span> <span class="function-name">addTraceAsMessages</span> (ctx : Context) (log : MessageLog) (traceState : TraceState) : MessageLog <span class="constant">:=</span>
2355   traceState.traces.foldl (init <span class="constant">:=</span> log) <span class="keyword">fun</span> (log : MessageLog) traceElem <span class="constant">=&gt;</span>
2356       <span class="keyword">let</span> ref <span class="constant">:=</span> replaceRef traceElem.ref ctx.ref;
2357       <span class="keyword">let</span> pos <span class="constant">:=</span> ref.getPos?.getD <span class="constant">0</span>;
2358       log.add (mkMessageCore ctx.fileName ctx.fileMap traceElem.msg MessageSeverity.information pos)
2359 
<span class="keyword">2360 def</span> <span class="function-name">liftTermElabM</span> {&#945;} (declName? : Option Name) (x : TermElabM &#945;) : CommandElabM &#945; <span class="constant">:=</span> <span class="keyword">do</span>
2361   <span class="keyword">let</span> ctx &#8592; read
2362   <span class="keyword">let</span> s   &#8592; get
2363   <span class="keyword">let</span> heartbeats &#8592; IO.getNumHeartbeats (&#949; <span class="constant">:=</span> Exception)
2364   <span class="comment-delimiter">-- </span><span class="comment">dbg_trace "heartbeats: {heartbeats}"
</span>2365   <span class="keyword">let</span> scope <span class="constant">:=</span> s.scopes.head<span class="constant">!</span>
2366   <span class="comment-delimiter">-- </span><span class="comment">We execute `x` with an empty message log. Thus, `x` cannot modify/view messages produced by previous commands.
</span>2367   <span class="comment-delimiter">-- </span><span class="comment">This is useful for implementing `runTermElabM` where we use `Term.resetMessageLog`
</span>2368   <span class="keyword">let</span> x : MetaM <span class="preprocessor">_</span>      <span class="constant">:=</span> (observing x).run (mkTermContext ctx s declName?) (mkTermState scope s)
2369   <span class="keyword">let</span> x : CoreM <span class="preprocessor">_</span>      <span class="constant">:=</span> x.run mkMetaContext {}
2370   <span class="keyword">let</span> x : EIO <span class="preprocessor">_</span> <span class="preprocessor">_</span>      <span class="constant">:=</span> x.run (mkCoreContext ctx s heartbeats) { env <span class="constant">:=</span> s.env, ngen <span class="constant">:=</span> s.ngen, nextMacroScope <span class="constant">:=</span> s.nextMacroScope }
2371   <span class="keyword">let</span> (((ea, termS), metaS), coreS) &#8592; liftEIO x
2372   <span class="keyword">let</span> infoTrees        <span class="constant">:=</span> termS.infoState.trees.map <span class="keyword">fun</span> tree <span class="constant">=&gt;</span>
2373     <span class="keyword">let</span> tree <span class="constant">:=</span> tree.substitute termS.infoState.assignment
2374     InfoTree.context {
2375       env <span class="constant">:=</span> coreS.env, fileMap <span class="constant">:=</span> ctx.fileMap, mctx <span class="constant">:=</span> metaS.mctx, currNamespace <span class="constant">:=</span> scope.currNamespace, openDecls <span class="constant">:=</span> scope.openDecls, options <span class="constant">:=</span> scope.opts
2376     } tree
2377   modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span>
2378     env             <span class="constant">:=</span> coreS.env
2379     messages        <span class="constant">:=</span> addTraceAsMessages ctx (s.messages <span class="constant">++</span> termS.messages) coreS.traceState
2380     nextMacroScope  <span class="constant">:=</span> coreS.nextMacroScope
2381     ngen            <span class="constant">:=</span> coreS.ngen
2382     infoState.trees <span class="constant">:=</span> s.infoState.trees.append infoTrees
2383   }
2384   <span class="keyword">match</span> ea <span class="keyword">with</span>
2385   | Except.ok a     <span class="constant">=&gt;</span> pure a
2386   | Except.error ex <span class="constant">=&gt;</span> throw ex
2387 
<span class="doc">2388 @[inline]</span> <span class="keyword">def</span> <span class="function-name">runTermElabM</span> {&#945;} (declName? : Option Name) (elabFn : Array Expr <span class="constant">&#8594;</span> TermElabM &#945;) : CommandElabM &#945; <span class="constant">:=</span> <span class="keyword">do</span>
2389   <span class="keyword">let</span> scope &#8592; getScope
2390   liftTermElabM declName? <span class="constant">&lt;</span>|
2391     Term.withAutoBoundImplicit <span class="constant">&lt;</span>|
2392       Term.elabBinders scope.varDecls <span class="keyword">fun</span> xs <span class="constant">=&gt;</span> <span class="keyword">do</span>
2393         <span class="comment-delimiter">-- </span><span class="comment">We need to synthesize postponed terms because this is a checkpoint for the auto-bound implicit feature
</span>2394         <span class="comment-delimiter">-- </span><span class="comment">If we don't use this checkpoint here, then auto-bound implicits in the postponed terms will not be handled correctly.
</span>2395         Term.synthesizeSyntheticMVarsNoPostponing
2396         <span class="keyword">let</span> <span class="keyword">mut</span> sectionFVars <span class="constant">:=</span> {}
2397         <span class="keyword">for</span> uid <span class="keyword">in</span> scope.varUIds, x <span class="keyword">in</span> xs <span class="keyword">do</span>
2398           sectionFVars <span class="constant">:=</span> sectionFVars.insert uid x
2399         withReader ({ &#183; <span class="keyword">with</span> sectionFVars <span class="constant">:=</span> sectionFVars }) <span class="keyword">do</span>
2400           <span class="comment-delimiter">-- </span><span class="comment">We don't want to store messages produced when elaborating `(getVarDecls s)` because they have already been saved when we elaborated the `variable`(s) command.
</span>2401           <span class="comment-delimiter">-- </span><span class="comment">So, we use `Term.resetMessageLog`.
</span>2402           Term.resetMessageLog
2403           <span class="keyword">let</span> xs &#8592; Term.addAutoBoundImplicits xs
2404           Term.withoutAutoBoundImplicit <span class="constant">&lt;</span>| elabFn xs
2405 
<span class="doc">2406 @[inline]</span> <span class="keyword">def</span> <span class="function-name">catchExceptions</span> (x : CommandElabM Unit) : CommandElabCoreM Empty Unit <span class="constant">:=</span> <span class="keyword">fun</span> ctx ref <span class="constant">=&gt;</span>
2407   EIO.catchExceptions (withLogging x ctx ref) (<span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> pure ())
2408 
<span class="keyword">2409 private</span> <span class="keyword">def</span> <span class="function-name">liftAttrM</span> {&#945;} (x : AttrM &#945;) : CommandElabM &#945; <span class="constant">:=</span> <span class="keyword">do</span>
2410   liftCoreM x
2411 
<span class="keyword">2412 private</span> <span class="keyword">def</span> <span class="function-name">addScope</span> (isNewNamespace : Bool) (header : String) (newNamespace : Name) : CommandElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
2413   modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span>
2414     env    <span class="constant">:=</span> s.env.registerNamespace newNamespace,
2415     scopes <span class="constant">:=</span> { s.scopes.head<span class="constant">!</span> <span class="keyword">with</span> header <span class="constant">:=</span> header, currNamespace <span class="constant">:=</span> newNamespace } :: s.scopes
2416   }
2417   pushScope
2418   <span class="keyword">if</span> isNewNamespace <span class="keyword">then</span>
2419     activateScoped newNamespace
2420 
<span class="keyword">2421 private</span> <span class="keyword">def</span> <span class="function-name">addScopes</span> (isNewNamespace : Bool) : Name <span class="constant">&#8594;</span> CommandElabM Unit
2422   | Name.anonymous <span class="constant">=&gt;</span> pure ()
2423   | Name.str p header <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">do</span>
2424     addScopes isNewNamespace p
2425     <span class="keyword">let</span> currNamespace &#8592; getCurrNamespace
2426     addScope isNewNamespace header (<span class="keyword">if</span> isNewNamespace <span class="keyword">then</span> Name.mkStr currNamespace header <span class="keyword">else</span> currNamespace)
2427   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwError <span class="string">"invalid scope"</span>
2428 
<span class="keyword">2429 private</span> <span class="keyword">def</span> <span class="function-name">addNamespace</span> (header : Name) : CommandElabM Unit <span class="constant">:=</span>
2430   addScopes (isNewNamespace <span class="constant">:=</span> true) header
2431 
<span class="constant">2432 @</span>[builtinCommandElab <span class="comment">&#171;</span>namespace<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabNamespace</span> : CommandElab <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="constant">=&gt;</span>
2433   <span class="keyword">match</span> stx <span class="keyword">with</span>
2434   | `(<span class="keyword">namespace</span> <span class="constant">$</span>n) <span class="constant">=&gt;</span> addNamespace n.getId
2435   | <span class="preprocessor">_</span>               <span class="constant">=&gt;</span> throwUnsupportedSyntax
2436 
<span class="constant">2437 @</span>[builtinCommandElab <span class="comment">&#171;</span>section<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabSection</span> : CommandElab <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="constant">=&gt;</span>
2438   <span class="keyword">match</span> stx <span class="keyword">with</span>
2439   | `(<span class="keyword">section</span> <span class="constant">$</span>header:ident) <span class="constant">=&gt;</span> addScopes (isNewNamespace <span class="constant">:=</span> false) header.getId
2440   | `(<span class="keyword">section</span>)               <span class="constant">=&gt;</span> <span class="keyword">do</span> <span class="keyword">let</span> currNamespace &#8592; getCurrNamespace; addScope (isNewNamespace <span class="constant">:=</span> false) <span class="string">""</span> currNamespace
2441   | <span class="preprocessor">_</span>                        <span class="constant">=&gt;</span> throwUnsupportedSyntax
2442 
<span class="keyword">2443 def</span> <span class="function-name">getScopes</span> : CommandElabM (List Scope) <span class="constant">:=</span> <span class="keyword">do</span>
2444   pure (&#8592; get).scopes
2445 
<span class="keyword">2446 private</span> <span class="keyword">def</span> <span class="function-name">checkAnonymousScope</span> : List Scope <span class="constant">&#8594;</span> Bool
2447   | { header <span class="constant">:=</span> <span class="string">""</span>, .. } :: <span class="preprocessor">_</span>   <span class="constant">=&gt;</span> true
2448   | <span class="preprocessor">_</span>                           <span class="constant">=&gt;</span> false
2449 
<span class="keyword">2450 private</span> <span class="keyword">def</span> <span class="function-name">checkEndHeader</span> : Name <span class="constant">&#8594;</span> List Scope <span class="constant">&#8594;</span> Bool
2451   | Name.anonymous, <span class="preprocessor">_</span>                             <span class="constant">=&gt;</span> true
2452   | Name.str p s <span class="preprocessor">_</span>, { header <span class="constant">:=</span> h, .. } :: scopes <span class="constant">=&gt;</span> h <span class="constant">==</span> s <span class="constant">&amp;&amp;</span> checkEndHeader p scopes
2453   | <span class="preprocessor">_</span>,              <span class="preprocessor">_</span>                             <span class="constant">=&gt;</span> false
2454 
<span class="keyword">2455 private</span> <span class="keyword">def</span> <span class="function-name">popScopes</span> (numScopes : Nat) : CommandElabM Unit <span class="constant">:=</span>
2456   <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="constant">0</span>:numScopes] <span class="keyword">do</span>
2457     popScope
2458 
<span class="constant">2459 @</span>[builtinCommandElab <span class="comment">&#171;</span>end<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabEnd</span> : CommandElab <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="constant">=&gt;</span> <span class="keyword">do</span>
2460   <span class="keyword">let</span> header? <span class="constant">:=</span> (stx.getArg <span class="constant">1</span>).getOptionalIdent?;
2461   <span class="keyword">let</span> endSize <span class="constant">:=</span> <span class="keyword">match</span> header? <span class="keyword">with</span>
2462     | none   <span class="constant">=&gt;</span> <span class="constant">1</span>
2463     | some n <span class="constant">=&gt;</span> n.getNumParts
2464   <span class="keyword">let</span> scopes &#8592; getScopes
2465   <span class="keyword">if</span> endSize <span class="constant">&lt;</span> scopes.length <span class="keyword">then</span>
2466     modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> scopes <span class="constant">:=</span> s.scopes.drop endSize }
2467     popScopes endSize
2468   <span class="keyword">else</span> <span class="comment-delimiter">-- </span><span class="comment">we keep "root" scope
</span>2469     <span class="keyword">let</span> n <span class="constant">:=</span> (&#8592; get).scopes.length <span class="constant">-</span> <span class="constant">1</span>
2470     modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> scopes <span class="constant">:=</span> s.scopes.drop n }
2471     popScopes n
2472     throwError <span class="string">"invalid 'end', insufficient scopes"</span>
2473   <span class="keyword">match</span> header? <span class="keyword">with</span>
2474   | none        <span class="constant">=&gt;</span>
2475     <span class="keyword">unless</span> checkAnonymousScope scopes <span class="keyword">do</span>
2476       throwError <span class="string">"invalid 'end', name is missing"</span>
2477   | some header <span class="constant">=&gt;</span>
2478     <span class="keyword">unless</span> checkEndHeader header scopes <span class="keyword">do</span>
2479       addCompletionInfo <span class="constant">&lt;</span>| CompletionInfo.endSection stx (scopes.map <span class="keyword">fun</span> scope <span class="constant">=&gt;</span> scope.header)
2480       throwError <span class="string">"invalid 'end', name mismatch"</span>
2481 
<span class="doc">2482 @[inline]</span> <span class="keyword">def</span> <span class="function-name">withNamespace</span> {&#945;} (ns : Name) (elabFn : CommandElabM &#945;) : CommandElabM &#945; <span class="constant">:=</span> <span class="keyword">do</span>
2483   addNamespace ns
2484   <span class="keyword">let</span> a &#8592; elabFn
2485   modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> scopes <span class="constant">:=</span> s.scopes.drop ns.getNumParts }
2486   pure a
2487 
<span class="doc">2488 @[specialize]</span> <span class="keyword">def</span> <span class="function-name">modifyScope</span> (f : Scope <span class="constant">&#8594;</span> Scope) : CommandElabM Unit <span class="constant">:=</span>
2489   modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span>
2490     scopes <span class="constant">:=</span> <span class="keyword">match</span> s.scopes <span class="keyword">with</span>
2491       | h::t <span class="constant">=&gt;</span> f h :: t
2492       | []   <span class="constant">=&gt;</span> <span class="warning">unreachable</span><span class="constant">!</span>
2493   }
2494 
<span class="keyword">2495 def</span> <span class="function-name">getLevelNames</span> : CommandElabM (List Name) <span class="constant">:=</span>
2496   <span class="keyword">return</span> (&#8592; getScope).levelNames
2497 
<span class="keyword">2498 def</span> <span class="function-name">addUnivLevel</span> (idStx : Syntax) : CommandElabM Unit <span class="constant">:=</span> withRef idStx <span class="keyword">do</span>
2499   <span class="keyword">let</span> id <span class="constant">:=</span> idStx.getId
2500   <span class="keyword">let</span> levelNames &#8592; getLevelNames
2501   <span class="keyword">if</span> levelNames.elem id <span class="keyword">then</span>
2502     throwAlreadyDeclaredUniverseLevel id
2503   <span class="keyword">else</span>
2504     modifyScope <span class="keyword">fun</span> scope <span class="constant">=&gt;</span> { scope <span class="keyword">with</span> levelNames <span class="constant">:=</span> id :: scope.levelNames }
2505 
<span class="keyword">2506 partial</span> <span class="keyword">def</span> <span class="function-name">elabChoiceAux</span> (cmds : Array Syntax) (i : Nat) : CommandElabM Unit <span class="constant">:=</span>
2507   <span class="keyword">if</span> h : i <span class="constant">&lt;</span> cmds.size <span class="keyword">then</span>
2508     <span class="keyword">let</span> cmd <span class="constant">:=</span> cmds.get &#10216;i, h&#10217;;
2509     catchInternalId unsupportedSyntaxExceptionId
2510       (elabCommand cmd)
2511       (<span class="keyword">fun</span> ex <span class="constant">=&gt;</span> elabChoiceAux cmds (i<span class="constant">+1</span>))
2512   <span class="keyword">else</span>
2513     throwUnsupportedSyntax
2514 
<span class="doc">2515 @[builtinCommandElab choice]</span> <span class="keyword">def</span> <span class="function-name">elbChoice</span> : CommandElab <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="constant">=&gt;</span>
2516   elabChoiceAux stx.getArgs <span class="constant">0</span>
2517 
<span class="constant">2518 @</span>[builtinCommandElab <span class="comment">&#171;</span>universe<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabUniverse</span> : CommandElab <span class="constant">:=</span> <span class="keyword">fun</span> n <span class="constant">=&gt;</span> <span class="keyword">do</span>
2519   addUnivLevel n[<span class="constant">1</span>]
2520 
<span class="constant">2521 @</span>[builtinCommandElab <span class="comment">&#171;</span>universes<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabUniverses</span> : CommandElab <span class="constant">:=</span> <span class="keyword">fun</span> n <span class="constant">=&gt;</span> <span class="keyword">do</span>
2522   n[<span class="constant">1</span>].forArgsM addUnivLevel
2523 
<span class="constant">2524 @</span>[builtinCommandElab <span class="comment">&#171;</span>init_quot<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabInitQuot</span> : CommandElab <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="constant">=&gt;</span> <span class="keyword">do</span>
2525   <span class="keyword">match</span> (&#8592; getEnv).addDecl Declaration.quotDecl <span class="keyword">with</span>
2526   | Except.ok env   <span class="constant">=&gt;</span> setEnv env
2527   | Except.error ex <span class="constant">=&gt;</span> throwError (ex.toMessageData (&#8592; getOptions))
2528 
<span class="constant">2529 @</span>[builtinCommandElab <span class="comment">&#171;</span>export<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabExport</span> : CommandElab <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="constant">=&gt;</span> <span class="keyword">do</span>
2530   <span class="comment-delimiter">-- </span><span class="comment">`stx` is of the form (Command.export "export" &lt;namespace&gt; "(" (null &lt;ids&gt;*) ")")
</span>2531   <span class="keyword">let</span> id  <span class="constant">:=</span> stx[<span class="constant">1</span>].getId
2532   <span class="keyword">let</span> ns &#8592; resolveNamespace id
2533   <span class="keyword">let</span> currNamespace &#8592; getCurrNamespace
2534   <span class="keyword">if</span> ns <span class="constant">==</span> currNamespace <span class="keyword">then</span> throwError <span class="string">"invalid 'export', self export"</span>
2535   <span class="keyword">let</span> env &#8592; getEnv
2536   <span class="keyword">let</span> ids <span class="constant">:=</span> stx[<span class="constant">3</span>].getArgs
2537   <span class="keyword">let</span> aliases &#8592; ids.foldlM (init <span class="constant">:=</span> []) <span class="keyword">fun</span> (aliases : List (Name <span class="constant">&#215;</span> Name)) (idStx : Syntax) <span class="constant">=&gt;</span> <span class="keyword">do</span>
2538     <span class="keyword">let</span> id <span class="constant">:=</span> idStx.getId
2539     <span class="keyword">let</span> declName <span class="constant">:=</span> ns <span class="constant">++</span> id
2540     <span class="keyword">if</span> env.contains declName <span class="keyword">then</span>
2541       pure <span class="constant">&lt;</span>| (currNamespace <span class="constant">++</span> id, declName) :: aliases
2542     <span class="keyword">else</span>
2543       withRef idStx <span class="constant">&lt;</span>| logUnknownDecl declName
2544       pure aliases
2545   modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> env <span class="constant">:=</span> aliases.foldl (init <span class="constant">:=</span> s.env) <span class="keyword">fun</span> env p <span class="constant">=&gt;</span> addAlias env p.<span class="constant">1</span> p.<span class="constant">2</span> }
2546 
<span class="constant">2547 @</span>[builtinCommandElab <span class="comment">&#171;</span>open<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabOpen</span> : CommandElab <span class="constant">:=</span> <span class="keyword">fun</span> n <span class="constant">=&gt;</span> <span class="keyword">do</span>
2548   <span class="keyword">let</span> openDecls &#8592; elabOpenDecl n[<span class="constant">1</span>]
2549   modifyScope <span class="keyword">fun</span> scope <span class="constant">=&gt;</span> { scope <span class="keyword">with</span> openDecls <span class="constant">:=</span> openDecls }
2550 
<span class="constant">2551 @</span>[builtinCommandElab <span class="comment">&#171;</span>variable<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabVariable</span> : CommandElab
2552   | `(<span class="keyword">variable</span> <span class="constant">$</span>binders<span class="constant">*</span>) <span class="constant">=&gt;</span> <span class="keyword">do</span>
2553     <span class="comment-delimiter">-- </span><span class="comment">Try to elaborate `binders` for sanity checking
</span>2554     runTermElabM none <span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> Term.withAutoBoundImplicit <span class="constant">&lt;</span>|
2555       Term.elabBinders binders <span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> pure ()
2556     <span class="keyword">let</span> varUIds &#8592; binders.concatMap getBracketedBinderIds |<span class="constant">&gt;</span>.mapM (withFreshMacroScope <span class="constant">&#8728;</span> MonadQuotation.addMacroScope)
2557     modifyScope <span class="keyword">fun</span> scope <span class="constant">=&gt;</span> { scope <span class="keyword">with</span> varDecls <span class="constant">:=</span> scope.varDecls <span class="constant">++</span> binders, varUIds <span class="constant">:=</span> scope.varUIds <span class="constant">++</span> varUIds }
2558   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwUnsupportedSyntax
2559 
<span class="keyword">2560 open</span> Meta
2561 
<span class="doc">2562 @[builtinCommandElab Lean.Parser.Command.check]</span> <span class="keyword">def</span> <span class="function-name">elabCheck</span> : CommandElab
2563   | `(<span class="keyword">#check</span>%<span class="constant">$</span>tk <span class="constant">$</span>term) <span class="constant">=&gt;</span> withoutModifyingEnv <span class="constant">$</span> runTermElabM (some `_check) <span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">do</span>
2564     <span class="keyword">let</span> e &#8592; Term.elabTerm term none
2565     Term.synthesizeSyntheticMVarsNoPostponing
2566     <span class="keyword">let</span> (e, <span class="preprocessor">_</span>) &#8592; Term.levelMVarToParam (&#8592; instantiateMVars e)
2567     <span class="keyword">let</span> type &#8592; inferType e
2568     <span class="keyword">unless</span> e.isSyntheticSorry <span class="keyword">do</span>
2569       logInfoAt tk m<span class="constant">!</span><span class="string">"{e} : {type}"</span>
2570   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwUnsupportedSyntax
2571 
<span class="doc">2572 @[builtinCommandElab Lean.Parser.Command.reduce]</span> <span class="keyword">def</span> <span class="function-name">elabReduce</span> : CommandElab
2573   | `(<span class="keyword">#reduce</span>%<span class="constant">$</span>tk <span class="constant">$</span>term) <span class="constant">=&gt;</span> withoutModifyingEnv <span class="constant">&lt;</span>| runTermElabM (some `_check) <span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">do</span>
2574     <span class="keyword">let</span> e &#8592; Term.elabTerm term none
2575     Term.synthesizeSyntheticMVarsNoPostponing
2576     <span class="keyword">let</span> (e, <span class="preprocessor">_</span>) &#8592; Term.levelMVarToParam (&#8592; instantiateMVars e)
2577     <span class="comment-delimiter">-- </span><span class="comment">TODO: add options or notation for setting the following parameters
</span>2578     withTheReader Core.Context (<span class="keyword">fun</span> ctx <span class="constant">=&gt;</span> { ctx <span class="keyword">with</span> options <span class="constant">:=</span> ctx.options.setBool `smartUnfolding false }) <span class="keyword">do</span>
2579       <span class="keyword">let</span> e &#8592; withTransparency (mode <span class="constant">:=</span> TransparencyMode.all) <span class="constant">&lt;</span>| reduce e (skipProofs <span class="constant">:=</span> false) (skipTypes <span class="constant">:=</span> false)
2580       logInfoAt tk e
2581   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwUnsupportedSyntax
2582 
<span class="keyword">2583 def</span> <span class="function-name">hasNoErrorMessages</span> : CommandElabM Bool <span class="constant">:=</span> <span class="keyword">do</span>
2584   <span class="keyword">return</span> <span class="constant">!</span>(&#8592; get).messages.hasErrors
2585 
<span class="keyword">2586 def</span> <span class="function-name">failIfSucceeds</span> (x : CommandElabM Unit) : CommandElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
2587   <span class="keyword">let</span> resetMessages : CommandElabM MessageLog <span class="constant">:=</span> <span class="keyword">do</span>
2588     <span class="keyword">let</span> s &#8592; get
2589     <span class="keyword">let</span> messages <span class="constant">:=</span> s.messages;
2590     modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> messages <span class="constant">:=</span> {} };
2591     pure messages
2592   <span class="keyword">let</span> restoreMessages (prevMessages : MessageLog) : CommandElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
2593     modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> messages <span class="constant">:=</span> prevMessages <span class="constant">++</span> s.messages.errorsToWarnings }
2594   <span class="keyword">let</span> prevMessages &#8592; resetMessages
2595   <span class="keyword">let</span> succeeded &#8592;
2596     <span class="keyword">try</span>
2597       x
2598       hasNoErrorMessages
2599     <span class="keyword">catch</span>
2600       | ex<span class="constant">@</span>(Exception.error <span class="preprocessor">_</span> <span class="preprocessor">_</span>) <span class="constant">=&gt;</span> <span class="keyword">do</span> logException ex; pure false
2601       | Exception.internal id <span class="preprocessor">_</span>  <span class="constant">=&gt;</span> <span class="keyword">do</span> logError (&#8592; id.getName); pure false
2602     <span class="keyword">finally</span>
2603       restoreMessages prevMessages
2604   <span class="keyword">if</span> succeeded <span class="keyword">then</span>
2605     throwError <span class="string">"unexpected success"</span>
2606 
<span class="constant">2607 @</span>[builtinCommandElab <span class="comment">&#171;</span>check_failure<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabCheckFailure</span> : CommandElab
2608   | `(<span class="keyword">#check_failure</span> <span class="constant">$</span>term) <span class="constant">=&gt;</span> <span class="keyword">do</span>
2609     failIfSucceeds <span class="constant">&lt;</span>| elabCheck (&#8592; `(<span class="keyword">#check</span> <span class="constant">$</span>term))
2610   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwUnsupportedSyntax
2611 
<span class="keyword">2612 unsafe</span> <span class="keyword">def</span> <span class="function-name">elabEvalUnsafe</span> : CommandElab
2613   | `(<span class="keyword">#eval</span>%<span class="constant">$</span>tk <span class="constant">$</span>term) <span class="constant">=&gt;</span> <span class="keyword">do</span>
2614     <span class="keyword">let</span> n <span class="constant">:=</span> `_eval
2615     <span class="keyword">let</span> ctx &#8592; read
2616     <span class="keyword">let</span> addAndCompile (value : Expr) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
2617       <span class="keyword">let</span> type &#8592; inferType value
2618       <span class="keyword">let</span> decl <span class="constant">:=</span> Declaration.defnDecl {
2619         name        <span class="constant">:=</span> n
2620         levelParams <span class="constant">:=</span> []
2621         type        <span class="constant">:=</span> type
2622         value       <span class="constant">:=</span> value
2623         hints       <span class="constant">:=</span> ReducibilityHints.opaque
2624         safety      <span class="constant">:=</span> DefinitionSafety.<span class="keyword">unsafe</span>
2625       }
2626       Term.ensureNoUnassignedMVars decl
2627       addAndCompile decl
2628     <span class="keyword">let</span> elabMetaEval : CommandElabM Unit <span class="constant">:=</span> runTermElabM (some n) <span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">do</span>
2629       <span class="keyword">let</span> e &#8592; Term.elabTerm term none
2630       Term.synthesizeSyntheticMVarsNoPostponing
2631       <span class="keyword">let</span> e &#8592; withLocalDeclD `env (mkConst ``Lean.Environment) <span class="keyword">fun</span> env <span class="constant">=&gt;</span>
2632           withLocalDeclD `opts (mkConst ``Lean.Options) <span class="keyword">fun</span> opts <span class="constant">=&gt;</span> <span class="keyword">do</span>
2633             <span class="keyword">let</span> e &#8592; mkAppM ``Lean.runMetaEval <span class="constant">#</span>[env, opts, e];
2634             mkLambdaFVars <span class="constant">#</span>[env, opts] e
2635       <span class="keyword">let</span> env &#8592; getEnv
2636       <span class="keyword">let</span> opts &#8592; getOptions
2637       <span class="keyword">let</span> act &#8592; <span class="keyword">try</span> addAndCompile e; evalConst (Environment <span class="constant">&#8594;</span> Options <span class="constant">&#8594;</span> IO (String <span class="constant">&#215;</span> Except IO.Error Environment)) n <span class="keyword">finally</span> setEnv env
2638       <span class="keyword">let</span> (out, res) &#8592; act env opts <span class="comment-delimiter">-- </span><span class="comment">we execute `act` using the environment
</span>2639       logInfoAt tk out
2640       <span class="keyword">match</span> res <span class="keyword">with</span>
2641       | Except.error e <span class="constant">=&gt;</span> throwError e.toString
2642       | Except.ok env  <span class="constant">=&gt;</span> <span class="keyword">do</span> setEnv env; pure ()
2643     <span class="keyword">let</span> elabEval : CommandElabM Unit <span class="constant">:=</span> runTermElabM (some n) <span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">do</span>
2644       <span class="comment-delimiter">-- </span><span class="comment">fall back to non-meta eval if MetaEval hasn't been defined yet
</span>2645       <span class="comment-delimiter">-- </span><span class="comment">modify e to `runEval e`
</span>2646       <span class="keyword">let</span> e &#8592; Term.elabTerm term none
2647       <span class="keyword">let</span> e <span class="constant">:=</span> mkSimpleThunk e
2648       Term.synthesizeSyntheticMVarsNoPostponing
2649       <span class="keyword">let</span> e &#8592; mkAppM ``Lean.runEval <span class="constant">#</span>[e]
2650       <span class="keyword">let</span> env &#8592; getEnv
2651       <span class="keyword">let</span> act &#8592; <span class="keyword">try</span> addAndCompile e; evalConst (IO (String <span class="constant">&#215;</span> Except IO.Error Unit)) n <span class="keyword">finally</span> setEnv env
2652       <span class="keyword">let</span> (out, res) &#8592; liftM (m <span class="constant">:=</span> IO) act
2653       logInfoAt tk out
2654       <span class="keyword">match</span> res <span class="keyword">with</span>
2655       | Except.error e <span class="constant">=&gt;</span> throwError e.toString
2656       | Except.ok <span class="preprocessor">_</span>    <span class="constant">=&gt;</span> pure ()
2657     <span class="keyword">if</span> (&#8592; getEnv).contains ``Lean.MetaEval <span class="keyword">then</span> <span class="keyword">do</span>
2658       elabMetaEval
2659     <span class="keyword">else</span>
2660       elabEval
2661   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwUnsupportedSyntax
2662 
<span class="constant">2663 @</span>[builtinCommandElab <span class="comment">&#171;</span>eval<span class="comment">&#187;</span>, implementedBy elabEvalUnsafe]
<span class="keyword">2664 constant</span> <span class="function-name">elabEval</span> : CommandElab
2665 
<span class="constant">2666 @</span>[builtinCommandElab <span class="comment">&#171;</span>synth<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabSynth</span> : CommandElab <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="constant">=&gt;</span> <span class="keyword">do</span>
2667   <span class="keyword">let</span> term <span class="constant">:=</span> stx[<span class="constant">1</span>]
2668   withoutModifyingEnv <span class="constant">&lt;</span>| runTermElabM `_synth_cmd <span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">do</span>
2669     <span class="keyword">let</span> inst &#8592; Term.elabTerm term none
2670     Term.synthesizeSyntheticMVarsNoPostponing
2671     <span class="keyword">let</span> inst &#8592; instantiateMVars inst
2672     <span class="keyword">let</span> val  &#8592; synthInstance inst
2673     logInfo val
2674     pure ()
2675 
<span class="constant">2676 @</span>[builtinCommandElab <span class="comment">&#171;</span>set_option<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabSetOption</span> : CommandElab <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="constant">=&gt;</span> <span class="keyword">do</span>
2677   <span class="keyword">let</span> options &#8592; Elab.elabSetOption stx[<span class="constant">1</span>] stx[<span class="constant">2</span>]
2678   modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> maxRecDepth <span class="constant">:=</span> maxRecDepth.get options }
2679   modifyScope <span class="keyword">fun</span> scope <span class="constant">=&gt;</span> { scope <span class="keyword">with</span> opts <span class="constant">:=</span> options }
2680 
<span class="constant">2681 @</span>[builtinMacro Lean.Parser.Command.<span class="comment">&#171;</span>in<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">expandInCmd</span> : Macro <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="constant">=&gt;</span> <span class="keyword">do</span>
2682   <span class="keyword">let</span> cmd&#8321; <span class="constant">:=</span> stx[<span class="constant">0</span>]
2683   <span class="keyword">let</span> cmd&#8322; <span class="constant">:=</span> stx[<span class="constant">2</span>]
2684   `(<span class="keyword">section</span> <span class="constant">$</span>cmd&#8321;:command <span class="constant">$</span>cmd&#8322;:command <span class="keyword">end</span>)
2685 
<span class="keyword">2686 def</span> <span class="function-name">expandDeclId</span> (declId : Syntax) (modifiers : Modifiers) : CommandElabM ExpandDeclIdResult <span class="constant">:=</span> <span class="keyword">do</span>
2687   <span class="keyword">let</span> currNamespace &#8592; getCurrNamespace
2688   <span class="keyword">let</span> currLevelNames &#8592; getLevelNames
2689   Lean.Elab.expandDeclId currNamespace currLevelNames declId modifiers
2690 
<span class="keyword">2691 end</span> Elab.Command
2692 
<span class="keyword">2693 export</span> Elab.Command (Linter addLinter)
2694 
<span class="keyword">2695 end</span> Lean
2696 ::::::::::::::
2697 Elab<span class="constant">/</span>Declaration.lean
2698 ::::::::::::::
<span class="comment-delimiter">2699 /-</span><span class="comment">
2700 Copyright (c) 2020 Microsoft Corporation. All rights reserved.
2701 Released under Apache 2.0 license as described in the file LICENSE.
2702 Authors: Leonardo de Moura, Sebastian Ullrich
2703 -/</span>
<span class="keyword">2704 import</span> Lean.Util.CollectLevelParams
<span class="keyword">2705 import</span> Lean.Elab.DeclUtil
<span class="keyword">2706 import</span> Lean.Elab.DefView
<span class="keyword">2707 import</span> Lean.Elab.Inductive
<span class="keyword">2708 import</span> Lean.Elab.Structure
<span class="keyword">2709 import</span> Lean.Elab.MutualDef
<span class="keyword">2710 import</span> Lean.Elab.DeclarationRange
<span class="keyword">2711 namespace</span> Lean.Elab.Command
2712 
<span class="keyword">2713 open</span> Meta
2714 
<span class="comment-delimiter">2715 /- </span><span class="comment">Auxiliary function for `expandDeclNamespace?` -/</span>
<span class="keyword">2716 def</span> <span class="function-name">expandDeclIdNamespace?</span> (declId : Syntax) : Option (Name <span class="constant">&#215;</span> Syntax) <span class="constant">:=</span>
2717   <span class="keyword">let</span> (id, optUnivDeclStx) <span class="constant">:=</span> expandDeclIdCore declId
2718   <span class="keyword">let</span> scpView <span class="constant">:=</span> extractMacroScopes id
2719   <span class="keyword">match</span> scpView.name <span class="keyword">with</span>
2720   | Name.str Name.anonymous s <span class="preprocessor">_</span> <span class="constant">=&gt;</span> none
2721   | Name.str pre s <span class="preprocessor">_</span>            <span class="constant">=&gt;</span>
2722     <span class="keyword">let</span> nameNew <span class="constant">:=</span> { scpView <span class="keyword">with</span> name <span class="constant">:=</span> Name.mkSimple s }.review
2723     <span class="keyword">if</span> declId.isIdent <span class="keyword">then</span>
2724       some (pre, mkIdentFrom declId nameNew)
2725     <span class="keyword">else</span>
2726       some (pre, declId.setArg <span class="constant">0</span> (mkIdentFrom declId nameNew))
2727   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> none
2728 
<span class="comment-delimiter">2729 /- </span><span class="comment">given declarations such as `@[...] def Foo.Bla.f ...` return `some (Foo.Bla, @[...] def f ...)` -/</span>
<span class="keyword">2730 def</span> <span class="function-name">expandDeclNamespace?</span> (stx : Syntax) : Option (Name <span class="constant">&#215;</span> Syntax) <span class="constant">:=</span>
2731   <span class="keyword">if</span> <span class="constant">!</span>stx.isOfKind `Lean.Parser.Command.declaration <span class="keyword">then</span> none
2732   <span class="keyword">else</span>
2733     <span class="keyword">let</span> decl <span class="constant">:=</span> stx[<span class="constant">1</span>]
2734     <span class="keyword">let</span> k <span class="constant">:=</span> decl.getKind
2735     <span class="keyword">if</span> k <span class="constant">==</span> `Lean.Parser.Command.<span class="keyword">abbrev</span> <span class="constant">||</span>
2736        k <span class="constant">==</span> `Lean.Parser.Command.<span class="keyword">def</span> <span class="function-name">||</span>
2737        k <span class="constant">==</span> `Lean.Parser.Command.<span class="keyword">theorem</span> <span class="function-name">||</span>
2738        k <span class="constant">==</span> `Lean.Parser.Command.<span class="keyword">constant</span> <span class="function-name">||</span>
2739        k <span class="constant">==</span> `Lean.Parser.Command.<span class="keyword">axiom</span> <span class="function-name">||</span>
2740        k <span class="constant">==</span> `Lean.Parser.Command.<span class="keyword">inductive</span> <span class="function-name">||</span>
2741        k <span class="constant">==</span> `Lean.Parser.Command.classInductive <span class="constant">||</span>
2742        k <span class="constant">==</span> `Lean.Parser.Command.<span class="keyword">structure</span> <span class="function-name">then</span>
2743       <span class="keyword">match</span> expandDeclIdNamespace? decl[<span class="constant">1</span>] <span class="keyword">with</span>
2744       | some (ns, declId) <span class="constant">=&gt;</span> some (ns, stx.setArg <span class="constant">1</span> (decl.setArg <span class="constant">1</span> declId))
2745       | none              <span class="constant">=&gt;</span> none
2746     <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> `Lean.Parser.Command.<span class="keyword">instance</span> <span class="function-name">then</span>
2747       <span class="keyword">let</span> optDeclId <span class="constant">:=</span> decl[<span class="constant">3</span>]
2748       <span class="keyword">if</span> optDeclId.isNone <span class="keyword">then</span> none
2749       <span class="keyword">else</span> <span class="keyword">match</span> expandDeclIdNamespace? optDeclId[<span class="constant">0</span>] <span class="keyword">with</span>
2750         | some (ns, declId) <span class="constant">=&gt;</span> some (ns, stx.setArg <span class="constant">1</span> (decl.setArg <span class="constant">3</span> (optDeclId.setArg <span class="constant">0</span> declId)))
2751         | none              <span class="constant">=&gt;</span> none
2752     <span class="keyword">else</span>
2753       none
2754 
<span class="keyword">2755 def</span> <span class="function-name">elabAxiom</span> (modifiers : Modifiers) (stx : Syntax) : CommandElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
2756   <span class="comment-delimiter">-- </span><span class="comment">leading_parser "axiom " &gt;&gt; declId &gt;&gt; declSig
</span>2757   <span class="keyword">let</span> declId             <span class="constant">:=</span> stx[<span class="constant">1</span>]
2758   <span class="keyword">let</span> (binders, typeStx) <span class="constant">:=</span> expandDeclSig stx[<span class="constant">2</span>]
2759   <span class="keyword">let</span> scopeLevelNames &#8592; getLevelNames
2760   <span class="keyword">let</span> &#10216;name, declName, allUserLevelNames&#10217; &#8592; expandDeclId declId modifiers
2761   addDeclarationRanges declName stx
2762   runTermElabM declName <span class="keyword">fun</span> vars <span class="constant">=&gt;</span> Term.withLevelNames allUserLevelNames <span class="constant">$</span> Term.elabBinders binders.getArgs <span class="keyword">fun</span> xs <span class="constant">=&gt;</span> <span class="keyword">do</span>
2763     Term.applyAttributesAt declName modifiers.attrs AttributeApplicationTime.beforeElaboration
2764     <span class="keyword">let</span> type &#8592; Term.elabType typeStx
2765     Term.synthesizeSyntheticMVarsNoPostponing
2766     <span class="keyword">let</span> type &#8592; instantiateMVars type
2767     <span class="keyword">let</span> type &#8592; mkForallFVars xs type
2768     <span class="keyword">let</span> type &#8592; mkForallFVars vars type (usedOnly <span class="constant">:=</span> true)
2769     <span class="keyword">let</span> (type, <span class="preprocessor">_</span>) &#8592; Term.levelMVarToParam type
2770     <span class="keyword">let</span> usedParams  <span class="constant">:=</span> collectLevelParams {} type |<span class="constant">&gt;</span>.params
2771     <span class="keyword">match</span> sortDeclLevelParams scopeLevelNames allUserLevelNames usedParams <span class="keyword">with</span>
2772     | Except.error msg      <span class="constant">=&gt;</span> throwErrorAt stx msg
2773     | Except.ok levelParams <span class="constant">=&gt;</span>
2774       <span class="keyword">let</span> decl <span class="constant">:=</span> Declaration.axiomDecl {
2775         name        <span class="constant">:=</span> declName,
2776         levelParams <span class="constant">:=</span> levelParams,
2777         type        <span class="constant">:=</span> type,
2778         isUnsafe    <span class="constant">:=</span> modifiers.isUnsafe
2779       }
2780       Term.ensureNoUnassignedMVars decl
2781       addDecl decl
2782       Term.applyAttributesAt declName modifiers.attrs AttributeApplicationTime.afterTypeChecking
2783       <span class="keyword">if</span> isExtern (&#8592; getEnv) declName <span class="keyword">then</span>
2784         compileDecl decl
2785       Term.applyAttributesAt declName modifiers.attrs AttributeApplicationTime.afterCompilation
2786 
<span class="comment-delimiter">2787 /-</span><span class="comment">
2788 leading_parser "inductive " &gt;&gt; declId &gt;&gt; optDeclSig &gt;&gt; optional ":=" &gt;&gt; many ctor
2789 leading_parser atomic (group ("class " &gt;&gt; "inductive ")) &gt;&gt; declId &gt;&gt; optDeclSig &gt;&gt; optional ":=" &gt;&gt; many ctor &gt;&gt; optDeriving
2790 -/</span>
<span class="keyword">2791 private</span> <span class="keyword">def</span> <span class="function-name">inductiveSyntaxToView</span> (modifiers : Modifiers) (decl : Syntax) : CommandElabM InductiveView <span class="constant">:=</span> <span class="keyword">do</span>
2792   checkValidInductiveModifier modifiers
2793   <span class="keyword">let</span> (binders, type?) <span class="constant">:=</span> expandOptDeclSig decl[<span class="constant">2</span>]
2794   <span class="keyword">let</span> declId           <span class="constant">:=</span> decl[<span class="constant">1</span>]
2795   <span class="keyword">let</span> &#10216;name, declName, levelNames&#10217; &#8592; expandDeclId declId modifiers
2796   addDeclarationRanges declName decl
2797   <span class="keyword">let</span> ctors      &#8592; decl[<span class="constant">4</span>].getArgs.mapM <span class="keyword">fun</span> ctor <span class="constant">=&gt;</span> withRef ctor <span class="keyword">do</span>
2798     <span class="comment-delimiter">-- </span><span class="comment">def ctor := leading_parser " | " &gt;&gt; declModifiers &gt;&gt; ident &gt;&gt; optional inferMod &gt;&gt; optDeclSig
</span>2799     <span class="keyword">let</span> ctorModifiers &#8592; elabModifiers ctor[<span class="constant">1</span>]
2800     <span class="keyword">if</span> ctorModifiers.isPrivate <span class="constant">&amp;&amp;</span> modifiers.isPrivate <span class="keyword">then</span>
2801       throwError <span class="string">"invalid 'private' constructor in a 'private' inductive datatype"</span>
2802     <span class="keyword">if</span> ctorModifiers.isProtected <span class="constant">&amp;&amp;</span> modifiers.isPrivate <span class="keyword">then</span>
2803       throwError <span class="string">"invalid 'protected' constructor in a 'private' inductive datatype"</span>
2804     checkValidCtorModifier ctorModifiers
2805     <span class="keyword">let</span> ctorName <span class="constant">:=</span> ctor.getIdAt <span class="constant">2</span>
2806     <span class="keyword">let</span> ctorName <span class="constant">:=</span> declName <span class="constant">++</span> ctorName
2807     <span class="keyword">let</span> ctorName &#8592; withRef ctor[<span class="constant">2</span>] <span class="constant">$</span> applyVisibility ctorModifiers.visibility ctorName
2808     <span class="keyword">let</span> inferMod <span class="constant">:=</span> <span class="constant">!</span>ctor[<span class="constant">3</span>].isNone
2809     <span class="keyword">let</span> (binders, type?) <span class="constant">:=</span> expandOptDeclSig ctor[<span class="constant">4</span>]
2810     addDocString' ctorName ctorModifiers.docString?
2811     addAuxDeclarationRanges ctorName ctor ctor[<span class="constant">2</span>]
2812     pure { ref <span class="constant">:=</span> ctor, modifiers <span class="constant">:=</span> ctorModifiers, declName <span class="constant">:=</span> ctorName, inferMod <span class="constant">:=</span> inferMod, binders <span class="constant">:=</span> binders, type? <span class="constant">:=</span> type? : CtorView }
2813   <span class="keyword">let</span> classes &#8592; getOptDerivingClasses decl[<span class="constant">5</span>]
2814   pure {
2815     ref             <span class="constant">:=</span> decl
2816     modifiers       <span class="constant">:=</span> modifiers
2817     shortDeclName   <span class="constant">:=</span> name
2818     declName        <span class="constant">:=</span> declName
2819     levelNames      <span class="constant">:=</span> levelNames
2820     binders         <span class="constant">:=</span> binders
2821     type?           <span class="constant">:=</span> type?
2822     ctors           <span class="constant">:=</span> ctors
2823     derivingClasses <span class="constant">:=</span> classes
2824   }
2825 
<span class="keyword">2826 private</span> <span class="keyword">def</span> <span class="function-name">classInductiveSyntaxToView</span> (modifiers : Modifiers) (decl : Syntax) : CommandElabM InductiveView <span class="constant">:=</span>
2827   inductiveSyntaxToView modifiers decl
2828 
<span class="keyword">2829 def</span> <span class="function-name">elabInductive</span> (modifiers : Modifiers) (stx : Syntax) : CommandElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
2830   <span class="keyword">let</span> v &#8592; inductiveSyntaxToView modifiers stx
2831   elabInductiveViews <span class="constant">#</span>[v]
2832 
<span class="keyword">2833 def</span> <span class="function-name">elabClassInductive</span> (modifiers : Modifiers) (stx : Syntax) : CommandElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
2834   <span class="keyword">let</span> modifiers <span class="constant">:=</span> modifiers.addAttribute { name <span class="constant">:=</span> `<span class="keyword">class</span> <span class="function-name">}</span>
2835   <span class="keyword">let</span> v &#8592; classInductiveSyntaxToView modifiers stx
2836   elabInductiveViews <span class="constant">#</span>[v]
2837 
<span class="doc">2838 @[builtinCommandElab declaration]</span>
<span class="keyword">2839 def</span> <span class="function-name">elabDeclaration</span> : CommandElab <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="constant">=&gt;</span>
2840   <span class="keyword">match</span> expandDeclNamespace? stx <span class="keyword">with</span>
2841   | some (ns, newStx) <span class="constant">=&gt;</span> <span class="keyword">do</span>
2842     <span class="keyword">let</span> ns <span class="constant">:=</span> mkIdentFrom stx ns
2843     <span class="keyword">let</span> newStx &#8592; `(<span class="keyword">namespace</span> <span class="constant">$</span>ns:ident <span class="constant">$</span>newStx <span class="keyword">end</span> <span class="constant">$</span>ns:ident)
2844     withMacroExpansion stx newStx <span class="constant">$</span> elabCommand newStx
2845   | none <span class="constant">=&gt;</span> <span class="keyword">do</span>
2846     <span class="keyword">let</span> modifiers &#8592; elabModifiers stx[<span class="constant">0</span>]
2847     <span class="keyword">let</span> decl     <span class="constant">:=</span> stx[<span class="constant">1</span>]
2848     <span class="keyword">let</span> declKind <span class="constant">:=</span> decl.getKind
2849     <span class="keyword">if</span> declKind <span class="constant">==</span> `Lean.Parser.Command.<span class="comment">&#171;</span>axiom<span class="comment">&#187;</span> <span class="keyword">then</span>
2850       elabAxiom modifiers decl
2851     <span class="keyword">else</span> <span class="keyword">if</span> declKind <span class="constant">==</span> `Lean.Parser.Command.<span class="comment">&#171;</span>inductive<span class="comment">&#187;</span> <span class="keyword">then</span>
2852       elabInductive modifiers decl
2853     <span class="keyword">else</span> <span class="keyword">if</span> declKind <span class="constant">==</span> `Lean.Parser.Command.classInductive <span class="keyword">then</span>
2854       elabClassInductive modifiers decl
2855     <span class="keyword">else</span> <span class="keyword">if</span> declKind <span class="constant">==</span> `Lean.Parser.Command.<span class="comment">&#171;</span>structure<span class="comment">&#187;</span> <span class="keyword">then</span>
2856       elabStructure modifiers decl
2857     <span class="keyword">else</span> <span class="keyword">if</span> isDefLike decl <span class="keyword">then</span>
2858       elabMutualDef <span class="constant">#</span>[stx]
2859     <span class="keyword">else</span>
2860       throwError <span class="string">"unexpected declaration"</span>
2861 
<span class="comment-delimiter">2862 /- </span><span class="comment">Return true if all elements of the mutual-block are inductive declarations. -/</span>
<span class="keyword">2863 private</span> <span class="keyword">def</span> <span class="function-name">isMutualInductive</span> (stx : Syntax) : Bool <span class="constant">:=</span>
2864   stx[<span class="constant">1</span>].getArgs.all <span class="keyword">fun</span> elem <span class="constant">=&gt;</span>
2865     <span class="keyword">let</span> decl     <span class="constant">:=</span> elem[<span class="constant">1</span>]
2866     <span class="keyword">let</span> declKind <span class="constant">:=</span> decl.getKind
2867     declKind <span class="constant">==</span> `Lean.Parser.Command.<span class="keyword">inductive</span>
2868 
<span class="keyword">2869 private</span> <span class="keyword">def</span> <span class="function-name">elabMutualInductive</span> (elems : Array Syntax) : CommandElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
2870   <span class="keyword">let</span> views &#8592; elems.mapM <span class="keyword">fun</span> stx <span class="constant">=&gt;</span> <span class="keyword">do</span>
2871      <span class="keyword">let</span> modifiers &#8592; elabModifiers stx[<span class="constant">0</span>]
2872      inductiveSyntaxToView modifiers stx[<span class="constant">1</span>]
2873   elabInductiveViews views
2874 
<span class="comment-delimiter">2875 /- </span><span class="comment">Return true if all elements of the mutual-block are definitions/theorems/abbrevs. -/</span>
<span class="keyword">2876 private</span> <span class="keyword">def</span> <span class="function-name">isMutualDef</span> (stx : Syntax) : Bool <span class="constant">:=</span>
2877   stx[<span class="constant">1</span>].getArgs.all <span class="keyword">fun</span> elem <span class="constant">=&gt;</span>
2878     <span class="keyword">let</span> decl <span class="constant">:=</span> elem[<span class="constant">1</span>]
2879     isDefLike decl
2880 
<span class="keyword">2881 private</span> <span class="keyword">def</span> <span class="function-name">isMutualPreambleCommand</span> (stx : Syntax) : Bool <span class="constant">:=</span>
2882   <span class="keyword">let</span> k <span class="constant">:=</span> stx.getKind
2883   k <span class="constant">==</span> `Lean.Parser.Command.<span class="keyword">variable</span> <span class="constant">||</span>
2884   k <span class="constant">==</span> `Lean.Parser.Command.<span class="keyword">variables</span> <span class="constant">||</span>
2885   k <span class="constant">==</span> `Lean.Parser.Command.<span class="keyword">universe</span> <span class="constant">||</span>
2886   k <span class="constant">==</span> `Lean.Parser.Command.<span class="keyword">universes</span> <span class="constant">||</span>
2887   k <span class="constant">==</span> `Lean.Parser.Command.check <span class="constant">||</span>
2888   k <span class="constant">==</span> `Lean.Parser.Command.<span class="keyword">set_option</span> <span class="constant">||</span>
2889   k <span class="constant">==</span> `Lean.Parser.Command.<span class="keyword">open</span>
2890 
<span class="keyword">2891 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">splitMutualPreamble</span> (elems : Array Syntax) : Option (Array Syntax <span class="constant">&#215;</span> Array Syntax) <span class="constant">:=</span>
2892   <span class="keyword">let</span> <span class="keyword">rec</span> loop (i : Nat) : Option (Array Syntax <span class="constant">&#215;</span> Array Syntax) <span class="constant">:=</span>
2893     <span class="keyword">if</span> h : i <span class="constant">&lt;</span> elems.size <span class="keyword">then</span>
2894       <span class="keyword">let</span> elem <span class="constant">:=</span> elems.get &#10216;i, h&#10217;
2895       <span class="keyword">if</span> isMutualPreambleCommand elem <span class="keyword">then</span>
2896         loop (i<span class="constant">+1</span>)
2897       <span class="keyword">else</span> <span class="keyword">if</span> i <span class="constant">==</span> <span class="constant">0</span> <span class="keyword">then</span>
2898         none <span class="comment-delimiter">-- </span><span class="comment">`mutual` block does not contain any preamble commands
</span>2899       <span class="keyword">else</span>
2900         some (elems[<span class="constant">0</span>:i], elems[i:elems.size])
2901     <span class="keyword">else</span>
2902       none <span class="comment-delimiter">-- </span><span class="comment">a `mutual` block containing only preamble commands is not a valid `mutual` block
</span>2903   loop <span class="constant">0</span>
2904 
<span class="doc">2905 @[builtinMacro Lean.Parser.Command.mutual]</span>
<span class="keyword">2906 def</span> <span class="function-name">expandMutualNamespace</span> : Macro <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="constant">=&gt;</span> <span class="keyword">do</span>
2907   <span class="keyword">let</span> <span class="keyword">mut</span> ns?      <span class="constant">:=</span> none
2908   <span class="keyword">let</span> <span class="keyword">mut</span> elemsNew <span class="constant">:=</span> <span class="constant">#</span>[]
2909   <span class="keyword">for</span> elem <span class="keyword">in</span> stx[<span class="constant">1</span>].getArgs <span class="keyword">do</span>
2910     <span class="keyword">match</span> ns?, expandDeclNamespace? elem <span class="keyword">with</span>
2911     | <span class="preprocessor">_</span>, none                         <span class="constant">=&gt;</span> elemsNew <span class="constant">:=</span> elemsNew.push elem
2912     | none, some (ns, elem)           <span class="constant">=&gt;</span> ns? <span class="constant">:=</span> some ns; elemsNew <span class="constant">:=</span> elemsNew.push elem
2913     | some nsCurr, some (nsNew, elem) <span class="constant">=&gt;</span>
2914       <span class="keyword">if</span> nsCurr <span class="constant">==</span> nsNew <span class="keyword">then</span>
2915         elemsNew <span class="constant">:=</span> elemsNew.push elem
2916       <span class="keyword">else</span>
2917         Macro.throwErrorAt elem s<span class="constant">!</span><span class="string">"conflicting namespaces in mutual declaration, using namespace '{nsNew}', but used '{nsCurr}' in previous declaration"</span>
2918   <span class="keyword">match</span> ns? <span class="keyword">with</span>
2919   | some ns <span class="constant">=&gt;</span>
2920     <span class="keyword">let</span> ns <span class="constant">:=</span> mkIdentFrom stx ns
2921     <span class="keyword">let</span> stxNew <span class="constant">:=</span> stx.setArg <span class="constant">1</span> (mkNullNode elemsNew)
2922     `(<span class="keyword">namespace</span> <span class="constant">$</span>ns:ident <span class="constant">$</span>stxNew <span class="keyword">end</span> <span class="constant">$</span>ns:ident)
2923   | none <span class="constant">=&gt;</span> Macro.throwUnsupported
2924 
<span class="doc">2925 @[builtinMacro Lean.Parser.Command.mutual]</span>
<span class="keyword">2926 def</span> <span class="function-name">expandMutualElement</span> : Macro <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="constant">=&gt;</span> <span class="keyword">do</span>
2927   <span class="keyword">let</span> <span class="keyword">mut</span> elemsNew <span class="constant">:=</span> <span class="constant">#</span>[]
2928   <span class="keyword">let</span> <span class="keyword">mut</span> modified <span class="constant">:=</span> false
2929   <span class="keyword">for</span> elem <span class="keyword">in</span> stx[<span class="constant">1</span>].getArgs <span class="keyword">do</span>
2930     <span class="keyword">match</span> (&#8592; expandMacro? elem) <span class="keyword">with</span>
2931     | some elemNew <span class="constant">=&gt;</span> elemsNew <span class="constant">:=</span> elemsNew.push elemNew; modified <span class="constant">:=</span> true
2932     | none         <span class="constant">=&gt;</span> elemsNew <span class="constant">:=</span> elemsNew.push elem
2933   <span class="keyword">if</span> modified <span class="keyword">then</span>
2934     pure <span class="constant">$</span> stx.setArg <span class="constant">1</span> (mkNullNode elemsNew)
2935   <span class="keyword">else</span>
2936     Macro.throwUnsupported
2937 
<span class="doc">2938 @[builtinMacro Lean.Parser.Command.mutual]</span>
<span class="keyword">2939 def</span> <span class="function-name">expandMutualPreamble</span> : Macro <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="constant">=&gt;</span>
2940   <span class="keyword">match</span> splitMutualPreamble stx[<span class="constant">1</span>].getArgs <span class="keyword">with</span>
2941   | none <span class="constant">=&gt;</span> Macro.throwUnsupported
2942   | some (preamble, rest) <span class="constant">=&gt;</span> <span class="keyword">do</span>
2943     <span class="keyword">let</span> secCmd    &#8592; `(<span class="keyword">section</span>)
2944     <span class="keyword">let</span> newMutual <span class="constant">:=</span> stx.setArg <span class="constant">1</span> (mkNullNode rest)
2945     <span class="keyword">let</span> endCmd    &#8592; `(<span class="keyword">end</span>)
2946     pure <span class="constant">$</span> mkNullNode (<span class="constant">#</span>[secCmd] <span class="constant">++</span> preamble <span class="constant">++</span> <span class="constant">#</span>[newMutual] <span class="constant">++</span> <span class="constant">#</span>[endCmd])
2947 
<span class="constant">2948 @</span>[builtinCommandElab <span class="comment">&#171;</span>mutual<span class="comment">&#187;</span>]
<span class="keyword">2949 def</span> <span class="function-name">elabMutual</span> : CommandElab <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="constant">=&gt;</span> <span class="keyword">do</span>
2950   <span class="keyword">if</span> isMutualInductive stx <span class="keyword">then</span>
2951     elabMutualInductive stx[<span class="constant">1</span>].getArgs
2952   <span class="keyword">else</span> <span class="keyword">if</span> isMutualDef stx <span class="keyword">then</span>
2953     elabMutualDef stx[<span class="constant">1</span>].getArgs
2954   <span class="keyword">else</span>
2955     throwError <span class="string">"invalid mutual block"</span>
2956 
<span class="comment-delimiter">2957 /- </span><span class="comment">leading_parser "attribute " &gt;&gt; "[" &gt;&gt; sepBy1 (eraseAttr &lt;|&gt; Term.attrInstance) ", " &gt;&gt; "]" &gt;&gt; many1 ident -/</span>
<span class="constant">2958 @</span>[builtinCommandElab <span class="comment">&#171;</span>attribute<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabAttr</span> : CommandElab <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="constant">=&gt;</span> <span class="keyword">do</span>
2959   <span class="keyword">let</span> <span class="keyword">mut</span> attrInsts <span class="constant">:=</span> <span class="constant">#</span>[]
2960   <span class="keyword">let</span> <span class="keyword">mut</span> toErase <span class="constant">:=</span> <span class="constant">#</span>[]
2961   <span class="keyword">for</span> attrKindStx <span class="keyword">in</span> stx[<span class="constant">2</span>].getSepArgs <span class="keyword">do</span>
2962     <span class="keyword">if</span> attrKindStx.getKind <span class="constant">==</span> ``Lean.Parser.Command.eraseAttr <span class="keyword">then</span>
2963       <span class="keyword">let</span> attrName <span class="constant">:=</span> attrKindStx[<span class="constant">1</span>].getId.eraseMacroScopes
2964       <span class="keyword">unless</span> isAttribute (&#8592; getEnv) attrName <span class="keyword">do</span>
2965         throwError <span class="string">"unknown attribute [{attrName}]"</span>
2966       toErase <span class="constant">:=</span> toErase.push attrName
2967     <span class="keyword">else</span>
2968       attrInsts <span class="constant">:=</span> attrInsts.push attrKindStx
2969   <span class="keyword">let</span> attrs &#8592; elabAttrs attrInsts
2970   <span class="keyword">let</span> idents <span class="constant">:=</span> stx[<span class="constant">4</span>].getArgs
2971   <span class="keyword">for</span> ident <span class="keyword">in</span> idents <span class="keyword">do</span> withRef ident <span class="constant">&lt;</span>| liftTermElabM none <span class="keyword">do</span>
2972     <span class="keyword">let</span> declName &#8592; resolveGlobalConstNoOverloadWithInfo ident
2973     Term.applyAttributes declName attrs
2974     <span class="keyword">for</span> attrName <span class="keyword">in</span> toErase <span class="keyword">do</span>
2975       Attribute.erase declName attrName
2976 
<span class="keyword">2977 def</span> <span class="function-name">expandInitCmd</span> (builtin : Bool) : Macro <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="constant">=&gt;</span>
2978   <span class="keyword">let</span> optHeader <span class="constant">:=</span> stx[<span class="constant">1</span>]
2979   <span class="keyword">let</span> doSeq     <span class="constant">:=</span> stx[<span class="constant">2</span>]
2980   <span class="keyword">let</span> attrId    <span class="constant">:=</span> mkIdentFrom stx <span class="constant">$</span> <span class="keyword">if</span> builtin <span class="keyword">then</span> `builtinInit <span class="keyword">else</span> `init
2981   <span class="keyword">if</span> optHeader.isNone <span class="keyword">then</span>
2982     `(<span class="doc">@[$attrId:ident]</span><span class="keyword">def</span> <span class="function-name">initFn</span> : IO Unit <span class="constant">:=</span> <span class="keyword">do</span> <span class="constant">$</span>doSeq)
2983   <span class="keyword">else</span>
2984     <span class="keyword">let</span> id   <span class="constant">:=</span> optHeader[<span class="constant">0</span>]
2985     <span class="keyword">let</span> type <span class="constant">:=</span> optHeader[<span class="constant">1</span>][<span class="constant">1</span>]
2986     `(<span class="keyword">def</span> <span class="function-name">initFn</span> : IO <span class="constant">$</span>type <span class="constant">:=</span> <span class="keyword">do</span> <span class="constant">$</span>doSeq
2987       <span class="doc">@[$attrId:ident initFn]</span><span class="keyword">constant</span> <span class="function-name">$id</span> : <span class="constant">$</span>type)
2988 
<span class="constant">2989 @</span>[builtinMacro Lean.Parser.Command.<span class="comment">&#171;</span>initialize<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">expandInitialize</span> : Macro <span class="constant">:=</span>
2990   expandInitCmd (builtin <span class="constant">:=</span> false)
2991 
<span class="constant">2992 @</span>[builtinMacro Lean.Parser.Command.<span class="comment">&#171;</span>builtin_initialize<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">expandBuiltinInitialize</span> : Macro <span class="constant">:=</span>
2993   expandInitCmd (builtin <span class="constant">:=</span> true)
2994 
<span class="keyword">2995 end</span> Lean.Elab.Command
2996 ::::::::::::::
2997 Elab<span class="constant">/</span>DeclarationRange.lean
2998 ::::::::::::::
<span class="comment-delimiter">2999 /-</span><span class="comment">
3000 Copyright (c) 2021 Microsoft Corporation. All rights reserved.
3001 Released under Apache 2.0 license as described in the file LICENSE.
3002 Authors: Leonardo de Moura
3003 -/</span>
<span class="keyword">3004 import</span> Lean.DeclarationRange
<span class="keyword">3005 import</span> Lean.Elab.Log
<span class="keyword">3006 import</span> Lean.Data.Lsp.Utf16
3007 
<span class="keyword">3008 namespace</span> Lean.Elab
3009 
<span class="keyword">3010 def</span> <span class="function-name">getDeclarationRange</span> [Monad m] [MonadFileMap m] (stx : Syntax) : m DeclarationRange <span class="constant">:=</span> <span class="keyword">do</span>
3011   <span class="keyword">let</span> fileMap &#8592; getFileMap
3012   <span class="keyword">let</span> pos    <span class="constant">:=</span> stx.getPos?.getD <span class="constant">0</span>
3013   <span class="keyword">let</span> endPos <span class="constant">:=</span> stx.getTailPos?.getD pos |<span class="constant">&gt;</span> fileMap.toPosition
3014   <span class="keyword">let</span> pos    <span class="constant">:=</span> pos |<span class="constant">&gt;</span> fileMap.toPosition
3015   <span class="keyword">return</span> {
3016     pos          <span class="constant">:=</span> pos
3017     charUtf16    <span class="constant">:=</span> fileMap.leanPosToLspPos pos |<span class="constant">&gt;</span>.character
3018     endPos       <span class="constant">:=</span> endPos
3019     endCharUtf16 <span class="constant">:=</span> fileMap.leanPosToLspPos endPos |<span class="constant">&gt;</span>.character
3020   }
3021 
<span class="comment-delimiter">3022 /-</span><span class="comment">-
3023   For most builtin declarations, the selection range is just its name, which is stored in the second position.
3024   Example:
3025   ```
3026   "def " &gt;&gt; declId &gt;&gt; optDeclSig &gt;&gt; declVal
3027   ```
3028   For instances, we use the whole header since the name is optional.
3029   This function converts the given `Syntax` into one that represents its "selection range".
3030 -/</span>
<span class="keyword">3031 def</span> <span class="function-name">getDeclarationSelectionRef</span> (stx : Syntax) : Syntax <span class="constant">:=</span>
3032   <span class="keyword">if</span> stx.getKind <span class="constant">==</span> ``Parser.Command.<span class="comment">&#171;</span>instance<span class="comment">&#187;</span> <span class="keyword">then</span>
3033     stx.setArg <span class="constant">5</span> mkNullNode
3034   <span class="keyword">else</span>
3035     stx[<span class="constant">1</span>]
3036 
<span class="comment-delimiter">3037 /-</span><span class="comment">-
3038   Store the `range` and `selectionRange` for `declName` where `stx` is the whole syntax object decribing `declName`.
3039   This method is for the builtin declarations only.
3040   User-defined commands should use `Lean.addDeclarationRanges` to store this information for their commands. -/</span>
<span class="keyword">3041 def</span> <span class="function-name">addDeclarationRanges</span> [Monad m] [MonadEnv m] [MonadFileMap m] (declName : Name) (stx : Syntax) : m Unit <span class="constant">:=</span> <span class="keyword">do</span>
3042   <span class="keyword">if</span> stx.getKind <span class="constant">==</span> ``Parser.Command.<span class="comment">&#171;</span>example<span class="comment">&#187;</span> <span class="keyword">then</span>
3043     <span class="keyword">return</span> ()
3044   <span class="keyword">else</span>
3045     Lean.addDeclarationRanges declName {
3046       range          <span class="constant">:=</span> (&#8592; getDeclarationRange stx)
3047       selectionRange <span class="constant">:=</span> (&#8592; getDeclarationRange (getDeclarationSelectionRef stx))
3048     }
3049 
<span class="comment-delimiter">3050 /-</span><span class="comment">- Auxiliary method for recording ranges for auxiliary declarations (e.g., fields, nested declarations, etc. -/</span>
<span class="keyword">3051 def</span> <span class="function-name">addAuxDeclarationRanges</span> [Monad m] [MonadEnv m] [MonadFileMap m] (declName : Name) (stx : Syntax) (header : Syntax) : m Unit <span class="constant">:=</span> <span class="keyword">do</span>
3052   Lean.addDeclarationRanges declName {
3053     range          <span class="constant">:=</span> (&#8592; getDeclarationRange stx)
3054     selectionRange <span class="constant">:=</span> (&#8592; getDeclarationRange header)
3055   }
3056 
<span class="keyword">3057 end</span> Lean.Elab
3058 ::::::::::::::
3059 Elab<span class="constant">/</span>DeclModifiers.lean
3060 ::::::::::::::
<span class="comment-delimiter">3061 /-</span><span class="comment">
3062 Copyright (c) 2020 Microsoft Corporation. All rights reserved.
3063 Released under Apache 2.0 license as described in the file LICENSE.
3064 Authors: Leonardo de Moura, Sebastian Ullrich
3065 -/</span>
<span class="keyword">3066 import</span> Lean.Modifiers
<span class="keyword">3067 import</span> Lean.DocString
<span class="keyword">3068 import</span> Lean.Elab.Attributes
<span class="keyword">3069 import</span> Lean.Elab.Exception
<span class="keyword">3070 import</span> Lean.Elab.DeclUtil
3071 
<span class="keyword">3072 namespace</span> Lean.Elab
3073 
<span class="keyword">3074 def</span> <span class="function-name">checkNotAlreadyDeclared</span> {m} [Monad m] [MonadEnv m] [MonadError m] (declName : Name) : m Unit <span class="constant">:=</span> <span class="keyword">do</span>
3075   <span class="keyword">let</span> env &#8592; getEnv
3076   <span class="keyword">if</span> env.contains declName <span class="keyword">then</span>
3077     <span class="keyword">match</span> privateToUserName? declName <span class="keyword">with</span>
3078     | none          <span class="constant">=&gt;</span> throwError <span class="string">"'{declName}' has already been declared"</span>
3079     | some declName <span class="constant">=&gt;</span> throwError <span class="string">"private declaration '{declName}' has already been declared"</span>
3080   <span class="keyword">if</span> env.contains (mkPrivateName env declName) <span class="keyword">then</span>
3081     throwError <span class="string">"a private declaration '{declName}' has already been declared"</span>
3082   <span class="keyword">match</span> privateToUserName? declName <span class="keyword">with</span>
3083   | none <span class="constant">=&gt;</span> pure ()
3084   | some declName <span class="constant">=&gt;</span>
3085     <span class="keyword">if</span> env.contains declName <span class="keyword">then</span>
3086       throwError <span class="string">"a non-private declaration '{declName}' has already been declared"</span>
3087 
<span class="keyword">3088 inductive</span> <span class="function-name">Visibility</span> <span class="keyword">where</span>
3089   | regular | <span class="comment">&#171;</span>protected<span class="comment">&#187;</span> | <span class="comment">&#171;</span>private<span class="comment">&#187;</span>
3090   <span class="keyword">deriving</span> Inhabited
3091 
<span class="keyword">3092 instance</span> <span class="function-name">:</span> ToString Visibility <span class="constant">:=</span> &#10216;<span class="keyword">fun</span>
3093   | Visibility.regular     <span class="constant">=&gt;</span> <span class="string">"regular"</span>
3094   | Visibility.<span class="comment">&#171;</span>private<span class="comment">&#187;</span>   <span class="constant">=&gt;</span> <span class="string">"private"</span>
3095   | Visibility.<span class="comment">&#171;</span>protected<span class="comment">&#187;</span> <span class="constant">=&gt;</span> <span class="string">"protected"</span>&#10217;
3096 
<span class="keyword">3097 structure</span> <span class="function-name">Modifiers</span> <span class="keyword">where</span>
3098   docString?      : Option String <span class="constant">:=</span> none
3099   visibility      : Visibility <span class="constant">:=</span> Visibility.regular
3100   isNoncomputable : Bool <span class="constant">:=</span> false
3101   isPartial       : Bool <span class="constant">:=</span> false
3102   isUnsafe        : Bool <span class="constant">:=</span> false
3103   attrs           : Array Attribute <span class="constant">:=</span> <span class="constant">#</span>[]
3104   <span class="keyword">deriving</span> Inhabited
3105 
<span class="keyword">3106 def</span> <span class="function-name">Modifiers.isPrivate</span> : Modifiers <span class="constant">&#8594;</span> Bool
3107   | { visibility <span class="constant">:=</span> Visibility.<span class="keyword">private</span>, .. } <span class="constant">=&gt;</span> true
3108   | <span class="preprocessor">_</span>                                        <span class="constant">=&gt;</span> false
3109 
<span class="keyword">3110 def</span> <span class="function-name">Modifiers.isProtected</span> : Modifiers <span class="constant">&#8594;</span> Bool
3111   | { visibility <span class="constant">:=</span> Visibility.<span class="keyword">protected</span>, .. } <span class="constant">=&gt;</span> true
3112   | <span class="preprocessor">_</span>                                          <span class="constant">=&gt;</span> false
3113 
<span class="keyword">3114 def</span> <span class="function-name">Modifiers.addAttribute</span> (modifiers : Modifiers) (attr : Attribute) : Modifiers <span class="constant">:=</span>
3115   { modifiers <span class="keyword">with</span> attrs <span class="constant">:=</span> modifiers.attrs.push attr }
3116 
<span class="keyword">3117 instance</span> <span class="function-name">:</span> ToFormat Modifiers <span class="constant">:=</span> &#10216;<span class="keyword">fun</span> m <span class="constant">=&gt;</span>
3118   <span class="keyword">let</span> components : List Format <span class="constant">:=</span>
3119     (<span class="keyword">match</span> m.docString? <span class="keyword">with</span>
3120      | some str <span class="constant">=&gt;</span> [f<span class="constant">!</span><span class="string">"/--{str}-/"</span>]
3121      | none     <span class="constant">=&gt;</span> [])
3122     <span class="constant">++</span> (<span class="keyword">match</span> m.visibility <span class="keyword">with</span>
3123      | Visibility.regular   <span class="constant">=&gt;</span> []
3124      | Visibility.<span class="keyword">protected</span> <span class="constant">=&gt;</span> [f<span class="constant">!</span><span class="string">"protected"</span>]
3125      | Visibility.<span class="keyword">private</span>   <span class="constant">=&gt;</span> [f<span class="constant">!</span><span class="string">"private"</span>])
3126     <span class="constant">++</span> (<span class="keyword">if</span> m.isNoncomputable <span class="keyword">then</span> [f<span class="constant">!</span><span class="string">"noncomputable"</span>] <span class="keyword">else</span> [])
3127     <span class="constant">++</span> (<span class="keyword">if</span> m.isPartial <span class="keyword">then</span> [f<span class="constant">!</span><span class="string">"partial"</span>] <span class="keyword">else</span> [])
3128     <span class="constant">++</span> (<span class="keyword">if</span> m.isUnsafe <span class="keyword">then</span> [f<span class="constant">!</span><span class="string">"unsafe"</span>] <span class="keyword">else</span> [])
3129     <span class="constant">++</span> m.attrs.toList.map (<span class="keyword">fun</span> attr <span class="constant">=&gt;</span> fmt attr)
3130   Format.bracket <span class="string">"{"</span> (Format.joinSep components (<span class="string">","</span> <span class="constant">++</span> Format.line)) <span class="string">"}"</span>&#10217;
3131 
<span class="keyword">3132 instance</span> <span class="function-name">:</span> ToString Modifiers <span class="constant">:=</span> &#10216;toString <span class="constant">&#8728;</span> format&#10217;
3133 
<span class="keyword">3134 def</span> <span class="function-name">expandOptDocComment?</span> [Monad m] [MonadError m] (optDocComment : Syntax) : m (Option String) <span class="constant">:=</span>
3135   <span class="keyword">match</span> optDocComment.getOptional? <span class="keyword">with</span>
3136   | none   <span class="constant">=&gt;</span> pure none
3137   | some s <span class="constant">=&gt;</span> <span class="keyword">match</span> s[<span class="constant">1</span>] <span class="keyword">with</span>
3138     | Syntax.atom <span class="preprocessor">_</span> val <span class="constant">=&gt;</span> pure (some (val.extract <span class="constant">0</span> (val.bsize <span class="constant">-</span> <span class="constant">2</span>)))
3139     | <span class="preprocessor">_</span>                 <span class="constant">=&gt;</span> throwErrorAt s <span class="string">"unexpected doc string{indentD s[1]}"</span>
3140 
<span class="keyword">3141 section</span> Methods
3142 
<span class="keyword">3143 variable</span> [Monad m] [MonadEnv m] [MonadResolveName m] [MonadError m] [MonadMacroAdapter m] [MonadRecDepth m]
3144 
<span class="keyword">3145 def</span> <span class="function-name">elabModifiers</span> (stx : Syntax) : m Modifiers <span class="constant">:=</span> <span class="keyword">do</span>
3146   <span class="keyword">let</span> docCommentStx <span class="constant">:=</span> stx[<span class="constant">0</span>]
3147   <span class="keyword">let</span> attrsStx      <span class="constant">:=</span> stx[<span class="constant">1</span>]
3148   <span class="keyword">let</span> visibilityStx <span class="constant">:=</span> stx[<span class="constant">2</span>]
3149   <span class="keyword">let</span> noncompStx    <span class="constant">:=</span> stx[<span class="constant">3</span>]
3150   <span class="keyword">let</span> unsafeStx     <span class="constant">:=</span> stx[<span class="constant">4</span>]
3151   <span class="keyword">let</span> partialStx    <span class="constant">:=</span> stx[<span class="constant">5</span>]
3152   <span class="keyword">let</span> docString? &#8592; <span class="keyword">match</span> docCommentStx.getOptional? <span class="keyword">with</span>
3153     | none   <span class="constant">=&gt;</span> pure none
3154     | some s <span class="constant">=&gt;</span> <span class="keyword">match</span> s[<span class="constant">1</span>] <span class="keyword">with</span>
3155       | Syntax.atom <span class="preprocessor">_</span> val <span class="constant">=&gt;</span> pure (some (val.extract <span class="constant">0</span> (val.bsize <span class="constant">-</span> <span class="constant">2</span>)))
3156       | <span class="preprocessor">_</span>                 <span class="constant">=&gt;</span> throwErrorAt s <span class="string">"unexpected doc string{indentD s[1]}"</span>
3157   <span class="keyword">let</span> visibility &#8592; <span class="keyword">match</span> visibilityStx.getOptional? <span class="keyword">with</span>
3158     | none   <span class="constant">=&gt;</span> pure Visibility.regular
3159     | some v <span class="constant">=&gt;</span>
3160       <span class="keyword">let</span> kind <span class="constant">:=</span> v.getKind
3161       <span class="keyword">if</span> kind <span class="constant">==</span> `Lean.Parser.Command.<span class="keyword">private</span> <span class="keyword">then</span> pure Visibility.<span class="keyword">private</span>
3162       <span class="keyword">else</span> <span class="keyword">if</span> kind <span class="constant">==</span> `Lean.Parser.Command.<span class="keyword">protected</span> <span class="keyword">then</span> pure Visibility.<span class="keyword">protected</span>
3163       <span class="keyword">else</span> throwErrorAt v <span class="string">"unexpected visibility modifier"</span>
3164   <span class="keyword">let</span> attrs &#8592; <span class="keyword">match</span> attrsStx.getOptional? <span class="keyword">with</span>
3165     | none       <span class="constant">=&gt;</span> pure <span class="constant">#</span>[]
3166     | some attrs <span class="constant">=&gt;</span> elabDeclAttrs attrs
3167   pure {
3168     docString?      <span class="constant">:=</span> docString?,
3169     visibility      <span class="constant">:=</span> visibility,
3170     isPartial       <span class="constant">:=</span> <span class="constant">!</span>partialStx.isNone,
3171     isUnsafe        <span class="constant">:=</span> <span class="constant">!</span>unsafeStx.isNone,
3172     isNoncomputable <span class="constant">:=</span> <span class="constant">!</span>noncompStx.isNone,
3173     attrs           <span class="constant">:=</span> attrs
3174   }
3175 
<span class="keyword">3176 def</span> <span class="function-name">applyVisibility</span> (visibility : Visibility) (declName : Name) : m Name <span class="constant">:=</span> <span class="keyword">do</span>
3177   <span class="keyword">match</span> visibility <span class="keyword">with</span>
3178   | Visibility.<span class="keyword">private</span> <span class="constant">=&gt;</span>
3179     <span class="keyword">let</span> env &#8592; getEnv
3180     <span class="keyword">let</span> declName <span class="constant">:=</span> mkPrivateName env declName
3181     checkNotAlreadyDeclared declName
3182     pure declName
3183   | Visibility.<span class="keyword">protected</span> <span class="constant">=&gt;</span>
3184     checkNotAlreadyDeclared declName
3185     <span class="keyword">let</span> env &#8592; getEnv
3186     <span class="keyword">let</span> env <span class="constant">:=</span> addProtected env declName
3187     setEnv env
3188     pure declName
3189   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
3190     checkNotAlreadyDeclared declName
3191     pure declName
3192 
<span class="keyword">3193 def</span> <span class="function-name">mkDeclName</span> (currNamespace : Name) (modifiers : Modifiers) (shortName : Name) : m (Name <span class="constant">&#215;</span> Name) <span class="constant">:=</span> <span class="keyword">do</span>
3194   <span class="keyword">let</span> name <span class="constant">:=</span> (extractMacroScopes shortName).name
3195   <span class="keyword">unless</span> name.isAtomic <span class="constant">||</span> isFreshInstanceName name <span class="keyword">do</span>
3196     throwError <span class="string">"atomic identifier expected '{shortName}'"</span>
3197   <span class="keyword">let</span> declName <span class="constant">:=</span> currNamespace <span class="constant">++</span> shortName
3198   <span class="keyword">let</span> declName &#8592; applyVisibility modifiers.visibility declName
3199   <span class="keyword">match</span> modifiers.visibility <span class="keyword">with</span>
3200   | Visibility.<span class="keyword">protected</span> <span class="constant">=&gt;</span>
3201     <span class="keyword">match</span> currNamespace <span class="keyword">with</span>
3202     | Name.str <span class="preprocessor">_</span> s <span class="preprocessor">_</span> <span class="constant">=&gt;</span> pure (declName, Name.mkSimple s <span class="constant">++</span> shortName)
3203     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwError <span class="string">"protected declarations must be in a namespace"</span>
3204   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> pure (declName, shortName)
3205 
<span class="comment-delimiter">3206 /-</span><span class="comment">
3207   `declId` is of the form
3208   ```
3209   leading_parser ident &gt;&gt; optional (".{" &gt;&gt; sepBy1 ident ", " &gt;&gt; "}")
3210   ```
3211   but we also accept a single identifier to users to make macro writing more convenient .
3212 -/</span>
<span class="keyword">3213 def</span> <span class="function-name">expandDeclIdCore</span> (declId : Syntax) : Name <span class="constant">&#215;</span> Syntax <span class="constant">:=</span>
3214   <span class="keyword">if</span> declId.isIdent <span class="keyword">then</span>
3215     (declId.getId, mkNullNode)
3216   <span class="keyword">else</span>
3217     <span class="keyword">let</span> id             <span class="constant">:=</span> declId[<span class="constant">0</span>].getId
3218     <span class="keyword">let</span> optUnivDeclStx <span class="constant">:=</span> declId[<span class="constant">1</span>]
3219     (id, optUnivDeclStx)
3220 
<span class="keyword">3221 structure</span> <span class="function-name">ExpandDeclIdResult</span> <span class="keyword">where</span>
3222   shortName  : Name
3223   declName   : Name
3224   levelNames : List Name
3225 
<span class="keyword">3226 def</span> <span class="function-name">expandDeclId</span> (currNamespace : Name) (currLevelNames : List Name) (declId : Syntax) (modifiers : Modifiers) : m ExpandDeclIdResult <span class="constant">:=</span> <span class="keyword">do</span>
3227   <span class="comment-delimiter">-- </span><span class="comment">ident &gt;&gt; optional (".{" &gt;&gt; sepBy1 ident ", " &gt;&gt; "}")
</span>3228   <span class="keyword">let</span> (shortName, optUnivDeclStx) <span class="constant">:=</span> expandDeclIdCore declId
3229   <span class="keyword">let</span> levelNames &#8592;
3230     <span class="keyword">if</span> optUnivDeclStx.isNone <span class="keyword">then</span>
3231       pure currLevelNames
3232     <span class="keyword">else</span>
3233       <span class="keyword">let</span> extraLevels <span class="constant">:=</span> optUnivDeclStx[<span class="constant">1</span>].getArgs.getEvenElems
3234       extraLevels.foldlM
3235         (<span class="keyword">fun</span> levelNames idStx <span class="constant">=&gt;</span>
3236           <span class="keyword">let</span> id <span class="constant">:=</span> idStx.getId
3237           <span class="keyword">if</span> levelNames.elem id <span class="keyword">then</span>
3238             withRef idStx <span class="constant">$</span> throwAlreadyDeclaredUniverseLevel id
3239           <span class="keyword">else</span>
3240             pure (id :: levelNames))
3241         currLevelNames
3242   <span class="keyword">let</span> (declName, shortName) &#8592; withRef declId <span class="constant">$</span> mkDeclName currNamespace modifiers shortName
3243   addDocString' declName modifiers.docString?
3244   pure { shortName <span class="constant">:=</span> shortName, declName <span class="constant">:=</span> declName, levelNames <span class="constant">:=</span> levelNames }
3245 
<span class="keyword">3246 end</span> Methods
3247 
<span class="keyword">3248 end</span> Lean.Elab
3249 ::::::::::::::
3250 Elab<span class="constant">/</span>DeclUtil.lean
3251 ::::::::::::::
<span class="comment-delimiter">3252 /-</span><span class="comment">
3253 Copyright (c) 2020 Microsoft Corporation. All rights reserved.
3254 Released under Apache 2.0 license as described in the file LICENSE.
3255 Authors: Leonardo de Moura, Sebastian Ullrich
3256 -/</span>
<span class="keyword">3257 import</span> Lean.Meta.ExprDefEq
3258 
<span class="keyword">3259 namespace</span> Lean.Meta
3260 
<span class="keyword">3261 def</span> <span class="function-name">forallTelescopeCompatibleAux</span> {&#945;} (k : Array Expr <span class="constant">&#8594;</span> Expr <span class="constant">&#8594;</span> Expr <span class="constant">&#8594;</span> MetaM &#945;) : Nat <span class="constant">&#8594;</span> Expr <span class="constant">&#8594;</span> Expr <span class="constant">&#8594;</span> Array Expr <span class="constant">&#8594;</span> MetaM &#945;
3262   | <span class="constant">0</span>, type&#8321;, type&#8322;, xs   <span class="constant">=&gt;</span> k xs type&#8321; type&#8322;
3263   | i<span class="constant">+1</span>, type&#8321;, type&#8322;, xs <span class="constant">=&gt;</span> <span class="keyword">do</span>
3264     <span class="keyword">let</span> type&#8321; &#8592; whnf type&#8321;
3265     <span class="keyword">let</span> type&#8322; &#8592; whnf type&#8322;
3266     <span class="keyword">match</span> type&#8321;, type&#8322; <span class="keyword">with</span>
3267     | Expr.forallE n&#8321; d&#8321; b&#8321; c&#8321;, Expr.forallE n&#8322; d&#8322; b&#8322; c&#8322; <span class="constant">=&gt;</span>
3268       <span class="keyword">unless</span> n&#8321; <span class="constant">==</span> n&#8322; <span class="keyword">do</span>
3269         throwError <span class="string">"parameter name mismatch '{n&#8321;}', expected '{n&#8322;}'"</span>
3270       <span class="keyword">unless</span> (&#8592; isDefEq d&#8321; d&#8322;) <span class="keyword">do</span>
3271         throwError <span class="string">"parameter '{n&#8321;}' {&#8592; mkHasTypeButIsExpectedMsg d&#8321; d&#8322;}"</span>
3272       <span class="keyword">unless</span> c&#8321;.binderInfo <span class="constant">==</span> c&#8322;.binderInfo <span class="keyword">do</span>
3273         throwError <span class="string">"binder annotation mismatch at parameter '{n&#8321;}'"</span>
3274       withLocalDecl n&#8321; c&#8321;.binderInfo d&#8321; <span class="keyword">fun</span> x <span class="constant">=&gt;</span>
3275         <span class="keyword">let</span> type&#8321; <span class="constant">:=</span> b&#8321;.instantiate1 x
3276         <span class="keyword">let</span> type&#8322; <span class="constant">:=</span> b&#8322;.instantiate1 x
3277         forallTelescopeCompatibleAux k i type&#8321; type&#8322; (xs.push x)
3278     | <span class="preprocessor">_</span>, <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwError <span class="string">"unexpected number of parameters"</span>
3279 
<span class="comment-delimiter">3280 /-</span><span class="comment">- Given two forall-expressions `type&#8321;` and `type&#8322;`, ensure the first `numParams` parameters are compatible, and
3281     then execute `k` with the parameters and remaining types. -/</span>
<span class="doc">3282 @[inline]</span> <span class="keyword">def</span> <span class="function-name">forallTelescopeCompatible</span> {&#945; m} [Monad m] [MonadControlT MetaM m] (type&#8321; type&#8322; : Expr) (numParams : Nat) (k : Array Expr <span class="constant">&#8594;</span> Expr <span class="constant">&#8594;</span> Expr <span class="constant">&#8594;</span> m &#945;) : m &#945; <span class="constant">:=</span>
3283   controlAt MetaM <span class="keyword">fun</span> runInBase <span class="constant">=&gt;</span>
3284     forallTelescopeCompatibleAux (<span class="keyword">fun</span> xs type&#8321; type&#8322; <span class="constant">=&gt;</span> runInBase <span class="constant">$</span> k xs type&#8321; type&#8322;) numParams type&#8321; type&#8322; <span class="constant">#</span>[]
3285 
<span class="keyword">3286 end</span> Meta
3287 
<span class="keyword">3288 namespace</span> Elab
3289 
<span class="keyword">3290 def</span> <span class="function-name">expandOptDeclSig</span> (stx : Syntax) : Syntax <span class="constant">&#215;</span> Option Syntax <span class="constant">:=</span>
3291   <span class="comment-delimiter">-- </span><span class="comment">many Term.bracketedBinder &gt;&gt; Term.optType
</span>3292   <span class="keyword">let</span> binders <span class="constant">:=</span> stx[<span class="constant">0</span>]
3293   <span class="keyword">let</span> optType <span class="constant">:=</span> stx[<span class="constant">1</span>] <span class="comment-delimiter">-- </span><span class="comment">optional (leading_parser " : " &gt;&gt; termParser)
</span>3294   <span class="keyword">if</span> optType.isNone <span class="keyword">then</span>
3295     (binders, none)
3296   <span class="keyword">else</span>
3297     <span class="keyword">let</span> typeSpec <span class="constant">:=</span> optType[<span class="constant">0</span>]
3298     (binders, some typeSpec[<span class="constant">1</span>])
3299 
<span class="keyword">3300 def</span> <span class="function-name">expandDeclSig</span> (stx : Syntax) : Syntax <span class="constant">&#215;</span> Syntax <span class="constant">:=</span>
3301   <span class="comment-delimiter">-- </span><span class="comment">many Term.bracketedBinder &gt;&gt; Term.typeSpec
</span>3302   <span class="keyword">let</span> binders  <span class="constant">:=</span> stx[<span class="constant">0</span>]
3303   <span class="keyword">let</span> typeSpec <span class="constant">:=</span> stx[<span class="constant">1</span>]
3304   (binders, typeSpec[<span class="constant">1</span>])
3305 
<span class="keyword">3306 def</span> <span class="function-name">mkFreshInstanceName</span> (env : Environment) (nextIdx : Nat) : Name <span class="constant">:=</span>
3307   (env.mainModule <span class="constant">++</span> `_instance).appendIndexAfter nextIdx
3308 
<span class="keyword">3309 def</span> <span class="function-name">isFreshInstanceName</span> (name : Name) : Bool <span class="constant">:=</span>
3310   <span class="keyword">match</span> name <span class="keyword">with</span>
3311   | Name.str <span class="preprocessor">_</span> s <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="string">"_instance"</span>.isPrefixOf s
3312   | <span class="preprocessor">_</span>              <span class="constant">=&gt;</span> false
3313 
<span class="comment-delimiter">3314 /-</span><span class="comment">-
3315   Sort the given list of `usedParams` using the following order:
3316   - If it is an explicit level `allUserParams`, then use user given order.
3317   - Otherwise, use lexicographical.
3318 
3319   Remark: `scopeParams` are the universe params introduced using the `universe` command. `allUserParams` contains
3320   the universe params introduced using the `universe` command *and* the `.{...}` notation.
3321 
3322   Remark: this function return an exception if there is an `u` not in `usedParams`, that is in `allUserParams` but not in `scopeParams`.
3323 
3324   Remark: `explicitParams` are in reverse declaration order. That is, the head is the last declared parameter. -/</span>
<span class="keyword">3325 def</span> <span class="function-name">sortDeclLevelParams</span> (scopeParams : List Name) (allUserParams : List Name) (usedParams : Array Name) : Except String (List Name) <span class="constant">:=</span>
3326   <span class="keyword">match</span> allUserParams.find? <span class="constant">$</span> <span class="keyword">fun</span> u <span class="constant">=&gt;</span> <span class="constant">!</span>usedParams.contains u <span class="constant">&amp;&amp;</span> <span class="constant">!</span>scopeParams.elem u <span class="keyword">with</span>
3327   | some u <span class="constant">=&gt;</span> throw s<span class="constant">!</span><span class="string">"unused universe parameter '{u}'"</span>
3328   | none   <span class="constant">=&gt;</span>
3329     <span class="keyword">let</span> result <span class="constant">:=</span> allUserParams.foldl (<span class="keyword">fun</span> result levelName <span class="constant">=&gt;</span> <span class="keyword">if</span> usedParams.elem levelName <span class="keyword">then</span> levelName :: result <span class="keyword">else</span> result) []
3330     <span class="keyword">let</span> remaining <span class="constant">:=</span> usedParams.filter (<span class="keyword">fun</span> levelParam <span class="constant">=&gt;</span> <span class="constant">!</span>allUserParams.elem levelParam)
3331     <span class="keyword">let</span> remaining <span class="constant">:=</span> remaining.qsort Name.lt
3332     pure <span class="constant">$</span> result <span class="constant">++</span> remaining.toList
3333 
<span class="keyword">3334 end</span> Lean.Elab
3335 ::::::::::::::
3336 Elab<span class="constant">/</span>DefView.lean
3337 ::::::::::::::
<span class="comment-delimiter">3338 /-</span><span class="comment">
3339 Copyright (c) 2020 Microsoft Corporation. All rights reserved.
3340 Released under Apache 2.0 license as described in the file LICENSE.
3341 Authors: Leonardo de Moura, Sebastian Ullrich
3342 -/</span>
<span class="keyword">3343 import</span> Std.ShareCommon
<span class="keyword">3344 import</span> Lean.Parser.Command
<span class="keyword">3345 import</span> Lean.Util.CollectLevelParams
<span class="keyword">3346 import</span> Lean.Util.FoldConsts
<span class="keyword">3347 import</span> Lean.Meta.CollectFVars
<span class="keyword">3348 import</span> Lean.Elab.Command
<span class="keyword">3349 import</span> Lean.Elab.SyntheticMVars
<span class="keyword">3350 import</span> Lean.Elab.Binders
<span class="keyword">3351 import</span> Lean.Elab.DeclUtil
<span class="keyword">3352 namespace</span> Lean.Elab
3353 
<span class="keyword">3354 inductive</span> <span class="function-name">DefKind</span> <span class="keyword">where</span>
3355   | <span class="comment">&#171;</span>def<span class="comment">&#187;</span> | <span class="comment">&#171;</span>theorem<span class="comment">&#187;</span> | <span class="comment">&#171;</span>example<span class="comment">&#187;</span> | <span class="comment">&#171;</span>opaque<span class="comment">&#187;</span> | <span class="comment">&#171;</span>abbrev<span class="comment">&#187;</span>
3356   <span class="keyword">deriving</span> Inhabited
3357 
<span class="keyword">3358 def</span> <span class="function-name">DefKind.isTheorem</span> : DefKind <span class="constant">&#8594;</span> Bool
3359   | <span class="comment">&#171;</span>theorem<span class="comment">&#187;</span> <span class="constant">=&gt;</span> true
3360   | <span class="preprocessor">_</span>         <span class="constant">=&gt;</span> false
3361 
<span class="keyword">3362 def</span> <span class="function-name">DefKind.isDefOrAbbrevOrOpaque</span> : DefKind <span class="constant">&#8594;</span> Bool
3363   | <span class="comment">&#171;</span>def<span class="comment">&#187;</span>    <span class="constant">=&gt;</span> true
3364   | <span class="comment">&#171;</span>opaque<span class="comment">&#187;</span> <span class="constant">=&gt;</span> true
3365   | <span class="comment">&#171;</span>abbrev<span class="comment">&#187;</span> <span class="constant">=&gt;</span> true
3366   | <span class="preprocessor">_</span>        <span class="constant">=&gt;</span> false
3367 
<span class="keyword">3368 def</span> <span class="function-name">DefKind.isExample</span> : DefKind <span class="constant">&#8594;</span> Bool
3369   | <span class="comment">&#171;</span>example<span class="comment">&#187;</span> <span class="constant">=&gt;</span> true
3370   | <span class="preprocessor">_</span>         <span class="constant">=&gt;</span> false
3371 
<span class="keyword">3372 structure</span> <span class="function-name">DefView</span> <span class="keyword">where</span>
3373   kind          : DefKind
3374   ref           : Syntax
3375   modifiers     : Modifiers
3376   declId        : Syntax
3377   binders       : Syntax
3378   type?         : Option Syntax
3379   value         : Syntax
3380   <span class="keyword">deriving</span> Inhabited
3381 
<span class="keyword">3382 namespace</span> Command
3383 
<span class="keyword">3384 open</span> Meta
3385 
<span class="keyword">3386 def</span> <span class="function-name">mkDefViewOfAbbrev</span> (modifiers : Modifiers) (stx : Syntax) : DefView <span class="constant">:=</span>
3387   <span class="comment-delimiter">-- </span><span class="comment">leading_parser "abbrev " &gt;&gt; declId &gt;&gt; optDeclSig &gt;&gt; declVal
</span>3388   <span class="keyword">let</span> (binders, type) <span class="constant">:=</span> expandOptDeclSig (stx.getArg <span class="constant">2</span>)
3389   <span class="keyword">let</span> modifiers       <span class="constant">:=</span> modifiers.addAttribute { name <span class="constant">:=</span> `inline }
3390   <span class="keyword">let</span> modifiers       <span class="constant">:=</span> modifiers.addAttribute { name <span class="constant">:=</span> `reducible }
3391   { ref <span class="constant">:=</span> stx, kind <span class="constant">:=</span> DefKind.<span class="keyword">abbrev</span>, modifiers <span class="constant">:=</span> modifiers,
3392     declId <span class="constant">:=</span> stx.getArg <span class="constant">1</span>, binders <span class="constant">:=</span> binders, type? <span class="constant">:=</span> type, value <span class="constant">:=</span> stx.getArg <span class="constant">3</span> }
3393 
<span class="keyword">3394 def</span> <span class="function-name">mkDefViewOfDef</span> (modifiers : Modifiers) (stx : Syntax) : DefView <span class="constant">:=</span>
3395   <span class="comment-delimiter">-- </span><span class="comment">leading_parser "def " &gt;&gt; declId &gt;&gt; optDeclSig &gt;&gt; declVal
</span>3396   <span class="keyword">let</span> (binders, type) <span class="constant">:=</span> expandOptDeclSig (stx.getArg <span class="constant">2</span>)
3397   { ref <span class="constant">:=</span> stx, kind <span class="constant">:=</span> DefKind.<span class="keyword">def</span><span class="function-name">,</span> modifiers <span class="constant">:=</span> modifiers,
3398     declId <span class="constant">:=</span> stx.getArg <span class="constant">1</span>, binders <span class="constant">:=</span> binders, type? <span class="constant">:=</span> type, value <span class="constant">:=</span> stx.getArg <span class="constant">3</span> }
3399 
<span class="keyword">3400 def</span> <span class="function-name">mkDefViewOfTheorem</span> (modifiers : Modifiers) (stx : Syntax) : DefView <span class="constant">:=</span>
3401   <span class="comment-delimiter">-- </span><span class="comment">leading_parser "theorem " &gt;&gt; declId &gt;&gt; declSig &gt;&gt; declVal
</span>3402   <span class="keyword">let</span> (binders, type) <span class="constant">:=</span> expandDeclSig (stx.getArg <span class="constant">2</span>)
3403   { ref <span class="constant">:=</span> stx, kind <span class="constant">:=</span> DefKind.<span class="keyword">theorem</span><span class="function-name">,</span> modifiers <span class="constant">:=</span> modifiers,
3404     declId <span class="constant">:=</span> stx.getArg <span class="constant">1</span>, binders <span class="constant">:=</span> binders, type? <span class="constant">:=</span> some type, value <span class="constant">:=</span> stx.getArg <span class="constant">3</span> }
3405 
<span class="keyword">3406 namespace</span> MkInstanceName
3407 
<span class="comment-delimiter">3408 -- </span><span class="comment">Table for `mkInstanceName`
</span><span class="keyword">3409 private</span> <span class="keyword">def</span> <span class="function-name">kindReplacements</span> : NameMap String <span class="constant">:=</span>
3410   Std.RBMap.ofList [
3411     (``Parser.Term.depArrow, <span class="string">"DepArrow"</span>),
3412     (``Parser.Term.<span class="comment">&#171;</span>forall<span class="comment">&#187;</span>, <span class="string">"Forall"</span>),
3413     (``Parser.Term.arrow, <span class="string">"Arrow"</span>),
3414     (``Parser.Term.prop,  <span class="string">"Prop"</span>),
3415     (``Parser.Term.sort,  <span class="string">"Sort"</span>),
3416     (``Parser.Term.type,  <span class="string">"Type"</span>)
3417   ]
3418 
<span class="keyword">3419 abbrev</span> M <span class="constant">:=</span> StateRefT String CommandElabM
3420 
<span class="keyword">3421 def</span> <span class="function-name">isFirst</span> : M Bool <span class="constant">:=</span>
3422   <span class="keyword">return</span> (&#8592; get) <span class="constant">==</span> <span class="string">""</span>
3423 
<span class="keyword">3424 def</span> <span class="function-name">append</span> (str : String) : M Unit <span class="constant">:=</span>
3425   modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> s <span class="constant">++</span> str
3426 
<span class="keyword">3427 partial</span> <span class="keyword">def</span> <span class="function-name">collect</span> (stx : Syntax) : M Unit <span class="constant">:=</span> <span class="keyword">do</span>
3428   <span class="keyword">match</span> stx <span class="keyword">with</span>
3429   | Syntax.node k args <span class="constant">=&gt;</span>
3430     <span class="keyword">unless</span> (&#8592; isFirst) <span class="keyword">do</span>
3431       <span class="keyword">match</span> kindReplacements.find? k <span class="keyword">with</span>
3432       | some r <span class="constant">=&gt;</span> append r
3433       | none   <span class="constant">=&gt;</span> pure ()
3434     <span class="keyword">for</span> arg <span class="keyword">in</span> args <span class="keyword">do</span>
3435       collect arg
3436   | Syntax.ident (preresolved <span class="constant">:=</span> preresolved) .. <span class="constant">=&gt;</span>
3437     <span class="keyword">unless</span> preresolved.isEmpty <span class="constant">&amp;&amp;</span> (&#8592; resolveGlobalName stx.getId).isEmpty <span class="keyword">do</span>
3438       <span class="keyword">match</span> stx.getId.eraseMacroScopes <span class="keyword">with</span>
3439       | Name.str <span class="preprocessor">_</span> str <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
3440           <span class="keyword">if</span> str[<span class="constant">0</span>].isLower <span class="keyword">then</span>
3441             append str.capitalize
3442           <span class="keyword">else</span>
3443             append str
3444       | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> pure ()
3445   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> pure ()
3446 
<span class="keyword">3447 def</span> <span class="function-name">mkFreshInstanceName</span> : CommandElabM Name <span class="constant">:=</span> <span class="keyword">do</span>
3448   <span class="keyword">let</span> s &#8592; get
3449   <span class="keyword">let</span> idx <span class="constant">:=</span> s.nextInstIdx
3450   modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> nextInstIdx <span class="constant">:=</span> s.nextInstIdx <span class="constant">+</span> <span class="constant">1</span> }
3451   <span class="keyword">return</span> Lean.Elab.mkFreshInstanceName s.env idx
3452 
<span class="keyword">3453 partial</span> <span class="keyword">def</span> <span class="function-name">main</span> (type : Syntax) : CommandElabM Name <span class="constant">:=</span> <span class="keyword">do</span>
3454   <span class="comment-delimiter">/- </span><span class="comment">We use `expandMacros` to expand notation such as `x &lt; y` into `LT.lt x y` -/</span>
3455   <span class="keyword">let</span> type &#8592; liftMacroM <span class="constant">&lt;</span>| expandMacros type
3456   <span class="keyword">let</span> (<span class="preprocessor">_</span>, str) &#8592; collect type |<span class="constant">&gt;</span>.run <span class="string">""</span>
3457   <span class="keyword">if</span> str.isEmpty <span class="keyword">then</span>
3458     mkFreshInstanceName
3459   <span class="keyword">else</span>
3460     mkUnusedBaseName <span class="constant">&lt;</span>| Name.mkSimple (<span class="string">"inst"</span> <span class="constant">++</span> str)
3461 
<span class="keyword">3462 end</span> MkInstanceName
3463 
<span class="keyword">3464 def</span> <span class="function-name">mkDefViewOfConstant</span> (modifiers : Modifiers) (stx : Syntax) : CommandElabM DefView <span class="constant">:=</span> <span class="keyword">do</span>
3465   <span class="comment-delimiter">-- </span><span class="comment">leading_parser "constant " &gt;&gt; declId &gt;&gt; declSig &gt;&gt; optional declValSimple
</span>3466   <span class="keyword">let</span> (binders, type) <span class="constant">:=</span> expandDeclSig (stx.getArg <span class="constant">2</span>)
3467   <span class="keyword">let</span> val &#8592; <span class="keyword">match</span> (stx.getArg <span class="constant">3</span>).getOptional? <span class="keyword">with</span>
3468     | some val <span class="constant">=&gt;</span> pure val
3469     | none     <span class="constant">=&gt;</span>
3470       <span class="keyword">let</span> val &#8592; `(arbitrary)
3471       pure <span class="constant">$</span> Syntax.node ``Parser.Command.declValSimple <span class="constant">#</span>[ mkAtomFrom stx <span class="string">":="</span>, val ]
3472   <span class="keyword">return</span> {
3473     ref <span class="constant">:=</span> stx, kind <span class="constant">:=</span> DefKind.opaque, modifiers <span class="constant">:=</span> modifiers,
3474     declId <span class="constant">:=</span> stx.getArg <span class="constant">1</span>, binders <span class="constant">:=</span> binders, type? <span class="constant">:=</span> some type, value <span class="constant">:=</span> val
3475   }
3476 
<span class="keyword">3477 def</span> <span class="function-name">mkDefViewOfInstance</span> (modifiers : Modifiers) (stx : Syntax) : CommandElabM DefView <span class="constant">:=</span> <span class="keyword">do</span>
3478   <span class="comment-delimiter">-- </span><span class="comment">leading_parser Term.attrKind &gt;&gt; "instance " &gt;&gt; optNamedPrio &gt;&gt; optional declId &gt;&gt; declSig &gt;&gt; declVal
</span>3479   <span class="keyword">let</span> attrKind        &#8592; toAttributeKind stx[<span class="constant">0</span>]
3480   <span class="keyword">let</span> prio            &#8592; liftMacroM <span class="constant">&lt;</span>| expandOptNamedPrio stx[<span class="constant">2</span>]
3481   <span class="keyword">let</span> attrStx         &#8592; `(attr| <span class="keyword">instance</span> <span class="function-name">$</span>(quote prio):numLit)
3482   <span class="keyword">let</span> (binders, type) <span class="constant">:=</span> expandDeclSig stx[<span class="constant">4</span>]
3483   <span class="keyword">let</span> modifiers       <span class="constant">:=</span> modifiers.addAttribute { kind <span class="constant">:=</span> attrKind, name <span class="constant">:=</span> `<span class="keyword">instance</span><span class="function-name">,</span> stx <span class="constant">:=</span> attrStx }
3484   <span class="keyword">let</span> declId &#8592; <span class="keyword">match</span> stx[<span class="constant">3</span>].getOptional? <span class="keyword">with</span>
3485     | some declId <span class="constant">=&gt;</span> pure declId
3486     | none        <span class="constant">=&gt;</span>
3487       <span class="keyword">let</span> id &#8592; MkInstanceName.main type
3488       pure <span class="constant">&lt;</span>| Syntax.node ``Parser.Command.declId <span class="constant">#</span>[mkIdentFrom stx id, mkNullNode]
3489   <span class="keyword">return</span> {
3490     ref <span class="constant">:=</span> stx, kind <span class="constant">:=</span> DefKind.<span class="keyword">def</span><span class="function-name">,</span> modifiers <span class="constant">:=</span> modifiers,
3491     declId <span class="constant">:=</span> declId, binders <span class="constant">:=</span> binders, type? <span class="constant">:=</span> type, value <span class="constant">:=</span> stx[<span class="constant">5</span>]
3492   }
3493 
<span class="keyword">3494 def</span> <span class="function-name">mkDefViewOfExample</span> (modifiers : Modifiers) (stx : Syntax) : DefView <span class="constant">:=</span>
3495   <span class="comment-delimiter">-- </span><span class="comment">leading_parser "example " &gt;&gt; declSig &gt;&gt; declVal
</span>3496   <span class="keyword">let</span> (binders, type) <span class="constant">:=</span> expandDeclSig (stx.getArg <span class="constant">1</span>)
3497   <span class="keyword">let</span> id              <span class="constant">:=</span> mkIdentFrom stx `_example
3498   <span class="keyword">let</span> declId          <span class="constant">:=</span> Syntax.node ``Parser.Command.declId <span class="constant">#</span>[id, mkNullNode]
3499   { ref <span class="constant">:=</span> stx, kind <span class="constant">:=</span> DefKind.<span class="keyword">example</span>, modifiers <span class="constant">:=</span> modifiers,
3500     declId <span class="constant">:=</span> declId, binders <span class="constant">:=</span> binders, type? <span class="constant">:=</span> some type, value <span class="constant">:=</span> stx.getArg <span class="constant">2</span> }
3501 
<span class="keyword">3502 def</span> <span class="function-name">isDefLike</span> (stx : Syntax) : Bool <span class="constant">:=</span>
3503   <span class="keyword">let</span> declKind <span class="constant">:=</span> stx.getKind
3504   declKind <span class="constant">==</span> ``Parser.Command.<span class="comment">&#171;</span>abbrev<span class="comment">&#187;</span> <span class="constant">||</span>
3505   declKind <span class="constant">==</span> ``Parser.Command.<span class="comment">&#171;</span>def<span class="comment">&#187;</span> <span class="constant">||</span>
3506   declKind <span class="constant">==</span> ``Parser.Command.<span class="comment">&#171;</span>theorem<span class="comment">&#187;</span> <span class="constant">||</span>
3507   declKind <span class="constant">==</span> ``Parser.Command.<span class="comment">&#171;</span>constant<span class="comment">&#187;</span> <span class="constant">||</span>
3508   declKind <span class="constant">==</span> ``Parser.Command.<span class="comment">&#171;</span>instance<span class="comment">&#187;</span> <span class="constant">||</span>
3509   declKind <span class="constant">==</span> ``Parser.Command.<span class="comment">&#171;</span>example<span class="comment">&#187;</span>
3510 
<span class="keyword">3511 def</span> <span class="function-name">mkDefView</span> (modifiers : Modifiers) (stx : Syntax) : CommandElabM DefView <span class="constant">:=</span>
3512   <span class="keyword">let</span> declKind <span class="constant">:=</span> stx.getKind
3513   <span class="keyword">if</span> declKind <span class="constant">==</span> ``Parser.Command.<span class="comment">&#171;</span>abbrev<span class="comment">&#187;</span> <span class="keyword">then</span>
3514     pure <span class="constant">$</span> mkDefViewOfAbbrev modifiers stx
3515   <span class="keyword">else</span> <span class="keyword">if</span> declKind <span class="constant">==</span> ``Parser.Command.<span class="comment">&#171;</span>def<span class="comment">&#187;</span> <span class="keyword">then</span>
3516     pure <span class="constant">$</span> mkDefViewOfDef modifiers stx
3517   <span class="keyword">else</span> <span class="keyword">if</span> declKind <span class="constant">==</span> ``Parser.Command.<span class="comment">&#171;</span>theorem<span class="comment">&#187;</span> <span class="keyword">then</span>
3518     pure <span class="constant">$</span> mkDefViewOfTheorem modifiers stx
3519   <span class="keyword">else</span> <span class="keyword">if</span> declKind <span class="constant">==</span> ``Parser.Command.<span class="comment">&#171;</span>constant<span class="comment">&#187;</span> <span class="keyword">then</span>
3520     mkDefViewOfConstant modifiers stx
3521   <span class="keyword">else</span> <span class="keyword">if</span> declKind <span class="constant">==</span> ``Parser.Command.<span class="comment">&#171;</span>instance<span class="comment">&#187;</span> <span class="keyword">then</span>
3522     mkDefViewOfInstance modifiers stx
3523   <span class="keyword">else</span> <span class="keyword">if</span> declKind <span class="constant">==</span> ``Parser.Command.<span class="comment">&#171;</span>example<span class="comment">&#187;</span> <span class="keyword">then</span>
3524     pure <span class="constant">$</span> mkDefViewOfExample modifiers stx
3525   <span class="keyword">else</span>
3526     throwError <span class="string">"unexpected kind of definition"</span>
3527 
<span class="keyword">3528 builtin_initialize</span> registerTraceClass `Elab.definition
3529 
<span class="keyword">3530 end</span> Command
<span class="keyword">3531 end</span> Lean.Elab
3532 ::::::::::::::
3533 Elab<span class="constant">/</span>Deriving.lean
3534 ::::::::::::::
<span class="comment-delimiter">3535 /-</span><span class="comment">
3536 Copyright (c) 2020 Microsoft Corporation. All rights reserved.
3537 Released under Apache 2.0 license as described in the file LICENSE.
3538 Authors: Leonardo de Moura
3539 -/</span>
<span class="keyword">3540 import</span> Lean.Elab.Deriving.Basic
<span class="keyword">3541 import</span> Lean.Elab.Deriving.Util
<span class="keyword">3542 import</span> Lean.Elab.Deriving.Inhabited
<span class="keyword">3543 import</span> Lean.Elab.Deriving.BEq
<span class="keyword">3544 import</span> Lean.Elab.Deriving.DecEq
<span class="keyword">3545 import</span> Lean.Elab.Deriving.Repr
<span class="keyword">3546 import</span> Lean.Elab.Deriving.FromToJson
<span class="keyword">3547 import</span> Lean.Elab.Deriving.SizeOf
<span class="keyword">3548 import</span> Lean.Elab.Deriving.Hashable
<span class="keyword">3549 import</span> Lean.Elab.Deriving.Ord
3550 ::::::::::::::
3551 Elab<span class="constant">/</span>Do.lean
3552 ::::::::::::::
<span class="comment-delimiter">3553 /-</span><span class="comment">
3554 Copyright (c) 2020 Microsoft Corporation. All rights reserved.
3555 Released under Apache 2.0 license as described in the file LICENSE.
3556 Authors: Leonardo de Moura
3557 -/</span>
<span class="keyword">3558 import</span> Lean.Elab.Term
<span class="keyword">3559 import</span> Lean.Elab.Binders
<span class="keyword">3560 import</span> Lean.Elab.Match
<span class="keyword">3561 import</span> Lean.Elab.Quotation.Util
<span class="keyword">3562 import</span> Lean.Parser.Do
3563 
<span class="keyword">3564 namespace</span> Lean.Elab.Term
<span class="keyword">3565 open</span> Lean.Parser.Term
<span class="keyword">3566 open</span> Meta
3567 
<span class="keyword">3568 private</span> <span class="keyword">def</span> <span class="function-name">getDoSeqElems</span> (doSeq : Syntax) : List Syntax <span class="constant">:=</span>
3569   <span class="keyword">if</span> doSeq.getKind <span class="constant">==</span> `Lean.Parser.Term.doSeqBracketed <span class="keyword">then</span>
3570     doSeq[<span class="constant">1</span>].getArgs.toList.map <span class="keyword">fun</span> arg <span class="constant">=&gt;</span> arg[<span class="constant">0</span>]
3571   <span class="keyword">else</span> <span class="keyword">if</span> doSeq.getKind <span class="constant">==</span> `Lean.Parser.Term.doSeqIndent <span class="keyword">then</span>
3572     doSeq[<span class="constant">0</span>].getArgs.toList.map <span class="keyword">fun</span> arg <span class="constant">=&gt;</span> arg[<span class="constant">0</span>]
3573   <span class="keyword">else</span>
3574     []
3575 
<span class="keyword">3576 private</span> <span class="keyword">def</span> <span class="function-name">getDoSeq</span> (doStx : Syntax) : Syntax <span class="constant">:=</span>
3577   doStx[<span class="constant">1</span>]
3578 
<span class="doc">3579 @[builtinTermElab liftMethod]</span> <span class="keyword">def</span> <span class="function-name">elabLiftMethod</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
3580   throwErrorAt stx <span class="string">"invalid use of `(&lt;- ...)`, must be nested inside a 'do' expression"</span>
3581 
<span class="comment-delimiter">3582 /-</span><span class="comment">- Return true if we should not lift `(&lt;- ...)` actions nested in the syntax nodes with the given kind. -/</span>
<span class="keyword">3583 private</span> <span class="keyword">def</span> <span class="function-name">liftMethodDelimiter</span> (k : SyntaxNodeKind) : Bool <span class="constant">:=</span>
3584   k <span class="constant">==</span> ``Lean.Parser.Term.<span class="keyword">do</span> <span class="constant">||</span>
3585   k <span class="constant">==</span> ``Lean.Parser.Term.doSeqIndent <span class="constant">||</span>
3586   k <span class="constant">==</span> ``Lean.Parser.Term.doSeqBracketed <span class="constant">||</span>
3587   k <span class="constant">==</span> ``Lean.Parser.Term.termReturn <span class="constant">||</span>
3588   k <span class="constant">==</span> ``Lean.Parser.Term.termUnless <span class="constant">||</span>
3589   k <span class="constant">==</span> ``Lean.Parser.Term.termTry <span class="constant">||</span>
3590   k <span class="constant">==</span> ``Lean.Parser.Term.termFor
3591 
<span class="comment-delimiter">3592 /-</span><span class="comment">- Return true if we should generate an error message when lifting a method over this kind of syntax. -/</span>
<span class="keyword">3593 private</span> <span class="keyword">def</span> <span class="function-name">liftMethodForbiddenBinder</span> (k : SyntaxNodeKind) : Bool <span class="constant">:=</span>
3594   k <span class="constant">==</span> ``Lean.Parser.Term.<span class="keyword">fun</span> <span class="constant">||</span>
3595   k <span class="constant">==</span> ``Lean.Parser.Term.matchAlts
3596 
<span class="keyword">3597 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">hasLiftMethod</span> : Syntax <span class="constant">&#8594;</span> Bool
3598   | Syntax.node k args <span class="constant">=&gt;</span>
3599     <span class="keyword">if</span> liftMethodDelimiter k <span class="keyword">then</span> false
3600     <span class="comment-delimiter">-- </span><span class="comment">NOTE: We don't check for lifts in quotations here, which doesn't break anything but merely makes this rare case a
</span>3601     <span class="comment-delimiter">-- </span><span class="comment">bit slower
</span>3602     <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> `Lean.Parser.Term.liftMethod <span class="keyword">then</span> true
3603     <span class="keyword">else</span> args.any hasLiftMethod
3604   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> false
3605 
<span class="keyword">3606 structure</span> <span class="function-name">ExtractMonadResult</span> <span class="keyword">where</span>
3607   m            : Expr
3608   &#945;            : Expr
3609   hasBindInst  : Expr
3610   expectedType : Expr
3611 
<span class="keyword">3612 private</span> <span class="keyword">def</span> <span class="function-name">mkIdBindFor</span> (type : Expr) : TermElabM ExtractMonadResult <span class="constant">:=</span> <span class="keyword">do</span>
3613   <span class="keyword">let</span> u &#8592; getDecLevel type
3614   <span class="keyword">let</span> id        <span class="constant">:=</span> Lean.mkConst `Id [u]
3615   <span class="keyword">let</span> idBindVal <span class="constant">:=</span> Lean.mkConst `Id.hasBind [u]
3616   pure { m <span class="constant">:=</span> id, hasBindInst <span class="constant">:=</span> idBindVal, &#945; <span class="constant">:=</span> type, expectedType <span class="constant">:=</span> mkApp id type }
3617 
<span class="keyword">3618 private</span> <span class="keyword">def</span> <span class="function-name">extractBind</span> (expectedType? : Option Expr) : TermElabM ExtractMonadResult <span class="constant">:=</span> <span class="keyword">do</span>
3619   <span class="keyword">match</span> expectedType? <span class="keyword">with</span>
3620   | none <span class="constant">=&gt;</span> throwError <span class="string">"invalid 'do' notation, expected type is not available"</span>
3621   | some expectedType <span class="constant">=&gt;</span>
3622     <span class="keyword">let</span> type &#8592; withReducible <span class="constant">$</span> whnf expectedType
3623     <span class="keyword">if</span>  type.getAppFn.isMVar <span class="keyword">then</span> throwError <span class="string">"invalid 'do' notation, expected type is not available"</span>
3624     <span class="keyword">match</span> type <span class="keyword">with</span>
3625     | Expr.app m &#945; <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
3626       <span class="keyword">try</span>
3627         <span class="keyword">let</span> bindInstType &#8592; mkAppM `Bind <span class="constant">#</span>[m]
3628         <span class="keyword">let</span> bindInstVal  &#8592; synthesizeInst bindInstType
3629         pure { m <span class="constant">:=</span> m, hasBindInst <span class="constant">:=</span> bindInstVal, &#945; <span class="constant">:=</span> &#945;, expectedType <span class="constant">:=</span> expectedType }
3630       <span class="keyword">catch</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
3631         mkIdBindFor type
3632     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> mkIdBindFor type
3633 
<span class="keyword">3634 namespace</span> Do
3635 
<span class="comment-delimiter">3636 /- </span><span class="comment">A `doMatch` alternative. `vars` is the array of variables declared by `patterns`. -/</span>
<span class="keyword">3637 structure</span> <span class="function-name">Alt</span> (&#963; : <span class="type">Type</span>) <span class="keyword">where</span>
3638   ref : Syntax
3639   vars : Array Name
3640   patterns : Syntax
3641   rhs : &#963;
3642   <span class="keyword">deriving</span> Inhabited
3643 
<span class="comment-delimiter">3644 /-</span><span class="comment">
3645   Auxiliary datastructure for representing a `do` code block, and compiling "reassignments" (e.g., `x := x + 1`).
3646   We convert `Code` into a `Syntax` term representing the:
3647   - `do`-block, or
3648   - the visitor argument for the `forIn` combinator.
3649 
3650   We say the following constructors are terminals:
3651   - `break`:    for interrupting a `for x in s`
3652   - `continue`: for interrupting the current iteration of a `for x in s`
3653   - `return e`: for returning `e` as the result for the whole `do` computation block
3654   - `action a`: for executing action `a` as a terminal
3655   - `ite`:      if-then-else
3656   - `match`:    pattern matching
3657   - `jmp`       a goto to a join-point
3658 
3659   We say the terminals `break`, `continue`, `action`, and `return` are "exit points"
3660 
3661   Note that, `return e` is not equivalent to `action (pure e)`. Here is an example:
3662   ```
3663   def f (x : Nat) : IO Unit := do
3664   if x == 0 then
3665      return ()
3666   IO.println "hello"
3667   ```
3668   Executing `#eval f 0` will not print "hello". Now, consider
3669   ```
3670   def g (x : Nat) : IO Unit := do
3671   if x == 0 then
3672      pure ()
3673   IO.println "hello"
3674   ```
3675   The `if` statement is essentially a noop, and "hello" is printed when we execute `g 0`.
3676 
3677   - `decl` represents all declaration-like `doElem`s (e.g., `let`, `have`, `let rec`).
3678     The field `stx` is the actual `doElem`,
3679     `vars` is the array of variables declared by it, and `cont` is the next instruction in the `do` code block.
3680     `vars` is an array since we have declarations such as `let (a, b) := s`.
3681 
3682   - `reassign` is an reassignment-like `doElem` (e.g., `x := x + 1`).
3683 
3684   - `joinpoint` is a join point declaration: an auxiliary `let`-declaration used to represent the control-flow.
3685 
3686   - `seq a k` executes action `a`, ignores its result, and then executes `k`.
3687     We also store the do-elements `dbg_trace` and `assert!` as actions in a `seq`.
3688 
3689   A code block `C` is well-formed if
3690   - For every `jmp ref j as` in `C`, there is a `joinpoint j ps b k` and `jmp ref j as` is in `k`, and
3691     `ps.size == as.size` -/</span>
<span class="keyword">3692 inductive</span> <span class="function-name">Code</span> <span class="keyword">where</span>
3693   | decl         (xs : Array Name) (doElem : Syntax) (k : Code)
3694   | reassign     (xs : Array Name) (doElem : Syntax) (k : Code)
3695   <span class="comment-delimiter">/- </span><span class="comment">The Boolean value in `params` indicates whether we should use `(x : typeof! x)` when generating term Syntax or not -/</span>
3696   | joinpoint    (name : Name) (params : Array (Name <span class="constant">&#215;</span> Bool)) (body : Code) (k : Code)
3697   | seq          (action : Syntax) (k : Code)
3698   | action       (action : Syntax)
3699   | <span class="comment">&#171;</span>break<span class="comment">&#187;</span>      (ref : Syntax)
3700   | <span class="comment">&#171;</span>continue<span class="comment">&#187;</span>   (ref : Syntax)
3701   | <span class="comment">&#171;</span>return<span class="comment">&#187;</span>     (ref : Syntax) (val : Syntax)
3702   <span class="comment-delimiter">/- </span><span class="comment">Recall that an if-then-else may declare a variable using `optIdent` for the branches `thenBranch` and `elseBranch`. We store the variable name at `var?`. -/</span>
3703   | ite          (ref : Syntax) (h? : Option Name) (optIdent : Syntax) (cond : Syntax) (thenBranch : Code) (elseBranch : Code)
3704   | <span class="comment">&#171;</span>match<span class="comment">&#187;</span>      (ref : Syntax) (gen : Syntax) (discrs : Syntax) (optType : Syntax) (alts : Array (Alt Code))
3705   | jmp          (ref : Syntax) (jpName : Name) (args : Array Syntax)
3706   <span class="keyword">deriving</span> Inhabited
3707 
<span class="comment-delimiter">3708 /- </span><span class="comment">A code block, and the collection of variables updated by it. -/</span>
<span class="keyword">3709 structure</span> <span class="function-name">CodeBlock</span> <span class="keyword">where</span>
3710   code  : Code
3711   uvars : NameSet <span class="constant">:=</span> {} <span class="comment-delimiter">-- </span><span class="comment">set of variables updated by `code`
</span>3712 
<span class="keyword">3713 private</span> <span class="keyword">def</span> <span class="function-name">nameSetToArray</span> (s : NameSet) : Array Name <span class="constant">:=</span>
3714   s.fold (<span class="keyword">fun</span> (xs : Array Name) x <span class="constant">=&gt;</span> xs.push x) <span class="constant">#</span>[]
3715 
<span class="keyword">3716 private</span> <span class="keyword">def</span> <span class="function-name">varsToMessageData</span> (vars : Array Name) : MessageData <span class="constant">:=</span>
3717   MessageData.joinSep (vars.toList.map <span class="keyword">fun</span> n <span class="constant">=&gt;</span> MessageData.ofName (n.simpMacroScopes)) <span class="string">" "</span>
3718 
<span class="keyword">3719 partial</span> <span class="keyword">def</span> <span class="function-name">CodeBlocl.toMessageData</span> (codeBlock : CodeBlock) : MessageData <span class="constant">:=</span>
3720   <span class="keyword">let</span> us <span class="constant">:=</span> MessageData.ofList <span class="constant">$</span> (nameSetToArray codeBlock.uvars).toList.map MessageData.ofName
3721   <span class="keyword">let</span> <span class="keyword">rec</span> loop : Code <span class="constant">&#8594;</span> MessageData
3722     | Code.decl xs <span class="preprocessor">_</span> k            <span class="constant">=&gt;</span> m<span class="constant">!</span><span class="string">"let {varsToMessageData xs} := ...\n{loop k}"</span>
3723     | Code.reassign xs <span class="preprocessor">_</span> k        <span class="constant">=&gt;</span> m<span class="constant">!</span><span class="string">"{varsToMessageData xs} := ...\n{loop k}"</span>
3724     | Code.joinpoint n ps body k  <span class="constant">=&gt;</span> m<span class="constant">!</span><span class="string">"let {n.simpMacroScopes} {varsToMessageData (ps.map Prod.fst)} := {indentD (loop body)}\n{loop k}"</span>
3725     | Code.seq e k                <span class="constant">=&gt;</span> m<span class="constant">!</span><span class="string">"{e}\n{loop k}"</span>
3726     | Code.action e               <span class="constant">=&gt;</span> e
3727     | Code.ite <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="preprocessor">_</span> c t e        <span class="constant">=&gt;</span> m<span class="constant">!</span><span class="string">"if {c} then {indentD (loop t)}\nelse{loop e}"</span>
3728     | Code.jmp <span class="preprocessor">_</span> j xs             <span class="constant">=&gt;</span> m<span class="constant">!</span><span class="string">"jmp {j.simpMacroScopes} {xs.toList}"</span>
3729     | Code.<span class="comment">&#171;</span>break<span class="comment">&#187;</span> <span class="preprocessor">_</span>              <span class="constant">=&gt;</span> m<span class="constant">!</span><span class="string">"break {us}"</span>
3730     | Code.<span class="comment">&#171;</span>continue<span class="comment">&#187;</span> <span class="preprocessor">_</span>           <span class="constant">=&gt;</span> m<span class="constant">!</span><span class="string">"continue {us}"</span>
3731     | Code.<span class="comment">&#171;</span>return<span class="comment">&#187;</span> <span class="preprocessor">_</span> v           <span class="constant">=&gt;</span> m<span class="constant">!</span><span class="string">"return {v} {us}"</span>
3732     | Code.<span class="comment">&#171;</span>match<span class="comment">&#187;</span> <span class="preprocessor">_</span> <span class="preprocessor">_</span> ds t alts  <span class="constant">=&gt;</span>
3733       m<span class="constant">!</span><span class="string">"match {ds} with"</span>
3734       <span class="constant">++</span> alts.foldl (init <span class="constant">:=</span> m<span class="constant">!</span><span class="string">""</span>) <span class="keyword">fun</span> acc alt <span class="constant">=&gt;</span> acc <span class="constant">++</span> m<span class="constant">!</span><span class="string">"\n| {alt.patterns} =&gt; {loop alt.rhs}"</span>
3735   loop codeBlock.code
3736 
<span class="comment-delimiter">3737 /- </span><span class="comment">Return true if the give code contains an exit point that satisfies `p` -/</span>
<span class="doc">3738 @[inline]</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">hasExitPointPred</span> (c : Code) (p : Code <span class="constant">&#8594;</span> Bool) : Bool <span class="constant">:=</span>
3739   <span class="keyword">let</span> <span class="keyword">rec</span> <span class="doc">@[specialize]</span> loop : Code <span class="constant">&#8594;</span> Bool
3740     | Code.decl <span class="preprocessor">_</span> <span class="preprocessor">_</span> k           <span class="constant">=&gt;</span> loop k
3741     | Code.reassign <span class="preprocessor">_</span> <span class="preprocessor">_</span> k       <span class="constant">=&gt;</span> loop k
3742     | Code.joinpoint <span class="preprocessor">_</span> <span class="preprocessor">_</span> b k    <span class="constant">=&gt;</span> loop b <span class="constant">||</span> loop k
3743     | Code.seq <span class="preprocessor">_</span> k              <span class="constant">=&gt;</span> loop k
3744     | Code.ite <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="preprocessor">_</span> t e      <span class="constant">=&gt;</span> loop t <span class="constant">||</span> loop e
3745     | Code.<span class="comment">&#171;</span>match<span class="comment">&#187;</span> <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="preprocessor">_</span> alts <span class="constant">=&gt;</span> alts.any (loop &#183;.rhs)
3746     | Code.jmp <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="preprocessor">_</span>            <span class="constant">=&gt;</span> false
3747     | c                         <span class="constant">=&gt;</span> p c
3748   loop c
3749 
<span class="keyword">3750 def</span> <span class="function-name">hasExitPoint</span> (c : Code) : Bool <span class="constant">:=</span>
3751   hasExitPointPred c <span class="keyword">fun</span> c <span class="constant">=&gt;</span> true
3752 
<span class="keyword">3753 def</span> <span class="function-name">hasReturn</span> (c : Code) : Bool <span class="constant">:=</span>
3754   hasExitPointPred c <span class="keyword">fun</span>
3755     | Code.<span class="comment">&#171;</span>return<span class="comment">&#187;</span> <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> true
3756     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> false
3757 
<span class="keyword">3758 def</span> <span class="function-name">hasTerminalAction</span> (c : Code) : Bool <span class="constant">:=</span>
3759   hasExitPointPred c <span class="keyword">fun</span>
3760     | Code.<span class="comment">&#171;</span>action<span class="comment">&#187;</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> true
3761     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> false
3762 
<span class="keyword">3763 def</span> <span class="function-name">hasBreakContinue</span> (c : Code) : Bool <span class="constant">:=</span>
3764   hasExitPointPred c <span class="keyword">fun</span>
3765     | Code.<span class="comment">&#171;</span>break<span class="comment">&#187;</span> <span class="preprocessor">_</span>    <span class="constant">=&gt;</span> true
3766     | Code.<span class="comment">&#171;</span>continue<span class="comment">&#187;</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> true
3767     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> false
3768 
<span class="keyword">3769 def</span> <span class="function-name">hasBreakContinueReturn</span> (c : Code) : Bool <span class="constant">:=</span>
3770   hasExitPointPred c <span class="keyword">fun</span>
3771     | Code.<span class="comment">&#171;</span>break<span class="comment">&#187;</span> <span class="preprocessor">_</span>    <span class="constant">=&gt;</span> true
3772     | Code.<span class="comment">&#171;</span>continue<span class="comment">&#187;</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> true
3773     | Code.<span class="comment">&#171;</span>return<span class="comment">&#187;</span> <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> true
3774     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> false
3775 
<span class="keyword">3776 def</span> <span class="function-name">mkAuxDeclFor</span> {m} [Monad m] [MonadQuotation m] (e : Syntax) (mkCont : Syntax <span class="constant">&#8594;</span> m Code) : m Code <span class="constant">:=</span> withRef e <span class="constant">&lt;</span>| withFreshMacroScope <span class="keyword">do</span>
3777   <span class="keyword">let</span> y &#8592; `(y)
3778   <span class="keyword">let</span> yName <span class="constant">:=</span> y.getId
3779   <span class="keyword">let</span> doElem &#8592; `(doElem| <span class="keyword">let</span> y &#8592; <span class="constant">$</span>e:term)
3780   <span class="comment-delimiter">-- </span><span class="comment">Add elaboration hint for producing sane error message
</span>3781   <span class="keyword">let</span> y &#8592; `(ensureExpectedType% <span class="string">"type mismatch, result value"</span> <span class="constant">$</span>y)
3782   <span class="keyword">let</span> k &#8592; mkCont y
3783   pure <span class="constant">$</span> Code.decl <span class="constant">#</span>[yName] doElem k
3784 
<span class="comment-delimiter">3785 /- </span><span class="comment">Convert `action _ e` instructions in `c` into `let y &#8592; e; jmp _ jp (xs y)`. -/</span>
<span class="keyword">3786 partial</span> <span class="keyword">def</span> <span class="function-name">convertTerminalActionIntoJmp</span> (code : Code) (jp : Name) (xs : Array Name) : MacroM Code <span class="constant">:=</span>
3787   <span class="keyword">let</span> <span class="keyword">rec</span> loop : Code <span class="constant">&#8594;</span> MacroM Code
3788     | Code.decl xs stx k           <span class="constant">=&gt;</span> <span class="keyword">do</span> Code.decl xs stx (&#8592; loop k)
3789     | Code.reassign xs stx k       <span class="constant">=&gt;</span> <span class="keyword">do</span> Code.reassign xs stx (&#8592; loop k)
3790     | Code.joinpoint n ps b k      <span class="constant">=&gt;</span> <span class="keyword">do</span> Code.joinpoint n ps (&#8592; loop b) (&#8592; loop k)
3791     | Code.seq e k                 <span class="constant">=&gt;</span> <span class="keyword">do</span> Code.seq e (&#8592; loop k)
3792     | Code.ite ref x? h c t e      <span class="constant">=&gt;</span> <span class="keyword">do</span> Code.ite ref x? h c (&#8592; loop t) (&#8592; loop e)
3793     | Code.<span class="comment">&#171;</span>match<span class="comment">&#187;</span> ref g ds t alts <span class="constant">=&gt;</span> <span class="keyword">do</span> Code.<span class="comment">&#171;</span>match<span class="comment">&#187;</span> ref g ds t (&#8592; alts.mapM <span class="keyword">fun</span> alt <span class="constant">=&gt;</span> <span class="keyword">do</span> pure { alt <span class="keyword">with</span> rhs <span class="constant">:=</span> (&#8592; loop alt.rhs) })
3794     | Code.action e                <span class="constant">=&gt;</span> mkAuxDeclFor e <span class="keyword">fun</span> y <span class="constant">=&gt;</span>
3795       <span class="keyword">let</span> ref <span class="constant">:=</span> e
3796       <span class="comment-delimiter">-- </span><span class="comment">We jump to `jp` with xs **and** y
</span>3797       <span class="keyword">let</span> jmpArgs <span class="constant">:=</span> xs.map <span class="constant">$</span> mkIdentFrom ref
3798       <span class="keyword">let</span> jmpArgs <span class="constant">:=</span> jmpArgs.push y
3799       pure <span class="constant">$</span> Code.jmp ref jp jmpArgs
3800     | c                            <span class="constant">=&gt;</span> pure c
3801   loop code
3802 
<span class="keyword">3803 structure</span> <span class="function-name">JPDecl</span> <span class="keyword">where</span>
3804   name : Name
3805   params : Array (Name <span class="constant">&#215;</span> Bool)
3806   body : Code
3807 
<span class="keyword">3808 def</span> <span class="function-name">attachJP</span> (jpDecl : JPDecl) (k : Code) : Code <span class="constant">:=</span>
3809   Code.joinpoint jpDecl.name jpDecl.params jpDecl.body k
3810 
<span class="keyword">3811 def</span> <span class="function-name">attachJPs</span> (jpDecls : Array JPDecl) (k : Code) : Code <span class="constant">:=</span>
3812   jpDecls.foldr attachJP k
3813 
<span class="keyword">3814 def</span> <span class="function-name">mkFreshJP</span> (ps : Array (Name <span class="constant">&#215;</span> Bool)) (body : Code) : TermElabM JPDecl <span class="constant">:=</span> <span class="keyword">do</span>
3815   <span class="keyword">let</span> ps &#8592;
3816     <span class="keyword">if</span> ps.isEmpty <span class="keyword">then</span>
3817       <span class="keyword">let</span> y &#8592; mkFreshUserName `y
3818       pure <span class="constant">#</span>[(y, false)]
3819     <span class="keyword">else</span>
3820       pure ps
3821   <span class="comment-delimiter">-- </span><span class="comment">Remark: the compiler frontend implemented in C++ currently detects jointpoints created by
</span>3822   <span class="comment-delimiter">-- </span><span class="comment">the "do" notation by testing the name. See hack at method `visit_let` at `lcnf.cpp`
</span>3823   <span class="comment-delimiter">-- </span><span class="comment">We will remove this hack when we re-implement the compiler frontend in Lean.
</span>3824   <span class="keyword">let</span> name &#8592; mkFreshUserName `_do_jp
3825   pure { name <span class="constant">:=</span> name, params <span class="constant">:=</span> ps, body <span class="constant">:=</span> body }
3826 
<span class="keyword">3827 def</span> <span class="function-name">mkFreshJP'</span> (xs : Array Name) (body : Code) : TermElabM JPDecl <span class="constant">:=</span>
3828   mkFreshJP (xs.map <span class="keyword">fun</span> x <span class="constant">=&gt;</span> (x, true)) body
3829 
<span class="keyword">3830 def</span> <span class="function-name">addFreshJP</span> (ps : Array (Name <span class="constant">&#215;</span> Bool)) (body : Code) : StateRefT (Array JPDecl) TermElabM Name <span class="constant">:=</span> <span class="keyword">do</span>
3831   <span class="keyword">let</span> jp &#8592; mkFreshJP ps body
3832   modify <span class="keyword">fun</span> (jps : Array JPDecl) <span class="constant">=&gt;</span> jps.push jp
3833   pure jp.name
3834 
<span class="keyword">3835 def</span> <span class="function-name">insertVars</span> (rs : NameSet) (xs : Array Name) : NameSet <span class="constant">:=</span>
3836   xs.foldl (&#183;.insert &#183;) rs
3837 
<span class="keyword">3838 def</span> <span class="function-name">eraseVars</span> (rs : NameSet) (xs : Array Name) : NameSet <span class="constant">:=</span>
3839   xs.foldl (&#183;.erase &#183;) rs
3840 
<span class="keyword">3841 def</span> <span class="function-name">eraseOptVar</span> (rs : NameSet) (x? : Option Name) : NameSet <span class="constant">:=</span>
3842   <span class="keyword">match</span> x? <span class="keyword">with</span>
3843   | none   <span class="constant">=&gt;</span> rs
3844   | some x <span class="constant">=&gt;</span> rs.insert x
3845 
<span class="comment-delimiter">3846 /- </span><span class="comment">Create a new jointpoint for `c`, and jump to it with the variables `rs` -/</span>
<span class="keyword">3847 def</span> <span class="function-name">mkSimpleJmp</span> (ref : Syntax) (rs : NameSet) (c : Code) : StateRefT (Array JPDecl) TermElabM Code <span class="constant">:=</span> <span class="keyword">do</span>
3848   <span class="keyword">let</span> xs <span class="constant">:=</span> nameSetToArray rs
3849   <span class="keyword">let</span> jp &#8592; addFreshJP (xs.map <span class="keyword">fun</span> x <span class="constant">=&gt;</span> (x, true)) c
3850   <span class="keyword">if</span> xs.isEmpty <span class="keyword">then</span>
3851     <span class="keyword">let</span> unit &#8592; `(Unit.unit)
3852     <span class="keyword">return</span> Code.jmp ref jp <span class="constant">#</span>[unit]
3853   <span class="keyword">else</span>
3854     <span class="keyword">return</span> Code.jmp ref jp (xs.map <span class="constant">$</span> mkIdentFrom ref)
3855 
<span class="comment-delimiter">3856 /- </span><span class="comment">Create a new joinpoint that takes `rs` and `val` as arguments. `val` must be syntax representing a pure value.
3857    The body of the joinpoint is created using `mkJPBody yFresh`, where `yFresh`
3858    is a fresh variable created by this method. -/</span>
<span class="keyword">3859 def</span> <span class="function-name">mkJmp</span> (ref : Syntax) (rs : NameSet) (val : Syntax) (mkJPBody : Syntax <span class="constant">&#8594;</span> MacroM Code) : StateRefT (Array JPDecl) TermElabM Code <span class="constant">:=</span> <span class="keyword">do</span>
3860   <span class="keyword">let</span> xs <span class="constant">:=</span> nameSetToArray rs
3861   <span class="keyword">let</span> args <span class="constant">:=</span> xs.map <span class="constant">$</span> mkIdentFrom ref
3862   <span class="keyword">let</span> args <span class="constant">:=</span> args.push val
3863   <span class="keyword">let</span> yFresh &#8592; mkFreshUserName `y
3864   <span class="keyword">let</span> ps <span class="constant">:=</span> xs.map <span class="keyword">fun</span> x <span class="constant">=&gt;</span> (x, true)
3865   <span class="keyword">let</span> ps <span class="constant">:=</span> ps.push (yFresh, false)
3866   <span class="keyword">let</span> jpBody &#8592; liftMacroM <span class="constant">$</span> mkJPBody (mkIdentFrom ref yFresh)
3867   <span class="keyword">let</span> jp &#8592; addFreshJP ps jpBody
3868   pure <span class="constant">$</span> Code.jmp ref jp args
3869 
<span class="comment-delimiter">3870 /- </span><span class="comment">`pullExitPointsAux rs c` auxiliary method for `pullExitPoints`, `rs` is the set of update variable in the current path.  -/</span>
<span class="keyword">3871 partial</span> <span class="keyword">def</span> <span class="function-name">pullExitPointsAux</span> : NameSet <span class="constant">&#8594;</span> Code <span class="constant">&#8594;</span> StateRefT (Array JPDecl) TermElabM Code
3872   | rs, Code.decl xs stx k           <span class="constant">=&gt;</span> <span class="keyword">do</span> Code.decl xs stx (&#8592; pullExitPointsAux (eraseVars rs xs) k)
3873   | rs, Code.reassign xs stx k       <span class="constant">=&gt;</span> <span class="keyword">do</span> Code.reassign xs stx (&#8592; pullExitPointsAux (insertVars rs xs) k)
3874   | rs, Code.joinpoint j ps b k      <span class="constant">=&gt;</span> <span class="keyword">do</span> Code.joinpoint j ps (&#8592; pullExitPointsAux rs b) (&#8592; pullExitPointsAux rs k)
3875   | rs, Code.seq e k                 <span class="constant">=&gt;</span> <span class="keyword">do</span> Code.seq e (&#8592; pullExitPointsAux rs k)
3876   | rs, Code.ite ref x? o c t e      <span class="constant">=&gt;</span> <span class="keyword">do</span> Code.ite ref x? o c (&#8592; pullExitPointsAux (eraseOptVar rs x?) t) (&#8592; pullExitPointsAux (eraseOptVar rs x?) e)
3877   | rs, Code.<span class="comment">&#171;</span>match<span class="comment">&#187;</span> ref g ds t alts <span class="constant">=&gt;</span> <span class="keyword">do</span>
3878     Code.<span class="comment">&#171;</span>match<span class="comment">&#187;</span> ref g ds t (&#8592; alts.mapM <span class="keyword">fun</span> alt <span class="constant">=&gt;</span> <span class="keyword">do</span> pure { alt <span class="keyword">with</span> rhs <span class="constant">:=</span> (&#8592; pullExitPointsAux (eraseVars rs alt.vars) alt.rhs) })
3879   | rs, c<span class="constant">@</span>(Code.jmp <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="preprocessor">_</span>)           <span class="constant">=&gt;</span> pure c
3880   | rs, Code.<span class="comment">&#171;</span>break<span class="comment">&#187;</span> ref             <span class="constant">=&gt;</span> mkSimpleJmp ref rs (Code.<span class="comment">&#171;</span>break<span class="comment">&#187;</span> ref)
3881   | rs, Code.<span class="comment">&#171;</span>continue<span class="comment">&#187;</span> ref          <span class="constant">=&gt;</span> mkSimpleJmp ref rs (Code.<span class="comment">&#171;</span>continue<span class="comment">&#187;</span> ref)
3882   | rs, Code.<span class="comment">&#171;</span>return<span class="comment">&#187;</span> ref val        <span class="constant">=&gt;</span> mkJmp ref rs val (<span class="keyword">fun</span> y <span class="constant">=&gt;</span> pure <span class="constant">$</span> Code.<span class="comment">&#171;</span>return<span class="comment">&#187;</span> ref y)
3883   | rs, Code.action e                <span class="constant">=&gt;</span>
3884     <span class="comment-delimiter">-- </span><span class="comment">We use `mkAuxDeclFor` because `e` is not pure.
</span>3885     mkAuxDeclFor e <span class="keyword">fun</span> y <span class="constant">=&gt;</span>
3886       <span class="keyword">let</span> ref <span class="constant">:=</span> e
3887       mkJmp ref rs y (<span class="keyword">fun</span> yFresh <span class="constant">=&gt;</span> <span class="keyword">do</span> pure <span class="constant">$</span> Code.action (&#8592; `(Pure.pure <span class="constant">$</span>yFresh)))
3888 
<span class="comment-delimiter">3889 /-</span><span class="comment">
3890 Auxiliary operation for adding new variables to the collection of updated variables in a CodeBlock.
3891 When a new variable is not already in the collection, but is shadowed by some declaration in `c`,
3892 we create auxiliary join points to make sure we preserve the semantics of the code block.
3893 Example: suppose we have the code block `print x; let x := 10; return x`. And we want to extend it
3894 with the reassignment `x := x + 1`. We first use `pullExitPoints` to create
3895 ```
3896 let jp (x!1) :=  return x!1;
3897 print x;
3898 let x := 10;
3899 jmp jp x
3900 ```
3901 and then we add the reassignment
3902 ```
3903 x := x + 1
3904 let jp (x!1) := return x!1;
3905 print x;
3906 let x := 10;
3907 jmp jp x
3908 ```
3909 Note that we created a fresh variable `x!1` to avoid accidental name capture.
3910 As another example, consider
3911 ```
3912 print x;
3913 let x := 10
3914 y := y + 1;
3915 return x;
3916 ```
3917 We transform it into
3918 ```
3919 let jp (y x!1) := return x!1;
3920 print x;
3921 let x := 10
3922 y := y + 1;
3923 jmp jp y x
3924 ```
3925 and then we add the reassignment as in the previous example.
3926 We need to include `y` in the jump, because each exit point is implicitly returning the set of
3927 update variables.
3928 
3929 We implement the method as follows. Let `us` be `c.uvars`, then
3930 1- for each `return _ y` in `c`, we create a join point
3931   `let j (us y!1) := return y!1`
3932    and replace the `return _ y` with `jmp us y`
3933 2- for each `break`, we create a join point
3934   `let j (us) := break`
3935    and replace the `break` with `jmp us`.
3936 3- Same as 2 for `continue`.
3937 -/</span>
<span class="keyword">3938 def</span> <span class="function-name">pullExitPoints</span> (c : Code) : TermElabM Code <span class="constant">:=</span> <span class="keyword">do</span>
3939   <span class="keyword">if</span> hasExitPoint c <span class="keyword">then</span>
3940     <span class="keyword">let</span> (c, jpDecls) &#8592; (pullExitPointsAux {} c).run <span class="constant">#</span>[]
3941     pure <span class="constant">$</span> attachJPs jpDecls c
3942   <span class="keyword">else</span>
3943     pure c
3944 
<span class="keyword">3945 partial</span> <span class="keyword">def</span> <span class="function-name">extendUpdatedVarsAux</span> (c : Code) (ws : NameSet) : TermElabM Code <span class="constant">:=</span>
3946   <span class="keyword">let</span> <span class="keyword">rec</span> update : Code <span class="constant">&#8594;</span> TermElabM Code
3947     | Code.joinpoint j ps b k          <span class="constant">=&gt;</span> <span class="keyword">do</span> Code.joinpoint j ps (&#8592; update b) (&#8592; update k)
3948     | Code.seq e k                     <span class="constant">=&gt;</span> <span class="keyword">do</span> Code.seq e (&#8592; update k)
3949     | c<span class="constant">@</span>(Code.<span class="comment">&#171;</span>match<span class="comment">&#187;</span> ref g ds t alts) <span class="constant">=&gt;</span> <span class="keyword">do</span>
3950       <span class="keyword">if</span> alts.any <span class="keyword">fun</span> alt <span class="constant">=&gt;</span> alt.vars.any <span class="keyword">fun</span> x <span class="constant">=&gt;</span> ws.contains x <span class="keyword">then</span>
3951         <span class="comment-delimiter">-- </span><span class="comment">If a pattern variable is shadowing a variable in ws, we `pullExitPoints`
</span>3952         pullExitPoints c
3953       <span class="keyword">else</span>
3954         Code.<span class="comment">&#171;</span>match<span class="comment">&#187;</span> ref g ds t (&#8592; alts.mapM <span class="keyword">fun</span> alt <span class="constant">=&gt;</span> <span class="keyword">do</span> pure { alt <span class="keyword">with</span> rhs <span class="constant">:=</span> (&#8592; update alt.rhs) })
3955     | Code.ite ref none o c t e <span class="constant">=&gt;</span> <span class="keyword">do</span> Code.ite ref none o c (&#8592; update t) (&#8592; update e)
3956     | c<span class="constant">@</span>(Code.ite ref (some h) o cond t e) <span class="constant">=&gt;</span> <span class="keyword">do</span>
3957       <span class="keyword">if</span> ws.contains h <span class="keyword">then</span>
3958         <span class="comment-delimiter">-- </span><span class="comment">if the `h` at `if h:c then t else e` shadows a variable in `ws`, we `pullExitPoints`
</span>3959         pullExitPoints c
3960       <span class="keyword">else</span>
3961         Code.ite ref (some h) o cond (&#8592; update t) (&#8592; update e)
3962     | Code.reassign xs stx k <span class="constant">=&gt;</span> <span class="keyword">do</span> Code.reassign xs stx (&#8592; update k)
3963     | c<span class="constant">@</span>(Code.decl xs stx k) <span class="constant">=&gt;</span> <span class="keyword">do</span>
3964       <span class="keyword">if</span> xs.any <span class="keyword">fun</span> x <span class="constant">=&gt;</span> ws.contains x <span class="keyword">then</span>
3965         <span class="comment-delimiter">-- </span><span class="comment">One the declared variables is shadowing a variable in `ws`
</span>3966         pullExitPoints c
3967       <span class="keyword">else</span>
3968         Code.decl xs stx (&#8592; update k)
3969     | c <span class="constant">=&gt;</span> pure c
3970   update c
3971 
<span class="comment-delimiter">3972 /-</span><span class="comment">
3973 Extend the set of updated variables. It assumes `ws` is a super set of `c.uvars`.
3974 We **cannot** simply update the field `c.uvars`, because `c` may have shadowed some variable in `ws`.
3975 See discussion at `pullExitPoints`.
3976 -/</span>
<span class="keyword">3977 partial</span> <span class="keyword">def</span> <span class="function-name">extendUpdatedVars</span> (c : CodeBlock) (ws : NameSet) : TermElabM CodeBlock <span class="constant">:=</span> <span class="keyword">do</span>
3978   <span class="keyword">if</span> ws.any <span class="keyword">fun</span> x <span class="constant">=&gt;</span> <span class="constant">!</span>c.uvars.contains x <span class="keyword">then</span>
3979     <span class="comment-delimiter">-- </span><span class="comment">`ws` contains a variable that is not in `c.uvars`, but in `c.dvars` (i.e., it has been shadowed)
</span>3980     pure { code <span class="constant">:=</span> (&#8592; extendUpdatedVarsAux c.code ws), uvars <span class="constant">:=</span> ws }
3981   <span class="keyword">else</span>
3982     pure { c <span class="keyword">with</span> uvars <span class="constant">:=</span> ws }
3983 
<span class="keyword">3984 private</span> <span class="keyword">def</span> <span class="function-name">union</span> (s&#8321; s&#8322; : NameSet) : NameSet <span class="constant">:=</span>
3985   s&#8321;.fold (&#183;.insert &#183;) s&#8322;
3986 
<span class="comment-delimiter">3987 /-</span><span class="comment">
3988 Given two code blocks `c&#8321;` and `c&#8322;`, make sure they have the same set of updated variables.
3989 Let `ws` the union of the updated variables in `c&#8321;&#8245; and &#8245;c&#8322;`.
3990 We use `extendUpdatedVars c&#8321; ws` and `extendUpdatedVars c&#8322; ws`
3991 -/</span>
<span class="keyword">3992 def</span> <span class="function-name">homogenize</span> (c&#8321; c&#8322; : CodeBlock) : TermElabM (CodeBlock <span class="constant">&#215;</span> CodeBlock) <span class="constant">:=</span> <span class="keyword">do</span>
3993   <span class="keyword">let</span> ws <span class="constant">:=</span> union c&#8321;.uvars c&#8322;.uvars
3994   <span class="keyword">let</span> c&#8321; &#8592; extendUpdatedVars c&#8321; ws
3995   <span class="keyword">let</span> c&#8322; &#8592; extendUpdatedVars c&#8322; ws
3996   pure (c&#8321;, c&#8322;)
3997 
<span class="comment-delimiter">3998 /-</span><span class="comment">
3999 Extending code blocks with variable declarations: `let x : t := v` and `let x : t &#8592; v`.
4000 We remove `x` from the collection of updated varibles.
4001 Remark: `stx` is the syntax for the declaration (e.g., `letDecl`), and `xs` are the variables
4002 declared by it. It is an array because we have let-declarations that declare multiple variables.
4003 Example: `let (x, y) := t`
4004 -/</span>
<span class="keyword">4005 def</span> <span class="function-name">mkVarDeclCore</span> (xs : Array Name) (stx : Syntax) (c : CodeBlock) : CodeBlock <span class="constant">:=</span> {
4006   code <span class="constant">:=</span> Code.decl xs stx c.code,
4007   uvars <span class="constant">:=</span> eraseVars c.uvars xs
4008 }
4009 
<span class="comment-delimiter">4010 /-</span><span class="comment">
4011 Extending code blocks with reassignments: `x : t := v` and `x : t &#8592; v`.
4012 Remark: `stx` is the syntax for the declaration (e.g., `letDecl`), and `xs` are the variables
4013 declared by it. It is an array because we have let-declarations that declare multiple variables.
4014 Example: `(x, y) &#8592; t`
4015 -/</span>
<span class="keyword">4016 def</span> <span class="function-name">mkReassignCore</span> (xs : Array Name) (stx : Syntax) (c : CodeBlock) : TermElabM CodeBlock <span class="constant">:=</span> <span class="keyword">do</span>
4017   <span class="keyword">let</span> us <span class="constant">:=</span> c.uvars
4018   <span class="keyword">let</span> ws <span class="constant">:=</span> insertVars us xs
4019   <span class="comment-delimiter">-- </span><span class="comment">If `xs` contains a new updated variable, then we must use `extendUpdatedVars`.
</span>4020   <span class="comment-delimiter">-- </span><span class="comment">See discussion at `pullExitPoints`
</span>4021   <span class="keyword">let</span> code &#8592; <span class="keyword">if</span> xs.any <span class="keyword">fun</span> x <span class="constant">=&gt;</span> <span class="constant">!</span>us.contains x <span class="keyword">then</span> extendUpdatedVarsAux c.code ws <span class="keyword">else</span> pure c.code
4022   pure { code <span class="constant">:=</span> Code.reassign xs stx code, uvars <span class="constant">:=</span> ws }
4023 
<span class="keyword">4024 def</span> <span class="function-name">mkSeq</span> (action : Syntax) (c : CodeBlock) : CodeBlock <span class="constant">:=</span>
4025   { c <span class="keyword">with</span> code <span class="constant">:=</span> Code.seq action c.code }
4026 
<span class="keyword">4027 def</span> <span class="function-name">mkTerminalAction</span> (action : Syntax) : CodeBlock <span class="constant">:=</span>
4028   { code <span class="constant">:=</span> Code.action action }
4029 
<span class="keyword">4030 def</span> <span class="function-name">mkReturn</span> (ref : Syntax) (val : Syntax) : CodeBlock <span class="constant">:=</span>
4031   { code <span class="constant">:=</span> Code.<span class="comment">&#171;</span>return<span class="comment">&#187;</span> ref val }
4032 
<span class="keyword">4033 def</span> <span class="function-name">mkBreak</span> (ref : Syntax) : CodeBlock <span class="constant">:=</span>
4034   { code <span class="constant">:=</span> Code.<span class="comment">&#171;</span>break<span class="comment">&#187;</span> ref }
4035 
<span class="keyword">4036 def</span> <span class="function-name">mkContinue</span> (ref : Syntax) : CodeBlock <span class="constant">:=</span>
4037   { code <span class="constant">:=</span> Code.<span class="comment">&#171;</span>continue<span class="comment">&#187;</span> ref }
4038 
<span class="keyword">4039 def</span> <span class="function-name">mkIte</span> (ref : Syntax) (optIdent : Syntax) (cond : Syntax) (thenBranch : CodeBlock) (elseBranch : CodeBlock) : TermElabM CodeBlock <span class="constant">:=</span> <span class="keyword">do</span>
4040   <span class="keyword">let</span> x? <span class="constant">:=</span> <span class="keyword">if</span> optIdent.isNone <span class="keyword">then</span> none <span class="keyword">else</span> some optIdent[<span class="constant">0</span>].getId
4041   <span class="keyword">let</span> (thenBranch, elseBranch) &#8592; homogenize thenBranch elseBranch
4042   pure {
4043     code  <span class="constant">:=</span> Code.ite ref x? optIdent cond thenBranch.code elseBranch.code,
4044     uvars <span class="constant">:=</span> thenBranch.uvars,
4045   }
4046 
<span class="keyword">4047 private</span> <span class="keyword">def</span> <span class="function-name">mkUnit</span> : MacroM Syntax <span class="constant">:=</span>
4048   `((&#10216;&#10217; : PUnit))
4049 
<span class="keyword">4050 private</span> <span class="keyword">def</span> <span class="function-name">mkPureUnit</span> : MacroM Syntax <span class="constant">:=</span>
4051   `(pure PUnit.unit)
4052 
<span class="keyword">4053 def</span> <span class="function-name">mkPureUnitAction</span> : MacroM CodeBlock <span class="constant">:=</span> <span class="keyword">do</span>
4054   mkTerminalAction (&#8592; mkPureUnit)
4055 
<span class="keyword">4056 def</span> <span class="function-name">mkUnless</span> (cond : Syntax) (c : CodeBlock) : MacroM CodeBlock <span class="constant">:=</span> <span class="keyword">do</span>
4057   <span class="keyword">let</span> thenBranch &#8592; mkPureUnitAction
4058   pure { c <span class="keyword">with</span> code <span class="constant">:=</span> Code.ite (&#8592; getRef) none mkNullNode cond thenBranch.code c.code }
4059 
<span class="keyword">4060 def</span> <span class="function-name">mkMatch</span> (ref : Syntax) (genParam : Syntax) (discrs : Syntax) (optType : Syntax) (alts : Array (Alt CodeBlock)) : TermElabM CodeBlock <span class="constant">:=</span> <span class="keyword">do</span>
4061   <span class="comment-delimiter">-- </span><span class="comment">nary version of homogenize
</span>4062   <span class="keyword">let</span> ws <span class="constant">:=</span> alts.foldl (union &#183; &#183;.rhs.uvars) {}
4063   <span class="keyword">let</span> alts &#8592; alts.mapM <span class="keyword">fun</span> alt <span class="constant">=&gt;</span> <span class="keyword">do</span>
4064     <span class="keyword">let</span> rhs &#8592; extendUpdatedVars alt.rhs ws
4065     pure { ref <span class="constant">:=</span> alt.ref, vars <span class="constant">:=</span> alt.vars, patterns <span class="constant">:=</span> alt.patterns, rhs <span class="constant">:=</span> rhs.code : Alt Code }
4066   pure { code <span class="constant">:=</span> Code.<span class="comment">&#171;</span>match<span class="comment">&#187;</span> ref genParam discrs optType alts, uvars <span class="constant">:=</span> ws }
4067 
<span class="comment-delimiter">4068 /- </span><span class="comment">Return a code block that executes `terminal` and then `k` with the value produced by `terminal`.
4069    This method assumes `terminal` is a terminal -/</span>
<span class="keyword">4070 def</span> <span class="function-name">concat</span> (terminal : CodeBlock) (kRef : Syntax) (y? : Option Name) (k : CodeBlock) : TermElabM CodeBlock <span class="constant">:=</span> <span class="keyword">do</span>
4071   <span class="keyword">unless</span> hasTerminalAction terminal.code <span class="keyword">do</span>
4072     throwErrorAt kRef <span class="string">"'do' element is unreachable"</span>
4073   <span class="keyword">let</span> (terminal, k) &#8592; homogenize terminal k
4074   <span class="keyword">let</span> xs <span class="constant">:=</span> nameSetToArray k.uvars
4075   <span class="keyword">let</span> y &#8592; <span class="keyword">match</span> y? <span class="keyword">with</span> | some y <span class="constant">=&gt;</span> pure y | none <span class="constant">=&gt;</span> mkFreshUserName `y
4076   <span class="keyword">let</span> ps <span class="constant">:=</span> xs.map <span class="keyword">fun</span> x <span class="constant">=&gt;</span> (x, true)
4077   <span class="keyword">let</span> ps <span class="constant">:=</span> ps.push (y, false)
4078   <span class="keyword">let</span> jpDecl &#8592; mkFreshJP ps k.code
4079   <span class="keyword">let</span> jp <span class="constant">:=</span> jpDecl.name
4080   <span class="keyword">let</span> terminal &#8592; liftMacroM <span class="constant">$</span> convertTerminalActionIntoJmp terminal.code jp xs
4081   pure { code  <span class="constant">:=</span> attachJP jpDecl terminal, uvars <span class="constant">:=</span> k.uvars }
4082 
<span class="keyword">4083 def</span> <span class="function-name">getLetIdDeclVar</span> (letIdDecl : Syntax) : Name <span class="constant">:=</span>
4084   letIdDecl[<span class="constant">0</span>].getId
4085 
<span class="keyword">4086 def</span> <span class="function-name">getPatternVarNames</span> (pvars : Array PatternVar) : Array Name <span class="constant">:=</span>
4087   pvars.filterMap <span class="keyword">fun</span>
4088     | PatternVar.localVar x <span class="constant">=&gt;</span> some x
4089     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> none
4090 
<span class="comment-delimiter">4091 -- </span><span class="comment">support both regular and syntax match
</span><span class="keyword">4092 def</span> <span class="function-name">getPatternVarsEx</span> (pattern : Syntax) : TermElabM (Array Name) <span class="constant">:=</span>
4093   getPatternVarNames <span class="constant">&lt;$&gt;</span> getPatternVars pattern <span class="constant">&lt;</span>|<span class="constant">&gt;</span>
4094   Array.map Syntax.getId <span class="constant">&lt;$&gt;</span> Quotation.getPatternVars pattern
4095 
<span class="keyword">4096 def</span> <span class="function-name">getPatternsVarsEx</span> (patterns : Array Syntax) : TermElabM (Array Name) <span class="constant">:=</span>
4097   getPatternVarNames <span class="constant">&lt;$&gt;</span> getPatternsVars patterns <span class="constant">&lt;</span>|<span class="constant">&gt;</span>
4098   Array.map Syntax.getId <span class="constant">&lt;$&gt;</span> Quotation.getPatternsVars patterns
4099 
<span class="keyword">4100 def</span> <span class="function-name">getLetPatDeclVars</span> (letPatDecl : Syntax) : TermElabM (Array Name) <span class="constant">:=</span> <span class="keyword">do</span>
4101   <span class="keyword">let</span> pattern <span class="constant">:=</span> letPatDecl[<span class="constant">0</span>]
4102   getPatternVarsEx pattern
4103 
<span class="keyword">4104 def</span> <span class="function-name">getLetEqnsDeclVar</span> (letEqnsDecl : Syntax) : Name <span class="constant">:=</span>
4105   letEqnsDecl[<span class="constant">0</span>].getId
4106 
<span class="keyword">4107 def</span> <span class="function-name">getLetDeclVars</span> (letDecl : Syntax) : TermElabM (Array Name) <span class="constant">:=</span> <span class="keyword">do</span>
4108   <span class="keyword">let</span> arg <span class="constant">:=</span> letDecl[<span class="constant">0</span>]
4109   <span class="keyword">if</span> arg.getKind <span class="constant">==</span> `Lean.Parser.Term.letIdDecl <span class="keyword">then</span>
4110     pure <span class="constant">#</span>[getLetIdDeclVar arg]
4111   <span class="keyword">else</span> <span class="keyword">if</span> arg.getKind <span class="constant">==</span> `Lean.Parser.Term.letPatDecl <span class="keyword">then</span>
4112     getLetPatDeclVars arg
4113   <span class="keyword">else</span> <span class="keyword">if</span> arg.getKind <span class="constant">==</span> `Lean.Parser.Term.letEqnsDecl <span class="keyword">then</span>
4114     pure <span class="constant">#</span>[getLetEqnsDeclVar arg]
4115   <span class="keyword">else</span>
4116     throwError <span class="string">"unexpected kind of let declaration"</span>
4117 
<span class="keyword">4118 def</span> <span class="function-name">getDoLetVars</span> (doLet : Syntax) : TermElabM (Array Name) <span class="constant">:=</span>
4119   <span class="comment-delimiter">-- </span><span class="comment">leading_parser "let " &gt;&gt; optional "mut " &gt;&gt; letDecl
</span>4120   getLetDeclVars doLet[<span class="constant">2</span>]
4121 
<span class="keyword">4122 def</span> <span class="function-name">getDoHaveVar</span> (doHave : Syntax) : Name <span class="constant">:=</span>
4123   <span class="comment-delimiter">/-</span><span class="comment">
4124     `leading_parser "have " &gt;&gt; Term.haveDecl`
4125     where
4126     ```
4127     haveDecl := leading_parser optIdent &gt;&gt; termParser &gt;&gt; (haveAssign &lt;|&gt; fromTerm &lt;|&gt; byTactic)
4128     optIdent := optional (try (ident &gt;&gt; " : "))
4129 
4130     ```
4131   -/</span>
4132   <span class="keyword">let</span> optIdent <span class="constant">:=</span> doHave[<span class="constant">1</span>][<span class="constant">0</span>]
4133   <span class="keyword">if</span> optIdent.isNone <span class="keyword">then</span>
4134     `<span class="keyword">this</span>
4135   <span class="keyword">else</span>
4136     optIdent[<span class="constant">0</span>].getId
4137 
<span class="keyword">4138 def</span> <span class="function-name">getDoLetRecVars</span> (doLetRec : Syntax) : TermElabM (Array Name) <span class="constant">:=</span> <span class="keyword">do</span>
4139   <span class="comment-delimiter">-- </span><span class="comment">letRecDecls is an array of `(group (optional attributes &gt;&gt; letDecl))`
</span>4140   <span class="keyword">let</span> letRecDecls <span class="constant">:=</span> doLetRec[<span class="constant">1</span>][<span class="constant">0</span>].getSepArgs
4141   <span class="keyword">let</span> letDecls <span class="constant">:=</span> letRecDecls.map <span class="keyword">fun</span> p <span class="constant">=&gt;</span> p[<span class="constant">2</span>]
4142   <span class="keyword">let</span> <span class="keyword">mut</span> allVars <span class="constant">:=</span> <span class="constant">#</span>[]
4143   <span class="keyword">for</span> letDecl <span class="keyword">in</span> letDecls <span class="keyword">do</span>
4144     <span class="keyword">let</span> vars &#8592; getLetDeclVars letDecl
4145     allVars <span class="constant">:=</span> allVars <span class="constant">++</span> vars
4146   pure allVars
4147 
<span class="comment-delimiter">4148 -- </span><span class="comment">ident &gt;&gt; optType &gt;&gt; leftArrow &gt;&gt; termParser
</span><span class="keyword">4149 def</span> <span class="function-name">getDoIdDeclVar</span> (doIdDecl : Syntax) : Name <span class="constant">:=</span>
4150   doIdDecl[<span class="constant">0</span>].getId
4151 
<span class="comment-delimiter">4152 -- </span><span class="comment">termParser &gt;&gt; leftArrow &gt;&gt; termParser &gt;&gt; optional (" | " &gt;&gt; termParser)
</span><span class="keyword">4153 def</span> <span class="function-name">getDoPatDeclVars</span> (doPatDecl : Syntax) : TermElabM (Array Name) <span class="constant">:=</span> <span class="keyword">do</span>
4154   <span class="keyword">let</span> pattern <span class="constant">:=</span> doPatDecl[<span class="constant">0</span>]
4155   getPatternVarsEx pattern
4156 
<span class="comment-delimiter">4157 -- </span><span class="comment">leading_parser "let " &gt;&gt; optional "mut " &gt;&gt; (doIdDecl &lt;|&gt; doPatDecl)
</span><span class="keyword">4158 def</span> <span class="function-name">getDoLetArrowVars</span> (doLetArrow : Syntax) : TermElabM (Array Name) <span class="constant">:=</span> <span class="keyword">do</span>
4159   <span class="keyword">let</span> decl <span class="constant">:=</span> doLetArrow[<span class="constant">2</span>]
4160   <span class="keyword">if</span> decl.getKind <span class="constant">==</span> `Lean.Parser.Term.doIdDecl <span class="keyword">then</span>
4161     pure <span class="constant">#</span>[getDoIdDeclVar decl]
4162   <span class="keyword">else</span> <span class="keyword">if</span> decl.getKind <span class="constant">==</span> `Lean.Parser.Term.doPatDecl <span class="keyword">then</span>
4163     getDoPatDeclVars decl
4164   <span class="keyword">else</span>
4165     throwError <span class="string">"unexpected kind of 'do' declaration"</span>
4166 
<span class="keyword">4167 def</span> <span class="function-name">getDoReassignVars</span> (doReassign : Syntax) : TermElabM (Array Name) <span class="constant">:=</span> <span class="keyword">do</span>
4168   <span class="keyword">let</span> arg <span class="constant">:=</span> doReassign[<span class="constant">0</span>]
4169   <span class="keyword">if</span> arg.getKind <span class="constant">==</span> `Lean.Parser.Term.letIdDecl <span class="keyword">then</span>
4170     pure <span class="constant">#</span>[getLetIdDeclVar arg]
4171   <span class="keyword">else</span> <span class="keyword">if</span> arg.getKind <span class="constant">==</span> `Lean.Parser.Term.letPatDecl <span class="keyword">then</span>
4172     getLetPatDeclVars arg
4173   <span class="keyword">else</span>
4174     throwError <span class="string">"unexpected kind of reassignment"</span>
4175 
<span class="keyword">4176 def</span> <span class="function-name">mkDoSeq</span> (doElems : Array Syntax) : Syntax <span class="constant">:=</span>
4177   mkNode `Lean.Parser.Term.doSeqIndent <span class="constant">#</span>[mkNullNode <span class="constant">$</span> doElems.map <span class="keyword">fun</span> doElem <span class="constant">=&gt;</span> mkNullNode <span class="constant">#</span>[doElem, mkNullNode]]
4178 
<span class="keyword">4179 def</span> <span class="function-name">mkSingletonDoSeq</span> (doElem : Syntax) : Syntax <span class="constant">:=</span>
4180   mkDoSeq <span class="constant">#</span>[doElem]
4181 
<span class="comment-delimiter">4182 /-</span><span class="comment">
4183   If the given syntax is a `doIf`, return an equivalente `doIf` that has an `else` but no `else if`s or `if let`s.  -/</span>
<span class="keyword">4184 private</span> <span class="keyword">def</span> <span class="function-name">expandDoIf?</span> (stx : Syntax) : MacroM (Option Syntax) <span class="constant">:=</span> <span class="keyword">match</span> stx <span class="keyword">with</span>
4185   | `(doElem|<span class="keyword">if</span> <span class="constant">$</span>p:doIfProp <span class="keyword">then</span> <span class="constant">$</span>t <span class="keyword">else</span> <span class="constant">$</span>e) <span class="constant">=&gt;</span> pure none
4186   | `(doElem|<span class="keyword">if</span>%<span class="constant">$</span>i <span class="constant">$</span>cond:doIfCond <span class="keyword">then</span> <span class="constant">$</span>t <span class="constant">$</span>[<span class="keyword">else</span> <span class="keyword">if</span>%<span class="constant">$</span>is <span class="constant">$</span>conds:doIfCond <span class="keyword">then</span> <span class="constant">$</span>ts]<span class="constant">*</span> <span class="constant">$</span>[<span class="keyword">else</span> <span class="constant">$</span>e?]?) <span class="constant">=&gt;</span> withRef stx <span class="keyword">do</span>
4187     <span class="keyword">let</span> <span class="keyword">mut</span> e      <span class="constant">:=</span> e?.getD (&#8592; `(doSeq|pure PUnit.unit))
4188     <span class="keyword">let</span> <span class="keyword">mut</span> eIsSeq <span class="constant">:=</span> true
4189     <span class="keyword">for</span> (i, cond, t) <span class="keyword">in</span> Array.zip (is.reverse.push i) (Array.zip (conds.reverse.push cond) (ts.reverse.push t)) <span class="keyword">do</span>
4190       e &#8592; <span class="keyword">if</span> eIsSeq <span class="keyword">then</span> e <span class="keyword">else</span> `(doSeq|<span class="constant">$</span>e:doElem)
4191       e &#8592; withRef cond <span class="constant">&lt;</span>| <span class="keyword">match</span> cond <span class="keyword">with</span>
4192         | `(doIfCond|<span class="keyword">let</span> <span class="constant">$</span>pat <span class="constant">:=</span> <span class="constant">$</span>d) <span class="constant">=&gt;</span> `(doElem| <span class="keyword">match</span>%<span class="constant">$</span>i <span class="constant">$</span>d:term <span class="keyword">with</span> | <span class="constant">$</span>pat:term <span class="constant">=&gt;</span> <span class="constant">$</span>t | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="constant">$</span>e)
4193         | `(doIfCond|<span class="keyword">let</span> <span class="constant">$</span>pat &#8592; <span class="constant">$</span>d)  <span class="constant">=&gt;</span> `(doElem| <span class="keyword">match</span>%<span class="constant">$</span>i &#8592; <span class="constant">$</span>d    <span class="keyword">with</span> | <span class="constant">$</span>pat:term <span class="constant">=&gt;</span> <span class="constant">$</span>t | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="constant">$</span>e)
4194         | `(doIfCond|<span class="constant">$</span>cond:doIfProp) <span class="constant">=&gt;</span> `(doElem| <span class="keyword">if</span>%<span class="constant">$</span>i <span class="constant">$</span>cond:doIfProp <span class="keyword">then</span> <span class="constant">$</span>t <span class="keyword">else</span> <span class="constant">$</span>e)
4195         | <span class="preprocessor">_</span>                          <span class="constant">=&gt;</span> `(doElem| <span class="keyword">if</span>%<span class="constant">$</span>i <span class="constant">$</span>(Syntax.missing) <span class="keyword">then</span> <span class="constant">$</span>t <span class="keyword">else</span> <span class="constant">$</span>e)
4196       eIsSeq <span class="constant">:=</span> false
4197     <span class="keyword">return</span> some e
4198   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> pure none
4199 
<span class="keyword">4200 structure</span> <span class="function-name">DoIfView</span> <span class="keyword">where</span>
4201   ref        : Syntax
4202   optIdent   : Syntax
4203   cond       : Syntax
4204   thenBranch : Syntax
4205   elseBranch : Syntax
4206 
<span class="comment-delimiter">4207 /- </span><span class="comment">This method assumes `expandDoIf?` is not applicable. -/</span>
<span class="keyword">4208 private</span> <span class="keyword">def</span> <span class="function-name">mkDoIfView</span> (doIf : Syntax) : MacroM DoIfView <span class="constant">:=</span> <span class="keyword">do</span>
4209   pure {
4210     ref        <span class="constant">:=</span> doIf,
4211     optIdent   <span class="constant">:=</span> doIf[<span class="constant">1</span>][<span class="constant">0</span>],
4212     cond       <span class="constant">:=</span> doIf[<span class="constant">1</span>][<span class="constant">1</span>],
4213     thenBranch <span class="constant">:=</span> doIf[<span class="constant">3</span>],
4214     elseBranch <span class="constant">:=</span> doIf[<span class="constant">5</span>][<span class="constant">1</span>]
4215   }
4216 
<span class="comment-delimiter">4217 /-</span><span class="comment">
4218 We use `MProd` instead of `Prod` to group values when expanding the
4219 `do` notation. `MProd` is a universe monomorphic product.
4220 The motivation is to generate simpler universe constraints in code
4221 that was not written by the user.
4222 Note that we are not restricting the macro power since the
4223 `Bind.bind` combinator already forces values computed by monadic
4224 actions to be in the same universe.
4225 -/</span>
<span class="keyword">4226 private</span> <span class="keyword">def</span> <span class="function-name">mkTuple</span> (elems : Array Syntax) : MacroM Syntax <span class="constant">:=</span> <span class="keyword">do</span>
4227   <span class="keyword">if</span> elems.size <span class="constant">==</span> <span class="constant">0</span> <span class="keyword">then</span>
4228     mkUnit
4229   <span class="keyword">else</span> <span class="keyword">if</span> elems.size <span class="constant">==</span> <span class="constant">1</span> <span class="keyword">then</span>
4230     pure elems[<span class="constant">0</span>]
4231   <span class="keyword">else</span>
4232     (elems.extract <span class="constant">0</span> (elems.size <span class="constant">-</span> <span class="constant">1</span>)).foldrM
4233       (<span class="keyword">fun</span> elem tuple <span class="constant">=&gt;</span> `(MProd.mk <span class="constant">$</span>elem <span class="constant">$</span>tuple))
4234       (elems.back)
4235 
<span class="comment-delimiter">4236 /- </span><span class="comment">Return `some action` if `doElem` is a `doExpr &lt;action&gt;`-/</span>
<span class="keyword">4237 def</span> <span class="function-name">isDoExpr?</span> (doElem : Syntax) : Option Syntax <span class="constant">:=</span>
4238   <span class="keyword">if</span> doElem.getKind <span class="constant">==</span> `Lean.Parser.Term.doExpr <span class="keyword">then</span>
4239     some doElem[<span class="constant">0</span>]
4240   <span class="keyword">else</span>
4241     none
4242 
<span class="comment-delimiter">4243 /-</span><span class="comment">-
4244   Given `uvars := #[a_1, ..., a_n, a_{n+1}]` construct term
4245   ```
4246   let a_1     := x.1
4247   let x       := x.2
4248   let a_2     := x.1
4249   let x       := x.2
4250   ...
4251   let a_n     := x.1
4252   let a_{n+1} := x.2
4253   body
4254   ```
4255   Special cases
4256   - `uvars := #[]` =&gt; `body`
4257   - `uvars := #[a]` =&gt; `let a := x; body`
4258 
4259 
4260   We use this method when expanding the `for-in` notation.
4261 -/</span>
<span class="keyword">4262 private</span> <span class="keyword">def</span> <span class="function-name">destructTuple</span> (uvars : Array Name) (x : Syntax) (body : Syntax) : MacroM Syntax <span class="constant">:=</span> <span class="keyword">do</span>
4263   <span class="keyword">if</span> uvars.size <span class="constant">==</span> <span class="constant">0</span> <span class="keyword">then</span>
4264     <span class="keyword">return</span> body
4265   <span class="keyword">else</span> <span class="keyword">if</span> uvars.size <span class="constant">==</span> <span class="constant">1</span> <span class="keyword">then</span>
4266     `(<span class="keyword">let</span> <span class="constant">$</span>(&#8592; mkIdentFromRef uvars[<span class="constant">0</span>]):ident <span class="constant">:=</span> <span class="constant">$</span>x; <span class="constant">$</span>body)
4267   <span class="keyword">else</span>
4268     destruct uvars.toList x body
<span class="keyword">4269 where</span>
4270   destruct (as : List Name) (x : Syntax) (body : Syntax) : MacroM Syntax <span class="constant">:=</span> <span class="keyword">do</span>
4271     <span class="keyword">match</span> as <span class="keyword">with</span>
4272       | [a, b]  <span class="constant">=&gt;</span> `(<span class="keyword">let</span> <span class="constant">$</span>(&#8592; mkIdentFromRef a):ident <span class="constant">:=</span> <span class="constant">$</span>x.<span class="constant">1</span>; <span class="keyword">let</span> <span class="constant">$</span>(&#8592; mkIdentFromRef b):ident <span class="constant">:=</span> <span class="constant">$</span>x.<span class="constant">2</span>; <span class="constant">$</span>body)
4273       | a :: as <span class="constant">=&gt;</span> withFreshMacroScope <span class="keyword">do</span>
4274         <span class="keyword">let</span> rest &#8592; destruct as (&#8592; `(x)) body
4275         `(<span class="keyword">let</span> <span class="constant">$</span>(&#8592; mkIdentFromRef a):ident <span class="constant">:=</span> <span class="constant">$</span>x.<span class="constant">1</span>; <span class="keyword">let</span> x <span class="constant">:=</span> <span class="constant">$</span>x.<span class="constant">2</span>; <span class="constant">$</span>rest)
4276       | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="warning">unreachable</span><span class="constant">!</span>
4277 
<span class="comment-delimiter">4278 /-</span><span class="comment">
4279 The procedure `ToTerm.run` converts a `CodeBlock` into a `Syntax` term.
4280 We use this method to convert
4281 1- The `CodeBlock` for a root `do ...` term into a `Syntax` term. This kind of
4282    `CodeBlock` never contains `break` nor `continue`. Moreover, the collection
4283    of updated variables is not packed into the result.
4284    Thus, we have two kinds of exit points
4285      - `Code.action e` which is converted into `e`
4286      - `Code.return _ e` which is converted into `pure e`
4287 
4288    We use `Kind.regular` for this case.
4289 
4290 2- The `CodeBlock` for `b` at `for x in xs do b`. In this case, we need to generate
4291    a `Syntax` term representing a function for the `xs.forIn` combinator.
4292 
4293    a) If `b` contain a `Code.return _ a` exit point. The generated `Syntax` term
4294       has type `m (ForInStep (Option &#945; &#215; &#963;))`, where `a : &#945;`, and the `&#963;` is the type
4295       of the tuple of variables reassigned by `b`.
4296       We use `Kind.forInWithReturn` for this case
4297 
4298    b) If `b` does not contain a `Code.return _ a` exit point. Then, the generated
4299       `Syntax` term has type `m (ForInStep &#963;)`.
4300       We use `Kind.forIn` for this case.
4301 
4302 3- The `CodeBlock` `c` for a `do` sequence nested in a monadic combinator (e.g., `MonadExcept.tryCatch`).
4303 
4304    The generated `Syntax` term for `c` must inform whether `c` "exited" using `Code.action`, `Code.return`,
4305    `Code.break` or `Code.continue`. We use the auxiliary types `DoResult`s for storing this information.
4306    For example, the auxiliary type `DoResultPBC &#945; &#963;` is used for a code block that exits with `Code.action`,
4307    **and** `Code.break`/`Code.continue`, `&#945;` is the type of values produced by the exit `action`, and
4308    `&#963;` is the type of the tuple of reassigned variables.
4309    The type `DoResult &#945; &#946; &#963;` is usedf for code blocks that exit with
4310    `Code.action`, `Code.return`, **and** `Code.break`/`Code.continue`, `&#946;` is the type of the returned values.
4311    We don't use `DoResult &#945; &#946; &#963;` for all cases because:
4312 
4313       a) The elaborator would not be able to infer all type parameters without extra annotations. For example,
4314          if the code block does not contain `Code.return _ _`, the elaborator will not be able to infer `&#946;`.
4315 
4316       b) We need to pattern match on the result produced by the combinator (e.g., `MonadExcept.tryCatch`),
4317          but we don't want to consider "unreachable" cases.
4318 
4319    We do not distinguish between cases that contain `break`, but not `continue`, and vice versa.
4320 
4321    When listing all cases, we use `a` to indicate the code block contains `Code.action _`, `r` for `Code.return _ _`,
4322    and `b/c` for a code block that contains `Code.break _` or `Code.continue _`.
4323 
4324    - `a`: `Kind.regular`, type `m (&#945; &#215; &#963;)`
4325 
4326    - `r`: `Kind.regular`, type `m (&#945; &#215; &#963;)`
4327            Note that the code that pattern matches on the result will behave differently in this case.
4328            It produces `return a` for this case, and `pure a` for the previous one.
4329 
4330    - `b/c`: `Kind.nestedBC`, type `m (DoResultBC &#963;)`
4331 
4332    - `a` and `r`:   `Kind.nestedPR`, type `m (DoResultPR &#945; &#946; &#963;)`
4333 
4334    - `a` and `bc`:  `Kind.nestedSBC`, type `m (DoResultSBC &#945; &#963;)`
4335 
4336    - `r` and `bc`:  `Kind.nestedSBC`, type `m (DoResultSBC &#945; &#963;)`
4337          Again the code that pattern matches on the result will behave differently in this case and
4338          the previous one. It produces `return a` for the constructor `DoResultSPR.pureReturn a u` for
4339          this case, and `pure a` for the previous case.
4340 
4341    - `a`, `r`, `b/c`: `Kind.nestedPRBC`, type type `m (DoResultPRBC &#945; &#946; &#963;)`
4342 
4343 Here is the recipe for adding new combinators with nested `do`s.
4344 Example: suppose we want to support `repeat doSeq`. Assuming we have `repeat : m &#945; &#8594; m &#945;`
4345 1- Convert `doSeq` into `codeBlock : CodeBlock`
4346 2- Create term `term` using `mkNestedTerm code m uvars a r bc` where
4347    `code` is `codeBlock.code`, `uvars` is an array containing `codeBlock.uvars`,
4348    `m` is a `Syntax` representing the Monad, and
4349    `a` is true if `code` contains `Code.action _`,
4350    `r` is true if `code` contains `Code.return _ _`,
4351    `bc` is true if `code` contains `Code.break _` or `Code.continue _`.
4352 
4353    Remark: for combinators such as `repeat` that take a single `doSeq`, all
4354    arguments, but `m`, are extracted from `codeBlock`.
4355 3- Create the term `repeat $term`
4356 4- and then, convert it into a `doSeq` using `matchNestedTermResult ref (repeat $term) uvsar a r bc`
4357 
4358 -/</span>
<span class="keyword">4359 namespace</span> ToTerm
4360 
<span class="keyword">4361 inductive</span> <span class="function-name">Kind</span> <span class="keyword">where</span>
4362   | regular
4363   | forIn
4364   | forInWithReturn
4365   | nestedBC
4366   | nestedPR
4367   | nestedSBC
4368   | nestedPRBC
4369 
<span class="keyword">4370 instance</span> <span class="function-name">:</span> Inhabited Kind <span class="constant">:=</span> &#10216;Kind.regular&#10217;
4371 
<span class="keyword">4372 def</span> <span class="function-name">Kind.isRegular</span> : Kind <span class="constant">&#8594;</span> Bool
4373   | Kind.regular <span class="constant">=&gt;</span> true
4374   | <span class="preprocessor">_</span>            <span class="constant">=&gt;</span> false
4375 
<span class="keyword">4376 structure</span> <span class="function-name">Context</span> <span class="keyword">where</span>
4377   m     : Syntax <span class="comment-delimiter">-- </span><span class="comment">Syntax to reference the monad associated with the do notation.
</span>4378   uvars : Array Name
4379   kind  : Kind
4380 
<span class="keyword">4381 abbrev</span> M <span class="constant">:=</span> ReaderT Context MacroM
4382 
<span class="keyword">4383 def</span> <span class="function-name">mkUVarTuple</span> : M Syntax <span class="constant">:=</span> <span class="keyword">do</span>
4384   <span class="keyword">let</span> ctx &#8592; read
4385   <span class="keyword">let</span> uvarIdents &#8592; ctx.uvars.mapM mkIdentFromRef
4386   mkTuple uvarIdents
4387 
<span class="keyword">4388 def</span> <span class="function-name">returnToTerm</span> (val : Syntax) : M Syntax <span class="constant">:=</span> <span class="keyword">do</span>
4389   <span class="keyword">let</span> ctx &#8592; read
4390   <span class="keyword">let</span> u &#8592; mkUVarTuple
4391   <span class="keyword">match</span> ctx.kind <span class="keyword">with</span>
4392   | Kind.regular         <span class="constant">=&gt;</span> <span class="keyword">if</span> ctx.uvars.isEmpty <span class="keyword">then</span> `(Pure.pure <span class="constant">$</span>val) <span class="keyword">else</span> `(Pure.pure (MProd.mk <span class="constant">$</span>val <span class="constant">$</span>u))
4393   | Kind.forIn           <span class="constant">=&gt;</span> `(Pure.pure (ForInStep.done <span class="constant">$</span>u))
4394   | Kind.forInWithReturn <span class="constant">=&gt;</span> `(Pure.pure (ForInStep.done (MProd.mk (some <span class="constant">$</span>val) <span class="constant">$</span>u)))
4395   | Kind.nestedBC        <span class="constant">=&gt;</span> <span class="warning">unreachable</span><span class="constant">!</span>
4396   | Kind.nestedPR        <span class="constant">=&gt;</span> `(Pure.pure (DoResultPR.<span class="comment">&#171;</span>return<span class="comment">&#187;</span> <span class="constant">$</span>val <span class="constant">$</span>u))
4397   | Kind.nestedSBC       <span class="constant">=&gt;</span> `(Pure.pure (DoResultSBC.<span class="comment">&#171;</span>pureReturn<span class="comment">&#187;</span> <span class="constant">$</span>val <span class="constant">$</span>u))
4398   | Kind.nestedPRBC      <span class="constant">=&gt;</span> `(Pure.pure (DoResultPRBC.<span class="comment">&#171;</span>return<span class="comment">&#187;</span> <span class="constant">$</span>val <span class="constant">$</span>u))
4399 
<span class="keyword">4400 def</span> <span class="function-name">continueToTerm</span> : M Syntax <span class="constant">:=</span> <span class="keyword">do</span>
4401   <span class="keyword">let</span> ctx &#8592; read
4402   <span class="keyword">let</span> u &#8592; mkUVarTuple
4403   <span class="keyword">match</span> ctx.kind <span class="keyword">with</span>
4404   | Kind.regular         <span class="constant">=&gt;</span> <span class="warning">unreachable</span><span class="constant">!</span>
4405   | Kind.forIn           <span class="constant">=&gt;</span> `(Pure.pure (ForInStep.yield <span class="constant">$</span>u))
4406   | Kind.forInWithReturn <span class="constant">=&gt;</span> `(Pure.pure (ForInStep.yield (MProd.mk none <span class="constant">$</span>u)))
4407   | Kind.nestedBC        <span class="constant">=&gt;</span> `(Pure.pure (DoResultBC.<span class="comment">&#171;</span>continue<span class="comment">&#187;</span> <span class="constant">$</span>u))
4408   | Kind.nestedPR        <span class="constant">=&gt;</span> <span class="warning">unreachable</span><span class="constant">!</span>
4409   | Kind.nestedSBC       <span class="constant">=&gt;</span> `(Pure.pure (DoResultSBC.<span class="comment">&#171;</span>continue<span class="comment">&#187;</span> <span class="constant">$</span>u))
4410   | Kind.nestedPRBC      <span class="constant">=&gt;</span> `(Pure.pure (DoResultPRBC.<span class="comment">&#171;</span>continue<span class="comment">&#187;</span> <span class="constant">$</span>u))
4411 
<span class="keyword">4412 def</span> <span class="function-name">breakToTerm</span> : M Syntax <span class="constant">:=</span> <span class="keyword">do</span>
4413   <span class="keyword">let</span> ctx &#8592; read
4414   <span class="keyword">let</span> u &#8592; mkUVarTuple
4415   <span class="keyword">match</span> ctx.kind <span class="keyword">with</span>
4416   | Kind.regular         <span class="constant">=&gt;</span> <span class="warning">unreachable</span><span class="constant">!</span>
4417   | Kind.forIn           <span class="constant">=&gt;</span> `(Pure.pure (ForInStep.done <span class="constant">$</span>u))
4418   | Kind.forInWithReturn <span class="constant">=&gt;</span> `(Pure.pure (ForInStep.done (MProd.mk none <span class="constant">$</span>u)))
4419   | Kind.nestedBC        <span class="constant">=&gt;</span> `(Pure.pure (DoResultBC.<span class="comment">&#171;</span>break<span class="comment">&#187;</span> <span class="constant">$</span>u))
4420   | Kind.nestedPR        <span class="constant">=&gt;</span> <span class="warning">unreachable</span><span class="constant">!</span>
4421   | Kind.nestedSBC       <span class="constant">=&gt;</span> `(Pure.pure (DoResultSBC.<span class="comment">&#171;</span>break<span class="comment">&#187;</span> <span class="constant">$</span>u))
4422   | Kind.nestedPRBC      <span class="constant">=&gt;</span> `(Pure.pure (DoResultPRBC.<span class="comment">&#171;</span>break<span class="comment">&#187;</span> <span class="constant">$</span>u))
4423 
<span class="keyword">4424 def</span> <span class="function-name">actionTerminalToTerm</span> (action : Syntax) : M Syntax <span class="constant">:=</span> withRef action <span class="constant">&lt;</span>| withFreshMacroScope <span class="keyword">do</span>
4425   <span class="keyword">let</span> ctx &#8592; read
4426   <span class="keyword">let</span> u &#8592; mkUVarTuple
4427   <span class="keyword">match</span> ctx.kind <span class="keyword">with</span>
4428   | Kind.regular         <span class="constant">=&gt;</span> <span class="keyword">if</span> ctx.uvars.isEmpty <span class="keyword">then</span> pure action <span class="keyword">else</span> `(Bind.bind <span class="constant">$</span>action <span class="keyword">fun</span> y <span class="constant">=&gt;</span> Pure.pure (MProd.mk y <span class="constant">$</span>u))
4429   | Kind.forIn           <span class="constant">=&gt;</span> `(Bind.bind <span class="constant">$</span>action <span class="keyword">fun</span> (<span class="preprocessor">_</span> : PUnit) <span class="constant">=&gt;</span> Pure.pure (ForInStep.yield <span class="constant">$</span>u))
4430   | Kind.forInWithReturn <span class="constant">=&gt;</span> `(Bind.bind <span class="constant">$</span>action <span class="keyword">fun</span> (<span class="preprocessor">_</span> : PUnit) <span class="constant">=&gt;</span> Pure.pure (ForInStep.yield (MProd.mk none <span class="constant">$</span>u)))
4431   | Kind.nestedBC        <span class="constant">=&gt;</span> <span class="warning">unreachable</span><span class="constant">!</span>
4432   | Kind.nestedPR        <span class="constant">=&gt;</span> `(Bind.bind <span class="constant">$</span>action <span class="keyword">fun</span> y <span class="constant">=&gt;</span> (Pure.pure (DoResultPR.<span class="comment">&#171;</span>pure<span class="comment">&#187;</span> y <span class="constant">$</span>u)))
4433   | Kind.nestedSBC       <span class="constant">=&gt;</span> `(Bind.bind <span class="constant">$</span>action <span class="keyword">fun</span> y <span class="constant">=&gt;</span> (Pure.pure (DoResultSBC.<span class="comment">&#171;</span>pureReturn<span class="comment">&#187;</span> y <span class="constant">$</span>u)))
4434   | Kind.nestedPRBC      <span class="constant">=&gt;</span> `(Bind.bind <span class="constant">$</span>action <span class="keyword">fun</span> y <span class="constant">=&gt;</span> (Pure.pure (DoResultPRBC.<span class="comment">&#171;</span>pure<span class="comment">&#187;</span> y <span class="constant">$</span>u)))
4435 
<span class="keyword">4436 def</span> <span class="function-name">seqToTerm</span> (action : Syntax) (k : Syntax) : M Syntax <span class="constant">:=</span> withRef action <span class="constant">&lt;</span>| withFreshMacroScope <span class="keyword">do</span>
4437   <span class="keyword">if</span> action.getKind <span class="constant">==</span> `Lean.Parser.Term.doDbgTrace <span class="keyword">then</span>
4438     <span class="keyword">let</span> msg <span class="constant">:=</span> action[<span class="constant">1</span>]
4439     `(dbg_trace <span class="constant">$</span>msg; <span class="constant">$</span>k)
4440   <span class="keyword">else</span> <span class="keyword">if</span> action.getKind <span class="constant">==</span> `Lean.Parser.Term.doAssert <span class="keyword">then</span>
4441     <span class="keyword">let</span> cond <span class="constant">:=</span> action[<span class="constant">1</span>]
4442     `(<span class="warning">assert</span><span class="constant">!</span> <span class="constant">$</span>cond; <span class="constant">$</span>k)
4443   <span class="keyword">else</span>
4444     <span class="keyword">let</span> action &#8592; withRef action `((<span class="constant">$</span>action : <span class="constant">$</span>((&#8592;read).m) PUnit))
4445     `(Bind.bind <span class="constant">$</span>action (<span class="keyword">fun</span> (<span class="preprocessor">_</span> : PUnit) <span class="constant">=&gt;</span> <span class="constant">$</span>k))
4446 
<span class="keyword">4447 def</span> <span class="function-name">declToTerm</span> (decl : Syntax) (k : Syntax) : M Syntax <span class="constant">:=</span> withRef decl <span class="constant">&lt;</span>| withFreshMacroScope <span class="keyword">do</span>
4448   <span class="keyword">let</span> kind <span class="constant">:=</span> decl.getKind
4449   <span class="keyword">if</span> kind <span class="constant">==</span> `Lean.Parser.Term.doLet <span class="keyword">then</span>
4450     <span class="keyword">let</span> letDecl <span class="constant">:=</span> decl[<span class="constant">2</span>]
4451     `(<span class="keyword">let</span> <span class="constant">$</span>letDecl:letDecl; <span class="constant">$</span>k)
4452   <span class="keyword">else</span> <span class="keyword">if</span> kind <span class="constant">==</span> `Lean.Parser.Term.doLetRec <span class="keyword">then</span>
4453     <span class="keyword">let</span> letRecToken <span class="constant">:=</span> decl[<span class="constant">0</span>]
4454     <span class="keyword">let</span> letRecDecls <span class="constant">:=</span> decl[<span class="constant">1</span>]
4455     pure <span class="constant">$</span> mkNode `Lean.Parser.Term.letrec <span class="constant">#</span>[letRecToken, letRecDecls, mkNullNode, k]
4456   <span class="keyword">else</span> <span class="keyword">if</span> kind <span class="constant">==</span> `Lean.Parser.Term.doLetArrow <span class="keyword">then</span>
4457     <span class="keyword">let</span> arg <span class="constant">:=</span> decl[<span class="constant">2</span>]
4458     <span class="keyword">let</span> ref <span class="constant">:=</span> arg
4459     <span class="keyword">if</span> arg.getKind <span class="constant">==</span> `Lean.Parser.Term.doIdDecl <span class="keyword">then</span>
4460       <span class="keyword">let</span> id     <span class="constant">:=</span> arg[<span class="constant">0</span>]
4461       <span class="keyword">let</span> type   <span class="constant">:=</span> expandOptType ref arg[<span class="constant">1</span>]
4462       <span class="keyword">let</span> doElem <span class="constant">:=</span> arg[<span class="constant">3</span>]
4463       <span class="comment-delimiter">-- </span><span class="comment">`doElem` must be a `doExpr action`. See `doLetArrowToCode`
</span>4464       <span class="keyword">match</span> isDoExpr? doElem <span class="keyword">with</span>
4465       | some action <span class="constant">=&gt;</span>
4466         <span class="keyword">let</span> action &#8592; withRef action `((<span class="constant">$</span>action : <span class="constant">$</span>((&#8592; read).m) <span class="constant">$</span>type))
4467         `(Bind.bind <span class="constant">$</span>action (<span class="keyword">fun</span> (<span class="constant">$</span>id:ident : <span class="constant">$</span>type) <span class="constant">=&gt;</span> <span class="constant">$</span>k))
4468       | none        <span class="constant">=&gt;</span> Macro.throwErrorAt decl <span class="string">"unexpected kind of 'do' declaration"</span>
4469     <span class="keyword">else</span>
4470       Macro.throwErrorAt decl <span class="string">"unexpected kind of 'do' declaration"</span>
4471   <span class="keyword">else</span> <span class="keyword">if</span> kind <span class="constant">==</span> `Lean.Parser.Term.doHave <span class="keyword">then</span>
4472     <span class="comment-delimiter">-- </span><span class="comment">The `have` term is of the form  `"have " &gt;&gt; haveDecl &gt;&gt; optSemicolon termParser`
</span>4473     <span class="keyword">let</span> args <span class="constant">:=</span> decl.getArgs
4474     <span class="keyword">let</span> args <span class="constant">:=</span> args <span class="constant">++</span> <span class="constant">#</span>[mkNullNode <span class="comment-delimiter">/- </span><span class="comment">optional ';' -/</span>, k]
4475     pure <span class="constant">$</span> mkNode `Lean.Parser.Term.<span class="comment">&#171;</span>have<span class="comment">&#187;</span> args
4476   <span class="keyword">else</span>
4477     Macro.throwErrorAt decl <span class="string">"unexpected kind of 'do' declaration"</span>
4478 
<span class="keyword">4479 def</span> <span class="function-name">reassignToTerm</span> (reassign : Syntax) (k : Syntax) : MacroM Syntax <span class="constant">:=</span> withRef reassign <span class="constant">&lt;</span>| withFreshMacroScope <span class="keyword">do</span>
4480   <span class="keyword">let</span> kind <span class="constant">:=</span> reassign.getKind
4481   <span class="keyword">if</span> kind <span class="constant">==</span> `Lean.Parser.Term.doReassign <span class="keyword">then</span>
4482     <span class="comment-delimiter">-- </span><span class="comment">doReassign := leading_parser (letIdDecl &lt;|&gt; letPatDecl)
</span>4483     <span class="keyword">let</span> arg <span class="constant">:=</span> reassign[<span class="constant">0</span>]
4484     <span class="keyword">if</span> arg.getKind <span class="constant">==</span> `Lean.Parser.Term.letIdDecl <span class="keyword">then</span>
4485       <span class="comment-delimiter">-- </span><span class="comment">letIdDecl := leading_parser ident &gt;&gt; many (ppSpace &gt;&gt; bracketedBinder) &gt;&gt; optType &gt;&gt;  " := " &gt;&gt; termParser
</span>4486       <span class="keyword">let</span> x   <span class="constant">:=</span> arg[<span class="constant">0</span>]
4487       <span class="keyword">let</span> val <span class="constant">:=</span> arg[<span class="constant">4</span>]
4488       <span class="keyword">let</span> newVal &#8592; `(ensureTypeOf% <span class="constant">$</span>x <span class="constant">$</span>(quote <span class="string">"invalid reassignment, value"</span>) <span class="constant">$</span>val)
4489       <span class="keyword">let</span> arg <span class="constant">:=</span> arg.setArg <span class="constant">4</span> newVal
4490       <span class="keyword">let</span> letDecl <span class="constant">:=</span> mkNode `Lean.Parser.Term.letDecl <span class="constant">#</span>[arg]
4491       `(<span class="keyword">let</span> <span class="constant">$</span>letDecl:letDecl; <span class="constant">$</span>k)
4492     <span class="keyword">else</span>
4493       <span class="comment-delimiter">-- </span><span class="comment">TODO: ensure the types did not change
</span>4494       <span class="keyword">let</span> letDecl <span class="constant">:=</span> mkNode `Lean.Parser.Term.letDecl <span class="constant">#</span>[arg]
4495       `(<span class="keyword">let</span> <span class="constant">$</span>letDecl:letDecl; <span class="constant">$</span>k)
4496   <span class="keyword">else</span>
4497     <span class="comment-delimiter">-- </span><span class="comment">Note that `doReassignArrow` is expanded by `doReassignArrowToCode
</span>4498     Macro.throwErrorAt reassign <span class="string">"unexpected kind of 'do' reassignment"</span>
4499 
<span class="keyword">4500 def</span> <span class="function-name">mkIte</span> (optIdent : Syntax) (cond : Syntax) (thenBranch : Syntax) (elseBranch : Syntax) : MacroM Syntax <span class="constant">:=</span> <span class="keyword">do</span>
4501   <span class="keyword">if</span> optIdent.isNone <span class="keyword">then</span>
4502     `(ite <span class="constant">$</span>cond <span class="constant">$</span>thenBranch <span class="constant">$</span>elseBranch)
4503   <span class="keyword">else</span>
4504     <span class="keyword">let</span> h <span class="constant">:=</span> optIdent[<span class="constant">0</span>]
4505     `(dite <span class="constant">$</span>cond (<span class="keyword">fun</span> <span class="constant">$</span>h <span class="constant">=&gt;</span> <span class="constant">$</span>thenBranch) (<span class="keyword">fun</span> <span class="constant">$</span>h <span class="constant">=&gt;</span> <span class="constant">$</span>elseBranch))
4506 
<span class="keyword">4507 def</span> <span class="function-name">mkJoinPoint</span> (j : Name) (ps : Array (Name <span class="constant">&#215;</span> Bool)) (body : Syntax) (k : Syntax) : M Syntax <span class="constant">:=</span> withRef body <span class="constant">&lt;</span>| withFreshMacroScope <span class="keyword">do</span>
4508   <span class="keyword">let</span> pTypes &#8592; ps.mapM <span class="keyword">fun</span> &#10216;id, useTypeOf&#10217; <span class="constant">=&gt;</span> <span class="keyword">do</span> <span class="keyword">if</span> useTypeOf <span class="keyword">then</span> `(typeOf% <span class="constant">$</span>(&#8592; mkIdentFromRef id)) <span class="keyword">else</span> `(<span class="preprocessor">_</span>)
4509   <span class="keyword">let</span> ps     &#8592; ps.mapM <span class="keyword">fun</span> &#10216;id, useTypeOf&#10217; <span class="constant">=&gt;</span> mkIdentFromRef id
4510   <span class="comment-delimiter">/-</span><span class="comment">
4511   We use `let_delayed` instead of `let` for joinpoints to make sure `$k` is elaborated before `$body`.
4512   By elaborating `$k` first, we "learn" more about `$body`'s type.
4513   For example, consider the following example `do` expression
4514   ```
4515   def f (x : Nat) : IO Unit := do
4516   if x &gt; 0 then
4517     IO.println "x is not zero" -- Error is here
4518   IO.mkRef true
4519   ```
4520   it is expanded into
4521   ```
4522   def f (x : Nat) : IO Unit := do
4523   let jp (u : Unit) : IO _ :=
4524     IO.mkRef true;
4525   if x &gt; 0 then
4526     IO.println "not zero"
4527     jp ()
4528   else
4529     jp ()
4530   ```
4531   If we use the regular `let` instead of `let_delayed`, the joinpoint `jp` will be elaborated and its type will be inferred to be `Unit &#8594; IO (IO.Ref Bool)`.
4532   Then, we get a typing error at `jp ()`. By using `let_delayed`, we first elaborate `if x &gt; 0 ...` and learn that `jp` has type `Unit &#8594; IO Unit`.
4533   Then, we get the expected type mismatch error at `IO.mkRef true`. -/</span>
4534   `(let_delayed <span class="constant">$</span>(&#8592; mkIdentFromRef j):ident <span class="constant">$</span>[(<span class="constant">$</span>ps : <span class="constant">$</span>pTypes)]<span class="constant">*</span> : <span class="constant">$</span>((&#8592; read).m) <span class="preprocessor">_</span> <span class="constant">:=</span> <span class="constant">$</span>body; <span class="constant">$</span>k)
4535 
<span class="keyword">4536 def</span> <span class="function-name">mkJmp</span> (ref : Syntax) (j : Name) (args : Array Syntax) : Syntax <span class="constant">:=</span>
4537   Syntax.mkApp (mkIdentFrom ref j) args
4538 
<span class="keyword">4539 partial</span> <span class="keyword">def</span> <span class="function-name">toTerm</span> : Code <span class="constant">&#8594;</span> M Syntax
4540   | Code.<span class="comment">&#171;</span>return<span class="comment">&#187;</span> ref val   <span class="constant">=&gt;</span> withRef ref <span class="constant">&lt;</span>| returnToTerm val
4541   | Code.<span class="comment">&#171;</span>continue<span class="comment">&#187;</span> ref     <span class="constant">=&gt;</span> withRef ref continueToTerm
4542   | Code.<span class="comment">&#171;</span>break<span class="comment">&#187;</span> ref        <span class="constant">=&gt;</span> withRef ref breakToTerm
4543   | Code.action e           <span class="constant">=&gt;</span> actionTerminalToTerm e
4544   | Code.joinpoint j ps b k <span class="constant">=&gt;</span> <span class="keyword">do</span> mkJoinPoint j ps (&#8592; toTerm b) (&#8592; toTerm k)
4545   | Code.jmp ref j args     <span class="constant">=&gt;</span> pure <span class="constant">$</span> mkJmp ref j args
4546   | Code.decl <span class="preprocessor">_</span> stx k       <span class="constant">=&gt;</span> <span class="keyword">do</span> declToTerm stx (&#8592; toTerm k)
4547   | Code.reassign <span class="preprocessor">_</span> stx k   <span class="constant">=&gt;</span> <span class="keyword">do</span> reassignToTerm stx (&#8592; toTerm k)
4548   | Code.seq stx k          <span class="constant">=&gt;</span> <span class="keyword">do</span> seqToTerm stx (&#8592; toTerm k)
4549   | Code.ite ref <span class="preprocessor">_</span> o c t e  <span class="constant">=&gt;</span> withRef ref <span class="constant">&lt;</span>| <span class="keyword">do</span> mkIte o c (&#8592; toTerm t) (&#8592; toTerm e)
4550   | Code.<span class="comment">&#171;</span>match<span class="comment">&#187;</span> ref genParam discrs optType alts <span class="constant">=&gt;</span> <span class="keyword">do</span>
4551     <span class="keyword">let</span> <span class="keyword">mut</span> termAlts <span class="constant">:=</span> <span class="constant">#</span>[]
4552     <span class="keyword">for</span> alt <span class="keyword">in</span> alts <span class="keyword">do</span>
4553       <span class="keyword">let</span> rhs &#8592; toTerm alt.rhs
4554       <span class="keyword">let</span> termAlt <span class="constant">:=</span> mkNode `Lean.Parser.Term.matchAlt <span class="constant">#</span>[mkAtomFrom alt.ref <span class="string">"|"</span>, alt.patterns, mkAtomFrom alt.ref <span class="string">"=&gt;"</span>, rhs]
4555       termAlts <span class="constant">:=</span> termAlts.push termAlt
4556     <span class="keyword">let</span> termMatchAlts <span class="constant">:=</span> mkNode `Lean.Parser.Term.matchAlts <span class="constant">#</span>[mkNullNode termAlts]
4557     pure <span class="constant">$</span> mkNode `Lean.Parser.Term.<span class="comment">&#171;</span>match<span class="comment">&#187;</span> <span class="constant">#</span>[mkAtomFrom ref <span class="string">"match"</span>, genParam, discrs, optType, mkAtomFrom ref <span class="string">"with"</span>, termMatchAlts]
4558 
<span class="keyword">4559 def</span> <span class="function-name">run</span> (code : Code) (m : Syntax) (uvars : Array Name <span class="constant">:=</span> <span class="constant">#</span>[]) (kind <span class="constant">:=</span> Kind.regular) : MacroM Syntax <span class="constant">:=</span> <span class="keyword">do</span>
4560   <span class="keyword">let</span> term &#8592; toTerm code { m <span class="constant">:=</span> m, kind <span class="constant">:=</span> kind, uvars <span class="constant">:=</span> uvars }
4561   pure term
4562 
<span class="comment-delimiter">4563 /- </span><span class="comment">Given
4564    - `a` is true if the code block has a `Code.action _` exit point
4565    - `r` is true if the code block has a `Code.return _ _` exit point
4566    - `bc` is true if the code block has a `Code.break _` or `Code.continue _` exit point
4567 
4568    generate Kind. See comment at the beginning of the `ToTerm` namespace. -/</span>
<span class="keyword">4569 def</span> <span class="function-name">mkNestedKind</span> (a r bc : Bool) : Kind <span class="constant">:=</span>
4570   <span class="keyword">match</span> a, r, bc <span class="keyword">with</span>
4571   | true,  false, false <span class="constant">=&gt;</span> Kind.regular
4572   | false, true,  false <span class="constant">=&gt;</span> Kind.regular
4573   | false, false, true  <span class="constant">=&gt;</span> Kind.nestedBC
4574   | true,  true,  false <span class="constant">=&gt;</span> Kind.nestedPR
4575   | true,  false, true  <span class="constant">=&gt;</span> Kind.nestedSBC
4576   | false, true,  true  <span class="constant">=&gt;</span> Kind.nestedSBC
4577   | true,  true,  true  <span class="constant">=&gt;</span> Kind.nestedPRBC
4578   | false, false, false <span class="constant">=&gt;</span> <span class="warning">unreachable</span><span class="constant">!</span>
4579 
<span class="keyword">4580 def</span> <span class="function-name">mkNestedTerm</span> (code : Code) (m : Syntax) (uvars : Array Name) (a r bc : Bool) : MacroM Syntax <span class="constant">:=</span> <span class="keyword">do</span>
4581   ToTerm.run code m uvars (mkNestedKind a r bc)
4582 
<span class="comment-delimiter">4583 /- </span><span class="comment">Given a term `term` produced by `ToTerm.run`, pattern match on its result.
4584    See comment at the beginning of the `ToTerm` namespace.
4585 
4586    - `a` is true if the code block has a `Code.action _` exit point
4587    - `r` is true if the code block has a `Code.return _ _` exit point
4588    - `bc` is true if the code block has a `Code.break _` or `Code.continue _` exit point
4589 
4590    The result is a sequence of `doElem` -/</span>
<span class="keyword">4591 def</span> <span class="function-name">matchNestedTermResult</span> (term : Syntax) (uvars : Array Name) (a r bc : Bool) : MacroM (List Syntax) <span class="constant">:=</span> <span class="keyword">do</span>
4592   <span class="keyword">let</span> toDoElems (auxDo : Syntax) : List Syntax <span class="constant">:=</span> getDoSeqElems (getDoSeq auxDo)
4593   <span class="keyword">let</span> u &#8592; mkTuple (&#8592; uvars.mapM mkIdentFromRef)
4594   <span class="keyword">match</span> a, r, bc <span class="keyword">with</span>
4595   | true, false, false <span class="constant">=&gt;</span>
4596     <span class="keyword">if</span> uvars.isEmpty <span class="keyword">then</span>
4597       toDoElems (&#8592; `(<span class="keyword">do</span> <span class="constant">$</span>term:term))
4598     <span class="keyword">else</span>
4599       toDoElems (&#8592; `(<span class="keyword">do</span> <span class="keyword">let</span> r &#8592; <span class="constant">$</span>term:term; <span class="constant">$</span>u:term <span class="constant">:=</span> r.<span class="constant">2</span>; pure r.<span class="constant">1</span>))
4600   | false, true, false <span class="constant">=&gt;</span>
4601     <span class="keyword">if</span> uvars.isEmpty <span class="keyword">then</span>
4602       toDoElems (&#8592; `(<span class="keyword">do</span> <span class="keyword">let</span> r &#8592; <span class="constant">$</span>term:term; <span class="keyword">return</span> r))
4603     <span class="keyword">else</span>
4604       toDoElems (&#8592; `(<span class="keyword">do</span> <span class="keyword">let</span> r &#8592; <span class="constant">$</span>term:term; <span class="constant">$</span>u:term <span class="constant">:=</span> r.<span class="constant">2</span>; <span class="keyword">return</span> r.<span class="constant">1</span>))
4605   | false, false, true <span class="constant">=&gt;</span> toDoElems <span class="constant">&lt;$&gt;</span>
4606     `(<span class="keyword">do</span> <span class="keyword">let</span> r &#8592; <span class="constant">$</span>term:term;
4607          <span class="keyword">match</span> r <span class="keyword">with</span>
4608          | DoResultBC.<span class="comment">&#171;</span>break<span class="comment">&#187;</span> u <span class="constant">=&gt;</span> <span class="constant">$</span>u:term <span class="constant">:=</span> u; <span class="keyword">break</span>
4609          | DoResultBC.<span class="comment">&#171;</span>continue<span class="comment">&#187;</span> u <span class="constant">=&gt;</span> <span class="constant">$</span>u:term <span class="constant">:=</span> u; <span class="keyword">continue</span>)
4610   | true, true, false <span class="constant">=&gt;</span> toDoElems <span class="constant">&lt;$&gt;</span>
4611     `(<span class="keyword">do</span> <span class="keyword">let</span> r &#8592; <span class="constant">$</span>term:term;
4612          <span class="keyword">match</span> r <span class="keyword">with</span>
4613          | DoResultPR.<span class="comment">&#171;</span>pure<span class="comment">&#187;</span> a u <span class="constant">=&gt;</span> <span class="constant">$</span>u:term <span class="constant">:=</span> u; pure a
4614          | DoResultPR.<span class="comment">&#171;</span>return<span class="comment">&#187;</span> b u <span class="constant">=&gt;</span> <span class="constant">$</span>u:term <span class="constant">:=</span> u; <span class="keyword">return</span> b)
4615   | true, false, true <span class="constant">=&gt;</span> toDoElems <span class="constant">&lt;$&gt;</span>
4616     `(<span class="keyword">do</span> <span class="keyword">let</span> r &#8592; <span class="constant">$</span>term:term;
4617          <span class="keyword">match</span> r <span class="keyword">with</span>
4618          | DoResultSBC.<span class="comment">&#171;</span>pureReturn<span class="comment">&#187;</span> a u <span class="constant">=&gt;</span> <span class="constant">$</span>u:term <span class="constant">:=</span> u; pure a
4619          | DoResultSBC.<span class="comment">&#171;</span>break<span class="comment">&#187;</span> u <span class="constant">=&gt;</span> <span class="constant">$</span>u:term <span class="constant">:=</span> u; <span class="keyword">break</span>
4620          | DoResultSBC.<span class="comment">&#171;</span>continue<span class="comment">&#187;</span> u <span class="constant">=&gt;</span> <span class="constant">$</span>u:term <span class="constant">:=</span> u; <span class="keyword">continue</span>)
4621   | false, true, true <span class="constant">=&gt;</span> toDoElems <span class="constant">&lt;$&gt;</span>
4622     `(<span class="keyword">do</span> <span class="keyword">let</span> r &#8592; <span class="constant">$</span>term:term;
4623          <span class="keyword">match</span> r <span class="keyword">with</span>
4624          | DoResultSBC.<span class="comment">&#171;</span>pureReturn<span class="comment">&#187;</span> a u <span class="constant">=&gt;</span> <span class="constant">$</span>u:term <span class="constant">:=</span> u; <span class="keyword">return</span> a
4625          | DoResultSBC.<span class="comment">&#171;</span>break<span class="comment">&#187;</span> u <span class="constant">=&gt;</span> <span class="constant">$</span>u:term <span class="constant">:=</span> u; <span class="keyword">break</span>
4626          | DoResultSBC.<span class="comment">&#171;</span>continue<span class="comment">&#187;</span> u <span class="constant">=&gt;</span> <span class="constant">$</span>u:term <span class="constant">:=</span> u; <span class="keyword">continue</span>)
4627   | true, true, true <span class="constant">=&gt;</span> toDoElems <span class="constant">&lt;$&gt;</span>
4628     `(<span class="keyword">do</span> <span class="keyword">let</span> r &#8592; <span class="constant">$</span>term:term;
4629          <span class="keyword">match</span> r <span class="keyword">with</span>
4630          | DoResultPRBC.<span class="comment">&#171;</span>pure<span class="comment">&#187;</span> a u <span class="constant">=&gt;</span> <span class="constant">$</span>u:term <span class="constant">:=</span> u; pure a
4631          | DoResultPRBC.<span class="comment">&#171;</span>return<span class="comment">&#187;</span> a u <span class="constant">=&gt;</span> <span class="constant">$</span>u:term <span class="constant">:=</span> u; <span class="keyword">return</span> a
4632          | DoResultPRBC.<span class="comment">&#171;</span>break<span class="comment">&#187;</span> u <span class="constant">=&gt;</span> <span class="constant">$</span>u:term <span class="constant">:=</span> u; <span class="keyword">break</span>
4633          | DoResultPRBC.<span class="comment">&#171;</span>continue<span class="comment">&#187;</span> u <span class="constant">=&gt;</span> <span class="constant">$</span>u:term <span class="constant">:=</span> u; <span class="keyword">continue</span>)
4634   | false, false, false <span class="constant">=&gt;</span> <span class="warning">unreachable</span><span class="constant">!</span>
4635 
<span class="keyword">4636 end</span> ToTerm
4637 
<span class="keyword">4638 def</span> <span class="function-name">isMutableLet</span> (doElem : Syntax) : Bool <span class="constant">:=</span>
4639   <span class="keyword">let</span> kind <span class="constant">:=</span> doElem.getKind
4640   (kind <span class="constant">==</span> `Lean.Parser.Term.doLetArrow <span class="constant">||</span> kind <span class="constant">==</span> `Lean.Parser.Term.doLet)
4641   <span class="constant">&amp;&amp;</span>
4642   <span class="constant">!</span>doElem[<span class="constant">1</span>].isNone
4643 
<span class="keyword">4644 namespace</span> ToCodeBlock
4645 
<span class="keyword">4646 structure</span> <span class="function-name">Context</span> <span class="keyword">where</span>
4647   ref         : Syntax
4648   m           : Syntax <span class="comment-delimiter">-- </span><span class="comment">Syntax representing the monad associated with the do notation.
</span>4649   mutableVars : NameSet <span class="constant">:=</span> {}
4650   insideFor   : Bool <span class="constant">:=</span> false
4651 
<span class="keyword">4652 abbrev</span> M <span class="constant">:=</span> ReaderT Context TermElabM
4653 
<span class="doc">4654 @[inline]</span> <span class="keyword">def</span> <span class="function-name">withNewMutableVars</span> {&#945;} (newVars : Array Name) (mutable : Bool) (x : M &#945;) : M &#945; <span class="constant">:=</span>
4655   withReader (<span class="keyword">fun</span> ctx <span class="constant">=&gt;</span> <span class="keyword">if</span> mutable <span class="keyword">then</span> { ctx <span class="keyword">with</span> mutableVars <span class="constant">:=</span> insertVars ctx.mutableVars newVars } <span class="keyword">else</span> ctx) x
4656 
<span class="keyword">4657 def</span> <span class="function-name">checkReassignable</span> (xs : Array Name) : M Unit <span class="constant">:=</span> <span class="keyword">do</span>
4658   <span class="keyword">let</span> throwInvalidReassignment (x : Name) : M Unit <span class="constant">:=</span>
4659     throwError <span class="string">"'{x.simpMacroScopes}' cannot be reassigned"</span>
4660   <span class="keyword">let</span> ctx &#8592; read
4661   <span class="keyword">for</span> x <span class="keyword">in</span> xs <span class="keyword">do</span>
4662     <span class="keyword">unless</span> ctx.mutableVars.contains x <span class="keyword">do</span>
4663       throwInvalidReassignment x
4664 
<span class="doc">4665 @[inline]</span> <span class="keyword">def</span> <span class="function-name">withFor</span> {&#945;} (x : M &#945;) : M &#945; <span class="constant">:=</span>
4666   withReader (<span class="keyword">fun</span> ctx <span class="constant">=&gt;</span> { ctx <span class="keyword">with</span> insideFor <span class="constant">:=</span> true }) x
4667 
<span class="keyword">4668 structure</span> <span class="function-name">ToForInTermResult</span> <span class="keyword">where</span>
4669   uvars      : Array Name
4670   term       : Syntax
4671 
<span class="keyword">4672 def</span> <span class="function-name">mkForInBody</span>  (x : Syntax) (forInBody : CodeBlock) : M ToForInTermResult <span class="constant">:=</span> <span class="keyword">do</span>
4673   <span class="keyword">let</span> ctx &#8592; read
4674   <span class="keyword">let</span> uvars <span class="constant">:=</span> forInBody.uvars
4675   <span class="keyword">let</span> uvars <span class="constant">:=</span> nameSetToArray uvars
4676   <span class="keyword">let</span> term &#8592; liftMacroM <span class="constant">$</span> ToTerm.run forInBody.code ctx.m uvars (<span class="keyword">if</span> hasReturn forInBody.code <span class="keyword">then</span> ToTerm.Kind.forInWithReturn <span class="keyword">else</span> ToTerm.Kind.forIn)
4677   pure &#10216;uvars, term&#10217;
4678 
<span class="keyword">4679 def</span> <span class="function-name">ensureInsideFor</span> : M Unit <span class="constant">:=</span>
4680   <span class="keyword">unless</span> (&#8592; read).insideFor <span class="keyword">do</span>
4681     throwError <span class="string">"invalid 'do' element, it must be inside 'for'"</span>
4682 
<span class="keyword">4683 def</span> <span class="function-name">ensureEOS</span> (doElems : List Syntax) : M Unit <span class="constant">:=</span>
4684   <span class="keyword">unless</span> doElems.isEmpty <span class="keyword">do</span>
4685     throwError <span class="string">"must be last element in a 'do' sequence"</span>
4686 
<span class="keyword">4687 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">expandLiftMethodAux</span> (inQuot : Bool) (inBinder : Bool) : Syntax <span class="constant">&#8594;</span> StateT (List Syntax) MacroM Syntax
4688   | stx<span class="constant">@</span>(Syntax.node k args) <span class="constant">=&gt;</span>
4689     <span class="keyword">if</span> liftMethodDelimiter k <span class="keyword">then</span>
4690       <span class="keyword">return</span> stx
4691     <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> `Lean.Parser.Term.liftMethod <span class="constant">&amp;&amp;</span> <span class="constant">!</span>inQuot <span class="keyword">then</span> withFreshMacroScope <span class="keyword">do</span>
4692       <span class="keyword">if</span> inBinder <span class="keyword">then</span>
4693         Macro.throwErrorAt stx <span class="string">"cannot lift `(&lt;- ...)` over a binder, this error usually happens when you are trying to lift a method nested in a `fun` or `match`-alternative, and it can often be fixed by adding a missing `do`"</span>
4694       <span class="keyword">let</span> term <span class="constant">:=</span> args[<span class="constant">1</span>]
4695       <span class="keyword">let</span> term &#8592; expandLiftMethodAux inQuot inBinder term
4696       <span class="keyword">let</span> auxDoElem &#8592; `(doElem| <span class="keyword">let</span> a &#8592; <span class="constant">$</span>term:term)
4697       modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> s <span class="constant">++</span> [auxDoElem]
4698       `(a)
4699     <span class="keyword">else</span> <span class="keyword">do</span>
4700       <span class="keyword">let</span> inAntiquot <span class="constant">:=</span> stx.isAntiquot <span class="constant">&amp;&amp;</span> <span class="constant">!</span>stx.isEscapedAntiquot
4701       <span class="keyword">let</span> inBinder   <span class="constant">:=</span> inBinder <span class="constant">||</span> (<span class="constant">!</span>inQuot <span class="constant">&amp;&amp;</span> liftMethodForbiddenBinder k)
4702       <span class="keyword">let</span> args &#8592; args.mapM (expandLiftMethodAux (inQuot <span class="constant">&amp;&amp;</span> <span class="constant">!</span>inAntiquot <span class="constant">||</span> stx.isQuot) inBinder)
4703       <span class="keyword">return</span> Syntax.node k args
4704   | stx <span class="constant">=&gt;</span> pure stx
4705 
<span class="keyword">4706 def</span> <span class="function-name">expandLiftMethod</span> (doElem : Syntax) : MacroM (List Syntax <span class="constant">&#215;</span> Syntax) <span class="constant">:=</span> <span class="keyword">do</span>
4707   <span class="keyword">if</span> <span class="constant">!</span>hasLiftMethod doElem <span class="keyword">then</span>
4708     pure ([], doElem)
4709   <span class="keyword">else</span>
4710     <span class="keyword">let</span> (doElem, doElemsNew) &#8592; (expandLiftMethodAux false false doElem).run []
4711     pure (doElemsNew, doElem)
4712 
<span class="keyword">4713 def</span> <span class="function-name">checkLetArrowRHS</span> (doElem : Syntax) : M Unit <span class="constant">:=</span> <span class="keyword">do</span>
4714   <span class="keyword">let</span> kind <span class="constant">:=</span> doElem.getKind
4715   <span class="keyword">if</span> kind <span class="constant">==</span> `Lean.Parser.Term.doLetArrow <span class="constant">||</span>
4716      kind <span class="constant">==</span> `Lean.Parser.Term.doLet <span class="constant">||</span>
4717      kind <span class="constant">==</span> `Lean.Parser.Term.doLetRec <span class="constant">||</span>
4718      kind <span class="constant">==</span> `Lean.Parser.Term.doHave <span class="constant">||</span>
4719      kind <span class="constant">==</span> `Lean.Parser.Term.doReassign <span class="constant">||</span>
4720      kind <span class="constant">==</span> `Lean.Parser.Term.doReassignArrow <span class="keyword">then</span>
4721     throwErrorAt doElem <span class="string">"invalid kind of value '{kind}' in an assignment"</span>
4722 
<span class="comment-delimiter">4723 /- </span><span class="comment">Generate `CodeBlock` for `doReturn` which is of the form
4724    ```
4725    "return " &gt;&gt; optional termParser
4726    ```
4727    `doElems` is only used for sanity checking. -/</span>
<span class="keyword">4728 def</span> <span class="function-name">doReturnToCode</span> (doReturn : Syntax) (doElems: List Syntax) : M CodeBlock <span class="constant">:=</span> withRef doReturn <span class="keyword">do</span>
4729   ensureEOS doElems
4730   <span class="keyword">let</span> argOpt <span class="constant">:=</span> doReturn[<span class="constant">1</span>]
4731   <span class="keyword">let</span> arg &#8592; <span class="keyword">if</span> argOpt.isNone <span class="keyword">then</span> liftMacroM mkUnit <span class="keyword">else</span> pure argOpt[<span class="constant">0</span>]
4732   <span class="keyword">return</span> mkReturn (&#8592; getRef) arg
4733 
<span class="keyword">4734 structure</span> <span class="function-name">Catch</span> <span class="keyword">where</span>
4735   x         : Syntax
4736   optType   : Syntax
4737   codeBlock : CodeBlock
4738 
<span class="keyword">4739 def</span> <span class="function-name">getTryCatchUpdatedVars</span> (tryCode : CodeBlock) (catches : Array Catch) (finallyCode? : Option CodeBlock) : NameSet <span class="constant">:=</span>
4740   <span class="keyword">let</span> ws <span class="constant">:=</span> tryCode.uvars
4741   <span class="keyword">let</span> ws <span class="constant">:=</span> catches.foldl (<span class="keyword">fun</span> ws alt <span class="constant">=&gt;</span> union alt.codeBlock.uvars ws) ws
4742   <span class="keyword">let</span> ws <span class="constant">:=</span> <span class="keyword">match</span> finallyCode? <span class="keyword">with</span>
4743     | none   <span class="constant">=&gt;</span> ws
4744     | some c <span class="constant">=&gt;</span> union c.uvars ws
4745   ws
4746 
<span class="keyword">4747 def</span> <span class="function-name">tryCatchPred</span> (tryCode : CodeBlock) (catches : Array Catch) (finallyCode? : Option CodeBlock) (p : Code <span class="constant">&#8594;</span> Bool) : Bool <span class="constant">:=</span>
4748   p tryCode.code <span class="constant">||</span>
4749   catches.any (<span class="keyword">fun</span> <span class="comment">&#171;</span>catch<span class="comment">&#187;</span> <span class="constant">=&gt;</span> p <span class="comment">&#171;</span>catch<span class="comment">&#187;</span>.codeBlock.code) <span class="constant">||</span>
4750   <span class="keyword">match</span> finallyCode? <span class="keyword">with</span>
4751   | none <span class="constant">=&gt;</span> false
4752   | some finallyCode <span class="constant">=&gt;</span> p finallyCode.code
4753 
<span class="keyword">4754 mutual</span>
4755   <span class="comment-delimiter">/- </span><span class="comment">"Concatenate" `c` with `doSeqToCode doElems` -/</span>
4756   <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">concatWith</span> (c : CodeBlock) (doElems : List Syntax) : M CodeBlock <span class="constant">:=</span>
4757     <span class="keyword">match</span> doElems <span class="keyword">with</span>
4758     | [] <span class="constant">=&gt;</span> pure c
4759     | nextDoElem :: <span class="preprocessor">_</span>  <span class="constant">=&gt;</span> <span class="keyword">do</span>
4760       <span class="keyword">let</span> k &#8592; doSeqToCode doElems
4761       <span class="keyword">let</span> ref <span class="constant">:=</span> nextDoElem
4762       concat c ref none k
4763 
4764   <span class="comment-delimiter">/- </span><span class="comment">Generate `CodeBlock` for `doLetArrow; doElems`
4765      `doLetArrow` is of the form
4766      ```
4767      "let " &gt;&gt; optional "mut " &gt;&gt; (doIdDecl &lt;|&gt; doPatDecl)
4768      ```
4769      where
4770      ```
4771      def doIdDecl   := leading_parser ident &gt;&gt; optType &gt;&gt; leftArrow &gt;&gt; doElemParser
4772      def doPatDecl  := leading_parser termParser &gt;&gt; leftArrow &gt;&gt; doElemParser &gt;&gt; optional (" | " &gt;&gt; doElemParser)
4773      ```
4774   -/</span>
4775   <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">doLetArrowToCode</span> (doLetArrow : Syntax) (doElems : List Syntax) : M CodeBlock <span class="constant">:=</span> <span class="keyword">do</span>
4776     <span class="keyword">let</span> ref     <span class="constant">:=</span> doLetArrow
4777     <span class="keyword">let</span> decl    <span class="constant">:=</span> doLetArrow[<span class="constant">2</span>]
4778     <span class="keyword">if</span> decl.getKind <span class="constant">==</span> `Lean.Parser.Term.doIdDecl <span class="keyword">then</span>
4779       <span class="keyword">let</span> y <span class="constant">:=</span> decl[<span class="constant">0</span>].getId
4780       <span class="keyword">let</span> doElem <span class="constant">:=</span> decl[<span class="constant">3</span>]
4781       <span class="keyword">let</span> k &#8592; withNewMutableVars <span class="constant">#</span>[y] (isMutableLet doLetArrow) (doSeqToCode doElems)
4782       <span class="keyword">match</span> isDoExpr? doElem <span class="keyword">with</span>
4783       | some action <span class="constant">=&gt;</span> pure <span class="constant">$</span> mkVarDeclCore <span class="constant">#</span>[y] doLetArrow k
4784       | none <span class="constant">=&gt;</span>
4785         checkLetArrowRHS doElem
4786         <span class="keyword">let</span> c &#8592; doSeqToCode [doElem]
4787         <span class="keyword">match</span> doElems <span class="keyword">with</span>
4788         | []       <span class="constant">=&gt;</span> pure c
4789         | kRef::<span class="preprocessor">_</span>  <span class="constant">=&gt;</span> concat c kRef y k
4790     <span class="keyword">else</span> <span class="keyword">if</span> decl.getKind <span class="constant">==</span> `Lean.Parser.Term.doPatDecl <span class="keyword">then</span>
4791       <span class="keyword">let</span> pattern <span class="constant">:=</span> decl[<span class="constant">0</span>]
4792       <span class="keyword">let</span> doElem  <span class="constant">:=</span> decl[<span class="constant">2</span>]
4793       <span class="keyword">let</span> optElse <span class="constant">:=</span> decl[<span class="constant">3</span>]
4794       <span class="keyword">if</span> optElse.isNone <span class="keyword">then</span> withFreshMacroScope <span class="keyword">do</span>
4795         <span class="keyword">let</span> auxDo &#8592;
4796           <span class="keyword">if</span> isMutableLet doLetArrow <span class="keyword">then</span>
4797             `(<span class="keyword">do</span> <span class="keyword">let</span> discr &#8592; <span class="constant">$</span>doElem; <span class="keyword">let</span> <span class="keyword">mut</span> <span class="constant">$</span>pattern:term <span class="constant">:=</span> discr)
4798           <span class="keyword">else</span>
4799             `(<span class="keyword">do</span> <span class="keyword">let</span> discr &#8592; <span class="constant">$</span>doElem; <span class="keyword">let</span> <span class="constant">$</span>pattern:term <span class="constant">:=</span> discr)
4800         doSeqToCode <span class="constant">&lt;</span>| getDoSeqElems (getDoSeq auxDo) <span class="constant">++</span> doElems
4801       <span class="keyword">else</span>
4802         <span class="keyword">if</span> isMutableLet doLetArrow <span class="keyword">then</span>
4803           throwError <span class="string">"'mut' is currently not supported in let-decls with 'else' case"</span>
4804         <span class="keyword">let</span> contSeq <span class="constant">:=</span> mkDoSeq doElems.toArray
4805         <span class="keyword">let</span> elseSeq <span class="constant">:=</span> mkSingletonDoSeq optElse[<span class="constant">1</span>]
4806         <span class="keyword">let</span> auxDo &#8592; `(<span class="keyword">do</span> <span class="keyword">let</span> discr &#8592; <span class="constant">$</span>doElem; <span class="keyword">match</span> discr <span class="keyword">with</span> | <span class="constant">$</span>pattern:term <span class="constant">=&gt;</span> <span class="constant">$</span>contSeq | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="constant">$</span>elseSeq)
4807         doSeqToCode <span class="constant">&lt;</span>| getDoSeqElems (getDoSeq auxDo)
4808     <span class="keyword">else</span>
4809       throwError <span class="string">"unexpected kind of 'do' declaration"</span>
4810 
4811 
4812   <span class="comment-delimiter">/- </span><span class="comment">Generate `CodeBlock` for `doReassignArrow; doElems`
4813      `doReassignArrow` is of the form
4814      ```
4815      (doIdDecl &lt;|&gt; doPatDecl)
4816      ```
4817   -/</span>
4818   <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">doReassignArrowToCode</span> (doReassignArrow : Syntax) (doElems : List Syntax) : M CodeBlock <span class="constant">:=</span> <span class="keyword">do</span>
4819     <span class="keyword">let</span> ref  <span class="constant">:=</span> doReassignArrow
4820     <span class="keyword">let</span> decl <span class="constant">:=</span> doReassignArrow[<span class="constant">0</span>]
4821     <span class="keyword">if</span> decl.getKind <span class="constant">==</span> `Lean.Parser.Term.doIdDecl <span class="keyword">then</span>
4822       <span class="keyword">let</span> doElem <span class="constant">:=</span> decl[<span class="constant">3</span>]
4823       <span class="keyword">let</span> y      <span class="constant">:=</span> decl[<span class="constant">0</span>]
4824       <span class="keyword">let</span> auxDo &#8592; `(<span class="keyword">do</span> <span class="keyword">let</span> r &#8592; <span class="constant">$</span>doElem; <span class="constant">$</span>y:ident <span class="constant">:=</span> r)
4825       doSeqToCode <span class="constant">&lt;</span>| getDoSeqElems (getDoSeq auxDo) <span class="constant">++</span> doElems
4826     <span class="keyword">else</span> <span class="keyword">if</span> decl.getKind <span class="constant">==</span> `Lean.Parser.Term.doPatDecl <span class="keyword">then</span>
4827       <span class="keyword">let</span> pattern <span class="constant">:=</span> decl[<span class="constant">0</span>]
4828       <span class="keyword">let</span> doElem  <span class="constant">:=</span> decl[<span class="constant">2</span>]
4829       <span class="keyword">let</span> optElse <span class="constant">:=</span> decl[<span class="constant">3</span>]
4830       <span class="keyword">if</span> optElse.isNone <span class="keyword">then</span> withFreshMacroScope <span class="keyword">do</span>
4831         <span class="keyword">let</span> auxDo &#8592; `(<span class="keyword">do</span> <span class="keyword">let</span> discr &#8592; <span class="constant">$</span>doElem; <span class="constant">$</span>pattern:term <span class="constant">:=</span> discr)
4832         doSeqToCode <span class="constant">&lt;</span>| getDoSeqElems (getDoSeq auxDo) <span class="constant">++</span> doElems
4833       <span class="keyword">else</span>
4834         throwError <span class="string">"reassignment with `|` (i.e., \"else clause\") is not currently supported"</span>
4835     <span class="keyword">else</span>
4836       throwError <span class="string">"unexpected kind of 'do' reassignment"</span>
4837 
4838   <span class="comment-delimiter">/- </span><span class="comment">Generate `CodeBlock` for `doIf; doElems`
4839      `doIf` is of the form
4840      ```
4841      "if " &gt;&gt; optIdent &gt;&gt; termParser &gt;&gt; " then " &gt;&gt; doSeq
4842       &gt;&gt; many (group (try (group (" else " &gt;&gt; " if ")) &gt;&gt; optIdent &gt;&gt; termParser &gt;&gt; " then " &gt;&gt; doSeq))
4843       &gt;&gt; optional (" else " &gt;&gt; doSeq)
4844      ```  -/</span>
4845   <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">doIfToCode</span> (doIf : Syntax) (doElems : List Syntax) : M CodeBlock <span class="constant">:=</span> <span class="keyword">do</span>
4846     <span class="keyword">let</span> view &#8592; liftMacroM <span class="constant">$</span> mkDoIfView doIf
4847     <span class="keyword">let</span> thenBranch &#8592; doSeqToCode (getDoSeqElems view.thenBranch)
4848     <span class="keyword">let</span> elseBranch &#8592; doSeqToCode (getDoSeqElems view.elseBranch)
4849     <span class="keyword">let</span> ite &#8592; mkIte view.ref view.optIdent view.cond thenBranch elseBranch
4850     concatWith ite doElems
4851 
4852   <span class="comment-delimiter">/- </span><span class="comment">Generate `CodeBlock` for `doUnless; doElems`
4853      `doUnless` is of the form
4854      ```
4855      "unless " &gt;&gt; termParser &gt;&gt; "do " &gt;&gt; doSeq
4856      ```  -/</span>
4857   <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">doUnlessToCode</span> (doUnless : Syntax) (doElems : List Syntax) : M CodeBlock <span class="constant">:=</span> withRef doUnless <span class="keyword">do</span>
4858     <span class="keyword">let</span> ref   <span class="constant">:=</span> doUnless
4859     <span class="keyword">let</span> cond  <span class="constant">:=</span> doUnless[<span class="constant">1</span>]
4860     <span class="keyword">let</span> doSeq <span class="constant">:=</span> doUnless[<span class="constant">3</span>]
4861     <span class="keyword">let</span> body &#8592; doSeqToCode (getDoSeqElems doSeq)
4862     <span class="keyword">let</span> unlessCode &#8592; liftMacroM <span class="constant">&lt;</span>| mkUnless cond body
4863     concatWith unlessCode doElems
4864 
4865   <span class="comment-delimiter">/- </span><span class="comment">Generate `CodeBlock` for `doFor; doElems`
4866      `doFor` is of the form
4867      ```
4868      def doForDecl := leading_parser termParser &gt;&gt; " in " &gt;&gt; withForbidden "do" termParser
4869      def doFor := leading_parser "for " &gt;&gt; sepBy1 doForDecl ", " &gt;&gt; "do " &gt;&gt; doSeq
4870      ```
4871   -/</span>
4872   <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">doForToCode</span> (doFor : Syntax) (doElems : List Syntax) : M CodeBlock <span class="constant">:=</span> <span class="keyword">do</span>
4873     <span class="keyword">let</span> doForDecls <span class="constant">:=</span> doFor[<span class="constant">1</span>].getSepArgs
4874     <span class="keyword">if</span> doForDecls.size <span class="constant">&gt;</span> <span class="constant">1</span> <span class="keyword">then</span>
4875       <span class="comment-delimiter">/-</span><span class="comment">
4876         Expand
4877         ```
4878         for x in xs, y in ys do
4879           body
4880         ```
4881         into
4882         ```
4883         let s := toStream ys
4884         for x in xs do
4885           match Stream.next? s with
4886           | none =&gt; break
4887           | some (y, s') =&gt;
4888             s := s'
4889             body
4890         ```
4891       -/</span>
4892       <span class="comment-delimiter">-- </span><span class="comment">Extract second element
</span>4893       <span class="keyword">let</span> doForDecl <span class="constant">:=</span> doForDecls[<span class="constant">1</span>]
4894       <span class="keyword">let</span> y  <span class="constant">:=</span> doForDecl[<span class="constant">0</span>]
4895       <span class="keyword">let</span> ys <span class="constant">:=</span> doForDecl[<span class="constant">2</span>]
4896       <span class="keyword">let</span> doForDecls <span class="constant">:=</span> doForDecls.eraseIdx <span class="constant">1</span>
4897       <span class="keyword">let</span> body <span class="constant">:=</span> doFor[<span class="constant">3</span>]
4898       withFreshMacroScope <span class="keyword">do</span>
4899         <span class="keyword">let</span> toStreamFn &#8592; withRef ys `(toStream)
4900         <span class="keyword">let</span> auxDo &#8592;
4901           `(<span class="keyword">do</span> <span class="keyword">let</span> <span class="keyword">mut</span> s <span class="constant">:=</span> <span class="constant">$</span>toStreamFn:ident <span class="constant">$</span>ys
4902                <span class="keyword">for</span> <span class="constant">$</span>doForDecls:doForDecl,<span class="constant">*</span> <span class="keyword">do</span>
4903                  <span class="keyword">match</span> Stream.next? s <span class="keyword">with</span>
4904                  | none <span class="constant">=&gt;</span> <span class="keyword">break</span>
4905                  | some (<span class="constant">$</span>y, s') <span class="constant">=&gt;</span>
4906                    s <span class="constant">:=</span> s'
4907                    <span class="keyword">do</span> <span class="constant">$</span>body)
4908         doSeqToCode (getDoSeqElems (getDoSeq auxDo) <span class="constant">++</span> doElems)
4909     <span class="keyword">else</span> withRef doFor <span class="keyword">do</span>
4910       <span class="keyword">let</span> x         <span class="constant">:=</span> doForDecls[<span class="constant">0</span>][<span class="constant">0</span>]
4911       <span class="keyword">let</span> xs        <span class="constant">:=</span> doForDecls[<span class="constant">0</span>][<span class="constant">2</span>]
4912       <span class="keyword">let</span> forElems  <span class="constant">:=</span> getDoSeqElems doFor[<span class="constant">3</span>]
4913       <span class="keyword">let</span> forInBodyCodeBlock &#8592; withFor (doSeqToCode forElems)
4914       <span class="keyword">let</span> &#10216;uvars, forInBody&#10217; &#8592; mkForInBody x forInBodyCodeBlock
4915       <span class="keyword">let</span> uvarsTuple &#8592; liftMacroM <span class="keyword">do</span> mkTuple (&#8592; uvars.mapM mkIdentFromRef)
4916       <span class="keyword">if</span> hasReturn forInBodyCodeBlock.code <span class="keyword">then</span>
4917         <span class="keyword">let</span> forInBody &#8592; liftMacroM <span class="constant">&lt;</span>| destructTuple uvars (&#8592; `(r)) forInBody
4918         <span class="keyword">let</span> forInTerm &#8592; `(forIn% <span class="constant">$</span>(xs) (MProd.mk none <span class="constant">$</span>uvarsTuple) <span class="keyword">fun</span> <span class="constant">$</span>x r <span class="constant">=&gt;</span> <span class="keyword">let</span> r <span class="constant">:=</span> r.<span class="constant">2</span>; <span class="constant">$</span>forInBody)
4919         <span class="keyword">let</span> auxDo &#8592; `(<span class="keyword">do</span> <span class="keyword">let</span> r &#8592; <span class="constant">$</span>forInTerm:term;
4920                          <span class="constant">$</span>uvarsTuple:term <span class="constant">:=</span> r.<span class="constant">2</span>;
4921                          <span class="keyword">match</span> r.<span class="constant">1</span> <span class="keyword">with</span>
4922                          | none <span class="constant">=&gt;</span> Pure.pure (ensureExpectedType% <span class="string">"type mismatch, 'for'"</span> PUnit.unit)
4923                          | some a <span class="constant">=&gt;</span> <span class="keyword">return</span> ensureExpectedType% <span class="string">"type mismatch, 'for'"</span> a)
4924         doSeqToCode (getDoSeqElems (getDoSeq auxDo) <span class="constant">++</span> doElems)
4925       <span class="keyword">else</span>
4926         <span class="keyword">let</span> forInBody &#8592; liftMacroM <span class="constant">&lt;</span>| destructTuple uvars (&#8592; `(r)) forInBody
4927         <span class="keyword">let</span> forInTerm &#8592; `(forIn% <span class="constant">$</span>(xs) <span class="constant">$</span>uvarsTuple <span class="keyword">fun</span> <span class="constant">$</span>x r <span class="constant">=&gt;</span> <span class="constant">$</span>forInBody)
4928         <span class="keyword">if</span> doElems.isEmpty <span class="keyword">then</span>
4929           <span class="keyword">let</span> auxDo &#8592; `(<span class="keyword">do</span> <span class="keyword">let</span> r &#8592; <span class="constant">$</span>forInTerm:term;
4930                            <span class="constant">$</span>uvarsTuple:term <span class="constant">:=</span> r;
4931                            Pure.pure (ensureExpectedType% <span class="string">"type mismatch, 'for'"</span> PUnit.unit))
4932           doSeqToCode <span class="constant">&lt;</span>| getDoSeqElems (getDoSeq auxDo)
4933         <span class="keyword">else</span>
4934           <span class="keyword">let</span> auxDo &#8592; `(<span class="keyword">do</span> <span class="keyword">let</span> r &#8592; <span class="constant">$</span>forInTerm:term; <span class="constant">$</span>uvarsTuple:term <span class="constant">:=</span> r)
4935           doSeqToCode <span class="constant">&lt;</span>| getDoSeqElems (getDoSeq auxDo) <span class="constant">++</span> doElems
4936 
4937   <span class="comment-delimiter">/-</span><span class="comment">- Generate `CodeBlock` for `doMatch; doElems` -/</span>
4938   <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">doMatchToCode</span> (doMatch : Syntax) (doElems: List Syntax) : M CodeBlock <span class="constant">:=</span> <span class="keyword">do</span>
4939     <span class="keyword">let</span> ref       <span class="constant">:=</span> doMatch
4940     <span class="keyword">let</span> genParam  <span class="constant">:=</span> doMatch[<span class="constant">1</span>]
4941     <span class="keyword">let</span> discrs    <span class="constant">:=</span> doMatch[<span class="constant">2</span>]
4942     <span class="keyword">let</span> optType   <span class="constant">:=</span> doMatch[<span class="constant">3</span>]
4943     <span class="keyword">let</span> matchAlts <span class="constant">:=</span> doMatch[<span class="constant">5</span>][<span class="constant">0</span>].getArgs <span class="comment-delimiter">-- </span><span class="comment">Array of `doMatchAlt`
</span>4944     <span class="keyword">let</span> alts &#8592;  matchAlts.mapM <span class="keyword">fun</span> matchAlt <span class="constant">=&gt;</span> <span class="keyword">do</span>
4945       <span class="keyword">let</span> patterns <span class="constant">:=</span> matchAlt[<span class="constant">1</span>]
4946       <span class="keyword">let</span> vars &#8592; getPatternsVarsEx patterns.getSepArgs
4947       <span class="keyword">let</span> rhs  <span class="constant">:=</span> matchAlt[<span class="constant">3</span>]
4948       <span class="keyword">let</span> rhs &#8592; doSeqToCode (getDoSeqElems rhs)
4949       pure { ref <span class="constant">:=</span> matchAlt, vars <span class="constant">:=</span> vars, patterns <span class="constant">:=</span> patterns, rhs <span class="constant">:=</span> rhs : Alt CodeBlock }
4950     <span class="keyword">let</span> matchCode &#8592; mkMatch ref genParam discrs optType alts
4951     concatWith matchCode doElems
4952 
4953   <span class="comment-delimiter">/-</span><span class="comment">-
4954     Generate `CodeBlock` for `doTry; doElems`
4955     ```
4956     def doTry := leading_parser "try " &gt;&gt; doSeq &gt;&gt; many (doCatch &lt;|&gt; doCatchMatch) &gt;&gt; optional doFinally
4957     def doCatch      := leading_parser "catch " &gt;&gt; binderIdent &gt;&gt; optional (":" &gt;&gt; termParser) &gt;&gt; darrow &gt;&gt; doSeq
4958     def doCatchMatch := leading_parser "catch " &gt;&gt; doMatchAlts
4959     def doFinally    := leading_parser "finally " &gt;&gt; doSeq
4960     ```
4961   -/</span>
4962   <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">doTryToCode</span> (doTry : Syntax) (doElems: List Syntax) : M CodeBlock <span class="constant">:=</span> <span class="keyword">do</span>
4963     <span class="keyword">let</span> ref <span class="constant">:=</span> doTry
4964     <span class="keyword">let</span> tryCode &#8592; doSeqToCode (getDoSeqElems doTry[<span class="constant">1</span>])
4965     <span class="keyword">let</span> optFinally <span class="constant">:=</span> doTry[<span class="constant">3</span>]
4966     <span class="keyword">let</span> catches &#8592; doTry[<span class="constant">2</span>].getArgs.mapM <span class="keyword">fun</span> catchStx <span class="constant">=&gt;</span> <span class="keyword">do</span>
4967       <span class="keyword">if</span> catchStx.getKind <span class="constant">==</span> `Lean.Parser.Term.doCatch <span class="keyword">then</span>
4968         <span class="keyword">let</span> x       <span class="constant">:=</span> catchStx[<span class="constant">1</span>]
4969         <span class="keyword">let</span> optType <span class="constant">:=</span> catchStx[<span class="constant">2</span>]
4970         <span class="keyword">let</span> c &#8592; doSeqToCode (getDoSeqElems catchStx[<span class="constant">4</span>])
4971         pure { x <span class="constant">:=</span> x, optType <span class="constant">:=</span> optType, codeBlock <span class="constant">:=</span> c : Catch }
4972       <span class="keyword">else</span> <span class="keyword">if</span> catchStx.getKind <span class="constant">==</span> `Lean.Parser.Term.doCatchMatch <span class="keyword">then</span>
4973         <span class="keyword">let</span> matchAlts <span class="constant">:=</span> catchStx[<span class="constant">1</span>]
4974         <span class="keyword">let</span> x &#8592; `(ex)
4975         <span class="keyword">let</span> auxDo &#8592; `(<span class="keyword">do</span> <span class="keyword">match</span> ex <span class="keyword">with</span> <span class="constant">$</span>matchAlts)
4976         <span class="keyword">let</span> c &#8592; doSeqToCode (getDoSeqElems (getDoSeq auxDo))
4977         pure { x <span class="constant">:=</span> x, codeBlock <span class="constant">:=</span> c, optType <span class="constant">:=</span> mkNullNode : Catch }
4978       <span class="keyword">else</span>
4979         throwError <span class="string">"unexpected kind of 'catch'"</span>
4980     <span class="keyword">let</span> finallyCode? &#8592; <span class="keyword">if</span> optFinally.isNone <span class="keyword">then</span> pure none <span class="keyword">else</span> some <span class="constant">&lt;$&gt;</span> doSeqToCode (getDoSeqElems optFinally[<span class="constant">0</span>][<span class="constant">1</span>])
4981     <span class="keyword">if</span> catches.isEmpty <span class="constant">&amp;&amp;</span> finallyCode?.isNone <span class="keyword">then</span>
4982       throwError <span class="string">"invalid 'try', it must have a 'catch' or 'finally'"</span>
4983     <span class="keyword">let</span> ctx &#8592; read
4984     <span class="keyword">let</span> ws    <span class="constant">:=</span> getTryCatchUpdatedVars tryCode catches finallyCode?
4985     <span class="keyword">let</span> uvars <span class="constant">:=</span> nameSetToArray ws
4986     <span class="keyword">let</span> a     <span class="constant">:=</span> tryCatchPred tryCode catches finallyCode? hasTerminalAction
4987     <span class="keyword">let</span> r     <span class="constant">:=</span> tryCatchPred tryCode catches finallyCode? hasReturn
4988     <span class="keyword">let</span> bc    <span class="constant">:=</span> tryCatchPred tryCode catches finallyCode? hasBreakContinue
4989     <span class="keyword">let</span> toTerm (codeBlock : CodeBlock) : M Syntax <span class="constant">:=</span> <span class="keyword">do</span>
4990       <span class="keyword">let</span> codeBlock &#8592; liftM <span class="constant">$</span> extendUpdatedVars codeBlock ws
4991       liftMacroM <span class="constant">$</span> ToTerm.mkNestedTerm codeBlock.code ctx.m uvars a r bc
4992     <span class="keyword">let</span> term &#8592; toTerm tryCode
4993     <span class="keyword">let</span> term &#8592; catches.foldlM
4994       (<span class="keyword">fun</span> term <span class="comment">&#171;</span>catch<span class="comment">&#187;</span> <span class="constant">=&gt;</span> <span class="keyword">do</span>
4995         <span class="keyword">let</span> catchTerm &#8592; toTerm <span class="comment">&#171;</span>catch<span class="comment">&#187;</span>.codeBlock
4996         <span class="keyword">if</span> <span class="keyword">catch</span>.optType.isNone <span class="keyword">then</span>
4997           `(MonadExcept.tryCatch <span class="constant">$</span>term (<span class="keyword">fun</span> <span class="constant">$</span>(<span class="comment">&#171;</span>catch<span class="comment">&#187;</span>.x):ident <span class="constant">=&gt;</span> <span class="constant">$</span>catchTerm))
4998         <span class="keyword">else</span>
4999           <span class="keyword">let</span> type <span class="constant">:=</span> <span class="comment">&#171;</span>catch<span class="comment">&#187;</span>.optType[<span class="constant">1</span>]
5000           `(tryCatchThe <span class="constant">$</span>type <span class="constant">$</span>term (<span class="keyword">fun</span> <span class="constant">$</span>(<span class="comment">&#171;</span>catch<span class="comment">&#187;</span>.x):ident <span class="constant">=&gt;</span> <span class="constant">$</span>catchTerm)))
5001       term
5002     <span class="keyword">let</span> term &#8592; <span class="keyword">match</span> finallyCode? <span class="keyword">with</span>
5003       | none             <span class="constant">=&gt;</span> pure term
5004       | some finallyCode <span class="constant">=&gt;</span> withRef optFinally <span class="keyword">do</span>
5005         <span class="keyword">unless</span> finallyCode.uvars.isEmpty <span class="keyword">do</span>
5006           throwError <span class="string">"'finally' currently does not support reassignments"</span>
5007         <span class="keyword">if</span> hasBreakContinueReturn finallyCode.code <span class="keyword">then</span>
5008           throwError <span class="string">"'finally' currently does 'return', 'break', nor 'continue'"</span>
5009         <span class="keyword">let</span> finallyTerm &#8592; liftMacroM <span class="constant">&lt;</span>| ToTerm.run finallyCode.code ctx.m {} ToTerm.Kind.regular
5010         `(tryFinally <span class="constant">$</span>term <span class="constant">$</span>finallyTerm)
5011     <span class="keyword">let</span> doElemsNew &#8592; liftMacroM <span class="constant">&lt;</span>| ToTerm.matchNestedTermResult term uvars a r bc
5012     doSeqToCode (doElemsNew <span class="constant">++</span> doElems)
5013 
5014   <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">doSeqToCode</span> : List Syntax <span class="constant">&#8594;</span> M CodeBlock
5015     | [] <span class="constant">=&gt;</span> <span class="keyword">do</span> liftMacroM mkPureUnitAction
5016     | doElem::doElems <span class="constant">=&gt;</span> withIncRecDepth <span class="constant">&lt;</span>| withRef doElem <span class="keyword">do</span>
5017       checkMaxHeartbeats <span class="string">"'do'-expander"</span>
5018       <span class="keyword">match</span> (&#8592; liftMacroM <span class="constant">&lt;</span>| expandMacro? doElem) <span class="keyword">with</span>
5019       | some doElem <span class="constant">=&gt;</span> doSeqToCode (doElem::doElems)
5020       | none <span class="constant">=&gt;</span>
5021       <span class="keyword">match</span> (&#8592; liftMacroM <span class="constant">&lt;</span>| expandDoIf? doElem) <span class="keyword">with</span>
5022       | some doElem <span class="constant">=&gt;</span> doSeqToCode (doElem::doElems)
5023       | none <span class="constant">=&gt;</span>
5024         <span class="keyword">let</span> (liftedDoElems, doElem) &#8592; liftM (liftMacroM <span class="constant">&lt;</span>| expandLiftMethod doElem : TermElabM <span class="preprocessor">_</span>)
5025         <span class="keyword">if</span> <span class="constant">!</span>liftedDoElems.isEmpty <span class="keyword">then</span>
5026           doSeqToCode (liftedDoElems <span class="constant">++</span> [doElem] <span class="constant">++</span> doElems)
5027         <span class="keyword">else</span>
5028           <span class="keyword">let</span> ref <span class="constant">:=</span> doElem
5029           <span class="keyword">let</span> concatWithRest (c : CodeBlock) : M CodeBlock <span class="constant">:=</span> concatWith c doElems
5030           <span class="keyword">let</span> k <span class="constant">:=</span> doElem.getKind
5031           <span class="keyword">if</span> k <span class="constant">==</span> `Lean.Parser.Term.doLet <span class="keyword">then</span>
5032             <span class="keyword">let</span> vars &#8592; getDoLetVars doElem
5033             mkVarDeclCore vars doElem <span class="constant">&lt;$&gt;</span> withNewMutableVars vars (isMutableLet doElem) (doSeqToCode doElems)
5034           <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> `Lean.Parser.Term.doHave <span class="keyword">then</span>
5035             <span class="keyword">let</span> var <span class="constant">:=</span> getDoHaveVar doElem
5036             mkVarDeclCore <span class="constant">#</span>[var] doElem <span class="constant">&lt;$&gt;</span> (doSeqToCode doElems)
5037           <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> `Lean.Parser.Term.doLetRec <span class="keyword">then</span>
5038             <span class="keyword">let</span> vars &#8592; getDoLetRecVars doElem
5039             mkVarDeclCore vars doElem <span class="constant">&lt;$&gt;</span> (doSeqToCode doElems)
5040           <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> `Lean.Parser.Term.doReassign <span class="keyword">then</span>
5041             <span class="keyword">let</span> vars &#8592; getDoReassignVars doElem
5042             checkReassignable vars
5043             <span class="keyword">let</span> k &#8592; doSeqToCode doElems
5044             mkReassignCore vars doElem k
5045           <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> `Lean.Parser.Term.doLetArrow <span class="keyword">then</span>
5046             doLetArrowToCode doElem doElems
5047           <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> `Lean.Parser.Term.doReassignArrow <span class="keyword">then</span>
5048             doReassignArrowToCode doElem doElems
5049           <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> `Lean.Parser.Term.doIf <span class="keyword">then</span>
5050             doIfToCode doElem doElems
5051           <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> `Lean.Parser.Term.doUnless <span class="keyword">then</span>
5052             doUnlessToCode doElem doElems
5053           <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> `Lean.Parser.Term.doFor <span class="keyword">then</span> withFreshMacroScope <span class="keyword">do</span>
5054             doForToCode doElem doElems
5055           <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> `Lean.Parser.Term.doMatch <span class="keyword">then</span>
5056             doMatchToCode doElem doElems
5057           <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> `Lean.Parser.Term.doTry <span class="keyword">then</span>
5058             doTryToCode doElem doElems
5059           <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> `Lean.Parser.Term.doBreak <span class="keyword">then</span>
5060             ensureInsideFor
5061             ensureEOS doElems
5062             <span class="keyword">return</span> mkBreak ref
5063           <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> `Lean.Parser.Term.doContinue <span class="keyword">then</span>
5064             ensureInsideFor
5065             ensureEOS doElems
5066             <span class="keyword">return</span> mkContinue ref
5067           <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> `Lean.Parser.Term.doReturn <span class="keyword">then</span>
5068             doReturnToCode doElem doElems
5069           <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> `Lean.Parser.Term.doDbgTrace <span class="keyword">then</span>
5070             <span class="keyword">return</span> mkSeq doElem (&#8592; doSeqToCode doElems)
5071           <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> `Lean.Parser.Term.doAssert <span class="keyword">then</span>
5072             <span class="keyword">return</span> mkSeq doElem (&#8592; doSeqToCode doElems)
5073           <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> `Lean.Parser.Term.doNested <span class="keyword">then</span>
5074             <span class="keyword">let</span> nestedDoSeq <span class="constant">:=</span> doElem[<span class="constant">1</span>]
5075             doSeqToCode (getDoSeqElems nestedDoSeq <span class="constant">++</span> doElems)
5076           <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> `Lean.Parser.Term.doExpr <span class="keyword">then</span>
5077             <span class="keyword">let</span> term <span class="constant">:=</span> doElem[<span class="constant">0</span>]
5078             <span class="keyword">if</span> doElems.isEmpty <span class="keyword">then</span>
5079               <span class="keyword">return</span> mkTerminalAction term
5080             <span class="keyword">else</span>
5081               <span class="keyword">return</span> mkSeq term (&#8592; doSeqToCode doElems)
5082           <span class="keyword">else</span>
5083             throwError <span class="string">"unexpected do-element\n{doElem}"</span>
<span class="keyword">5084 end</span>
5085 
<span class="keyword">5086 def</span> <span class="function-name">run</span> (doStx : Syntax) (m : Syntax) : TermElabM CodeBlock <span class="constant">:=</span>
5087   (doSeqToCode <span class="constant">&lt;</span>| getDoSeqElems <span class="constant">&lt;</span>| getDoSeq doStx).run { ref <span class="constant">:=</span> doStx, m <span class="constant">:=</span> m }
5088 
<span class="keyword">5089 end</span> ToCodeBlock
5090 
<span class="comment-delimiter">5091 /- </span><span class="comment">Create a synthetic metavariable `?m` and assign `m` to it.
5092    We use `?m` to refer to `m` when expanding the `do` notation. -/</span>
<span class="keyword">5093 private</span> <span class="keyword">def</span> <span class="function-name">mkMonadAlias</span> (m : Expr) : TermElabM Syntax <span class="constant">:=</span> <span class="keyword">do</span>
5094   <span class="keyword">let</span> result &#8592; `(?m)
5095   <span class="keyword">let</span> mType &#8592; inferType m
5096   <span class="keyword">let</span> mvar &#8592; elabTerm result mType
5097   assignExprMVar mvar.mvarId<span class="constant">!</span> m
5098   pure result
5099 
<span class="constant">5100 @</span>[builtinTermElab <span class="comment">&#171;</span>do<span class="comment">&#187;</span>]
<span class="keyword">5101 def</span> <span class="function-name">elabDo</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span> <span class="keyword">do</span>
5102   tryPostponeIfNoneOrMVar expectedType?
5103   <span class="keyword">let</span> bindInfo &#8592; extractBind expectedType?
5104   <span class="keyword">let</span> m &#8592; mkMonadAlias bindInfo.m
5105   <span class="keyword">let</span> codeBlock &#8592; ToCodeBlock.run stx m
5106   <span class="keyword">let</span> stxNew &#8592; liftMacroM <span class="constant">$</span> ToTerm.run codeBlock.code m
5107   trace[Elab.<span class="keyword">do</span>] stxNew
5108   withMacroExpansion stx stxNew <span class="constant">$</span> elabTermEnsuringType stxNew bindInfo.expectedType
5109 
<span class="keyword">5110 end</span> Do
5111 
<span class="keyword">5112 builtin_initialize</span> registerTraceClass `Elab.<span class="keyword">do</span>
5113 
<span class="keyword">5114 private</span> <span class="keyword">def</span> <span class="function-name">toDoElem</span> (newKind : SyntaxNodeKind) : Macro <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="constant">=&gt;</span> <span class="keyword">do</span>
5115   <span class="keyword">let</span> stx <span class="constant">:=</span> stx.setKind newKind
5116   withRef stx `(<span class="keyword">do</span> <span class="constant">$</span>stx:doElem)
5117 
<span class="doc">5118 @[builtinMacro Lean.Parser.Term.termFor]</span>
<span class="keyword">5119 def</span> <span class="function-name">expandTermFor</span> : Macro <span class="constant">:=</span> toDoElem `Lean.Parser.Term.doFor
5120 
<span class="doc">5121 @[builtinMacro Lean.Parser.Term.termTry]</span>
<span class="keyword">5122 def</span> <span class="function-name">expandTermTry</span> : Macro <span class="constant">:=</span> toDoElem `Lean.Parser.Term.doTry
5123 
<span class="doc">5124 @[builtinMacro Lean.Parser.Term.termUnless]</span>
<span class="keyword">5125 def</span> <span class="function-name">expandTermUnless</span> : Macro <span class="constant">:=</span> toDoElem `Lean.Parser.Term.doUnless
5126 
<span class="doc">5127 @[builtinMacro Lean.Parser.Term.termReturn]</span>
<span class="keyword">5128 def</span> <span class="function-name">expandTermReturn</span> : Macro <span class="constant">:=</span> toDoElem `Lean.Parser.Term.doReturn
5129 
<span class="keyword">5130 end</span> Lean.Elab.Term
5131 ::::::::::::::
5132 Elab<span class="constant">/</span>Exception.lean
5133 ::::::::::::::
<span class="comment-delimiter">5134 /-</span><span class="comment">
5135 Copyright (c) 2019 Microsoft Corporation. All rights reserved.
5136 Released under Apache 2.0 license as described in the file LICENSE.
5137 Authors: Leonardo de Moura
5138 -/</span>
<span class="keyword">5139 import</span> Lean.InternalExceptionId
<span class="keyword">5140 import</span> Lean.Meta.Basic
5141 
<span class="keyword">5142 namespace</span> Lean.Elab
5143 
<span class="keyword">5144 builtin_initialize</span> postponeExceptionId : InternalExceptionId &#8592; registerInternalExceptionId `postpone
<span class="keyword">5145 builtin_initialize</span> unsupportedSyntaxExceptionId : InternalExceptionId &#8592; registerInternalExceptionId `unsupportedSyntax
<span class="keyword">5146 builtin_initialize</span> abortCommandExceptionId : InternalExceptionId &#8592; registerInternalExceptionId `abortCommandElab
<span class="keyword">5147 builtin_initialize</span> abortTermExceptionId : InternalExceptionId &#8592; registerInternalExceptionId `abortTermElab
<span class="keyword">5148 builtin_initialize</span> autoBoundImplicitExceptionId : InternalExceptionId &#8592; registerInternalExceptionId `autoBoundImplicit
5149 
<span class="keyword">5150 def</span> <span class="function-name">throwPostpone</span> [MonadExceptOf Exception m] : m &#945; <span class="constant">:=</span>
5151   throw <span class="constant">$</span> Exception.internal postponeExceptionId
5152 
<span class="keyword">5153 def</span> <span class="function-name">throwUnsupportedSyntax</span> [MonadExceptOf Exception m] : m &#945; <span class="constant">:=</span>
5154   throw <span class="constant">$</span> Exception.internal unsupportedSyntaxExceptionId
5155 
<span class="keyword">5156 def</span> <span class="function-name">throwIllFormedSyntax</span> [Monad m] [MonadError m] : m &#945; <span class="constant">:=</span>
5157   throwError <span class="string">"ill-formed syntax"</span>
5158 
<span class="keyword">5159 def</span> <span class="function-name">throwAutoBoundImplicitLocal</span> [MonadExceptOf Exception m] (n : Name) : m &#945; <span class="constant">:=</span>
5160   throw <span class="constant">$</span> Exception.internal autoBoundImplicitExceptionId <span class="constant">&lt;</span>| KVMap.empty.insert `localId n
5161 
<span class="keyword">5162 def</span> <span class="function-name">isAutoBoundImplicitLocalException?</span> (ex : Exception) : Option Name <span class="constant">:=</span>
5163   <span class="keyword">match</span> ex <span class="keyword">with</span>
5164   | Exception.internal id k <span class="constant">=&gt;</span>
5165     <span class="keyword">if</span> id <span class="constant">==</span> autoBoundImplicitExceptionId <span class="keyword">then</span>
5166       some <span class="constant">&lt;</span>| k.getName `localId `x
5167     <span class="keyword">else</span>
5168       none
5169   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> none
5170 
<span class="keyword">5171 def</span> <span class="function-name">throwAlreadyDeclaredUniverseLevel</span> [Monad m] [MonadError m] (u : Name) : m &#945; <span class="constant">:=</span>
5172   throwError <span class="string">"a universe level named '{u}' has already been declared"</span>
5173 
<span class="comment-delimiter">5174 -- </span><span class="comment">Throw exception to abort elaboration of the current command without producing any error message
</span><span class="keyword">5175 def</span> <span class="function-name">throwAbortCommand</span> {&#945; m} [MonadExcept Exception m] : m &#945; <span class="constant">:=</span>
5176   throw <span class="constant">&lt;</span>| Exception.internal abortCommandExceptionId
5177 
<span class="comment-delimiter">5178 -- </span><span class="comment">Throw exception to abort elaboration of the current term without producing any error message
</span><span class="keyword">5179 def</span> <span class="function-name">throwAbortTerm</span> {&#945; m} [MonadExcept Exception m] : m &#945; <span class="constant">:=</span>
5180   throw <span class="constant">&lt;</span>| Exception.internal abortTermExceptionId
5181 
<span class="keyword">5182 def</span> <span class="function-name">isAbortExceptionId</span> (id : InternalExceptionId) : Bool <span class="constant">:=</span>
5183   id <span class="constant">==</span> abortCommandExceptionId <span class="constant">||</span> id <span class="constant">==</span> abortTermExceptionId
5184 
<span class="keyword">5185 def</span> <span class="function-name">mkMessageCore</span> (fileName : String) (fileMap : FileMap) (msgData : MessageData) (severity : MessageSeverity) (pos : String.Pos) : Message <span class="constant">:=</span>
5186   <span class="keyword">let</span> pos <span class="constant">:=</span> fileMap.toPosition pos
5187   { fileName <span class="constant">:=</span> fileName, pos <span class="constant">:=</span> pos, data <span class="constant">:=</span> msgData, severity <span class="constant">:=</span> severity }
5188 
<span class="keyword">5189 end</span> Lean.Elab
5190 ::::::::::::::
5191 Elab<span class="constant">/</span>Extra.lean
5192 ::::::::::::::
<span class="comment-delimiter">5193 /-</span><span class="comment">
5194 Copyright (c) 2021 Microsoft Corporation. All rights reserved.
5195 Released under Apache 2.0 license as described in the file LICENSE.
5196 Authors: Leonardo de Moura
5197 -/</span>
<span class="keyword">5198 import</span> Lean.Elab.App
5199 
<span class="comment-delimiter">5200 /-</span><span class="comment">
5201 Auxiliary elaboration functions: AKA custom elaborators
5202 -/</span>
5203 
<span class="keyword">5204 namespace</span> Lean.Elab.Term
<span class="keyword">5205 open</span> Meta
5206 
<span class="doc">5207 @[builtinTermElab binrel]</span> <span class="keyword">def</span> <span class="function-name">elabBinRel</span> : TermElab <span class="constant">:=</span>  <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span> <span class="keyword">do</span>
5208   <span class="keyword">match</span> (&#8592; resolveId? stx[<span class="constant">1</span>]) <span class="keyword">with</span>
5209   | some f <span class="constant">=&gt;</span>
5210     <span class="keyword">let</span> s &#8592; saveState
5211     <span class="keyword">let</span> (lhs, rhs) &#8592; withSynthesize (mayPostpone <span class="constant">:=</span> true) <span class="keyword">do</span>
5212       <span class="keyword">let</span> <span class="keyword">mut</span> lhs &#8592; elabTerm stx[<span class="constant">2</span>] none
5213       <span class="keyword">let</span> <span class="keyword">mut</span> rhs &#8592; elabTerm stx[<span class="constant">3</span>] none
5214       <span class="keyword">if</span> lhs.isAppOfArity `OfNat.ofNat <span class="constant">3</span> <span class="keyword">then</span>
5215         lhs &#8592; ensureHasType (&#8592; inferType rhs) lhs
5216       <span class="keyword">else</span> <span class="keyword">if</span> rhs.isAppOfArity `OfNat.ofNat <span class="constant">3</span> <span class="keyword">then</span>
5217         rhs &#8592; ensureHasType (&#8592; inferType lhs) rhs
5218       <span class="keyword">return</span> (lhs, rhs)
5219     <span class="keyword">let</span> lhsType &#8592; inferType lhs
5220     <span class="keyword">let</span> rhsType &#8592; inferType rhs
5221     <span class="keyword">let</span> (lhs, rhs) &#8592;
5222       <span class="keyword">try</span>
5223         pure (lhs, &#8592; withRef stx[<span class="constant">3</span>] <span class="keyword">do</span> ensureHasType lhsType rhs)
5224       <span class="keyword">catch</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
5225         <span class="keyword">try</span>
5226           pure (&#8592; withRef stx[<span class="constant">2</span>] <span class="keyword">do</span> ensureHasType rhsType lhs, rhs)
5227         <span class="keyword">catch</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
5228           s.restore
5229           <span class="comment-delimiter">-- </span><span class="comment">Use default approach
</span>5230           <span class="keyword">let</span> lhs &#8592; elabTerm stx[<span class="constant">2</span>] none
5231           <span class="keyword">let</span> rhs &#8592; elabTerm stx[<span class="constant">3</span>] none
5232           <span class="keyword">let</span> lhsType &#8592; inferType lhs
5233           <span class="keyword">let</span> rhsType &#8592; inferType rhs
5234           pure (lhs, &#8592; withRef stx[<span class="constant">3</span>] <span class="keyword">do</span> ensureHasType lhsType rhs)
5235     elabAppArgs f <span class="constant">#</span>[] <span class="constant">#</span>[Arg.expr lhs, Arg.expr rhs] expectedType? (explicit <span class="constant">:=</span> false) (ellipsis <span class="constant">:=</span> false)
5236   | none   <span class="constant">=&gt;</span> throwUnknownConstant stx[<span class="constant">1</span>].getId
5237 
<span class="doc">5238 @[builtinTermElab forInMacro]</span> <span class="keyword">def</span> <span class="function-name">elabForIn</span> : TermElab <span class="constant">:=</span>  <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span> <span class="keyword">do</span>
5239   <span class="keyword">match</span> stx <span class="keyword">with</span>
5240   | `(forIn% <span class="constant">$</span>col <span class="constant">$</span>init <span class="constant">$</span>body) <span class="constant">=&gt;</span>
5241       <span class="keyword">match</span> (&#8592; isLocalIdent? col) <span class="keyword">with</span>
5242       | none   <span class="constant">=&gt;</span> elabTerm (&#8592; `(<span class="keyword">let</span> col <span class="constant">:=</span> <span class="constant">$</span>col; forIn% col <span class="constant">$</span>init <span class="constant">$</span>body)) expectedType?
5243       | some colFVar <span class="constant">=&gt;</span>
5244         tryPostponeIfNoneOrMVar expectedType?
5245         <span class="keyword">let</span> m &#8592; getMonad expectedType?
5246         <span class="keyword">let</span> colType &#8592; inferType colFVar
5247         <span class="keyword">let</span> elemType &#8592; mkFreshExprMVar (mkSort (mkLevelSucc (&#8592; mkFreshLevelMVar)))
5248         <span class="keyword">let</span> forInInstance &#8592;
5249           <span class="keyword">try</span>
5250             mkAppM `ForIn <span class="constant">#</span>[m, colType, elemType]
5251           <span class="keyword">catch</span>
5252             ex <span class="constant">=&gt;</span> tryPostpone; throwError <span class="string">"failed to construct 'ForIn' instance for collection{indentExpr colType}\nand monad{indentExpr m}"</span>
5253         <span class="keyword">match</span> (&#8592; trySynthInstance forInInstance) <span class="keyword">with</span>
5254         | LOption.some val <span class="constant">=&gt;</span>
5255           <span class="keyword">let</span> ref &#8592; getRef
5256           <span class="keyword">let</span> forInFn &#8592; mkConst ``forIn
5257           <span class="keyword">let</span> namedArgs : Array NamedArg <span class="constant">:=</span> <span class="constant">#</span>[
5258             { ref <span class="constant">:=</span> ref, name <span class="constant">:=</span> `m, val <span class="constant">:=</span> Arg.expr m},
5259             { ref <span class="constant">:=</span> ref, name <span class="constant">:=</span> `&#961;, val <span class="constant">:=</span> Arg.expr colType},
5260             { ref <span class="constant">:=</span> ref, name <span class="constant">:=</span> `&#945;, val <span class="constant">:=</span> Arg.expr elemType},
5261             { ref <span class="constant">:=</span> ref, name <span class="constant">:=</span> `self, val <span class="constant">:=</span> Arg.expr forInInstance},
5262             { ref <span class="constant">:=</span> ref, name <span class="constant">:=</span> `inst, val <span class="constant">:=</span> Arg.expr val} ]
5263           elabAppArgs forInFn <span class="constant">#</span>[] <span class="constant">#</span>[Arg.stx col, Arg.stx init, Arg.stx body] expectedType? (explicit <span class="constant">:=</span> false) (ellipsis <span class="constant">:=</span> false)
5264         | LOption.undef    <span class="constant">=&gt;</span> tryPostpone; throwFailure forInInstance
5265         | LOption.none     <span class="constant">=&gt;</span> throwFailure forInInstance
5266   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwUnsupportedSyntax
<span class="keyword">5267 where</span>
5268   getMonad (expectedType? : Option Expr) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
5269     <span class="keyword">match</span> expectedType? <span class="keyword">with</span>
5270     | none <span class="constant">=&gt;</span> throwError <span class="string">"invalid 'forIn%' notation, expected type is not available"</span>
5271     | some expectedType <span class="constant">=&gt;</span>
5272       <span class="keyword">match</span> (&#8592; isTypeApp? expectedType) <span class="keyword">with</span>
5273       | some (m, <span class="preprocessor">_</span>) <span class="constant">=&gt;</span> <span class="keyword">return</span> m
5274       | none <span class="constant">=&gt;</span> throwError <span class="string">"invalid 'forIn%' notation, expected type is not of of the form `M &#945;`{indentExpr expectedType}"</span>
5275   throwFailure (forInInstance : Expr) : TermElabM Expr <span class="constant">:=</span>
5276     throwError <span class="string">"failed to synthesize instance for 'forIn%' notation{indentExpr forInInstance}"</span>
5277 
<span class="keyword">5278 end</span> Lean.Elab.Term
5279 ::::::::::::::
5280 Elab<span class="constant">/</span>Frontend.lean
5281 ::::::::::::::
<span class="comment-delimiter">5282 /-</span><span class="comment">
5283 Copyright (c) 2019 Microsoft Corporation. All rights reserved.
5284 Released under Apache 2.0 license as described in the file LICENSE.
5285 Authors: Leonardo de Moura, Sebastian Ullrich
5286 -/</span>
<span class="keyword">5287 import</span> Lean.Elab.Import
<span class="keyword">5288 import</span> Lean.Elab.Command
<span class="keyword">5289 import</span> Lean.Util.Profile
5290 
<span class="keyword">5291 namespace</span> Lean.Elab.Frontend
5292 
<span class="keyword">5293 structure</span> <span class="function-name">State</span> <span class="keyword">where</span>
5294   commandState : Command.State
5295   parserState  : Parser.ModuleParserState
5296   cmdPos       : String.Pos
5297   commands     : Array Syntax <span class="constant">:=</span> <span class="constant">#</span>[]
5298 
<span class="keyword">5299 structure</span> <span class="function-name">Context</span> <span class="keyword">where</span>
5300   inputCtx : Parser.InputContext
5301 
<span class="keyword">5302 abbrev</span> FrontendM <span class="constant">:=</span> ReaderT Context <span class="constant">$</span> StateRefT State IO
5303 
<span class="keyword">5304 def</span> <span class="function-name">setCommandState</span> (commandState : Command.State) : FrontendM Unit <span class="constant">:=</span>
5305   modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> commandState <span class="constant">:=</span> commandState }
5306 
<span class="doc">5307 @[inline]</span> <span class="keyword">def</span> <span class="function-name">runCommandElabM</span> (x : Command.CommandElabM &#945;) : FrontendM &#945; <span class="constant">:=</span> <span class="keyword">do</span>
5308   <span class="keyword">let</span> ctx &#8592; read
5309   <span class="keyword">let</span> s &#8592; get
5310   <span class="keyword">let</span> cmdCtx : Command.Context <span class="constant">:=</span> { cmdPos <span class="constant">:=</span> s.cmdPos, fileName <span class="constant">:=</span> ctx.inputCtx.fileName, fileMap <span class="constant">:=</span> ctx.inputCtx.fileMap }
5311   <span class="keyword">match</span> &#8592; liftM <span class="constant">&lt;</span>| EIO.toIO' <span class="constant">&lt;</span>| (x cmdCtx).run s.commandState <span class="keyword">with</span>
5312   | Except.error e      <span class="constant">=&gt;</span> throw <span class="constant">&lt;</span>| IO.Error.userError s<span class="constant">!</span><span class="string">"unexpected internal error: {&#8592; e.toMessageData.toString}"</span>
5313   | Except.ok (a, sNew) <span class="constant">=&gt;</span> setCommandState sNew; <span class="keyword">return</span> a
5314 
<span class="keyword">5315 def</span> <span class="function-name">elabCommandAtFrontend</span> (stx : Syntax) : FrontendM Unit <span class="constant">:=</span> <span class="keyword">do</span>
5316   runCommandElabM <span class="keyword">do</span>
5317     <span class="keyword">let</span> infoTreeEnabled <span class="constant">:=</span> (&#8592; getInfoState).enabled
5318     <span class="keyword">if</span> checkTraceOption (&#8592; getOptions) `Elab.info <span class="keyword">then</span>
5319       enableInfoTree
5320     Command.elabCommand stx
5321     enableInfoTree infoTreeEnabled
5322 
<span class="keyword">5323 def</span> <span class="function-name">updateCmdPos</span> : FrontendM Unit <span class="constant">:=</span> <span class="keyword">do</span>
5324   modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> cmdPos <span class="constant">:=</span> s.parserState.pos }
5325 
<span class="keyword">5326 def</span> <span class="function-name">getParserState</span> : FrontendM Parser.ModuleParserState <span class="constant">:=</span> <span class="keyword">do</span> pure (&#8592; get).parserState
<span class="keyword">5327 def</span> <span class="function-name">getCommandState</span> : FrontendM Command.State <span class="constant">:=</span> <span class="keyword">do</span> pure (&#8592; get).commandState
<span class="keyword">5328 def</span> <span class="function-name">setParserState</span> (ps : Parser.ModuleParserState) : FrontendM Unit <span class="constant">:=</span> modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> parserState <span class="constant">:=</span> ps }
<span class="keyword">5329 def</span> <span class="function-name">setMessages</span> (msgs : MessageLog) : FrontendM Unit <span class="constant">:=</span> modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> commandState <span class="constant">:=</span> { s.commandState <span class="keyword">with</span> messages <span class="constant">:=</span> msgs } }
<span class="keyword">5330 def</span> <span class="function-name">getInputContext</span> : FrontendM Parser.InputContext <span class="constant">:=</span> <span class="keyword">do</span> pure (&#8592; read).inputCtx
5331 
<span class="keyword">5332 def</span> <span class="function-name">processCommand</span> : FrontendM Bool <span class="constant">:=</span> <span class="keyword">do</span>
5333   updateCmdPos
5334   <span class="keyword">let</span> cmdState &#8592; getCommandState
5335   <span class="keyword">let</span> ictx &#8592; getInputContext
5336   <span class="keyword">let</span> pstate &#8592; getParserState
5337   <span class="keyword">let</span> scope <span class="constant">:=</span> cmdState.scopes.head<span class="constant">!</span>
5338   <span class="keyword">let</span> pmctx <span class="constant">:=</span> { env <span class="constant">:=</span> cmdState.env, options <span class="constant">:=</span> scope.opts, currNamespace <span class="constant">:=</span> scope.currNamespace, openDecls <span class="constant">:=</span> scope.openDecls }
5339   <span class="keyword">let</span> pos <span class="constant">:=</span> ictx.fileMap.toPosition pstate.pos
5340   <span class="keyword">match</span> profileit <span class="string">"parsing"</span> scope.opts <span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> Parser.parseCommand ictx pmctx pstate cmdState.messages <span class="keyword">with</span>
5341   | (cmd, ps, messages) <span class="constant">=&gt;</span>
5342     modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> commands <span class="constant">:=</span> s.commands.push cmd }
5343     setParserState ps
5344     setMessages messages
5345     <span class="keyword">if</span> Parser.isEOI cmd <span class="constant">||</span> Parser.isExitCommand cmd <span class="keyword">then</span>
5346       pure true <span class="comment-delimiter">-- </span><span class="comment">Done
</span>5347     <span class="keyword">else</span>
5348       profileitM IO.Error <span class="string">"elaboration"</span> scope.opts <span class="constant">&lt;</span>| elabCommandAtFrontend cmd
5349       pure false
5350 
<span class="keyword">5351 partial</span> <span class="keyword">def</span> <span class="function-name">processCommands</span> : FrontendM Unit <span class="constant">:=</span> <span class="keyword">do</span>
5352   <span class="keyword">let</span> done &#8592; processCommand
5353   <span class="keyword">unless</span> done <span class="keyword">do</span>
5354     processCommands
5355 
<span class="keyword">5356 end</span> Frontend
5357 
<span class="keyword">5358 open</span> Frontend
5359 
<span class="keyword">5360 def</span> <span class="function-name">IO.processCommands</span> (inputCtx : Parser.InputContext) (parserState : Parser.ModuleParserState) (commandState : Command.State) : IO State <span class="constant">:=</span> <span class="keyword">do</span>
5361   <span class="keyword">let</span> (<span class="preprocessor">_</span>, s) &#8592; (Frontend.processCommands.run { inputCtx <span class="constant">:=</span> inputCtx }).run { commandState <span class="constant">:=</span> commandState, parserState <span class="constant">:=</span> parserState, cmdPos <span class="constant">:=</span> parserState.pos }
5362   pure s
5363 
<span class="keyword">5364 def</span> <span class="function-name">process</span> (input : String) (env : Environment) (opts : Options) (fileName : Option String <span class="constant">:=</span> none) : IO (Environment <span class="constant">&#215;</span> MessageLog) <span class="constant">:=</span> <span class="keyword">do</span>
5365   <span class="keyword">let</span> fileName   <span class="constant">:=</span> fileName.getD <span class="string">"&lt;input&gt;"</span>
5366   <span class="keyword">let</span> inputCtx   <span class="constant">:=</span> Parser.mkInputContext input fileName
5367   <span class="keyword">let</span> s &#8592; IO.processCommands inputCtx { : Parser.ModuleParserState } (Command.mkState env {} opts)
5368   pure (s.commandState.env, s.commandState.messages)
5369 
<span class="keyword">5370 builtin_initialize</span>
5371   registerOption `printMessageEndPos { defValue <span class="constant">:=</span> false, descr <span class="constant">:=</span> <span class="string">"print end position of each message in addition to start position"</span> }
5372   registerTraceClass `Elab.info
5373 
<span class="keyword">5374 def</span> <span class="function-name">getPrintMessageEndPos</span> (opts : Options) : Bool <span class="constant">:=</span>
5375   opts.getBool `printMessageEndPos false
5376 
<span class="doc">5377 @[export lean_run_frontend]</span>
<span class="keyword">5378 def</span> <span class="function-name">runFrontend</span> (input : String) (opts : Options) (fileName : String) (mainModuleName : Name) : IO (Environment <span class="constant">&#215;</span> Bool) <span class="constant">:=</span> <span class="keyword">do</span>
5379   <span class="keyword">let</span> inputCtx <span class="constant">:=</span> Parser.mkInputContext input fileName
5380   <span class="keyword">let</span> (header, parserState, messages) &#8592; Parser.parseHeader inputCtx
5381   <span class="keyword">let</span> (env, messages) &#8592; processHeader header opts messages inputCtx
5382   <span class="keyword">let</span> env <span class="constant">:=</span> env.setMainModule mainModuleName
5383   <span class="keyword">let</span> s &#8592; IO.processCommands inputCtx parserState (Command.mkState env messages opts)
5384   <span class="keyword">for</span> msg <span class="keyword">in</span> s.commandState.messages.toList <span class="keyword">do</span>
5385     IO.print (&#8592; msg.toString (includeEndPos <span class="constant">:=</span> getPrintMessageEndPos opts))
5386   pure (s.commandState.env, <span class="constant">!</span>s.commandState.messages.hasErrors)
5387 
<span class="keyword">5388 end</span> Lean.Elab
5389 ::::::::::::::
5390 Elab<span class="constant">/</span>Import.lean
5391 ::::::::::::::
<span class="comment-delimiter">5392 /-</span><span class="comment">
5393 Copyright (c) 2019 Microsoft Corporation. All rights reserved.
5394 Released under Apache 2.0 license as described in the file LICENSE.
5395 Authors: Leonardo de Moura, Sebastian Ullrich
5396 -/</span>
<span class="keyword">5397 import</span> Lean.Parser.Module
<span class="keyword">5398 namespace</span> Lean.Elab
5399 
<span class="keyword">5400 def</span> <span class="function-name">headerToImports</span> (header : Syntax) : List Import <span class="constant">:=</span>
5401   <span class="keyword">let</span> imports <span class="constant">:=</span> <span class="keyword">if</span> header[<span class="constant">0</span>].isNone <span class="keyword">then</span> [{ module <span class="constant">:=</span> `Init : Import }] <span class="keyword">else</span> []
5402   imports <span class="constant">++</span> header[<span class="constant">1</span>].getArgs.toList.map <span class="keyword">fun</span> stx <span class="constant">=&gt;</span>
5403     <span class="comment-delimiter">-- </span><span class="comment">`stx` is of the form `(Module.import "import" "runtime"? id)
</span>5404     <span class="keyword">let</span> runtime <span class="constant">:=</span> <span class="constant">!</span>stx[<span class="constant">1</span>].isNone
5405     <span class="keyword">let</span> id      <span class="constant">:=</span> stx[<span class="constant">2</span>].getId
5406     { module <span class="constant">:=</span> id, runtimeOnly <span class="constant">:=</span> runtime }
5407 
<span class="keyword">5408 def</span> <span class="function-name">processHeader</span> (header : Syntax) (opts : Options) (messages : MessageLog) (inputCtx : Parser.InputContext) (trustLevel : UInt32 <span class="constant">:=</span> <span class="constant">0</span>)
5409     : IO (Environment <span class="constant">&#215;</span> MessageLog) <span class="constant">:=</span> <span class="keyword">do</span>
5410   <span class="keyword">try</span>
5411     <span class="keyword">let</span> env &#8592; importModules (headerToImports header) opts trustLevel
5412     pure (env, messages)
5413   <span class="keyword">catch</span> e <span class="constant">=&gt;</span>
5414     <span class="keyword">let</span> env &#8592; mkEmptyEnvironment
5415     <span class="keyword">let</span> spos <span class="constant">:=</span> header.getPos?.getD <span class="constant">0</span>
5416     <span class="keyword">let</span> pos  <span class="constant">:=</span> inputCtx.fileMap.toPosition spos
5417     pure (env, messages.add { fileName <span class="constant">:=</span> inputCtx.fileName, data <span class="constant">:=</span> toString e, pos <span class="constant">:=</span> pos })
5418 
<span class="keyword">5419 def</span> <span class="function-name">parseImports</span> (input : String) (fileName : Option String <span class="constant">:=</span> none) : IO (List Import <span class="constant">&#215;</span> Position <span class="constant">&#215;</span> MessageLog) <span class="constant">:=</span> <span class="keyword">do</span>
5420   <span class="keyword">let</span> fileName <span class="constant">:=</span> fileName.getD <span class="string">"&lt;input&gt;"</span>
5421   <span class="keyword">let</span> inputCtx <span class="constant">:=</span> Parser.mkInputContext input fileName
5422   <span class="keyword">let</span> (header, parserState, messages) &#8592; Parser.parseHeader inputCtx
5423   pure (headerToImports header, inputCtx.fileMap.toPosition parserState.pos, messages)
5424 
<span class="doc">5425 @[export lean_print_imports]</span>
<span class="keyword">5426 def</span> <span class="function-name">printImports</span> (input : String) (fileName : Option String) : IO Unit <span class="constant">:=</span> <span class="keyword">do</span>
5427   <span class="keyword">let</span> (deps, pos, log) &#8592; parseImports input fileName
5428   <span class="keyword">for</span> dep <span class="keyword">in</span> deps <span class="keyword">do</span>
5429     <span class="keyword">let</span> fname &#8592; findOLean dep.module
5430     IO.println fname
5431 
<span class="keyword">5432 end</span> Lean.Elab
5433 ::::::::::::::
5434 Elab<span class="constant">/</span>Inductive.lean
5435 ::::::::::::::
<span class="comment-delimiter">5436 /-</span><span class="comment">
5437 Copyright (c) 2020 Microsoft Corporation. All rights reserved.
5438 Released under Apache 2.0 license as described in the file LICENSE.
5439 Authors: Leonardo de Moura
5440 -/</span>
<span class="keyword">5441 import</span> Lean.Util.ReplaceLevel
<span class="keyword">5442 import</span> Lean.Util.ReplaceExpr
<span class="keyword">5443 import</span> Lean.Util.CollectLevelParams
<span class="keyword">5444 import</span> Lean.Util.Constructions
<span class="keyword">5445 import</span> Lean.Meta.CollectFVars
<span class="keyword">5446 import</span> Lean.Meta.SizeOf
<span class="keyword">5447 import</span> Lean.Elab.Command
<span class="keyword">5448 import</span> Lean.Elab.DefView
<span class="keyword">5449 import</span> Lean.Elab.DeclUtil
<span class="keyword">5450 import</span> Lean.Elab.Deriving.Basic
5451 
<span class="keyword">5452 namespace</span> Lean.Elab.Command
<span class="keyword">5453 open</span> Meta
5454 
<span class="keyword">5455 builtin_initialize</span>
5456   registerTraceClass `Elab.<span class="keyword">inductive</span>
5457 
<span class="keyword">5458 def</span> <span class="function-name">checkValidInductiveModifier</span> [Monad m] [MonadError m] (modifiers : Modifiers) : m Unit <span class="constant">:=</span> <span class="keyword">do</span>
5459   <span class="keyword">if</span> modifiers.isNoncomputable <span class="keyword">then</span>
5460     throwError <span class="string">"invalid use of 'noncomputable' in inductive declaration"</span>
5461   <span class="keyword">if</span> modifiers.isPartial <span class="keyword">then</span>
5462     throwError <span class="string">"invalid use of 'partial' in inductive declaration"</span>
5463   <span class="keyword">unless</span> modifiers.attrs.size <span class="constant">==</span> <span class="constant">0</span> <span class="constant">||</span> (modifiers.attrs.size <span class="constant">==</span> <span class="constant">1</span> <span class="constant">&amp;&amp;</span> modifiers.attrs[<span class="constant">0</span>].name <span class="constant">==</span> `<span class="keyword">class</span><span class="function-name">)</span> <span class="keyword">do</span>
5464     throwError <span class="string">"invalid use of attributes in inductive declaration"</span>
5465 
<span class="keyword">5466 def</span> <span class="function-name">checkValidCtorModifier</span> [Monad m] [MonadError m] (modifiers : Modifiers) : m Unit <span class="constant">:=</span> <span class="keyword">do</span>
5467   <span class="keyword">if</span> modifiers.isNoncomputable <span class="keyword">then</span>
5468     throwError <span class="string">"invalid use of 'noncomputable' in constructor declaration"</span>
5469   <span class="keyword">if</span> modifiers.isPartial <span class="keyword">then</span>
5470     throwError <span class="string">"invalid use of 'partial' in constructor declaration"</span>
5471   <span class="keyword">if</span> modifiers.isUnsafe <span class="keyword">then</span>
5472     throwError <span class="string">"invalid use of 'unsafe' in constructor declaration"</span>
5473   <span class="keyword">if</span> modifiers.attrs.size <span class="constant">!=</span> <span class="constant">0</span> <span class="keyword">then</span>
5474     throwError <span class="string">"invalid use of attributes in constructor declaration"</span>
5475 
<span class="keyword">5476 structure</span> <span class="function-name">CtorView</span> <span class="keyword">where</span>
5477   ref       : Syntax
5478   modifiers : Modifiers
5479   inferMod  : Bool  <span class="comment-delimiter">-- </span><span class="comment">true if `{}` is used in the constructor declaration
</span>5480   declName  : Name
5481   binders   : Syntax
5482   type?     : Option Syntax
5483   <span class="keyword">deriving</span> Inhabited
5484 
<span class="keyword">5485 structure</span> <span class="function-name">InductiveView</span> <span class="keyword">where</span>
5486   ref             : Syntax
5487   modifiers       : Modifiers
5488   shortDeclName   : Name
5489   declName        : Name
5490   levelNames      : List Name
5491   binders         : Syntax
5492   type?           : Option Syntax
5493   ctors           : Array CtorView
5494   derivingClasses : Array DerivingClassView
5495   <span class="keyword">deriving</span> Inhabited
5496 
<span class="keyword">5497 structure</span> <span class="function-name">ElabHeaderResult</span> <span class="keyword">where</span>
5498   view       : InductiveView
5499   lctx       : LocalContext
5500   localInsts : LocalInstances
5501   params     : Array Expr
5502   type       : Expr
5503   <span class="keyword">deriving</span> Inhabited
5504 
<span class="keyword">5505 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">elabHeaderAux</span> (views : Array InductiveView) (i : Nat) (acc : Array ElabHeaderResult) : TermElabM (Array ElabHeaderResult) <span class="constant">:=</span> <span class="keyword">do</span>
5506   <span class="keyword">if</span> h : i <span class="constant">&lt;</span> views.size <span class="keyword">then</span>
5507     <span class="keyword">let</span> view <span class="constant">:=</span> views.get &#10216;i, h&#10217;
5508     <span class="keyword">let</span> acc &#8592; Term.withAutoBoundImplicit <span class="constant">&lt;</span>| Term.elabBinders view.binders.getArgs <span class="keyword">fun</span> params <span class="constant">=&gt;</span> <span class="keyword">do</span>
5509       <span class="keyword">match</span> view.type? <span class="keyword">with</span>
5510       | none         <span class="constant">=&gt;</span>
5511         <span class="keyword">let</span> u &#8592; mkFreshLevelMVar
5512         <span class="keyword">let</span> type <span class="constant">:=</span> mkSort u
5513         Term.synthesizeSyntheticMVarsNoPostponing
5514         <span class="keyword">let</span> params &#8592; Term.addAutoBoundImplicits params
5515         pure <span class="constant">&lt;</span>| acc.push { lctx <span class="constant">:=</span> (&#8592; getLCtx), localInsts <span class="constant">:=</span> (&#8592; getLocalInstances), params <span class="constant">:=</span> params, type <span class="constant">:=</span> type, view <span class="constant">:=</span> view }
5516       | some typeStx <span class="constant">=&gt;</span>
5517         <span class="keyword">let</span> type &#8592; Term.elabType typeStx
5518         <span class="keyword">unless</span> (&#8592; isTypeFormerType type) <span class="keyword">do</span>
5519           throwErrorAt typeStx <span class="string">"invalid inductive type, resultant type is not a sort"</span>
5520         Term.synthesizeSyntheticMVarsNoPostponing
5521         <span class="keyword">let</span> params &#8592; Term.addAutoBoundImplicits params
5522         pure <span class="constant">&lt;</span>| acc.push { lctx <span class="constant">:=</span> (&#8592; getLCtx), localInsts <span class="constant">:=</span> (&#8592; getLocalInstances), params <span class="constant">:=</span> params, type <span class="constant">:=</span> type, view <span class="constant">:=</span> view }
5523     elabHeaderAux views (i<span class="constant">+1</span>) acc
5524   <span class="keyword">else</span>
5525     pure acc
5526 
<span class="keyword">5527 private</span> <span class="keyword">def</span> <span class="function-name">checkNumParams</span> (rs : Array ElabHeaderResult) : TermElabM Nat <span class="constant">:=</span> <span class="keyword">do</span>
5528   <span class="keyword">let</span> numParams <span class="constant">:=</span> rs[<span class="constant">0</span>].params.size
5529   <span class="keyword">for</span> r <span class="keyword">in</span> rs <span class="keyword">do</span>
5530     <span class="keyword">unless</span> r.params.size <span class="constant">==</span> numParams <span class="keyword">do</span>
5531       throwErrorAt r.view.ref <span class="string">"invalid inductive type, number of parameters mismatch in mutually inductive datatypes"</span>
5532   pure numParams
5533 
<span class="keyword">5534 private</span> <span class="keyword">def</span> <span class="function-name">checkUnsafe</span> (rs : Array ElabHeaderResult) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
5535   <span class="keyword">let</span> isUnsafe <span class="constant">:=</span> rs[<span class="constant">0</span>].view.modifiers.isUnsafe
5536   <span class="keyword">for</span> r <span class="keyword">in</span> rs <span class="keyword">do</span>
5537     <span class="keyword">unless</span> r.view.modifiers.isUnsafe <span class="constant">==</span> isUnsafe <span class="keyword">do</span>
5538       throwErrorAt r.view.ref <span class="string">"invalid inductive type, cannot mix unsafe and safe declarations in a mutually inductive datatypes"</span>
5539 
<span class="keyword">5540 private</span> <span class="keyword">def</span> <span class="function-name">checkLevelNames</span> (views : Array InductiveView) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
5541   <span class="keyword">if</span> views.size <span class="constant">&gt;</span> <span class="constant">1</span> <span class="keyword">then</span>
5542     <span class="keyword">let</span> levelNames <span class="constant">:=</span> views[<span class="constant">0</span>].levelNames
5543     <span class="keyword">for</span> view <span class="keyword">in</span> views <span class="keyword">do</span>
5544       <span class="keyword">unless</span> view.levelNames <span class="constant">==</span> levelNames <span class="keyword">do</span>
5545         throwErrorAt view.ref <span class="string">"invalid inductive type, universe parameters mismatch in mutually inductive datatypes"</span>
5546 
<span class="keyword">5547 private</span> <span class="keyword">def</span> <span class="function-name">mkTypeFor</span> (r : ElabHeaderResult) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
5548   withLCtx r.lctx r.localInsts <span class="keyword">do</span>
5549     mkForallFVars r.params r.type
5550 
<span class="keyword">5551 private</span> <span class="keyword">def</span> <span class="function-name">throwUnexpectedInductiveType</span> {&#945;} : TermElabM &#945; <span class="constant">:=</span>
5552   throwError <span class="string">"unexpected inductive resulting type"</span>
5553 
<span class="keyword">5554 private</span> <span class="keyword">def</span> <span class="function-name">eqvFirstTypeResult</span> (firstType type : Expr) : MetaM Bool <span class="constant">:=</span>
5555   forallTelescopeReducing firstType <span class="keyword">fun</span> <span class="preprocessor">_</span> firstTypeResult <span class="constant">=&gt;</span> isDefEq firstTypeResult type
5556 
<span class="comment-delimiter">5557 -- </span><span class="comment">Auxiliary function for checking whether the types in mutually inductive declaration are compatible.
</span><span class="keyword">5558 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">checkParamsAndResultType</span> (type firstType : Expr) (numParams : Nat) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
5559   <span class="keyword">try</span>
5560     forallTelescopeCompatible type firstType numParams <span class="keyword">fun</span> <span class="preprocessor">_</span> type firstType <span class="constant">=&gt;</span>
5561     forallTelescopeReducing type <span class="keyword">fun</span> <span class="preprocessor">_</span> type <span class="constant">=&gt;</span>
5562     forallTelescopeReducing firstType <span class="keyword">fun</span> <span class="preprocessor">_</span> firstType <span class="constant">=&gt;</span> <span class="keyword">do</span>
5563     <span class="keyword">match</span> type <span class="keyword">with</span>
5564     | Expr.sort .. <span class="constant">=&gt;</span>
5565       <span class="keyword">unless</span> (&#8592; isDefEq firstType type) <span class="keyword">do</span>
5566         throwError <span class="string">"resulting universe mismatch, given{indentExpr type}\nexpected type{indentExpr firstType}"</span>
5567     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
5568       throwError <span class="string">"unexpected inductive resulting type"</span>
5569   <span class="keyword">catch</span>
5570     | Exception.error ref msg <span class="constant">=&gt;</span> throw (Exception.error ref m<span class="constant">!</span><span class="string">"invalid mutually inductive types, {msg}"</span>)
5571     | ex <span class="constant">=&gt;</span> throw ex
5572 
<span class="comment-delimiter">5573 -- </span><span class="comment">Auxiliary function for checking whether the types in mutually inductive declaration are compatible.
</span><span class="keyword">5574 private</span> <span class="keyword">def</span> <span class="function-name">checkHeader</span> (r : ElabHeaderResult) (numParams : Nat) (firstType? : Option Expr) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
5575   <span class="keyword">let</span> type &#8592; mkTypeFor r
5576   <span class="keyword">match</span> firstType? <span class="keyword">with</span>
5577   | none           <span class="constant">=&gt;</span> pure type
5578   | some firstType <span class="constant">=&gt;</span>
5579     withRef r.view.ref <span class="constant">$</span> checkParamsAndResultType type firstType numParams
5580     pure firstType
5581 
<span class="comment-delimiter">5582 -- </span><span class="comment">Auxiliary function for checking whether the types in mutually inductive declaration are compatible.
</span><span class="keyword">5583 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">checkHeaders</span> (rs : Array ElabHeaderResult) (numParams : Nat) (i : Nat) (firstType? : Option Expr) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
5584   <span class="keyword">if</span> i <span class="constant">&lt;</span> rs.size <span class="keyword">then</span>
5585     <span class="keyword">let</span> type &#8592; checkHeader rs[i] numParams firstType?
5586     checkHeaders rs numParams (i<span class="constant">+1</span>) type
5587 
<span class="keyword">5588 private</span> <span class="keyword">def</span> <span class="function-name">elabHeader</span> (views : Array InductiveView) : TermElabM (Array ElabHeaderResult) <span class="constant">:=</span> <span class="keyword">do</span>
5589   <span class="keyword">let</span> rs &#8592; elabHeaderAux views <span class="constant">0</span> <span class="constant">#</span>[]
5590   <span class="keyword">if</span> rs.size <span class="constant">&gt;</span> <span class="constant">1</span> <span class="keyword">then</span>
5591     checkUnsafe rs
5592     <span class="keyword">let</span> numParams &#8592; checkNumParams rs
5593     checkHeaders rs numParams <span class="constant">0</span> none
5594   <span class="keyword">return</span> rs
5595 
<span class="comment-delimiter">5596 /- </span><span class="comment">Create a local declaration for each inductive type in `rs`, and execute `x params indFVars`, where `params` are the inductive type parameters and
5597    `indFVars` are the new local declarations.
5598    We use the local context/instances and parameters of rs[0].
5599    Note that this method is executed after we executed `checkHeaders` and established all
5600    parameters are compatible. -/</span>
<span class="keyword">5601 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">withInductiveLocalDecls</span> {&#945;} (rs : Array ElabHeaderResult) (x : Array Expr <span class="constant">&#8594;</span> Array Expr <span class="constant">&#8594;</span> TermElabM &#945;) : TermElabM &#945; <span class="constant">:=</span> <span class="keyword">do</span>
5602   <span class="keyword">let</span> namesAndTypes &#8592; rs.mapM <span class="keyword">fun</span> r <span class="constant">=&gt;</span> <span class="keyword">do</span>
5603     <span class="keyword">let</span> type &#8592; mkTypeFor r
5604     pure (r.view.shortDeclName, type)
5605   <span class="keyword">let</span> r0     <span class="constant">:=</span> rs[<span class="constant">0</span>]
5606   <span class="keyword">let</span> params <span class="constant">:=</span> r0.params
5607   withLCtx r0.lctx r0.localInsts <span class="constant">$</span> withRef r0.view.ref <span class="keyword">do</span>
5608     <span class="keyword">let</span> <span class="keyword">rec</span> loop (i : Nat) (indFVars : Array Expr) <span class="constant">:=</span> <span class="keyword">do</span>
5609       <span class="keyword">if</span> h : i <span class="constant">&lt;</span> namesAndTypes.size <span class="keyword">then</span>
5610         <span class="keyword">let</span> (id, type) <span class="constant">:=</span> namesAndTypes.get &#10216;i, h&#10217;
5611         withLocalDeclD id type <span class="keyword">fun</span> indFVar <span class="constant">=&gt;</span> loop (i<span class="constant">+1</span>) (indFVars.push indFVar)
5612       <span class="keyword">else</span>
5613         x params indFVars
5614     loop <span class="constant">0</span> <span class="constant">#</span>[]
5615 
<span class="keyword">5616 private</span> <span class="keyword">def</span> <span class="function-name">isInductiveFamily</span> (numParams : Nat) (indFVar : Expr) : TermElabM Bool <span class="constant">:=</span> <span class="keyword">do</span>
5617   <span class="keyword">let</span> indFVarType &#8592; inferType indFVar
5618   forallTelescopeReducing indFVarType <span class="keyword">fun</span> xs <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
5619     <span class="keyword">return</span> xs.size <span class="constant">&gt;</span> numParams
5620 
<span class="comment-delimiter">5621 /-</span><span class="comment">
5622   Elaborate constructor types.
5623 
5624   Remark: we check whether the resulting type is correct, and the parameter occurrences are consistent, but
5625   we currently do not check for:
5626   - Positivity (it is a rare failure, and the kernel already checks for it).
5627   - Universe constraints (the kernel checks for it).
5628 -/</span>
<span class="keyword">5629 private</span> <span class="keyword">def</span> <span class="function-name">elabCtors</span> (indFVars : Array Expr) (indFVar : Expr) (params : Array Expr) (r : ElabHeaderResult) : TermElabM (List Constructor) <span class="constant">:=</span> withRef r.view.ref <span class="keyword">do</span>
5630   <span class="keyword">let</span> indFamily &#8592; isInductiveFamily params.size indFVar
5631   r.view.ctors.toList.mapM <span class="keyword">fun</span> ctorView <span class="constant">=&gt;</span>
5632     Term.withAutoBoundImplicit <span class="constant">&lt;</span>| Term.elabBinders ctorView.binders.getArgs <span class="keyword">fun</span> ctorParams <span class="constant">=&gt;</span>
5633       withRef ctorView.ref <span class="keyword">do</span>
5634         <span class="keyword">let</span> <span class="keyword">rec</span> elabCtorType (k : Expr <span class="constant">&#8594;</span> TermElabM Constructor) : TermElabM Constructor <span class="constant">:=</span> <span class="keyword">do</span>
5635           <span class="keyword">match</span> ctorView.type? <span class="keyword">with</span>
5636           | none          <span class="constant">=&gt;</span>
5637             <span class="keyword">if</span> indFamily <span class="keyword">then</span>
5638               throwError <span class="string">"constructor resulting type must be specified in inductive family declaration"</span>
5639             k <span class="constant">&lt;</span>| mkAppN indFVar params
5640           | some ctorType <span class="constant">=&gt;</span>
5641             <span class="keyword">let</span> type &#8592; Term.elabType ctorType
5642             Term.synthesizeSyntheticMVars (mayPostpone <span class="constant">:=</span> true)
5643             <span class="keyword">let</span> type &#8592; instantiateMVars type
5644             <span class="keyword">let</span> type &#8592; checkParamOccs type
5645             forallTelescopeReducing type <span class="keyword">fun</span> <span class="preprocessor">_</span> resultingType <span class="constant">=&gt;</span> <span class="keyword">do</span>
5646               <span class="keyword">unless</span> resultingType.getAppFn <span class="constant">==</span> indFVar <span class="keyword">do</span>
5647                 throwError <span class="string">"unexpected constructor resulting type{indentExpr resultingType}"</span>
5648               <span class="keyword">unless</span> (&#8592; isType resultingType) <span class="keyword">do</span>
5649                 throwError <span class="string">"unexpected constructor resulting type, type expected{indentExpr resultingType}"</span>
5650             k type
5651         elabCtorType <span class="keyword">fun</span> type <span class="constant">=&gt;</span> <span class="keyword">do</span>
5652           Term.synthesizeSyntheticMVarsNoPostponing
5653           <span class="keyword">let</span> ctorParams &#8592; Term.addAutoBoundImplicits ctorParams
5654           <span class="keyword">let</span> type &#8592; mkForallFVars ctorParams type
5655           <span class="keyword">let</span> type &#8592; mkForallFVars params type
5656           <span class="keyword">return</span> { name <span class="constant">:=</span> ctorView.declName, type <span class="constant">:=</span> type }
<span class="keyword">5657 where</span>
5658   checkParamOccs (ctorType : Expr) : MetaM Expr <span class="constant">:=</span>
5659     <span class="keyword">let</span> visit (e : Expr) : MetaM TransformStep <span class="constant">:=</span> <span class="keyword">do</span>
5660       <span class="keyword">let</span> f <span class="constant">:=</span> e.getAppFn
5661       <span class="keyword">if</span> indFVars.contains f <span class="keyword">then</span>
5662         <span class="keyword">let</span> <span class="keyword">mut</span> args <span class="constant">:=</span> e.getAppArgs
5663         <span class="keyword">unless</span> args.size <span class="constant">&#8805;</span> params.size <span class="keyword">do</span>
5664           throwError <span class="string">"unexpected inductive type occurrence{indentExpr e}"</span>
5665         <span class="keyword">for</span> i <span class="keyword">in</span> [:params.size] <span class="keyword">do</span>
5666           <span class="keyword">let</span> param <span class="constant">:=</span> params[i]
5667           <span class="keyword">let</span> arg <span class="constant">:=</span> args[i]
5668           <span class="keyword">unless</span> (&#8592; isDefEq param arg) <span class="keyword">do</span>
5669             throwError <span class="string">"inductive datatype parameter mismatch{indentExpr arg}\nexpected{indentExpr param}"</span>
5670           args <span class="constant">:=</span> args.set<span class="constant">!</span> i param
5671         <span class="keyword">return</span> TransformStep.done (mkAppN f args)
5672       <span class="keyword">else</span>
5673         <span class="keyword">return</span> TransformStep.visit e
5674     transform ctorType (pre <span class="constant">:=</span> visit)
5675 
<span class="comment-delimiter">5676 /- </span><span class="comment">Convert universe metavariables occurring in the `indTypes` into new parameters.
5677    Remark: if the resulting inductive datatype has universe metavariables, we will fix it later using
5678    `inferResultingUniverse`. -/</span>
<span class="keyword">5679 private</span> <span class="keyword">def</span> <span class="function-name">levelMVarToParamAux</span> (indTypes : List InductiveType) : StateRefT Nat TermElabM (List InductiveType) <span class="constant">:=</span>
5680   indTypes.mapM <span class="keyword">fun</span> indType <span class="constant">=&gt;</span> <span class="keyword">do</span>
5681     <span class="keyword">let</span> type  &#8592; Term.levelMVarToParam' indType.type
5682     <span class="keyword">let</span> ctors &#8592; indType.ctors.mapM <span class="keyword">fun</span> ctor <span class="constant">=&gt;</span> <span class="keyword">do</span>
5683       <span class="keyword">let</span> ctorType &#8592; Term.levelMVarToParam' ctor.type
5684       pure { ctor <span class="keyword">with</span> type <span class="constant">:=</span> ctorType }
5685     pure { indType <span class="keyword">with</span> ctors <span class="constant">:=</span> ctors, type <span class="constant">:=</span> type }
5686 
<span class="keyword">5687 private</span> <span class="keyword">def</span> <span class="function-name">levelMVarToParam</span> (indTypes : List InductiveType) : TermElabM (List InductiveType) <span class="constant">:=</span>
5688   (levelMVarToParamAux indTypes).run' <span class="constant">1</span>
5689 
<span class="keyword">5690 private</span> <span class="keyword">def</span> <span class="function-name">getResultingUniverse</span> : List InductiveType <span class="constant">&#8594;</span> TermElabM Level
5691   | []           <span class="constant">=&gt;</span> throwError <span class="string">"unexpected empty inductive declaration"</span>
5692   | indType :: <span class="preprocessor">_</span> <span class="constant">=&gt;</span> forallTelescopeReducing indType.type <span class="keyword">fun</span> <span class="preprocessor">_</span> r <span class="constant">=&gt;</span> <span class="keyword">do</span>
5693     <span class="keyword">match</span> r <span class="keyword">with</span>
5694     | Expr.sort u <span class="preprocessor">_</span> <span class="constant">=&gt;</span> pure u
5695     | <span class="preprocessor">_</span>             <span class="constant">=&gt;</span> throwError <span class="string">"unexpected inductive type resulting type"</span>
5696 
<span class="keyword">5697 def</span> <span class="function-name">tmpIndParam</span> <span class="constant">:=</span> mkLevelParam `_tmp_ind_univ_param
5698 
<span class="comment-delimiter">5699 /-</span><span class="comment">-
5700   Return true if `u` is of the form `?m + k`.
5701   Return false if `u` does not contain universe metavariables.
5702   Throw exception otherwise. -/</span>
<span class="keyword">5703 def</span> <span class="function-name">shouldInferResultUniverse</span> (u : Level) : TermElabM Bool <span class="constant">:=</span> <span class="keyword">do</span>
5704   <span class="keyword">let</span> u &#8592; instantiateLevelMVars u
5705   <span class="keyword">if</span> u.hasMVar <span class="keyword">then</span>
5706     <span class="keyword">match</span> u.getLevelOffset <span class="keyword">with</span>
5707     | Level.mvar mvarId <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">do</span>
5708       Term.assignLevelMVar mvarId tmpIndParam
5709       pure true
5710     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
5711       throwError <span class="string">"cannot infer resulting universe level of inductive datatype, given level contains metavariables {mkSort u}, provide universe explicitly"</span>
5712   <span class="keyword">else</span>
5713     pure false
5714 
<span class="comment-delimiter">5715 /-</span><span class="comment">
5716   Auxiliary function for `updateResultingUniverse`
5717   `accLevelAtCtor u r rOffset us` add `u` components to `us` if they are not already there and it is different from the resulting universe level `r+rOffset`.
5718   If `u` is a `max`, then its components are recursively processed.
5719   If `u` is a `succ` and `rOffset &gt; 0`, we process the `u`s child using `rOffset-1`.
5720 
5721   This method is used to infer the resulting universe level of an inductive datatype. -/</span>
<span class="keyword">5722 def</span> <span class="function-name">accLevelAtCtor</span> : Level <span class="constant">&#8594;</span> Level <span class="constant">&#8594;</span> Nat <span class="constant">&#8594;</span> Array Level <span class="constant">&#8594;</span> TermElabM (Array Level)
5723   | Level.max u v <span class="preprocessor">_</span>,  r, rOffset,   us <span class="constant">=&gt;</span> <span class="keyword">do</span> <span class="keyword">let</span> us &#8592; accLevelAtCtor u r rOffset us; accLevelAtCtor v r rOffset us
5724   | Level.imax u v <span class="preprocessor">_</span>, r, rOffset,   us <span class="constant">=&gt;</span> <span class="keyword">do</span> <span class="keyword">let</span> us &#8592; accLevelAtCtor u r rOffset us; accLevelAtCtor v r rOffset us
5725   | Level.zero <span class="preprocessor">_</span>,     <span class="preprocessor">_</span>, <span class="preprocessor">_</span>,         us <span class="constant">=&gt;</span> pure us
5726   | Level.succ u <span class="preprocessor">_</span>,   r, rOffset<span class="constant">+1</span>, us <span class="constant">=&gt;</span> accLevelAtCtor u r rOffset us
5727   | u,                r, rOffset,   us <span class="constant">=&gt;</span>
5728     <span class="keyword">if</span> rOffset <span class="constant">==</span> <span class="constant">0</span> <span class="constant">&amp;&amp;</span> u <span class="constant">==</span> r <span class="keyword">then</span> pure us
5729     <span class="keyword">else</span> <span class="keyword">if</span> r.occurs u  <span class="keyword">then</span> throwError <span class="string">"failed to compute resulting universe level of inductive datatype, provide universe explicitly"</span>
5730     <span class="keyword">else</span> <span class="keyword">if</span> rOffset <span class="constant">&gt;</span> <span class="constant">0</span> <span class="keyword">then</span> throwError <span class="string">"failed to compute resulting universe level of inductive datatype, provide universe explicitly"</span>
5731     <span class="keyword">else</span> <span class="keyword">if</span> us.contains u <span class="keyword">then</span> pure us
5732     <span class="keyword">else</span> pure (us.push u)
5733 
<span class="comment-delimiter">5734 /- </span><span class="comment">Auxiliary function for `updateResultingUniverse` -/</span>
<span class="keyword">5735 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">collectUniversesFromCtorTypeAux</span> (r : Level) (rOffset : Nat) : Nat <span class="constant">&#8594;</span> Expr <span class="constant">&#8594;</span> Array Level <span class="constant">&#8594;</span> TermElabM (Array Level)
5736   | <span class="constant">0</span>,   Expr.forallE n d b c, us <span class="constant">=&gt;</span> <span class="keyword">do</span>
5737     <span class="keyword">let</span> u &#8592; getLevel d
5738     <span class="keyword">let</span> u &#8592; instantiateLevelMVars u
5739     <span class="keyword">let</span> us &#8592; accLevelAtCtor u r rOffset us
5740     withLocalDecl n c.binderInfo d <span class="keyword">fun</span> x <span class="constant">=&gt;</span>
5741       <span class="keyword">let</span> e <span class="constant">:=</span> b.instantiate1 x
5742       collectUniversesFromCtorTypeAux r rOffset <span class="constant">0</span> e us
5743   | i<span class="constant">+1</span>, Expr.forallE n d b c, us <span class="constant">=&gt;</span> <span class="keyword">do</span>
5744     withLocalDecl n c.binderInfo d <span class="keyword">fun</span> x <span class="constant">=&gt;</span>
5745       <span class="keyword">let</span> e <span class="constant">:=</span> b.instantiate1 x
5746       collectUniversesFromCtorTypeAux r rOffset i e us
5747   | <span class="preprocessor">_</span>, <span class="preprocessor">_</span>, us <span class="constant">=&gt;</span> pure us
5748 
<span class="comment-delimiter">5749 /- </span><span class="comment">Auxiliary function for `updateResultingUniverse` -/</span>
<span class="keyword">5750 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">collectUniversesFromCtorType</span>
5751     (r : Level) (rOffset : Nat) (ctorType : Expr) (numParams : Nat) (us : Array Level) : TermElabM (Array Level) <span class="constant">:=</span>
5752   collectUniversesFromCtorTypeAux r rOffset numParams ctorType us
5753 
<span class="comment-delimiter">5754 /- </span><span class="comment">Auxiliary function for `updateResultingUniverse` -/</span>
<span class="keyword">5755 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">collectUniverses</span> (r : Level) (rOffset : Nat) (numParams : Nat) (indTypes : List InductiveType) : TermElabM (Array Level) <span class="constant">:=</span> <span class="keyword">do</span>
5756   <span class="keyword">let</span> <span class="keyword">mut</span> us <span class="constant">:=</span> <span class="constant">#</span>[]
5757   <span class="keyword">for</span> indType <span class="keyword">in</span> indTypes <span class="keyword">do</span>
5758     <span class="keyword">for</span> ctor <span class="keyword">in</span> indType.ctors <span class="keyword">do</span>
5759       us &#8592; collectUniversesFromCtorType r rOffset ctor.type numParams us
5760   <span class="keyword">return</span> us
5761 
<span class="keyword">5762 def</span> <span class="function-name">mkResultUniverse</span> (us : Array Level) (rOffset : Nat) : Level <span class="constant">:=</span>
5763   <span class="keyword">if</span> us.isEmpty <span class="constant">&amp;&amp;</span> rOffset <span class="constant">==</span> <span class="constant">0</span> <span class="keyword">then</span>
5764     levelOne
5765   <span class="keyword">else</span>
5766     <span class="keyword">let</span> r <span class="constant">:=</span> Level.mkNaryMax us.toList
5767     <span class="keyword">if</span> rOffset <span class="constant">==</span> <span class="constant">0</span> <span class="constant">&amp;&amp;</span> <span class="constant">!</span>r.isZero <span class="constant">&amp;&amp;</span> <span class="constant">!</span>r.isNeverZero <span class="keyword">then</span>
5768       (mkLevelMax r levelOne).normalize
5769     <span class="keyword">else</span>
5770       r.normalize
5771 
<span class="keyword">5772 private</span> <span class="keyword">def</span> <span class="function-name">updateResultingUniverse</span> (numParams : Nat) (indTypes : List InductiveType) : TermElabM (List InductiveType) <span class="constant">:=</span> <span class="keyword">do</span>
5773   <span class="keyword">let</span> r &#8592; getResultingUniverse indTypes
5774   <span class="keyword">let</span> rOffset : Nat   <span class="constant">:=</span> r.getOffset
5775   <span class="keyword">let</span> r       : Level <span class="constant">:=</span> r.getLevelOffset
5776   <span class="keyword">unless</span> r.isParam <span class="keyword">do</span>
5777     throwError <span class="string">"failed to compute resulting universe level of inductive datatype, provide universe explicitly"</span>
5778   <span class="keyword">let</span> us &#8592; collectUniverses r rOffset numParams indTypes
5779   trace[Elab.<span class="keyword">inductive</span><span class="function-name">]</span> <span class="string">"updateResultingUniverse us: {us}, r: {r}, rOffset: {rOffset}"</span>
5780   <span class="keyword">let</span> rNew <span class="constant">:=</span> mkResultUniverse us rOffset
5781   <span class="keyword">let</span> updateLevel (e : Expr) : Expr <span class="constant">:=</span> e.replaceLevel <span class="keyword">fun</span> u <span class="constant">=&gt;</span> <span class="keyword">if</span> u <span class="constant">==</span> tmpIndParam <span class="keyword">then</span> some rNew <span class="keyword">else</span> none
5782   <span class="keyword">return</span> indTypes.map <span class="keyword">fun</span> indType <span class="constant">=&gt;</span>
5783     <span class="keyword">let</span> type <span class="constant">:=</span> updateLevel indType.type;
5784     <span class="keyword">let</span> ctors <span class="constant">:=</span> indType.ctors.map <span class="keyword">fun</span> ctor <span class="constant">=&gt;</span> { ctor <span class="keyword">with</span> type <span class="constant">:=</span> updateLevel ctor.type };
5785     { indType <span class="keyword">with</span> type <span class="constant">:=</span> type, ctors <span class="constant">:=</span> ctors }
5786 
<span class="keyword">5787 register_builtin_option</span> bootstrap.inductiveCheckResultingUniverse : Bool <span class="constant">:=</span> {
5788     defValue <span class="constant">:=</span> true,
5789     group    <span class="constant">:=</span> <span class="string">"bootstrap"</span>,
5790     descr    <span class="constant">:=</span> <span class="string">"by default the `inductive/structure commands report an error if the resulting universe is not zero, but may be zero for some universe parameters. Reason: unless this type is a subsingleton, it is hardly what the user wants since it can only eliminate into `Prop`. In the `Init` package, we define subsingletons, and we use this option to disable the check. This option may be deleted in the future after we improve the validator"</span>
5791 }
5792 
<span class="keyword">5793 def</span> <span class="function-name">checkResultingUniverse</span> (u : Level) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
5794   <span class="keyword">if</span> bootstrap.inductiveCheckResultingUniverse.get (&#8592; getOptions) <span class="keyword">then</span>
5795     <span class="keyword">let</span> u &#8592; instantiateLevelMVars u
5796     <span class="keyword">if</span> <span class="constant">!</span>u.isZero <span class="constant">&amp;&amp;</span> <span class="constant">!</span>u.isNeverZero <span class="keyword">then</span>
5797       throwError <span class="string">"invalid universe polymorphic type, the resultant universe is not Prop (i.e., 0), but it may be Prop for some parameter values (solution: use 'u+1' or 'max 1 u'{indentD u}"</span>
5798 
<span class="keyword">5799 private</span> <span class="keyword">def</span> <span class="function-name">checkResultingUniverses</span> (indTypes : List InductiveType) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
5800   checkResultingUniverse (&#8592; getResultingUniverse indTypes)
5801 
<span class="keyword">5802 private</span> <span class="keyword">def</span> <span class="function-name">collectUsed</span> (indTypes : List InductiveType) : StateRefT CollectFVars.State MetaM Unit <span class="constant">:=</span> <span class="keyword">do</span>
5803   indTypes.forM <span class="keyword">fun</span> indType <span class="constant">=&gt;</span> <span class="keyword">do</span>
5804     Term.collectUsedFVars indType.type
5805     indType.ctors.forM <span class="keyword">fun</span> ctor <span class="constant">=&gt;</span>
5806       Term.collectUsedFVars ctor.type
5807 
<span class="keyword">5808 private</span> <span class="keyword">def</span> <span class="function-name">removeUnused</span> (vars : Array Expr) (indTypes : List InductiveType) : TermElabM (LocalContext <span class="constant">&#215;</span> LocalInstances <span class="constant">&#215;</span> Array Expr) <span class="constant">:=</span> <span class="keyword">do</span>
5809   <span class="keyword">let</span> (<span class="preprocessor">_</span>, used) &#8592; (collectUsed indTypes).run {}
5810   Term.removeUnused vars used
5811 
<span class="keyword">5812 private</span> <span class="keyword">def</span> <span class="function-name">withUsed</span> {&#945;} (vars : Array Expr) (indTypes : List InductiveType) (k : Array Expr <span class="constant">&#8594;</span> TermElabM &#945;) : TermElabM &#945; <span class="constant">:=</span> <span class="keyword">do</span>
5813   <span class="keyword">let</span> (lctx, localInsts, vars) &#8592; removeUnused vars indTypes
5814   withLCtx lctx localInsts <span class="constant">$</span> k vars
5815 
<span class="keyword">5816 private</span> <span class="keyword">def</span> <span class="function-name">updateParams</span> (vars : Array Expr) (indTypes : List InductiveType) : TermElabM (List InductiveType) <span class="constant">:=</span>
5817   indTypes.mapM <span class="keyword">fun</span> indType <span class="constant">=&gt;</span> <span class="keyword">do</span>
5818     <span class="keyword">let</span> type &#8592; mkForallFVars vars indType.type
5819     <span class="keyword">let</span> ctors &#8592; indType.ctors.mapM <span class="keyword">fun</span> ctor <span class="constant">=&gt;</span> <span class="keyword">do</span>
5820       <span class="keyword">let</span> ctorType &#8592; mkForallFVars vars ctor.type
5821       pure { ctor <span class="keyword">with</span> type <span class="constant">:=</span> ctorType }
5822     pure { indType <span class="keyword">with</span> type <span class="constant">:=</span> type, ctors <span class="constant">:=</span> ctors }
5823 
<span class="keyword">5824 private</span> <span class="keyword">def</span> <span class="function-name">collectLevelParamsInInductive</span> (indTypes : List InductiveType) : Array Name <span class="constant">:=</span> <span class="keyword">do</span>
5825   <span class="keyword">let</span> <span class="keyword">mut</span> usedParams : CollectLevelParams.State <span class="constant">:=</span> {}
5826   <span class="keyword">for</span> indType <span class="keyword">in</span> indTypes <span class="keyword">do</span>
5827     usedParams <span class="constant">:=</span> collectLevelParams usedParams indType.type
5828     <span class="keyword">for</span> ctor <span class="keyword">in</span> indType.ctors <span class="keyword">do</span>
5829       usedParams <span class="constant">:=</span> collectLevelParams usedParams ctor.type
5830   <span class="keyword">return</span> usedParams.params
5831 
<span class="keyword">5832 private</span> <span class="keyword">def</span> <span class="function-name">mkIndFVar2Const</span> (views : Array InductiveView) (indFVars : Array Expr) (levelNames : List Name) : ExprMap Expr <span class="constant">:=</span> <span class="keyword">do</span>
5833   <span class="keyword">let</span> levelParams <span class="constant">:=</span> levelNames.map mkLevelParam;
5834   <span class="keyword">let</span> <span class="keyword">mut</span> m : ExprMap Expr <span class="constant">:=</span> {}
5835   <span class="keyword">for</span> i <span class="keyword">in</span> [:views.size] <span class="keyword">do</span>
5836     <span class="keyword">let</span> view    <span class="constant">:=</span> views[i]
5837     <span class="keyword">let</span> indFVar <span class="constant">:=</span> indFVars[i]
5838     m <span class="constant">:=</span> m.insert indFVar (mkConst view.declName levelParams)
5839   <span class="keyword">return</span> m
5840 
<span class="comment-delimiter">5841 /- </span><span class="comment">Remark: `numVars &lt;= numParams`. `numVars` is the number of context `variables` used in the inductive declaration,
5842    and `numParams` is `numVars` + number of explicit parameters provided in the declaration. -/</span>
<span class="keyword">5843 private</span> <span class="keyword">def</span> <span class="function-name">replaceIndFVarsWithConsts</span> (views : Array InductiveView) (indFVars : Array Expr) (levelNames : List Name)
5844     (numVars : Nat) (numParams : Nat) (indTypes : List InductiveType) : TermElabM (List InductiveType) <span class="constant">:=</span>
5845   <span class="keyword">let</span> indFVar2Const <span class="constant">:=</span> mkIndFVar2Const views indFVars levelNames
5846   indTypes.mapM <span class="keyword">fun</span> indType <span class="constant">=&gt;</span> <span class="keyword">do</span>
5847     <span class="keyword">let</span> ctors &#8592; indType.ctors.mapM <span class="keyword">fun</span> ctor <span class="constant">=&gt;</span> <span class="keyword">do</span>
5848       <span class="keyword">let</span> type &#8592; forallBoundedTelescope ctor.type numParams <span class="keyword">fun</span> params type <span class="constant">=&gt;</span> <span class="keyword">do</span>
5849         <span class="keyword">let</span> type <span class="constant">:=</span> type.replace <span class="keyword">fun</span> e <span class="constant">=&gt;</span>
5850           <span class="keyword">if</span> <span class="constant">!</span>e.isFVar <span class="keyword">then</span>
5851             none
5852           <span class="keyword">else</span> <span class="keyword">match</span> indFVar2Const.find? e <span class="keyword">with</span>
5853             | none   <span class="constant">=&gt;</span> none
5854             | some c <span class="constant">=&gt;</span> mkAppN c (params.extract <span class="constant">0</span> numVars)
5855         mkForallFVars params type
5856       pure { ctor <span class="keyword">with</span> type <span class="constant">:=</span> type }
5857     pure { indType <span class="keyword">with</span> ctors <span class="constant">:=</span> ctors }
5858 
<span class="keyword">5859 abbrev</span> Ctor2InferMod <span class="constant">:=</span> Std.HashMap Name Bool
5860 
<span class="keyword">5861 private</span> <span class="keyword">def</span> <span class="function-name">mkCtor2InferMod</span> (views : Array InductiveView) : Ctor2InferMod <span class="constant">:=</span> <span class="keyword">do</span>
5862   <span class="keyword">let</span> <span class="keyword">mut</span> m <span class="constant">:=</span> {}
5863   <span class="keyword">for</span> view <span class="keyword">in</span> views <span class="keyword">do</span>
5864     <span class="keyword">for</span> ctorView <span class="keyword">in</span> view.ctors <span class="keyword">do</span>
5865       m <span class="constant">:=</span> m.insert ctorView.declName ctorView.inferMod
5866   <span class="keyword">return</span> m
5867 
<span class="keyword">5868 private</span> <span class="keyword">def</span> <span class="function-name">applyInferMod</span> (views : Array InductiveView) (numParams : Nat) (indTypes : List InductiveType) : List InductiveType <span class="constant">:=</span>
5869   <span class="keyword">let</span> ctor2InferMod <span class="constant">:=</span> mkCtor2InferMod views
5870   indTypes.map <span class="keyword">fun</span> indType <span class="constant">=&gt;</span>
5871     <span class="keyword">let</span> ctors <span class="constant">:=</span> indType.ctors.map <span class="keyword">fun</span> ctor <span class="constant">=&gt;</span>
5872       <span class="keyword">let</span> inferMod <span class="constant">:=</span> ctor2InferMod.find<span class="constant">!</span> ctor.name <span class="comment-delimiter">-- </span><span class="comment">true if `{}` was used
</span>5873       <span class="keyword">let</span> ctorType <span class="constant">:=</span> ctor.type.inferImplicit numParams <span class="constant">!</span>inferMod
5874       { ctor <span class="keyword">with</span> type <span class="constant">:=</span> ctorType }
5875     { indType <span class="keyword">with</span> ctors <span class="constant">:=</span> ctors }
5876 
<span class="keyword">5877 private</span> <span class="keyword">def</span> <span class="function-name">mkAuxConstructions</span> (views : Array InductiveView) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
5878   <span class="keyword">let</span> env &#8592; getEnv
5879   <span class="keyword">let</span> hasEq   <span class="constant">:=</span> env.contains ``Eq
5880   <span class="keyword">let</span> hasHEq  <span class="constant">:=</span> env.contains ``HEq
5881   <span class="keyword">let</span> hasUnit <span class="constant">:=</span> env.contains ``PUnit
5882   <span class="keyword">let</span> hasProd <span class="constant">:=</span> env.contains ``Prod
5883   <span class="keyword">for</span> view <span class="keyword">in</span> views <span class="keyword">do</span>
5884     <span class="keyword">let</span> n <span class="constant">:=</span> view.declName
5885     mkRecOn n
5886     <span class="keyword">if</span> hasUnit <span class="keyword">then</span> mkCasesOn n
5887     <span class="keyword">if</span> hasUnit <span class="constant">&amp;&amp;</span> hasEq <span class="constant">&amp;&amp;</span> hasHEq <span class="keyword">then</span> mkNoConfusion n
5888     <span class="keyword">if</span> hasUnit <span class="constant">&amp;&amp;</span> hasProd <span class="keyword">then</span> mkBelow n
5889     <span class="keyword">if</span> hasUnit <span class="constant">&amp;&amp;</span> hasProd <span class="keyword">then</span> mkIBelow n
5890   <span class="keyword">for</span> view <span class="keyword">in</span> views <span class="keyword">do</span>
5891     <span class="keyword">let</span> n <span class="constant">:=</span> view.declName;
5892     <span class="keyword">if</span> hasUnit <span class="constant">&amp;&amp;</span> hasProd <span class="keyword">then</span> mkBRecOn n
5893     <span class="keyword">if</span> hasUnit <span class="constant">&amp;&amp;</span> hasProd <span class="keyword">then</span> mkBInductionOn n
5894 
<span class="keyword">5895 private</span> <span class="keyword">def</span> <span class="function-name">mkInductiveDecl</span> (vars : Array Expr) (views : Array InductiveView) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
5896   <span class="keyword">let</span> view0 <span class="constant">:=</span> views[<span class="constant">0</span>]
5897   <span class="keyword">let</span> scopeLevelNames &#8592; Term.getLevelNames
5898   checkLevelNames views
5899   <span class="keyword">let</span> allUserLevelNames <span class="constant">:=</span> view0.levelNames
5900   <span class="keyword">let</span> isUnsafe          <span class="constant">:=</span> view0.modifiers.isUnsafe
5901   withRef view0.ref <span class="constant">&lt;</span>| Term.withLevelNames allUserLevelNames <span class="keyword">do</span>
5902     <span class="keyword">let</span> rs &#8592; elabHeader views
5903     withInductiveLocalDecls rs <span class="keyword">fun</span> params indFVars <span class="constant">=&gt;</span> <span class="keyword">do</span>
5904       <span class="keyword">let</span> numExplicitParams <span class="constant">:=</span> params.size
5905       <span class="keyword">let</span> <span class="keyword">mut</span> indTypes <span class="constant">:=</span> <span class="constant">#</span>[]
5906       <span class="keyword">for</span> i <span class="keyword">in</span> [:views.size] <span class="keyword">do</span>
5907         <span class="keyword">let</span> indFVar <span class="constant">:=</span> indFVars[i]
5908         <span class="keyword">let</span> r       <span class="constant">:=</span> rs[i]
5909         <span class="keyword">let</span> type  &#8592; mkForallFVars params r.type
5910         <span class="keyword">let</span> ctors &#8592; elabCtors indFVars indFVar params r
5911         indTypes <span class="constant">:=</span> indTypes.push { name <span class="constant">:=</span> r.view.declName, type <span class="constant">:=</span> type, ctors <span class="constant">:=</span> ctors : InductiveType }
5912       <span class="keyword">let</span> indTypes <span class="constant">:=</span> indTypes.toList
5913       Term.synthesizeSyntheticMVarsNoPostponing
5914       <span class="keyword">let</span> u &#8592; getResultingUniverse indTypes
5915       <span class="keyword">let</span> inferLevel &#8592; shouldInferResultUniverse u
5916       withUsed vars indTypes <span class="keyword">fun</span> vars <span class="constant">=&gt;</span> <span class="keyword">do</span>
5917         <span class="keyword">let</span> numVars   <span class="constant">:=</span> vars.size
5918         <span class="keyword">let</span> numParams <span class="constant">:=</span> numVars <span class="constant">+</span> numExplicitParams
5919         <span class="keyword">let</span> indTypes &#8592; updateParams vars indTypes
5920         <span class="keyword">let</span> indTypes &#8592; levelMVarToParam indTypes
5921         <span class="keyword">let</span> indTypes &#8592; <span class="keyword">if</span> inferLevel <span class="keyword">then</span> updateResultingUniverse numParams indTypes <span class="keyword">else</span> checkResultingUniverses indTypes; pure indTypes
5922         <span class="keyword">let</span> usedLevelNames <span class="constant">:=</span> collectLevelParamsInInductive indTypes
5923         <span class="keyword">match</span> sortDeclLevelParams scopeLevelNames allUserLevelNames usedLevelNames <span class="keyword">with</span>
5924         | Except.error msg      <span class="constant">=&gt;</span> throwError msg
5925         | Except.ok levelParams <span class="constant">=&gt;</span> <span class="keyword">do</span>
5926           <span class="keyword">let</span> indTypes &#8592; replaceIndFVarsWithConsts views indFVars levelParams numVars numParams indTypes
5927           <span class="keyword">let</span> indTypes <span class="constant">:=</span> applyInferMod views numParams indTypes
5928           <span class="keyword">let</span> decl <span class="constant">:=</span> Declaration.inductDecl levelParams numParams indTypes isUnsafe
5929           Term.ensureNoUnassignedMVars decl
5930           addDecl decl
5931           mkAuxConstructions views
5932           <span class="comment-delimiter">-- </span><span class="comment">We need to invoke `applyAttributes` because `class` is implemented as an attribute.
</span>5933           <span class="keyword">for</span> view <span class="keyword">in</span> views <span class="keyword">do</span>
5934             Term.applyAttributesAt view.declName view.modifiers.attrs AttributeApplicationTime.afterTypeChecking
5935 
<span class="keyword">5936 private</span> <span class="keyword">def</span> <span class="function-name">applyDerivingHandlers</span> (views : Array InductiveView) : CommandElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
5937   <span class="keyword">let</span> <span class="keyword">mut</span> processed : NameSet <span class="constant">:=</span> {}
5938   <span class="keyword">for</span> view <span class="keyword">in</span> views <span class="keyword">do</span>
5939     <span class="keyword">for</span> classView <span class="keyword">in</span> view.derivingClasses <span class="keyword">do</span>
5940       <span class="keyword">let</span> className <span class="constant">:=</span> classView.className
5941       <span class="keyword">unless</span> processed.contains className <span class="keyword">do</span>
5942         processed <span class="constant">:=</span> processed.insert className
5943         <span class="keyword">let</span> <span class="keyword">mut</span> declNames <span class="constant">:=</span> <span class="constant">#</span>[]
5944         <span class="keyword">for</span> view <span class="keyword">in</span> views <span class="keyword">do</span>
5945           <span class="keyword">if</span> view.derivingClasses.any <span class="keyword">fun</span> classView <span class="constant">=&gt;</span> classView.className <span class="constant">==</span> className <span class="keyword">then</span>
5946             declNames <span class="constant">:=</span> declNames.push view.declName
5947         classView.applyHandlers declNames
5948 
<span class="keyword">5949 def</span> <span class="function-name">elabInductiveViews</span> (views : Array InductiveView) : CommandElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
5950   <span class="keyword">let</span> view0 <span class="constant">:=</span> views[<span class="constant">0</span>]
5951   <span class="keyword">let</span> ref <span class="constant">:=</span> view0.ref
5952   runTermElabM view0.declName <span class="keyword">fun</span> vars <span class="constant">=&gt;</span> withRef ref <span class="keyword">do</span>
5953     mkInductiveDecl vars views
5954     mkSizeOfInstances view0.declName
5955   applyDerivingHandlers views
5956 
<span class="keyword">5957 end</span> Lean.Elab.Command
5958 ::::::::::::::
5959 Elab<span class="constant">/</span>InfoTree.lean
5960 ::::::::::::::
<span class="comment-delimiter">5961 /-</span><span class="comment">
5962 Copyright (c) 2020 Wojciech Nawrocki. All rights reserved.
5963 Released under Apache 2.0 license as described in the file LICENSE.
5964 
5965 Authors: Wojciech Nawrocki, Leonardo de Moura
5966 -/</span>
<span class="keyword">5967 import</span> Lean.Data.Position
<span class="keyword">5968 import</span> Lean.Expr
<span class="keyword">5969 import</span> Lean.Message
<span class="keyword">5970 import</span> Lean.Data.Json
<span class="keyword">5971 import</span> Lean.Meta.Basic
<span class="keyword">5972 import</span> Lean.Meta.PPGoal
5973 
<span class="keyword">5974 namespace</span> Lean.Elab
5975 
<span class="keyword">5976 open</span> Std (PersistentArray PersistentArray.empty PersistentHashMap)
5977 
<span class="comment-delimiter">5978 /- </span><span class="comment">Context after executing `liftTermElabM`.
5979    Note that the term information collected during elaboration may contain metavariables, and their
5980    assignments are stored at `mctx`. -/</span>
<span class="keyword">5981 structure</span> <span class="function-name">ContextInfo</span> <span class="keyword">where</span>
5982   env           : Environment
5983   fileMap       : FileMap
5984   mctx          : MetavarContext <span class="constant">:=</span> {}
5985   options       : Options        <span class="constant">:=</span> {}
5986   currNamespace : Name           <span class="constant">:=</span> Name.anonymous
5987   openDecls     : List OpenDecl  <span class="constant">:=</span> []
5988   <span class="keyword">deriving</span> Inhabited
5989 
<span class="keyword">5990 structure</span> <span class="function-name">TermInfo</span> <span class="keyword">where</span>
5991   lctx : LocalContext <span class="comment-delimiter">-- </span><span class="comment">The local context when the term was elaborated.
</span>5992   expr : Expr
5993   stx  : Syntax
5994   <span class="keyword">deriving</span> Inhabited
5995 
<span class="keyword">5996 structure</span> <span class="function-name">CommandInfo</span> <span class="keyword">where</span>
5997   stx : Syntax
5998   <span class="keyword">deriving</span> Inhabited
5999 
<span class="keyword">6000 inductive</span> <span class="function-name">CompletionInfo</span> <span class="keyword">where</span>
6001   | dot (termInfo : TermInfo) (field? : Option Syntax) (expectedType? : Option Expr)
6002   | id (stx : Syntax) (id : Name) (danglingDot : Bool) (lctx : LocalContext) (expectedType? : Option Expr)
6003   | namespaceId (stx : Syntax)
6004   | option (stx : Syntax)
6005   | endSection (stx : Syntax) (scopeNames : List String)
6006   | tactic (stx : Syntax) (goals : List MVarId)
6007   <span class="comment-delimiter">-- </span><span class="comment">TODO `import`
</span>6008 
<span class="keyword">6009 def</span> <span class="function-name">CompletionInfo.stx</span> : CompletionInfo <span class="constant">&#8594;</span> Syntax
6010   | dot i .. <span class="constant">=&gt;</span> i.stx
6011   | id stx .. <span class="constant">=&gt;</span> stx
6012   | namespaceId stx <span class="constant">=&gt;</span> stx
6013   | option stx <span class="constant">=&gt;</span> stx
6014   | endSection stx .. <span class="constant">=&gt;</span> stx
6015   | tactic stx .. <span class="constant">=&gt;</span> stx
6016 
<span class="keyword">6017 structure</span> <span class="function-name">FieldInfo</span> <span class="keyword">where</span>
6018   name : Name
6019   lctx : LocalContext
6020   val  : Expr
6021   stx  : Syntax
6022   <span class="keyword">deriving</span> Inhabited
6023 
<span class="comment-delimiter">6024 /- </span><span class="comment">We store the list of goals before and after the execution of a tactic.
6025    We also store the metavariable context at each time since, we want to unassigned metavariables
6026    at tactic execution time to be displayed as `?m...`. -/</span>
<span class="keyword">6027 structure</span> <span class="function-name">TacticInfo</span> <span class="keyword">where</span>
6028   mctxBefore  : MetavarContext
6029   goalsBefore : List MVarId
6030   stx         : Syntax
6031   mctxAfter   : MetavarContext
6032   goalsAfter  : List MVarId
6033   <span class="keyword">deriving</span> Inhabited
6034 
<span class="keyword">6035 structure</span> <span class="function-name">MacroExpansionInfo</span> <span class="keyword">where</span>
6036   lctx   : LocalContext <span class="comment-delimiter">-- </span><span class="comment">The local context when the macro was expanded.
</span>6037   before : Syntax
6038   after  : Syntax
6039   <span class="keyword">deriving</span> Inhabited
6040 
<span class="keyword">6041 inductive</span> <span class="function-name">Info</span> <span class="keyword">where</span>
6042   | ofTacticInfo (i : TacticInfo)
6043   | ofTermInfo (i : TermInfo)
6044   | ofCommandInfo (i : CommandInfo)
6045   | ofMacroExpansionInfo (i : MacroExpansionInfo)
6046   | ofFieldInfo (i : FieldInfo)
6047   | ofCompletionInfo (i : CompletionInfo)
6048   <span class="keyword">deriving</span> Inhabited
6049 
<span class="keyword">6050 inductive</span> <span class="function-name">InfoTree</span> <span class="keyword">where</span>
6051   | context (i : ContextInfo) (t : InfoTree) <span class="comment-delimiter">-- </span><span class="comment">The context object is created by `liftTermElabM` at `Command.lean`
</span>6052   | node (i : Info) (children : PersistentArray InfoTree) <span class="comment-delimiter">-- </span><span class="comment">The children contains information for nested term elaboration and tactic evaluation
</span>6053   | ofJson (j : Json) <span class="comment-delimiter">-- </span><span class="comment">For user data
</span>6054   | hole (mvarId : MVarId) <span class="comment-delimiter">-- </span><span class="comment">The elaborator creates holes (aka metavariables) for tactics and postponed terms
</span>6055   <span class="keyword">deriving</span> Inhabited
6056 
<span class="keyword">6057 partial</span> <span class="keyword">def</span> <span class="function-name">InfoTree.findInfo?</span> (p : Info <span class="constant">&#8594;</span> Bool) (t : InfoTree) : Option InfoTree <span class="constant">:=</span>
6058   <span class="keyword">match</span> t <span class="keyword">with</span>
6059   | context <span class="preprocessor">_</span> t <span class="constant">=&gt;</span> findInfo? p t
6060   | node i ts   <span class="constant">=&gt;</span>
6061     <span class="keyword">if</span> p i <span class="keyword">then</span>
6062       some t
6063     <span class="keyword">else</span>
6064       ts.findSome? (findInfo? p)
6065   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> none
6066 
<span class="keyword">6067 structure</span> <span class="function-name">InfoState</span> <span class="keyword">where</span>
6068   enabled    : Bool <span class="constant">:=</span> false
6069   assignment : PersistentHashMap MVarId InfoTree <span class="constant">:=</span> {} <span class="comment-delimiter">-- </span><span class="comment">map from holeId to InfoTree
</span>6070   trees      : PersistentArray InfoTree <span class="constant">:=</span> {}
6071   <span class="keyword">deriving</span> Inhabited
6072 
<span class="keyword">6073 class</span> <span class="function-name">MonadInfoTree</span> (m : <span class="type">Type</span> <span class="constant">&#8594;</span> <span class="type">Type</span>)  <span class="keyword">where</span>
6074   getInfoState    : m InfoState
6075   modifyInfoState : (InfoState <span class="constant">&#8594;</span> InfoState) <span class="constant">&#8594;</span> m Unit
6076 
<span class="keyword">6077 export</span> MonadInfoTree (getInfoState modifyInfoState)
6078 
<span class="keyword">6079 instance</span> [MonadLift m n] [MonadInfoTree m] : MonadInfoTree n <span class="keyword">where</span>
6080   getInfoState      <span class="constant">:=</span> liftM (getInfoState : m <span class="preprocessor">_</span>)
6081   modifyInfoState f <span class="constant">:=</span> liftM (modifyInfoState f : m <span class="preprocessor">_</span>)
6082 
<span class="keyword">6083 partial</span> <span class="keyword">def</span> <span class="function-name">InfoTree.substitute</span> (tree : InfoTree) (assignment : PersistentHashMap MVarId InfoTree) : InfoTree <span class="constant">:=</span>
6084   <span class="keyword">match</span> tree <span class="keyword">with</span>
6085   | node i c <span class="constant">=&gt;</span> node i <span class="constant">&lt;</span>| c.map (substitute &#183; assignment)
6086   | context i t <span class="constant">=&gt;</span> context i (substitute t assignment)
6087   | ofJson j <span class="constant">=&gt;</span> ofJson j
6088   | hole id  <span class="constant">=&gt;</span> <span class="keyword">match</span> assignment.find? id <span class="keyword">with</span>
6089     | none      <span class="constant">=&gt;</span> hole id
6090     | some tree <span class="constant">=&gt;</span> substitute tree assignment
6091 
<span class="keyword">6092 def</span> <span class="function-name">ContextInfo.runMetaM</span> (info : ContextInfo) (lctx : LocalContext) (x : MetaM &#945;) : IO &#945; <span class="constant">:=</span> <span class="keyword">do</span>
6093   <span class="keyword">let</span> x <span class="constant">:=</span> x.run { lctx <span class="constant">:=</span> lctx } { mctx <span class="constant">:=</span> info.mctx }
6094   <span class="keyword">let</span> ((a, <span class="preprocessor">_</span>), <span class="preprocessor">_</span>) &#8592; x.toIO { options <span class="constant">:=</span> info.options, currNamespace <span class="constant">:=</span> info.currNamespace, openDecls <span class="constant">:=</span> info.openDecls } { env <span class="constant">:=</span> info.env }
6095   <span class="keyword">return</span> a
6096 
<span class="keyword">6097 def</span> <span class="function-name">ContextInfo.toPPContext</span> (info : ContextInfo) (lctx : LocalContext) : PPContext <span class="constant">:=</span>
6098   { env  <span class="constant">:=</span> info.env, mctx <span class="constant">:=</span> info.mctx, lctx <span class="constant">:=</span> lctx,
6099     opts <span class="constant">:=</span> info.options, currNamespace <span class="constant">:=</span> info.currNamespace, openDecls <span class="constant">:=</span> info.openDecls }
6100 
<span class="keyword">6101 def</span> <span class="function-name">ContextInfo.ppSyntax</span> (info : ContextInfo) (lctx : LocalContext) (stx : Syntax) : IO Format <span class="constant">:=</span> <span class="keyword">do</span>
6102   ppTerm (info.toPPContext lctx) stx
6103 
<span class="keyword">6104 private</span> <span class="keyword">def</span> <span class="function-name">formatStxRange</span> (ctx : ContextInfo) (stx : Syntax) : Format <span class="constant">:=</span> <span class="keyword">do</span>
6105   <span class="keyword">let</span> pos    <span class="constant">:=</span> stx.getPos?.getD <span class="constant">0</span>
6106   <span class="keyword">let</span> endPos <span class="constant">:=</span> stx.getTailPos?.getD pos
6107   <span class="keyword">return</span> f<span class="constant">!</span><span class="string">"{fmtPos pos stx.getHeadInfo}-{fmtPos endPos stx.getTailInfo}"</span>
<span class="keyword">6108 where</span> fmtPos pos info <span class="constant">:=</span>
6109     <span class="keyword">let</span> pos <span class="constant">:=</span> format <span class="constant">&lt;</span>| ctx.fileMap.toPosition pos
6110     <span class="keyword">match</span> info <span class="keyword">with</span>
6111     | SourceInfo.original ..  <span class="constant">=&gt;</span> pos
6112     | <span class="preprocessor">_</span>                       <span class="constant">=&gt;</span> f<span class="constant">!</span><span class="string">"{pos}&#8224;"</span>
6113 
<span class="keyword">6114 def</span> <span class="function-name">TermInfo.runMetaM</span> (info : TermInfo) (ctx : ContextInfo) (x : MetaM &#945;) : IO &#945; <span class="constant">:=</span>
6115   ctx.runMetaM info.lctx x
6116 
<span class="keyword">6117 def</span> <span class="function-name">TermInfo.format</span> (ctx : ContextInfo) (info : TermInfo) : IO Format <span class="constant">:=</span> <span class="keyword">do</span>
6118   info.runMetaM ctx <span class="keyword">do</span>
6119     <span class="keyword">return</span> f<span class="constant">!</span><span class="string">"{&#8592; Meta.ppExpr info.expr} : {&#8592; Meta.ppExpr (&#8592; Meta.inferType info.expr)} @ {formatStxRange ctx info.stx}"</span>
6120 
<span class="keyword">6121 def</span> <span class="function-name">CompletionInfo.format</span> (ctx : ContextInfo) (info : CompletionInfo) : IO Format <span class="constant">:=</span>
6122   <span class="keyword">match</span> info <span class="keyword">with</span>
6123   | CompletionInfo.dot i (expectedType? <span class="constant">:=</span> expectedType?) .. <span class="constant">=&gt;</span> <span class="keyword">return</span> f<span class="constant">!</span><span class="string">"[.] {&#8592; i.format ctx} : {expectedType?}"</span>
6124   | CompletionInfo.id stx <span class="preprocessor">_</span> <span class="preprocessor">_</span> lctx expectedType? <span class="constant">=&gt;</span> ctx.runMetaM lctx <span class="keyword">do</span> <span class="keyword">return</span> f<span class="constant">!</span><span class="string">"[.] {stx} : {expectedType?} @ {formatStxRange ctx info.stx}"</span>
6125   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">return</span> f<span class="constant">!</span><span class="string">"[.] {info.stx} @ {formatStxRange ctx info.stx}"</span>
6126 
<span class="keyword">6127 def</span> <span class="function-name">CommandInfo.format</span> (ctx : ContextInfo) (info : CommandInfo) : IO Format <span class="constant">:=</span> <span class="keyword">do</span>
6128   <span class="keyword">return</span> f<span class="constant">!</span><span class="string">"command @ {formatStxRange ctx info.stx}"</span>
6129 
<span class="keyword">6130 def</span> <span class="function-name">FieldInfo.format</span> (ctx : ContextInfo) (info : FieldInfo) : IO Format <span class="constant">:=</span> <span class="keyword">do</span>
6131   ctx.runMetaM info.lctx <span class="keyword">do</span>
6132     <span class="keyword">return</span> f<span class="constant">!</span><span class="string">"{info.name} : {&#8592; Meta.ppExpr (&#8592; Meta.inferType info.val)} := {&#8592; Meta.ppExpr info.val} @ {formatStxRange ctx info.stx}"</span>
6133 
<span class="keyword">6134 def</span> <span class="function-name">ContextInfo.ppGoals</span> (ctx : ContextInfo) (goals : List MVarId) : IO Format <span class="constant">:=</span>
6135   <span class="keyword">if</span> goals.isEmpty <span class="keyword">then</span>
6136     <span class="keyword">return</span> <span class="string">"no goals"</span>
6137   <span class="keyword">else</span>
6138     ctx.runMetaM {} (<span class="keyword">return</span> Std.Format.prefixJoin <span class="string">"\n"</span> (&#8592; goals.mapM Meta.ppGoal))
6139 
<span class="keyword">6140 def</span> <span class="function-name">TacticInfo.format</span> (ctx : ContextInfo) (info : TacticInfo) : IO Format <span class="constant">:=</span> <span class="keyword">do</span>
6141   <span class="keyword">let</span> ctxB <span class="constant">:=</span> { ctx <span class="keyword">with</span> mctx <span class="constant">:=</span> info.mctxBefore }
6142   <span class="keyword">let</span> ctxA <span class="constant">:=</span> { ctx <span class="keyword">with</span> mctx <span class="constant">:=</span> info.mctxAfter }
6143   <span class="keyword">let</span> goalsBefore &#8592; ctxB.ppGoals info.goalsBefore
6144   <span class="keyword">let</span> goalsAfter  &#8592; ctxA.ppGoals info.goalsAfter
6145   <span class="keyword">return</span> f<span class="constant">!</span><span class="string">"Tactic @ {formatStxRange ctx info.stx}\nbefore {goalsBefore}\nafter {goalsAfter}"</span>
6146 
<span class="keyword">6147 def</span> <span class="function-name">MacroExpansionInfo.format</span> (ctx : ContextInfo) (info : MacroExpansionInfo) : IO Format <span class="constant">:=</span> <span class="keyword">do</span>
6148   <span class="keyword">let</span> before &#8592; ctx.ppSyntax info.lctx info.before
6149   <span class="keyword">let</span> after  &#8592; ctx.ppSyntax info.lctx info.after
6150   <span class="keyword">return</span> f<span class="constant">!</span><span class="string">"Macro expansion\n{before}\n===&gt;\n{after}"</span>
6151 
<span class="keyword">6152 def</span> <span class="function-name">Info.format</span> (ctx : ContextInfo) : Info <span class="constant">&#8594;</span> IO Format
6153   | ofTacticInfo i         <span class="constant">=&gt;</span> i.format ctx
6154   | ofTermInfo i           <span class="constant">=&gt;</span> i.format ctx
6155   | ofCommandInfo i        <span class="constant">=&gt;</span> i.format ctx
6156   | ofMacroExpansionInfo i <span class="constant">=&gt;</span> i.format ctx
6157   | ofFieldInfo i          <span class="constant">=&gt;</span> i.format ctx
6158   | ofCompletionInfo i     <span class="constant">=&gt;</span> i.format ctx
6159 
<span class="comment-delimiter">6160 /-</span><span class="comment">-
6161   Helper function for propagating the tactic metavariable context to its children nodes.
6162   We need this function because we preserve `TacticInfo` nodes during backtracking *and* their
6163   children. Moreover, we backtrack the metavariable context to undo metavariable assignments.
6164   `TacticInfo` nodes save the metavariable context before/after the tactic application, and
6165   can be pretty printed without any extra information. This is not the case for `TermInfo` nodes.
6166   Without this function, the formatting method would often fail when processing `TermInfo` nodes
6167   that are children of `TacticInfo` nodes that have been preserved during backtracking.
6168   Saving the metavariable context at `TermInfo` nodes is also not a good option because
6169   at `TermInfo` creation time, the metavariable context often miss information, e.g.,
6170   a TC problem has not been resolved, a postponed subterm has not been elaborated, etc.
6171 
6172   See `Term.SavedState.restore`.
6173 -/</span>
<span class="keyword">6174 def</span> <span class="function-name">Info.updateContext?</span> : Option ContextInfo <span class="constant">&#8594;</span> Info <span class="constant">&#8594;</span> Option ContextInfo
6175   | some ctx, ofTacticInfo i <span class="constant">=&gt;</span> some { ctx <span class="keyword">with</span> mctx <span class="constant">:=</span> i.mctxAfter }
6176   | ctx?, <span class="preprocessor">_</span> <span class="constant">=&gt;</span> ctx?
6177 
<span class="keyword">6178 partial</span> <span class="keyword">def</span> <span class="function-name">InfoTree.format</span> (tree : InfoTree) (ctx? : Option ContextInfo <span class="constant">:=</span> none) : IO Format <span class="constant">:=</span> <span class="keyword">do</span>
6179   <span class="keyword">match</span> tree <span class="keyword">with</span>
6180   | ofJson j    <span class="constant">=&gt;</span> <span class="keyword">return</span> toString j
6181   | hole id     <span class="constant">=&gt;</span> <span class="keyword">return</span> toString id
6182   | context i t <span class="constant">=&gt;</span> format t i
6183   | node i cs   <span class="constant">=&gt;</span> <span class="keyword">match</span> ctx? <span class="keyword">with</span>
6184     | none <span class="constant">=&gt;</span> <span class="keyword">return</span> <span class="string">"&lt;context-not-available&gt;"</span>
6185     | some ctx <span class="constant">=&gt;</span>
6186       <span class="keyword">let</span> fmt &#8592; i.format ctx
6187       <span class="keyword">if</span> cs.size <span class="constant">==</span> <span class="constant">0</span> <span class="keyword">then</span>
6188         <span class="keyword">return</span> fmt
6189       <span class="keyword">else</span>
6190         <span class="keyword">let</span> ctx? <span class="constant">:=</span> i.updateContext? ctx?
6191         <span class="keyword">return</span> f<span class="constant">!</span><span class="string">"{fmt}{Std.Format.nestD &lt;| Std.Format.prefixJoin "</span>\n<span class="string">" (&#8592; cs.toList.mapM fun c =&gt; format c ctx?)}"</span>
6192 
<span class="keyword">6193 section</span>
<span class="keyword">6194 variable</span> [Monad m] [MonadInfoTree m]
6195 
<span class="doc">6196 @[inline]</span> <span class="keyword">private</span> <span class="keyword">def</span> <span class="function-name">modifyInfoTrees</span> (f : PersistentArray InfoTree <span class="constant">&#8594;</span> PersistentArray InfoTree) : m Unit <span class="constant">:=</span>
6197   modifyInfoState <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> trees <span class="constant">:=</span> f s.trees }
6198 
<span class="keyword">6199 private</span> <span class="keyword">def</span> <span class="function-name">getResetInfoTrees</span> : m (PersistentArray InfoTree) <span class="constant">:=</span> <span class="keyword">do</span>
6200   <span class="keyword">let</span> trees <span class="constant">:=</span> (&#8592; getInfoState).trees
6201   modifyInfoTrees <span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> {}
6202   <span class="keyword">return</span> trees
6203 
<span class="keyword">6204 def</span> <span class="function-name">pushInfoTree</span> (t : InfoTree) : m Unit <span class="constant">:=</span> <span class="keyword">do</span>
6205   <span class="keyword">if</span> (&#8592; getInfoState).enabled <span class="keyword">then</span>
6206     modifyInfoTrees <span class="keyword">fun</span> ts <span class="constant">=&gt;</span> ts.push t
6207 
<span class="keyword">6208 def</span> <span class="function-name">pushInfoLeaf</span> (t : Info) : m Unit <span class="constant">:=</span> <span class="keyword">do</span>
6209   <span class="keyword">if</span> (&#8592; getInfoState).enabled <span class="keyword">then</span>
6210     pushInfoTree <span class="constant">&lt;</span>| InfoTree.node (children <span class="constant">:=</span> {}) t
6211 
<span class="keyword">6212 def</span> <span class="function-name">addCompletionInfo</span> (info : CompletionInfo) : m Unit <span class="constant">:=</span> <span class="keyword">do</span>
6213   pushInfoLeaf <span class="constant">&lt;</span>| Info.ofCompletionInfo info
6214 
<span class="keyword">6215 def</span> <span class="function-name">resolveGlobalConstNoOverloadWithInfo</span> [MonadResolveName m] [MonadEnv m] [MonadError m] (stx : Syntax) (id <span class="constant">:=</span> stx.getId) : m Name <span class="constant">:=</span> <span class="keyword">do</span>
6216   <span class="keyword">let</span> n &#8592; resolveGlobalConstNoOverload id
6217   <span class="keyword">if</span> (&#8592; getInfoState).enabled <span class="keyword">then</span>
6218     pushInfoLeaf <span class="constant">&lt;</span>| Info.ofTermInfo { lctx <span class="constant">:=</span> LocalContext.empty, expr <span class="constant">:=</span> (&#8592; mkConstWithLevelParams n), stx <span class="constant">:=</span> stx }
6219   <span class="keyword">return</span> n
6220 
<span class="keyword">6221 def</span> <span class="function-name">resolveGlobalConstWithInfos</span> [MonadResolveName m] [MonadEnv m] [MonadError m] (stx : Syntax) (id <span class="constant">:=</span> stx.getId) : m (List Name) <span class="constant">:=</span> <span class="keyword">do</span>
6222   <span class="keyword">let</span> ns &#8592; resolveGlobalConst id
6223   <span class="keyword">if</span> (&#8592; getInfoState).enabled <span class="keyword">then</span>
6224     <span class="keyword">for</span> n <span class="keyword">in</span> ns <span class="keyword">do</span>
6225       pushInfoLeaf <span class="constant">&lt;</span>| Info.ofTermInfo { lctx <span class="constant">:=</span> LocalContext.empty, expr <span class="constant">:=</span> (&#8592; mkConstWithLevelParams n), stx <span class="constant">:=</span> stx }
6226   <span class="keyword">return</span> ns
6227 
<span class="keyword">6228 def</span> <span class="function-name">mkInfoNode</span> (info : Info) : m Unit <span class="constant">:=</span> <span class="keyword">do</span>
6229   <span class="keyword">if</span> (&#8592; getInfoState).enabled <span class="keyword">then</span>
6230     modifyInfoTrees <span class="keyword">fun</span> ts <span class="constant">=&gt;</span> PersistentArray.empty.push <span class="constant">&lt;</span>| InfoTree.node info ts
6231 
<span class="doc">6232 @[inline]</span> <span class="keyword">def</span> <span class="function-name">withInfoContext'</span> [MonadFinally m] (x : m &#945;) (mkInfo : &#945; <span class="constant">&#8594;</span> m (Sum Info MVarId)) : m &#945; <span class="constant">:=</span> <span class="keyword">do</span>
6233   <span class="keyword">if</span> (&#8592; getInfoState).enabled <span class="keyword">then</span>
6234     <span class="keyword">let</span> treesSaved &#8592; getResetInfoTrees
6235     Prod.fst <span class="constant">&lt;$&gt;</span> MonadFinally.tryFinally' x <span class="keyword">fun</span> a? <span class="constant">=&gt;</span> <span class="keyword">do</span>
6236       <span class="keyword">match</span> a? <span class="keyword">with</span>
6237       | none   <span class="constant">=&gt;</span> modifyInfoTrees <span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> treesSaved
6238       | some a <span class="constant">=&gt;</span>
6239         <span class="keyword">let</span> info &#8592; mkInfo a
6240         modifyInfoTrees <span class="keyword">fun</span> trees <span class="constant">=&gt;</span>
6241           <span class="keyword">match</span> info <span class="keyword">with</span>
6242           | Sum.inl info  <span class="constant">=&gt;</span> treesSaved.push <span class="constant">&lt;</span>| InfoTree.node info trees
6243           | Sum.inr mvaId <span class="constant">=&gt;</span> treesSaved.push <span class="constant">&lt;</span>| InfoTree.hole mvaId
6244   <span class="keyword">else</span>
6245     x
6246 
<span class="doc">6247 @[inline]</span> <span class="keyword">def</span> <span class="function-name">withInfoTreeContext</span> [MonadFinally m] (x : m &#945;) (mkInfoTree : PersistentArray InfoTree <span class="constant">&#8594;</span> m InfoTree) : m &#945; <span class="constant">:=</span> <span class="keyword">do</span>
6248   <span class="keyword">if</span> (&#8592; getInfoState).enabled <span class="keyword">then</span>
6249     <span class="keyword">let</span> treesSaved &#8592; getResetInfoTrees
6250     Prod.fst <span class="constant">&lt;$&gt;</span> MonadFinally.tryFinally' x <span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">do</span>
6251       <span class="keyword">let</span> st    &#8592; getInfoState
6252       <span class="keyword">let</span> tree  &#8592; mkInfoTree st.trees
6253       modifyInfoTrees <span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> treesSaved.push tree
6254   <span class="keyword">else</span>
6255     x
6256 
<span class="doc">6257 @[inline]</span> <span class="keyword">def</span> <span class="function-name">withInfoContext</span> [MonadFinally m] (x : m &#945;) (mkInfo : m Info) : m &#945; <span class="constant">:=</span> <span class="keyword">do</span>
6258   withInfoTreeContext x (<span class="keyword">fun</span> trees <span class="constant">=&gt;</span> <span class="keyword">do</span> <span class="keyword">return</span> InfoTree.node (&#8592; mkInfo) trees)
6259 
<span class="keyword">6260 def</span> <span class="function-name">getInfoHoleIdAssignment?</span> (mvarId : MVarId) : m (Option InfoTree) <span class="constant">:=</span>
6261   <span class="keyword">return</span> (&#8592; getInfoState).assignment[mvarId]
6262 
<span class="keyword">6263 def</span> <span class="function-name">assignInfoHoleId</span> (mvarId : MVarId) (infoTree : InfoTree) : m Unit <span class="constant">:=</span> <span class="keyword">do</span>
6264   <span class="warning">assert</span><span class="constant">!</span> (&#8592; getInfoHoleIdAssignment? mvarId).isNone
6265   modifyInfoState <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> assignment <span class="constant">:=</span> s.assignment.insert mvarId infoTree }
<span class="keyword">6266 end</span>
6267 
<span class="keyword">6268 def</span> <span class="function-name">withMacroExpansionInfo</span> [MonadFinally m] [Monad m] [MonadInfoTree m] [MonadLCtx m] (before after : Syntax) (x : m &#945;) : m &#945; <span class="constant">:=</span>
6269   <span class="keyword">let</span> mkInfo : m Info <span class="constant">:=</span> <span class="keyword">do</span>
6270     <span class="keyword">return</span> Info.ofMacroExpansionInfo {
6271       lctx   <span class="constant">:=</span> (&#8592; getLCtx)
6272       before <span class="constant">:=</span> before
6273       after  <span class="constant">:=</span> after
6274     }
6275   withInfoContext x mkInfo
6276 
<span class="doc">6277 @[inline]</span> <span class="keyword">def</span> <span class="function-name">withInfoHole</span> [MonadFinally m] [Monad m] [MonadInfoTree m] (mvarId : MVarId) (x : m &#945;) : m &#945; <span class="constant">:=</span> <span class="keyword">do</span>
6278   <span class="keyword">if</span> (&#8592; getInfoState).enabled <span class="keyword">then</span>
6279     <span class="keyword">let</span> treesSaved &#8592; getResetInfoTrees
6280     Prod.fst <span class="constant">&lt;$&gt;</span> MonadFinally.tryFinally' x <span class="keyword">fun</span> a? <span class="constant">=&gt;</span> modifyInfoState <span class="keyword">fun</span> s <span class="constant">=&gt;</span>
6281       <span class="keyword">if</span> s.trees.size <span class="constant">&gt;</span> <span class="constant">0</span> <span class="keyword">then</span>
6282         { s <span class="keyword">with</span> trees <span class="constant">:=</span> treesSaved, assignment <span class="constant">:=</span> s.assignment.insert mvarId s.trees[s.trees.size <span class="constant">-</span> <span class="constant">1</span>] }
6283       <span class="keyword">else</span>
6284         { s <span class="keyword">with</span> trees <span class="constant">:=</span> treesSaved }
6285   <span class="keyword">else</span>
6286     x
6287 
<span class="keyword">6288 def</span> <span class="function-name">enableInfoTree</span> [MonadInfoTree m] (flag <span class="constant">:=</span> true) : m Unit <span class="constant">:=</span>
6289   modifyInfoState <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> enabled <span class="constant">:=</span> flag }
6290 
<span class="keyword">6291 def</span> <span class="function-name">getInfoTrees</span> [MonadInfoTree m] [Monad m] : m (PersistentArray InfoTree) <span class="constant">:=</span>
6292   <span class="keyword">return</span> (&#8592; getInfoState).trees
6293 
<span class="keyword">6294 end</span> Lean.Elab
6295 ::::::::::::::
6296 Elab<span class="constant">/</span>LetRec.lean
6297 ::::::::::::::
<span class="comment-delimiter">6298 /-</span><span class="comment">
6299 Copyright (c) 2020 Microsoft Corporation. All rights reserved.
6300 Released under Apache 2.0 license as described in the file LICENSE.
6301 Authors: Leonardo de Moura
6302 -/</span>
<span class="keyword">6303 import</span> Lean.Elab.Attributes
<span class="keyword">6304 import</span> Lean.Elab.Binders
<span class="keyword">6305 import</span> Lean.Elab.DeclModifiers
<span class="keyword">6306 import</span> Lean.Elab.SyntheticMVars
<span class="keyword">6307 import</span> Lean.Elab.DeclarationRange
6308 
<span class="keyword">6309 namespace</span> Lean.Elab.Term
<span class="keyword">6310 open</span> Meta
6311 
<span class="keyword">6312 structure</span> <span class="function-name">LetRecDeclView</span> <span class="keyword">where</span>
6313   ref           : Syntax
6314   attrs         : Array Attribute
6315   shortDeclName : Name
6316   declName      : Name
6317   numParams     : Nat
6318   type          : Expr
6319   mvar          : Expr <span class="comment-delimiter">-- </span><span class="comment">auxiliary metavariable used to lift the 'let rec'
</span>6320   valStx        : Syntax
6321 
<span class="keyword">6322 structure</span> <span class="function-name">LetRecView</span> <span class="keyword">where</span>
6323   decls     : Array LetRecDeclView
6324   body      : Syntax
6325 
<span class="comment-delimiter">6326 /-  </span><span class="comment">group ("let " &gt;&gt; nonReservedSymbol "rec ") &gt;&gt; sepBy1 (group (optional &#171;</span>attributes<span class="comment">&#187; &gt;&gt; letDecl)) ", " &gt;&gt; "; " &gt;&gt; termParser -/</span>
<span class="keyword">6327 private</span> <span class="keyword">def</span> <span class="function-name">mkLetRecDeclView</span> (letRec : Syntax) : TermElabM LetRecView <span class="constant">:=</span> <span class="keyword">do</span>
6328   <span class="keyword">let</span> decls &#8592; letRec[<span class="constant">1</span>][<span class="constant">0</span>].getSepArgs.mapM <span class="keyword">fun</span> (attrDeclStx : Syntax) <span class="constant">=&gt;</span> <span class="keyword">do</span>
6329     <span class="keyword">let</span> docStr? &#8592; expandOptDocComment? attrDeclStx[<span class="constant">0</span>]
6330     <span class="keyword">let</span> attrOptStx <span class="constant">:=</span> attrDeclStx[<span class="constant">1</span>]
6331     <span class="keyword">let</span> attrs &#8592; <span class="keyword">if</span> attrOptStx.isNone <span class="keyword">then</span> pure <span class="constant">#</span>[] <span class="keyword">else</span> elabDeclAttrs attrOptStx[<span class="constant">0</span>]
6332     <span class="keyword">let</span> decl <span class="constant">:=</span> attrDeclStx[<span class="constant">2</span>][<span class="constant">0</span>]
6333     <span class="keyword">if</span> decl.isOfKind `Lean.Parser.Term.letPatDecl <span class="keyword">then</span>
6334       throwErrorAt decl <span class="string">"patterns are not allowed in 'let rec' expressions"</span>
6335     <span class="keyword">else</span> <span class="keyword">if</span> decl.isOfKind `Lean.Parser.Term.letIdDecl <span class="constant">||</span> decl.isOfKind `Lean.Parser.Term.letEqnsDecl <span class="keyword">then</span>
6336       <span class="keyword">let</span> shortDeclName <span class="constant">:=</span> decl[<span class="constant">0</span>].getId
6337       <span class="keyword">let</span> currDeclName? &#8592; getDeclName?
6338       <span class="keyword">let</span> declName <span class="constant">:=</span> currDeclName?.getD Name.anonymous <span class="constant">++</span> shortDeclName
6339       checkNotAlreadyDeclared declName
6340       applyAttributesAt declName attrs AttributeApplicationTime.beforeElaboration
6341       addDocString' declName docStr?
6342       addAuxDeclarationRanges declName decl decl[<span class="constant">0</span>]
6343       <span class="keyword">let</span> binders <span class="constant">:=</span> decl[<span class="constant">1</span>].getArgs
6344       <span class="keyword">let</span> typeStx <span class="constant">:=</span> expandOptType decl decl[<span class="constant">2</span>]
6345       <span class="keyword">let</span> (type, numParams) &#8592; elabBinders binders <span class="keyword">fun</span> xs <span class="constant">=&gt;</span> <span class="keyword">do</span>
6346           <span class="keyword">let</span> type &#8592; elabType typeStx
6347           registerCustomErrorIfMVar type typeStx <span class="string">"failed to infer 'let rec' declaration type"</span>
6348           <span class="keyword">let</span> type &#8592; mkForallFVars xs type
6349           pure (type, xs.size)
6350       <span class="keyword">let</span> mvar &#8592; mkFreshExprMVar type MetavarKind.syntheticOpaque
6351       <span class="keyword">let</span> valStx &#8592;
6352         <span class="keyword">if</span> decl.isOfKind `Lean.Parser.Term.letIdDecl <span class="keyword">then</span>
6353           pure decl[<span class="constant">4</span>]
6354         <span class="keyword">else</span>
6355           liftMacroM <span class="constant">$</span> expandMatchAltsIntoMatch decl decl[<span class="constant">3</span>]
6356       pure {
6357         ref           <span class="constant">:=</span> decl,
6358         attrs         <span class="constant">:=</span> attrs,
6359         shortDeclName <span class="constant">:=</span> shortDeclName,
6360         declName      <span class="constant">:=</span> declName,
6361         numParams     <span class="constant">:=</span> numParams,
6362         type          <span class="constant">:=</span> type,
6363         mvar          <span class="constant">:=</span> mvar,
6364         valStx        <span class="constant">:=</span> valStx
6365         : LetRecDeclView }
6366     <span class="keyword">else</span>
6367       throwUnsupportedSyntax
6368   pure {
6369     decls <span class="constant">:=</span> decls,
6370     body  <span class="constant">:=</span> letRec[<span class="constant">3</span>]
6371   }
6372 
<span class="keyword">6373 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">withAuxLocalDecls</span> {&#945;} (views : Array LetRecDeclView) (k : Array Expr <span class="constant">&#8594;</span> TermElabM &#945;) : TermElabM &#945; <span class="constant">:=</span>
6374   <span class="keyword">let</span> <span class="keyword">rec</span> loop (i : Nat) (fvars : Array Expr) : TermElabM &#945; <span class="constant">:=</span>
6375     <span class="keyword">if</span> h : i <span class="constant">&lt;</span> views.size <span class="keyword">then</span>
6376       <span class="keyword">let</span> view <span class="constant">:=</span> views.get &#10216;i, h&#10217;
6377       withLocalDeclD view.shortDeclName view.type <span class="keyword">fun</span> fvar <span class="constant">=&gt;</span> loop (i<span class="constant">+1</span>) (fvars.push fvar)
6378     <span class="keyword">else</span>
6379       k fvars
6380   loop <span class="constant">0</span> <span class="constant">#</span>[]
6381 
<span class="keyword">6382 private</span> <span class="keyword">def</span> <span class="function-name">elabLetRecDeclValues</span> (view : LetRecView) : TermElabM (Array Expr) <span class="constant">:=</span>
6383   view.decls.mapM <span class="keyword">fun</span> view <span class="constant">=&gt;</span> <span class="keyword">do</span>
6384     forallBoundedTelescope view.type view.numParams <span class="keyword">fun</span> xs type <span class="constant">=&gt;</span>
6385        withDeclName view.declName <span class="keyword">do</span>
6386          <span class="keyword">let</span> value &#8592; elabTermEnsuringType view.valStx type
6387          mkLambdaFVars xs value
6388 
<span class="keyword">6389 private</span> <span class="keyword">def</span> <span class="function-name">registerLetRecsToLift</span> (views : Array LetRecDeclView) (fvars : Array Expr) (values : Array Expr) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
6390   <span class="keyword">let</span> letRecsToLiftCurr <span class="constant">:=</span> (&#8592; get).letRecsToLift
6391   <span class="keyword">for</span> view <span class="keyword">in</span> views <span class="keyword">do</span>
6392     <span class="keyword">if</span> letRecsToLiftCurr.any <span class="keyword">fun</span> toLift <span class="constant">=&gt;</span> toLift.declName <span class="constant">==</span> view.declName <span class="keyword">then</span>
6393       withRef view.ref <span class="keyword">do</span>
6394         throwError <span class="string">"'{view.declName}' has already been declared"</span>
6395   <span class="keyword">let</span> lctx &#8592; getLCtx
6396   <span class="keyword">let</span> localInsts &#8592; getLocalInstances
6397   <span class="keyword">let</span> toLift <span class="constant">:=</span> views.mapIdx <span class="keyword">fun</span> i view <span class="constant">=&gt;</span> {
6398     ref            <span class="constant">:=</span> view.ref,
6399     fvarId         <span class="constant">:=</span> fvars[i].fvarId<span class="constant">!</span>,
6400     attrs          <span class="constant">:=</span> view.attrs,
6401     shortDeclName  <span class="constant">:=</span> view.shortDeclName,
6402     declName       <span class="constant">:=</span> view.declName,
6403     lctx           <span class="constant">:=</span> lctx,
6404     localInstances <span class="constant">:=</span> localInsts,
6405     type           <span class="constant">:=</span> view.type,
6406     val            <span class="constant">:=</span> values[i],
6407     mvarId         <span class="constant">:=</span> view.mvar.mvarId<span class="constant">!</span>
6408     : LetRecToLift }
6409   modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> letRecsToLift <span class="constant">:=</span> toLift.toList <span class="constant">++</span> s.letRecsToLift }
6410 
<span class="constant">6411 @</span>[builtinTermElab <span class="comment">&#171;</span>letrec<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabLetRec</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span> <span class="keyword">do</span>
6412   <span class="keyword">let</span> view &#8592; mkLetRecDeclView stx
6413   withAuxLocalDecls view.decls <span class="keyword">fun</span> fvars <span class="constant">=&gt;</span> <span class="keyword">do</span>
6414     <span class="keyword">let</span> values &#8592; elabLetRecDeclValues view
6415     <span class="keyword">let</span> body &#8592; elabTermEnsuringType view.body expectedType?
6416     registerLetRecsToLift view.decls fvars values
6417     <span class="keyword">let</span> mvars <span class="constant">:=</span> view.decls.map (&#183;.mvar)
6418     pure <span class="constant">$</span> mkAppN (&#8592; mkLambdaFVars fvars body) mvars
6419 
<span class="keyword">6420 end</span> Lean.Elab.Term
6421 ::::::::::::::
6422 Elab<span class="constant">/</span>Level.lean
6423 ::::::::::::::
<span class="comment-delimiter">6424 /-</span><span class="comment">
6425 Copyright (c) 2019 Microsoft Corporation. All rights reserved.
6426 Released under Apache 2.0 license as described in the file LICENSE.
6427 Authors: Leonardo de Moura
6428 -/</span>
<span class="keyword">6429 import</span> Lean.Meta.LevelDefEq
<span class="keyword">6430 import</span> Lean.Elab.Exception
<span class="keyword">6431 import</span> Lean.Elab.Log
<span class="keyword">6432 import</span> Lean.Elab.AutoBound
6433 
<span class="keyword">6434 namespace</span> Lean.Elab.Level
6435 
<span class="keyword">6436 structure</span> <span class="function-name">Context</span> <span class="keyword">where</span>
6437   options           : Options
6438   ref               : Syntax
6439   autoBoundImplicit : Bool
6440 
<span class="keyword">6441 structure</span> <span class="function-name">State</span> <span class="keyword">where</span>
6442   ngen       : NameGenerator
6443   mctx       : MetavarContext
6444   levelNames : List Name
6445 
<span class="keyword">6446 abbrev</span> LevelElabM <span class="constant">:=</span> ReaderT Context (EStateM Exception State)
6447 
<span class="keyword">6448 instance</span> <span class="function-name">:</span> MonadOptions LevelElabM <span class="keyword">where</span>
6449   getOptions <span class="constant">:=</span> <span class="keyword">return</span> (&#8592; read).options
6450 
<span class="keyword">6451 instance</span> <span class="function-name">:</span> MonadRef LevelElabM <span class="keyword">where</span>
6452   getRef        <span class="constant">:=</span> <span class="keyword">return</span> (&#8592; read).ref
6453   withRef ref x <span class="constant">:=</span> withReader (<span class="keyword">fun</span> ctx <span class="constant">=&gt;</span> { ctx <span class="keyword">with</span> ref <span class="constant">:=</span> ref }) x
6454 
<span class="keyword">6455 instance</span> <span class="function-name">:</span> AddMessageContext LevelElabM <span class="keyword">where</span>
6456   addMessageContext msg <span class="constant">:=</span> pure msg
6457 
<span class="keyword">6458 instance</span> <span class="function-name">:</span> MonadNameGenerator LevelElabM <span class="keyword">where</span>
6459   getNGen <span class="constant">:=</span> <span class="keyword">return</span> (&#8592; get).ngen
6460 
6461   setNGen ngen <span class="constant">:=</span> modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> ngen <span class="constant">:=</span> ngen }
6462 
<span class="keyword">6463 def</span> <span class="function-name">mkFreshLevelMVar</span> : LevelElabM Level <span class="constant">:=</span> <span class="keyword">do</span>
6464   <span class="keyword">let</span> mvarId &#8592; mkFreshId
6465   modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> mctx <span class="constant">:=</span> s.mctx.addLevelMVarDecl mvarId }
6466   <span class="keyword">return</span> mkLevelMVar mvarId
6467 
<span class="keyword">6468 register_builtin_option</span> maxUniverseOffset : Nat <span class="constant">:=</span> {
6469   defValue <span class="constant">:=</span> <span class="constant">32</span>
6470   descr    <span class="constant">:=</span> <span class="string">"maximum universe level offset"</span>
6471 }
6472 
<span class="keyword">6473 private</span> <span class="keyword">def</span> <span class="function-name">checkUniverseOffset</span> [Monad m] [MonadError m] [MonadOptions m] (n : Nat) : m Unit <span class="constant">:=</span> <span class="keyword">do</span>
6474   <span class="keyword">let</span> max <span class="constant">:=</span> maxUniverseOffset.get (&#8592; getOptions)
6475   <span class="keyword">unless</span> n <span class="constant">&lt;=</span> max <span class="keyword">do</span>
6476     throwError <span class="string">"maximum universe level offset threshold ({max}) has been reached, you can increase the limit using option `set_option maxUniverseOffset &lt;limit&gt;`, but you are probably misusing universe levels since offsets are usually small natural numbers"</span>
6477 
<span class="keyword">6478 partial</span> <span class="keyword">def</span> <span class="function-name">elabLevel</span> (stx : Syntax) : LevelElabM Level <span class="constant">:=</span> withRef stx <span class="keyword">do</span>
6479   <span class="keyword">let</span> kind <span class="constant">:=</span> stx.getKind
6480   <span class="keyword">if</span> kind <span class="constant">==</span> `Lean.Parser.Level.paren <span class="keyword">then</span>
6481     elabLevel (stx.getArg <span class="constant">1</span>)
6482   <span class="keyword">else</span> <span class="keyword">if</span> kind <span class="constant">==</span> `Lean.Parser.Level.max <span class="keyword">then</span>
6483     <span class="keyword">let</span> args <span class="constant">:=</span> stx.getArg <span class="constant">1</span> |<span class="constant">&gt;</span>.getArgs
6484     args[:args.size <span class="constant">-</span> <span class="constant">1</span>].foldrM (init <span class="constant">:=</span> &#8592; elabLevel args.back) <span class="keyword">fun</span> stx lvl <span class="constant">=&gt;</span>
6485       <span class="keyword">return</span> mkLevelMax' (&#8592; elabLevel stx) lvl
6486   <span class="keyword">else</span> <span class="keyword">if</span> kind <span class="constant">==</span> `Lean.Parser.Level.imax <span class="keyword">then</span>
6487     <span class="keyword">let</span> args <span class="constant">:=</span> stx.getArg <span class="constant">1</span> |<span class="constant">&gt;</span>.getArgs
6488     args[:args.size <span class="constant">-</span> <span class="constant">1</span>].foldrM (init <span class="constant">:=</span> &#8592; elabLevel args.back) <span class="keyword">fun</span> stx lvl <span class="constant">=&gt;</span>
6489       <span class="keyword">return</span> mkLevelIMax' (&#8592; elabLevel stx) lvl
6490   <span class="keyword">else</span> <span class="keyword">if</span> kind <span class="constant">==</span> `Lean.Parser.Level.hole <span class="keyword">then</span>
6491     mkFreshLevelMVar
6492   <span class="keyword">else</span> <span class="keyword">if</span> kind <span class="constant">==</span> numLitKind <span class="keyword">then</span>
6493     <span class="keyword">match</span> stx.isNatLit? <span class="keyword">with</span>
6494     | some val <span class="constant">=&gt;</span> checkUniverseOffset val; <span class="keyword">return</span> Level.ofNat val
6495     | none     <span class="constant">=&gt;</span> throwIllFormedSyntax
6496   <span class="keyword">else</span> <span class="keyword">if</span> kind <span class="constant">==</span> identKind <span class="keyword">then</span>
6497     <span class="keyword">let</span> paramName <span class="constant">:=</span> stx.getId
6498     <span class="keyword">unless</span> (&#8592; get).levelNames.contains paramName <span class="keyword">do</span>
6499       <span class="keyword">if</span> (&#8592; read).autoBoundImplicit <span class="constant">&amp;&amp;</span> isValidAutoBoundLevelName paramName <span class="keyword">then</span>
6500         modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> levelNames <span class="constant">:=</span> paramName :: s.levelNames }
6501       <span class="keyword">else</span>
6502         throwError <span class="string">"unknown universe level '{paramName}'"</span>
6503     <span class="keyword">return</span> mkLevelParam paramName
6504   <span class="keyword">else</span> <span class="keyword">if</span> kind <span class="constant">==</span> `Lean.Parser.Level.addLit <span class="keyword">then</span>
6505     <span class="keyword">let</span> lvl &#8592; elabLevel (stx.getArg <span class="constant">0</span>)
6506     <span class="keyword">match</span> stx.getArg <span class="constant">2</span> |<span class="constant">&gt;</span>.isNatLit? <span class="keyword">with</span>
6507     | some val <span class="constant">=&gt;</span> checkUniverseOffset val; <span class="keyword">return</span> lvl.addOffset val
6508     | none     <span class="constant">=&gt;</span> throwIllFormedSyntax
6509   <span class="keyword">else</span>
6510     throwError <span class="string">"unexpected universe level syntax kind"</span>
6511 
<span class="keyword">6512 end</span> Lean.Elab.Level
6513 ::::::::::::::
6514 Elab<span class="constant">/</span>Log.lean
6515 ::::::::::::::
<span class="comment-delimiter">6516 /-</span><span class="comment">
6517 Copyright (c) 2019 Microsoft Corporation. All rights reserved.
6518 Released under Apache 2.0 license as described in the file LICENSE.
6519 Authors: Leonardo de Moura
6520 -/</span>
<span class="keyword">6521 import</span> Lean.Elab.Util
<span class="keyword">6522 import</span> Lean.Util.Sorry
<span class="keyword">6523 import</span> Lean.Elab.Exception
6524 
<span class="keyword">6525 namespace</span> Lean.Elab
6526 
<span class="keyword">6527 class</span> <span class="function-name">MonadFileMap</span> (m : <span class="type">Type</span> <span class="constant">&#8594;</span> <span class="type">Type</span>) <span class="keyword">where</span>
6528   getFileMap  : m FileMap
6529 
<span class="keyword">6530 export</span> MonadFileMap (getFileMap)
6531 
<span class="keyword">6532 class</span> <span class="function-name">MonadLog</span> (m : <span class="type">Type</span> <span class="constant">&#8594;</span> <span class="type">Type</span>) <span class="keyword">extends</span> MonadFileMap m <span class="keyword">where</span>
6533   getRef       : m Syntax
6534   getFileName  : m String
6535   logMessage   : Message <span class="constant">&#8594;</span> m Unit
6536 
<span class="keyword">6537 export</span> MonadLog (getFileName logMessage)
6538 
<span class="keyword">6539 instance</span> (m n) [MonadLift m n] [MonadLog m] : MonadLog n <span class="keyword">where</span>
6540   getRef      <span class="constant">:=</span> liftM (MonadLog.getRef : m <span class="preprocessor">_</span>)
6541   getFileMap  <span class="constant">:=</span> liftM (getFileMap : m <span class="preprocessor">_</span>)
6542   getFileName <span class="constant">:=</span> liftM (getFileName : m <span class="preprocessor">_</span>)
6543   logMessage  <span class="constant">:=</span> <span class="keyword">fun</span> msg <span class="constant">=&gt;</span> liftM (logMessage msg : m <span class="preprocessor">_</span> )
6544 
<span class="keyword">6545 variable</span> {m : <span class="type">Type</span> <span class="constant">&#8594;</span> <span class="type">Type</span>} [Monad m] [MonadLog m] [AddMessageContext m]
6546 
<span class="keyword">6547 def</span> <span class="function-name">getRefPos</span> : m String.Pos <span class="constant">:=</span> <span class="keyword">do</span>
6548   <span class="keyword">let</span> ref &#8592; MonadLog.getRef
6549   <span class="keyword">return</span> ref.getPos?.getD <span class="constant">0</span>
6550 
<span class="keyword">6551 def</span> <span class="function-name">getRefPosition</span> : m Position <span class="constant">:=</span> <span class="keyword">do</span>
6552   <span class="keyword">let</span> fileMap &#8592; getFileMap
6553   <span class="keyword">return</span> fileMap.toPosition (&#8592; getRefPos)
6554 
<span class="keyword">6555 def</span> <span class="function-name">logAt</span> (ref : Syntax) (msgData : MessageData) (severity : MessageSeverity <span class="constant">:=</span> MessageSeverity.error): m Unit <span class="constant">:=</span>
6556   <span class="keyword">unless</span> severity <span class="constant">==</span> MessageSeverity.error <span class="constant">&amp;&amp;</span> msgData.hasSyntheticSorry <span class="keyword">do</span>
6557     <span class="keyword">let</span> ref    <span class="constant">:=</span> replaceRef ref (&#8592; MonadLog.getRef)
6558     <span class="keyword">let</span> pos    <span class="constant">:=</span> ref.getPos?.getD <span class="constant">0</span>
6559     <span class="keyword">let</span> endPos <span class="constant">:=</span> ref.getTailPos?.getD pos
6560     <span class="keyword">let</span> fileMap &#8592; getFileMap
6561     <span class="keyword">let</span> msgData &#8592; addMessageContext msgData
6562     logMessage { fileName <span class="constant">:=</span> (&#8592; getFileName), pos <span class="constant">:=</span> fileMap.toPosition pos, endPos <span class="constant">:=</span> fileMap.toPosition endPos, data <span class="constant">:=</span> msgData, severity <span class="constant">:=</span> severity }
6563 
<span class="keyword">6564 def</span> <span class="function-name">logErrorAt</span> (ref : Syntax) (msgData : MessageData) : m Unit <span class="constant">:=</span>
6565   logAt ref msgData MessageSeverity.error
6566 
<span class="keyword">6567 def</span> <span class="function-name">logWarningAt</span> (ref : Syntax) (msgData : MessageData) : m Unit <span class="constant">:=</span>
6568   logAt ref msgData MessageSeverity.warning
6569 
<span class="keyword">6570 def</span> <span class="function-name">logInfoAt</span> (ref : Syntax) (msgData : MessageData) : m Unit <span class="constant">:=</span>
6571   logAt ref msgData MessageSeverity.information
6572 
<span class="keyword">6573 def</span> <span class="function-name">log</span> (msgData : MessageData) (severity : MessageSeverity <span class="constant">:=</span> MessageSeverity.error): m Unit <span class="constant">:=</span> <span class="keyword">do</span>
6574   <span class="keyword">let</span> ref &#8592; MonadLog.getRef
6575   logAt ref msgData severity
6576 
<span class="keyword">6577 def</span> <span class="function-name">logError</span> (msgData : MessageData) : m Unit <span class="constant">:=</span>
6578   log msgData MessageSeverity.error
6579 
<span class="keyword">6580 def</span> <span class="function-name">logWarning</span> (msgData : MessageData) : m Unit <span class="constant">:=</span>
6581   log msgData MessageSeverity.warning
6582 
<span class="keyword">6583 def</span> <span class="function-name">logInfo</span> (msgData : MessageData) : m Unit <span class="constant">:=</span>
6584   log msgData MessageSeverity.information
6585 
<span class="keyword">6586 def</span> <span class="function-name">logException</span> [MonadLiftT IO m] (ex : Exception) : m Unit <span class="constant">:=</span> <span class="keyword">do</span>
6587   <span class="keyword">match</span> ex <span class="keyword">with</span>
6588   | Exception.error ref msg <span class="constant">=&gt;</span> logErrorAt ref msg
6589   | Exception.internal id <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
6590     <span class="keyword">unless</span> isAbortExceptionId id <span class="keyword">do</span>
6591       <span class="keyword">let</span> name &#8592; id.getName
6592       logError m<span class="constant">!</span><span class="string">"internal exception: {name}"</span>
6593 
<span class="keyword">6594 def</span> <span class="function-name">logTrace</span> (cls : Name) (msgData : MessageData) : m Unit <span class="constant">:=</span> <span class="keyword">do</span>
6595   logInfo (MessageData.tagged cls m<span class="constant">!</span><span class="string">"[{cls}] {msgData}"</span>)
6596 
<span class="doc">6597 @[inline]</span> <span class="keyword">def</span> <span class="function-name">trace</span> [MonadOptions m] (cls : Name) (msg : Unit <span class="constant">&#8594;</span> MessageData) : m Unit <span class="constant">:=</span> <span class="keyword">do</span>
6598   <span class="keyword">if</span> checkTraceOption (&#8592; getOptions) cls <span class="keyword">then</span>
6599     logTrace cls (msg ())
6600 
<span class="keyword">6601 def</span> <span class="function-name">logDbgTrace</span> [MonadOptions m] (msg : MessageData) : m Unit <span class="constant">:=</span> <span class="keyword">do</span>
6602   trace `Elab.debug <span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> msg
6603 
<span class="keyword">6604 def</span> <span class="function-name">logUnknownDecl</span> (declName : Name) : m Unit <span class="constant">:=</span>
6605   logError m<span class="constant">!</span><span class="string">"unknown declaration '{declName}'"</span>
6606 
<span class="keyword">6607 end</span> Lean.Elab
6608 ::::::::::::::
6609 Elab<span class="constant">/</span>Match.lean
6610 ::::::::::::::
<span class="comment-delimiter">6611 /-</span><span class="comment">
6612 Copyright (c) 2020 Microsoft Corporation. All rights reserved.
6613 Released under Apache 2.0 license as described in the file LICENSE.
6614 Authors: Leonardo de Moura
6615 -/</span>
<span class="keyword">6616 import</span> Lean.Util.CollectFVars
<span class="keyword">6617 import</span> Lean.Meta.Match.MatchPatternAttr
<span class="keyword">6618 import</span> Lean.Meta.Match.Match
<span class="keyword">6619 import</span> Lean.Meta.SortLocalDecls
<span class="keyword">6620 import</span> Lean.Meta.GeneralizeVars
<span class="keyword">6621 import</span> Lean.Elab.SyntheticMVars
<span class="keyword">6622 import</span> Lean.Elab.App
<span class="keyword">6623 import</span> Lean.Parser.Term
6624 
<span class="keyword">6625 namespace</span> Lean.Elab.Term
<span class="keyword">6626 open</span> Meta
<span class="keyword">6627 open</span> Lean.Parser.Term
6628 
<span class="comment-delimiter">6629 /- </span><span class="comment">This modules assumes "match"-expressions use the following syntax.
6630 
6631 ```lean
6632 def matchDiscr := leading_parser optional (try (ident &gt;&gt; checkNoWsBefore "no space before ':'" &gt;&gt; ":")) &gt;&gt; termParser
6633 
6634 def &#171;</span>match<span class="comment">&#187; := leading_parser:leadPrec "match " &gt;&gt; sepBy1 matchDiscr ", " &gt;&gt; optType &gt;&gt; " with " &gt;&gt; matchAlts
6635 ```
6636 -/</span>
6637 
<span class="keyword">6638 structure</span> <span class="function-name">MatchAltView</span> <span class="keyword">where</span>
6639   ref      : Syntax
6640   patterns : Array Syntax
6641   rhs      : Syntax
6642   <span class="keyword">deriving</span> Inhabited
6643 
<span class="keyword">6644 private</span> <span class="keyword">def</span> <span class="function-name">expandSimpleMatch</span> (stx discr lhsVar rhs : Syntax) (expectedType? : Option Expr) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
6645   <span class="keyword">let</span> newStx &#8592; `(<span class="keyword">let</span> <span class="constant">$</span>lhsVar <span class="constant">:=</span> <span class="constant">$</span>discr; <span class="constant">$</span>rhs)
6646   withMacroExpansion stx newStx <span class="constant">&lt;</span>| elabTerm newStx expectedType?
6647 
<span class="keyword">6648 private</span> <span class="keyword">def</span> <span class="function-name">elabDiscrsWitMatchType</span> (discrStxs : Array Syntax) (matchType : Expr) (expectedType : Expr) : TermElabM (Array Expr <span class="constant">&#215;</span> Bool) <span class="constant">:=</span> <span class="keyword">do</span>
6649   <span class="keyword">let</span> <span class="keyword">mut</span> discrs <span class="constant">:=</span> <span class="constant">#</span>[]
6650   <span class="keyword">let</span> <span class="keyword">mut</span> i <span class="constant">:=</span> <span class="constant">0</span>
6651   <span class="keyword">let</span> <span class="keyword">mut</span> matchType <span class="constant">:=</span> matchType
6652   <span class="keyword">let</span> <span class="keyword">mut</span> isDep <span class="constant">:=</span> false
6653   <span class="keyword">for</span> discrStx <span class="keyword">in</span> discrStxs <span class="keyword">do</span>
6654     i <span class="constant">:=</span> i <span class="constant">+</span> <span class="constant">1</span>
6655     matchType &#8592; whnf matchType
6656     <span class="keyword">match</span> matchType <span class="keyword">with</span>
6657     | Expr.forallE <span class="preprocessor">_</span> d b <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
6658       <span class="keyword">let</span> discr &#8592; fullApproxDefEq <span class="constant">&lt;</span>| elabTermEnsuringType discrStx[<span class="constant">1</span>] d
6659       trace[Elab.<span class="keyword">match</span>] <span class="string">"discr #{i} {discr} : {d}"</span>
6660       <span class="keyword">if</span> b.hasLooseBVars <span class="keyword">then</span>
6661         isDep <span class="constant">:=</span> true
6662       matchType &#8592; b.instantiate1 discr
6663       discrs <span class="constant">:=</span> discrs.push discr
6664     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
6665       throwError <span class="string">"invalid type provided to match-expression, function type with arity #{discrStxs.size} expected"</span>
6666   pure (discrs, isDep)
6667 
<span class="keyword">6668 private</span> <span class="keyword">def</span> <span class="function-name">mkUserNameFor</span> (e : Expr) : TermElabM Name <span class="constant">:=</span> <span class="keyword">do</span>
6669   <span class="keyword">match</span> e <span class="keyword">with</span>
6670   <span class="comment-delimiter">/- </span><span class="comment">Remark: we use `mkFreshUserName` to make sure we don't add a variable to the local context that can be resolved to `e`. -/</span>
6671   | Expr.fvar fvarId <span class="preprocessor">_</span> <span class="constant">=&gt;</span> mkFreshUserName ((&#8592; getLocalDecl fvarId).userName)
6672   | <span class="preprocessor">_</span>                  <span class="constant">=&gt;</span> mkFreshBinderName
6673 
<span class="comment-delimiter">6674 /-</span><span class="comment">- Return true iff `n` is an auxiliary variable created by `expandNonAtomicDiscrs?` -/</span>
<span class="keyword">6675 def</span> <span class="function-name">isAuxDiscrName</span> (n : Name) : Bool <span class="constant">:=</span>
6676   n.hasMacroScopes <span class="constant">&amp;&amp;</span> n.eraseMacroScopes <span class="constant">==</span> `_discr
6677 
<span class="comment-delimiter">6678 /- </span><span class="comment">We treat `@x` as atomic to avoid unnecessary extra local declarations from being
6679    inserted into the local context. Recall that `expandMatchAltsIntoMatch` uses `@` modifier.
6680    Thus this is kind of discriminant is quite common.
6681 
6682    Remark: if the discriminat is `Systax.missing`, we abort the elaboration of the `match`-expression.
6683    This can happen due to error recovery. Example
6684    ```
6685    example : (p &#8744; p) &#8594; p := fun h =&gt; match
6686    ```
6687    If we don't abort, the elaborator loops because we will keep trying to expand
6688    ```
6689    match
6690    ```
6691    into
6692    ```
6693    let d := &lt;Syntax.missing&gt;; match
6694    ```
6695    Recall that `Syntax.setArg stx i arg` is a no-op when `i` is out-of-bounds. -/</span>
<span class="keyword">6696 def</span> <span class="function-name">isAtomicDiscr?</span> (discr : Syntax) : TermElabM (Option Expr) <span class="constant">:=</span> <span class="keyword">do</span>
6697   <span class="keyword">match</span> discr <span class="keyword">with</span>
6698   | `(<span class="constant">$</span>x:ident)  <span class="constant">=&gt;</span> isLocalIdent? x
6699   | `(<span class="constant">@$</span>x:ident) <span class="constant">=&gt;</span> isLocalIdent? x
6700   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">if</span> discr.isMissing <span class="keyword">then</span> throwAbortTerm <span class="keyword">else</span> <span class="keyword">return</span> none
6701 
<span class="comment-delimiter">6702 -- </span><span class="comment">See expandNonAtomicDiscrs?
</span><span class="keyword">6703 private</span> <span class="keyword">def</span> <span class="function-name">elabAtomicDiscr</span> (discr : Syntax) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
6704   <span class="keyword">let</span> term <span class="constant">:=</span> discr[<span class="constant">1</span>]
6705   <span class="keyword">match</span> (&#8592; isAtomicDiscr? term) <span class="keyword">with</span>
6706   | some e<span class="constant">@</span>(Expr.fvar fvarId <span class="preprocessor">_</span>) <span class="constant">=&gt;</span>
6707     <span class="keyword">let</span> localDecl &#8592; getLocalDecl fvarId
6708     <span class="keyword">if</span> <span class="constant">!</span>isAuxDiscrName localDecl.userName <span class="keyword">then</span>
6709       pure e <span class="comment-delimiter">-- </span><span class="comment">it is not an auxiliary local created by `expandNonAtomicDiscrs?`
</span>6710     <span class="keyword">else</span>
6711       pure localDecl.value
6712   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwErrorAt discr <span class="string">"unexpected discriminant"</span>
6713 
<span class="keyword">6714 structure</span> <span class="function-name">ElabMatchTypeAndDiscsResult</span> <span class="keyword">where</span>
6715   discrs    : Array Expr
6716   matchType : Expr
6717   <span class="comment-delimiter">/- </span><span class="comment">`true` when performing dependent elimination. We use this to decide whether we optimize the "match unit" case.
6718      See `isMatchUnit?`. -/</span>
6719   isDep     : Bool
6720   alts      : Array MatchAltView
6721 
<span class="keyword">6722 private</span> <span class="keyword">def</span> <span class="function-name">elabMatchTypeAndDiscrs</span> (discrStxs : Array Syntax) (matchOptType : Syntax) (matchAltViews : Array MatchAltView) (expectedType : Expr)
6723     : TermElabM ElabMatchTypeAndDiscsResult <span class="constant">:=</span> <span class="keyword">do</span>
6724   <span class="keyword">let</span> numDiscrs <span class="constant">:=</span> discrStxs.size
6725   <span class="keyword">if</span> matchOptType.isNone <span class="keyword">then</span>
6726     <span class="keyword">let</span> <span class="keyword">rec</span> loop (i : Nat) (discrs : Array Expr) (matchType : Expr) (isDep : Bool) (matchAltViews : Array MatchAltView) <span class="constant">:=</span> <span class="keyword">do</span>
6727       <span class="keyword">match</span> i <span class="keyword">with</span>
6728       | <span class="constant">0</span>   <span class="constant">=&gt;</span> <span class="keyword">return</span> { discrs <span class="constant">:=</span> discrs.reverse, matchType <span class="constant">:=</span> matchType, isDep <span class="constant">:=</span> isDep, alts <span class="constant">:=</span> matchAltViews }
6729       | i<span class="constant">+1</span> <span class="constant">=&gt;</span>
6730         <span class="keyword">let</span> discrStx <span class="constant">:=</span> discrStxs[i]
6731         <span class="keyword">let</span> discr &#8592; elabAtomicDiscr discrStx
6732         <span class="keyword">let</span> discr &#8592; instantiateMVars discr
6733         <span class="keyword">let</span> discrType &#8592; inferType discr
6734         <span class="keyword">let</span> discrType &#8592; instantiateMVars discrType
6735         <span class="keyword">let</span> matchTypeBody &#8592; kabstract matchType discr
6736         <span class="keyword">let</span> isDep <span class="constant">:=</span> isDep <span class="constant">||</span> matchTypeBody.hasLooseBVars
6737         <span class="keyword">let</span> userName &#8592; mkUserNameFor discr
6738         <span class="keyword">if</span> discrStx[<span class="constant">0</span>].isNone <span class="keyword">then</span>
6739           loop i (discrs.push discr) (Lean.mkForall userName BinderInfo.default discrType matchTypeBody) isDep matchAltViews
6740         <span class="keyword">else</span>
6741           <span class="keyword">let</span> identStx <span class="constant">:=</span> discrStx[<span class="constant">0</span>][<span class="constant">0</span>]
6742           withLocalDeclD userName discrType <span class="keyword">fun</span> x <span class="constant">=&gt;</span> <span class="keyword">do</span>
6743             <span class="keyword">let</span> eqType &#8592; mkEq discr x
6744             withLocalDeclD identStx.getId eqType <span class="keyword">fun</span> h <span class="constant">=&gt;</span> <span class="keyword">do</span>
6745               <span class="keyword">let</span> matchTypeBody <span class="constant">:=</span> matchTypeBody.instantiate1 x
6746               <span class="keyword">let</span> matchType &#8592; mkForallFVars <span class="constant">#</span>[x, h] matchTypeBody
6747               <span class="keyword">let</span> refl &#8592; mkEqRefl discr
6748               <span class="keyword">let</span> discrs <span class="constant">:=</span> (discrs.push refl).push discr
6749               <span class="keyword">let</span> matchAltViews <span class="constant">:=</span> matchAltViews.map <span class="keyword">fun</span> altView <span class="constant">=&gt;</span>
6750                 { altView <span class="keyword">with</span> patterns <span class="constant">:=</span> altView.patterns.insertAt (i<span class="constant">+1</span>) identStx }
6751               loop i discrs matchType isDep matchAltViews
6752     loop discrStxs.size (discrs <span class="constant">:=</span> <span class="constant">#</span>[]) (isDep <span class="constant">:=</span> false) expectedType matchAltViews
6753   <span class="keyword">else</span>
6754     <span class="keyword">let</span> matchTypeStx <span class="constant">:=</span> matchOptType[<span class="constant">0</span>][<span class="constant">1</span>]
6755     <span class="keyword">let</span> matchType &#8592; elabType matchTypeStx
6756     <span class="keyword">let</span> (discrs, isDep) &#8592; elabDiscrsWitMatchType discrStxs matchType expectedType
6757     <span class="keyword">return</span> { discrs <span class="constant">:=</span> discrs, matchType <span class="constant">:=</span> matchType, isDep <span class="constant">:=</span> isDep, alts <span class="constant">:=</span> matchAltViews }
6758 
<span class="keyword">6759 def</span> <span class="function-name">expandMacrosInPatterns</span> (matchAlts : Array MatchAltView) : MacroM (Array MatchAltView) <span class="constant">:=</span> <span class="keyword">do</span>
6760   matchAlts.mapM <span class="keyword">fun</span> matchAlt <span class="constant">=&gt;</span> <span class="keyword">do</span>
6761     <span class="keyword">let</span> patterns &#8592; matchAlt.patterns.mapM expandMacros
6762     pure { matchAlt <span class="keyword">with</span> patterns <span class="constant">:=</span> patterns }
6763 
<span class="keyword">6764 private</span> <span class="keyword">def</span> <span class="function-name">getMatchGeneralizing?</span> : Syntax <span class="constant">&#8594;</span> Option Bool
6765   | `(<span class="keyword">match</span> (<span class="keyword">generalizing</span> <span class="constant">:=</span> true)  <span class="constant">$</span>discrs,<span class="constant">*</span> <span class="constant">$</span>[: <span class="constant">$</span>ty?]? <span class="keyword">with</span> <span class="constant">$</span>alts:matchAlt<span class="constant">*</span>) <span class="constant">=&gt;</span> some true
6766   | `(<span class="keyword">match</span> (<span class="keyword">generalizing</span> <span class="constant">:=</span> false) <span class="constant">$</span>discrs,<span class="constant">*</span> <span class="constant">$</span>[: <span class="constant">$</span>ty?]? <span class="keyword">with</span> <span class="constant">$</span>alts:matchAlt<span class="constant">*</span>) <span class="constant">=&gt;</span> some false
6767   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> none
6768 
<span class="comment-delimiter">6769 /- </span><span class="comment">Given `stx` a match-expression, return its alternatives. -/</span>
<span class="keyword">6770 private</span> <span class="keyword">def</span> <span class="function-name">getMatchAlts</span> : Syntax <span class="constant">&#8594;</span> Array MatchAltView
6771   | `(<span class="keyword">match</span> <span class="constant">$</span>[<span class="constant">$</span>gen]? <span class="constant">$</span>discrs,<span class="constant">*</span> <span class="constant">$</span>[: <span class="constant">$</span>ty?]? <span class="keyword">with</span> <span class="constant">$</span>alts:matchAlt<span class="constant">*</span>) <span class="constant">=&gt;</span>
6772     alts.filterMap <span class="keyword">fun</span> alt <span class="constant">=&gt;</span> <span class="keyword">match</span> alt <span class="keyword">with</span>
6773       | `(matchAltExpr| | <span class="constant">$</span>patterns,<span class="constant">*</span> <span class="constant">=&gt;</span> <span class="constant">$</span>rhs) <span class="constant">=&gt;</span> some {
6774           ref      <span class="constant">:=</span> alt,
6775           patterns <span class="constant">:=</span> patterns,
6776           rhs      <span class="constant">:=</span> rhs
6777         }
6778       | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> none
6779   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="constant">#</span>[]
6780 
<span class="comment-delimiter">6781 /-</span><span class="comment">-
6782   Auxiliary annotation used to mark terms marked with the "inaccessible" annotation `.(t)` and
6783   `_` in patterns. -/</span>
<span class="keyword">6784 def</span> <span class="function-name">mkInaccessible</span> (e : Expr) : Expr <span class="constant">:=</span>
6785   mkAnnotation `_inaccessible e
6786 
<span class="keyword">6787 def</span> <span class="function-name">inaccessible?</span> (e : Expr) : Option Expr <span class="constant">:=</span>
6788   annotation? `_inaccessible e
6789 
<span class="keyword">6790 inductive</span> <span class="function-name">PatternVar</span> <span class="keyword">where</span>
6791   | localVar     (userName : Name)
6792   <span class="comment-delimiter">-- </span><span class="comment">anonymous variables (`_`) are encoded using metavariables
</span>6793   | anonymousVar (mvarId   : MVarId)
6794 
<span class="keyword">6795 instance</span> <span class="function-name">:</span> ToString PatternVar <span class="constant">:=</span> &#10216;<span class="keyword">fun</span>
6796   | PatternVar.localVar x          <span class="constant">=&gt;</span> toString x
6797   | PatternVar.anonymousVar mvarId <span class="constant">=&gt;</span> s<span class="constant">!</span><span class="string">"?m{mvarId}"</span>&#10217;
6798 
<span class="keyword">6799 builtin_initialize</span> Parser.registerBuiltinNodeKind `MVarWithIdKind
6800 
<span class="comment-delimiter">6801 /-</span><span class="comment">-
6802   Create an auxiliary Syntax node wrapping a fresh metavariable id.
6803   We use this kind of Syntax for representing `_` occurring in patterns.
6804   The metavariables are created before we elaborate the patterns into `Expr`s. -/</span>
<span class="keyword">6805 private</span> <span class="keyword">def</span> <span class="function-name">mkMVarSyntax</span> : TermElabM Syntax <span class="constant">:=</span> <span class="keyword">do</span>
6806   <span class="keyword">let</span> mvarId &#8592; mkFreshId
6807   <span class="keyword">return</span> Syntax.node `MVarWithIdKind <span class="constant">#</span>[Syntax.node mvarId <span class="constant">#</span>[]]
6808 
<span class="comment-delimiter">6809 /-</span><span class="comment">- Given a syntax node constructed using `mkMVarSyntax`, return its MVarId -/</span>
<span class="keyword">6810 private</span> <span class="keyword">def</span> <span class="function-name">getMVarSyntaxMVarId</span> (stx : Syntax) : MVarId <span class="constant">:=</span>
6811   stx[<span class="constant">0</span>].getKind
6812 
<span class="comment-delimiter">6813 /-</span><span class="comment">-
6814   The elaboration function for `Syntax` created using `mkMVarSyntax`.
6815   It just converts the metavariable id wrapped by the Syntax into an `Expr`. -/</span>
<span class="doc">6816 @[builtinTermElab MVarWithIdKind]</span> <span class="keyword">def</span> <span class="function-name">elabMVarWithIdKind</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span>
6817   <span class="keyword">return</span> mkInaccessible <span class="constant">&lt;</span>| mkMVar (getMVarSyntaxMVarId stx)
6818 
<span class="doc">6819 @[builtinTermElab inaccessible]</span> <span class="keyword">def</span> <span class="function-name">elabInaccessible</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span> <span class="keyword">do</span>
6820   <span class="keyword">let</span> e &#8592; elabTerm stx[<span class="constant">1</span>] expectedType?
6821   <span class="keyword">return</span> mkInaccessible e
6822 
<span class="comment-delimiter">6823 /-</span><span class="comment">
6824   Patterns define new local variables.
6825   This module collect them and preprocess `_` occurring in patterns.
6826   Recall that an `_` may represent anonymous variables or inaccessible terms
6827   that are implied by typing constraints. Thus, we represent them with fresh named holes `?x`.
6828   After we elaborate the pattern, if the metavariable remains unassigned, we transform it into
6829   a regular pattern variable. Otherwise, it becomes an inaccessible term.
6830 
6831   Macros occurring in patterns are expanded before the `collectPatternVars` method is executed.
6832   The following kinds of Syntax are handled by this module
6833   - Constructor applications
6834   - Applications of functions tagged with the `[matchPattern]` attribute
6835   - Identifiers
6836   - Anonymous constructors
6837   - Structure instances
6838   - Inaccessible terms
6839   - Named patterns
6840   - Tuple literals
6841   - Type ascriptions
6842   - Literals: num, string and char
6843 -/</span>
<span class="keyword">6844 namespace</span> CollectPatternVars
6845 
<span class="keyword">6846 structure</span> <span class="function-name">State</span> <span class="keyword">where</span>
6847   found     : NameSet <span class="constant">:=</span> {}
6848   vars      : Array PatternVar <span class="constant">:=</span> <span class="constant">#</span>[]
6849 
<span class="keyword">6850 abbrev</span> M <span class="constant">:=</span> StateRefT State TermElabM
6851 
<span class="keyword">6852 private</span> <span class="keyword">def</span> <span class="function-name">throwCtorExpected</span> {&#945;} : M &#945; <span class="constant">:=</span>
6853   throwError <span class="string">"invalid pattern, constructor or constant marked with '[matchPattern]' expected"</span>
6854 
<span class="keyword">6855 private</span> <span class="keyword">def</span> <span class="function-name">getNumExplicitCtorParams</span> (ctorVal : ConstructorVal) : TermElabM Nat <span class="constant">:=</span>
6856   forallBoundedTelescope ctorVal.type ctorVal.numParams <span class="keyword">fun</span> ps <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">do</span>
6857     <span class="keyword">let</span> <span class="keyword">mut</span> result <span class="constant">:=</span> <span class="constant">0</span>
6858     <span class="keyword">for</span> p <span class="keyword">in</span> ps <span class="keyword">do</span>
6859       <span class="keyword">let</span> localDecl &#8592; getLocalDecl p.fvarId<span class="constant">!</span>
6860       <span class="keyword">if</span> localDecl.binderInfo.isExplicit <span class="keyword">then</span>
6861         result <span class="constant">:=</span> result<span class="constant">+1</span>
6862     pure result
6863 
<span class="keyword">6864 private</span> <span class="keyword">def</span> <span class="function-name">throwInvalidPattern</span> {&#945;} : M &#945; <span class="constant">:=</span>
6865   throwError <span class="string">"invalid pattern"</span>
6866 
<span class="comment-delimiter">6867 /-</span><span class="comment">
6868 An application in a pattern can be
6869 
6870 1- A constructor application
6871    The elaborator assumes fields are accessible and inductive parameters are not accessible.
6872 
6873 2- A regular application `(f ...)` where `f` is tagged with `[matchPattern]`.
6874    The elaborator assumes implicit arguments are not accessible and explicit ones are accessible.
6875 -/</span>
6876 
<span class="keyword">6877 structure</span> <span class="function-name">Context</span> <span class="keyword">where</span>
6878   funId         : Syntax
6879   ctorVal?      : Option ConstructorVal <span class="comment-delimiter">-- </span><span class="comment">It is `some`, if constructor application
</span>6880   explicit      : Bool
6881   ellipsis      : Bool
6882   paramDecls    : Array (Name <span class="constant">&#215;</span> BinderInfo) <span class="comment-delimiter">-- </span><span class="comment">parameters names and binder information
</span>6883   paramDeclIdx  : Nat <span class="constant">:=</span> <span class="constant">0</span>
6884   namedArgs     : Array NamedArg
6885   args          : List Arg
6886   newArgs       : Array Syntax <span class="constant">:=</span> <span class="constant">#</span>[]
6887   <span class="keyword">deriving</span> Inhabited
6888 
<span class="keyword">6889 private</span> <span class="keyword">def</span> <span class="function-name">isDone</span> (ctx : Context) : Bool <span class="constant">:=</span>
6890   ctx.paramDeclIdx <span class="constant">&#8805;</span> ctx.paramDecls.size
6891 
<span class="keyword">6892 private</span> <span class="keyword">def</span> <span class="function-name">finalize</span> (ctx : Context) : M Syntax <span class="constant">:=</span> <span class="keyword">do</span>
6893   <span class="keyword">if</span> ctx.namedArgs.isEmpty <span class="constant">&amp;&amp;</span> ctx.args.isEmpty <span class="keyword">then</span>
6894     <span class="keyword">let</span> fStx &#8592; `(<span class="constant">@$</span>(ctx.funId):ident)
6895     <span class="keyword">return</span> Syntax.mkApp fStx ctx.newArgs
6896   <span class="keyword">else</span>
6897     throwError <span class="string">"too many arguments"</span>
6898 
<span class="keyword">6899 private</span> <span class="keyword">def</span> <span class="function-name">isNextArgAccessible</span> (ctx : Context) : Bool <span class="constant">:=</span>
6900   <span class="keyword">let</span> i <span class="constant">:=</span> ctx.paramDeclIdx
6901   <span class="keyword">match</span> ctx.ctorVal? <span class="keyword">with</span>
6902   | some ctorVal <span class="constant">=&gt;</span> i <span class="constant">&#8805;</span> ctorVal.numParams <span class="comment-delimiter">-- </span><span class="comment">For constructor applications only fields are accessible
</span>6903   | none <span class="constant">=&gt;</span>
6904     <span class="keyword">if</span> h : i <span class="constant">&lt;</span> ctx.paramDecls.size <span class="keyword">then</span>
6905       <span class="comment-delimiter">-- </span><span class="comment">For `[matchPattern]` applications, only explicit parameters are accessible.
</span>6906       <span class="keyword">let</span> d <span class="constant">:=</span> ctx.paramDecls.get &#10216;i, h&#10217;
6907       d.<span class="constant">2</span>.isExplicit
6908     <span class="keyword">else</span>
6909       false
6910 
<span class="keyword">6911 private</span> <span class="keyword">def</span> <span class="function-name">getNextParam</span> (ctx : Context) : (Name <span class="constant">&#215;</span> BinderInfo) <span class="constant">&#215;</span> Context <span class="constant">:=</span>
6912   <span class="keyword">let</span> i <span class="constant">:=</span> ctx.paramDeclIdx
6913   <span class="keyword">let</span> d <span class="constant">:=</span> ctx.paramDecls[i]
6914   (d, { ctx <span class="keyword">with</span> paramDeclIdx <span class="constant">:=</span> ctx.paramDeclIdx <span class="constant">+</span> <span class="constant">1</span> })
6915 
<span class="keyword">6916 private</span> <span class="keyword">def</span> <span class="function-name">processVar</span> (idStx : Syntax) : M Syntax <span class="constant">:=</span> <span class="keyword">do</span>
6917   <span class="keyword">unless</span> idStx.isIdent <span class="keyword">do</span>
6918     throwErrorAt idStx <span class="string">"identifier expected"</span>
6919   <span class="keyword">let</span> id <span class="constant">:=</span> idStx.getId
6920   <span class="keyword">unless</span> id.eraseMacroScopes.isAtomic <span class="keyword">do</span>
6921     throwError <span class="string">"invalid pattern variable, must be atomic"</span>
6922   <span class="keyword">if</span> (&#8592; get).found.contains id <span class="keyword">then</span>
6923     throwError <span class="string">"invalid pattern, variable '{id}' occurred more than once"</span>
6924   modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> vars <span class="constant">:=</span> s.vars.push (PatternVar.localVar id), found <span class="constant">:=</span> s.found.insert id }
6925   <span class="keyword">return</span> idStx
6926 
<span class="keyword">6927 private</span> <span class="keyword">def</span> <span class="function-name">nameToPattern</span> : Name <span class="constant">&#8594;</span> TermElabM Syntax
6928   | Name.anonymous <span class="constant">=&gt;</span> `(Name.anonymous)
6929   | Name.str p s <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">do</span> <span class="keyword">let</span> p &#8592; nameToPattern p; `(Name.str <span class="constant">$</span>p <span class="constant">$</span>(quote s) <span class="preprocessor">_</span>)
6930   | Name.num p n <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">do</span> <span class="keyword">let</span> p &#8592; nameToPattern p; `(Name.num <span class="constant">$</span>p <span class="constant">$</span>(quote n) <span class="preprocessor">_</span>)
6931 
<span class="keyword">6932 private</span> <span class="keyword">def</span> <span class="function-name">quotedNameToPattern</span> (stx : Syntax) : TermElabM Syntax <span class="constant">:=</span>
6933   <span class="keyword">match</span> stx[<span class="constant">0</span>].isNameLit? <span class="keyword">with</span>
6934   | some val <span class="constant">=&gt;</span> nameToPattern val
6935   | none     <span class="constant">=&gt;</span> throwIllFormedSyntax
6936 
<span class="keyword">6937 private</span> <span class="keyword">def</span> <span class="function-name">doubleQuotedNameToPattern</span> (stx : Syntax) : TermElabM Syntax <span class="constant">:=</span> <span class="keyword">do</span>
6938   <span class="keyword">match</span> stx[<span class="constant">1</span>].isNameLit? <span class="keyword">with</span>
6939   | some val <span class="constant">=&gt;</span> nameToPattern (&#8592; resolveGlobalConstNoOverloadWithInfo stx[<span class="constant">1</span>] val)
6940   | none     <span class="constant">=&gt;</span> throwIllFormedSyntax
6941 
<span class="keyword">6942 partial</span> <span class="keyword">def</span> <span class="function-name">collect</span> (stx : Syntax) : M Syntax <span class="constant">:=</span> withRef stx <span class="constant">&lt;</span>| withFreshMacroScope <span class="keyword">do</span>
6943   <span class="keyword">let</span> k <span class="constant">:=</span> stx.getKind
6944   <span class="keyword">if</span> k <span class="constant">==</span> identKind <span class="keyword">then</span>
6945     processId stx
6946   <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> ``Lean.Parser.Term.app <span class="keyword">then</span>
6947     processCtorApp stx
6948   <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> ``Lean.Parser.Term.anonymousCtor <span class="keyword">then</span>
6949     <span class="keyword">let</span> elems &#8592; stx[<span class="constant">1</span>].getArgs.mapSepElemsM collect
6950     <span class="keyword">return</span> stx.setArg <span class="constant">1</span> <span class="constant">&lt;</span>| mkNullNode elems
6951   <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> ``Lean.Parser.Term.structInst <span class="keyword">then</span>
6952     <span class="comment-delimiter">/-</span><span class="comment">
6953     ```
6954     leading_parser "{" &gt;&gt; optional (atomic (termParser &gt;&gt; " with "))
6955                 &gt;&gt; manyIndent (group (structInstField &gt;&gt; optional ", "))
6956                 &gt;&gt; optional ".."
6957                 &gt;&gt; optional (" : " &gt;&gt; termParser)
6958                 &gt;&gt; " }"
6959     ```
6960     -/</span>
6961     <span class="keyword">let</span> withMod <span class="constant">:=</span> stx[<span class="constant">1</span>]
6962     <span class="keyword">unless</span> withMod.isNone <span class="keyword">do</span>
6963       throwErrorAt withMod <span class="string">"invalid struct instance pattern, 'with' is not allowed in patterns"</span>
6964     <span class="keyword">let</span> fields &#8592; stx[<span class="constant">2</span>].getArgs.mapM <span class="keyword">fun</span> p <span class="constant">=&gt;</span> <span class="keyword">do</span>
6965         <span class="comment-delimiter">-- </span><span class="comment">p is of the form (group (structInstField &gt;&gt; optional ", "))
</span>6966         <span class="keyword">let</span> field <span class="constant">:=</span> p[<span class="constant">0</span>]
6967         <span class="comment-delimiter">-- </span><span class="comment">leading_parser structInstLVal &gt;&gt; " := " &gt;&gt; termParser
</span>6968         <span class="keyword">let</span> newVal &#8592; collect field[<span class="constant">2</span>]
6969         <span class="keyword">let</span> field <span class="constant">:=</span> field.setArg <span class="constant">2</span> newVal
6970         pure <span class="constant">&lt;</span>| field.setArg <span class="constant">0</span> field
6971     <span class="keyword">return</span> stx.setArg <span class="constant">2</span> <span class="constant">&lt;</span>| mkNullNode fields
6972   <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> ``Lean.Parser.Term.hole <span class="keyword">then</span>
6973     <span class="keyword">let</span> r &#8592; mkMVarSyntax
6974     modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> vars <span class="constant">:=</span> s.vars.push <span class="constant">&lt;</span>| PatternVar.anonymousVar <span class="constant">&lt;</span>| getMVarSyntaxMVarId r }
6975     <span class="keyword">return</span> r
6976   <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> ``Lean.Parser.Term.paren <span class="keyword">then</span>
6977     <span class="keyword">let</span> arg <span class="constant">:=</span> stx[<span class="constant">1</span>]
6978     <span class="keyword">if</span> arg.isNone <span class="keyword">then</span>
6979       <span class="keyword">return</span> stx <span class="comment-delimiter">-- </span><span class="comment">`()`
</span>6980     <span class="keyword">else</span>
6981       <span class="keyword">let</span> t <span class="constant">:=</span> arg[<span class="constant">0</span>]
6982       <span class="keyword">let</span> s <span class="constant">:=</span> arg[<span class="constant">1</span>]
6983       <span class="keyword">if</span> s.isNone <span class="constant">||</span> s[<span class="constant">0</span>].getKind <span class="constant">==</span> ``Lean.Parser.Term.typeAscription <span class="keyword">then</span>
6984         <span class="comment-delimiter">-- </span><span class="comment">Ignore `s`, since it empty or it is a type ascription
</span>6985         <span class="keyword">let</span> t &#8592; collect t
6986         <span class="keyword">let</span> arg <span class="constant">:=</span> arg.setArg <span class="constant">0</span> t
6987         <span class="keyword">return</span> stx.setArg <span class="constant">1</span> arg
6988       <span class="keyword">else</span>
6989         <span class="comment-delimiter">-- </span><span class="comment">Tuple literal is a constructor
</span>6990         <span class="keyword">let</span> t &#8592; collect t
6991         <span class="keyword">let</span> arg <span class="constant">:=</span> arg.setArg <span class="constant">0</span> t
6992         <span class="keyword">let</span> tupleTail <span class="constant">:=</span> s[<span class="constant">0</span>]
6993         <span class="keyword">let</span> tupleTailElems <span class="constant">:=</span> tupleTail[<span class="constant">1</span>].getArgs
6994         <span class="keyword">let</span> tupleTailElems &#8592; tupleTailElems.mapSepElemsM collect
6995         <span class="keyword">let</span> tupleTail <span class="constant">:=</span> tupleTail.setArg <span class="constant">1</span> <span class="constant">&lt;</span>| mkNullNode tupleTailElems
6996         <span class="keyword">let</span> s         <span class="constant">:=</span> s.setArg <span class="constant">0</span> tupleTail
6997         <span class="keyword">let</span> arg       <span class="constant">:=</span> arg.setArg <span class="constant">1</span> s
6998         <span class="keyword">return</span> stx.setArg <span class="constant">1</span> arg
6999   <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> ``Lean.Parser.Term.explicitUniv <span class="keyword">then</span>
7000     processCtor stx[<span class="constant">0</span>]
7001   <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> ``Lean.Parser.Term.namedPattern <span class="keyword">then</span>
7002     <span class="comment-delimiter">/- </span><span class="comment">Recall that
7003       def namedPattern := check... &gt;&gt; trailing_parser "@" &gt;&gt; termParser -/</span>
7004     <span class="keyword">let</span> id <span class="constant">:=</span> stx[<span class="constant">0</span>]
7005     discard <span class="constant">&lt;</span>| processVar id
7006     <span class="keyword">let</span> pat <span class="constant">:=</span> stx[<span class="constant">2</span>]
7007     <span class="keyword">let</span> pat &#8592; collect pat
7008     `(_root_.namedPattern <span class="constant">$</span>id <span class="constant">$</span>pat)
7009   <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> ``Lean.Parser.Term.inaccessible <span class="keyword">then</span>
7010     <span class="keyword">return</span> stx
7011   <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> strLitKind <span class="keyword">then</span>
7012     <span class="keyword">return</span> stx
7013   <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> numLitKind <span class="keyword">then</span>
7014     <span class="keyword">return</span> stx
7015   <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> scientificLitKind <span class="keyword">then</span>
7016     <span class="keyword">return</span> stx
7017   <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> charLitKind <span class="keyword">then</span>
7018     <span class="keyword">return</span> stx
7019   <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> ``Lean.Parser.Term.quotedName <span class="keyword">then</span>
7020     <span class="comment-delimiter">/- </span><span class="comment">Quoted names have an elaboration function associated with them, and they will not be macro expanded.
7021       Note that macro expansion is not a good option since it produces a term using the smart constructors `Name.mkStr`, `Name.mkNum`
7022       instead of the constructors `Name.str` and `Name.num` -/</span>
7023     quotedNameToPattern stx
7024   <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> ``Lean.Parser.Term.doubleQuotedName <span class="keyword">then</span>
7025     <span class="comment-delimiter">/- </span><span class="comment">Similar to previous case -/</span>
7026     doubleQuotedNameToPattern stx
7027   <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> choiceKind <span class="keyword">then</span>
7028     throwError <span class="string">"invalid pattern, notation is ambiguous"</span>
7029   <span class="keyword">else</span>
7030     throwInvalidPattern
7031 
<span class="keyword">7032 where</span>
7033 
7034   processCtorApp (stx : Syntax) : M Syntax <span class="constant">:=</span> <span class="keyword">do</span>
7035     <span class="keyword">let</span> (f, namedArgs, args, ellipsis) &#8592; expandApp stx true
7036     processCtorAppCore f namedArgs args ellipsis
7037 
7038   processCtor (stx : Syntax) : M Syntax <span class="constant">:=</span> <span class="keyword">do</span>
7039     processCtorAppCore stx <span class="constant">#</span>[] <span class="constant">#</span>[] false
7040 
7041   <span class="comment-delimiter">/- </span><span class="comment">Check whether `stx` is a pattern variable or constructor-like (i.e., constructor or constant tagged with `[matchPattern]` attribute) -/</span>
7042   processId (stx : Syntax) : M Syntax <span class="constant">:=</span> <span class="keyword">do</span>
7043     <span class="keyword">match</span> (&#8592; resolveId? stx <span class="string">"pattern"</span>) <span class="keyword">with</span>
7044     | none   <span class="constant">=&gt;</span> processVar stx
7045     | some f <span class="constant">=&gt;</span> <span class="keyword">match</span> f <span class="keyword">with</span>
7046       | Expr.const fName <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
7047         <span class="keyword">match</span> (&#8592; getEnv).find? fName <span class="keyword">with</span>
7048         | some (ConstantInfo.ctorInfo <span class="preprocessor">_</span>) <span class="constant">=&gt;</span> processCtor stx
7049         | some <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
7050           <span class="keyword">if</span> hasMatchPatternAttribute (&#8592; getEnv) fName <span class="keyword">then</span>
7051             processCtor stx
7052           <span class="keyword">else</span>
7053             processVar stx
7054         | none <span class="constant">=&gt;</span> throwCtorExpected
7055       | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> processVar stx
7056 
7057   pushNewArg (accessible : Bool) (ctx : Context) (arg : Arg) : M Context <span class="constant">:=</span> <span class="keyword">do</span>
7058     <span class="keyword">match</span> arg <span class="keyword">with</span>
7059     | Arg.stx stx <span class="constant">=&gt;</span>
7060       <span class="keyword">let</span> stx &#8592; <span class="keyword">if</span> accessible <span class="keyword">then</span> collect stx <span class="keyword">else</span> pure stx
7061       <span class="keyword">return</span> { ctx <span class="keyword">with</span> newArgs <span class="constant">:=</span> ctx.newArgs.push stx }
7062     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="warning">unreachable</span><span class="constant">!</span>
7063 
7064   processExplicitArg (accessible : Bool) (ctx : Context) : M Context <span class="constant">:=</span> <span class="keyword">do</span>
7065     <span class="keyword">match</span> ctx.args <span class="keyword">with</span>
7066     | [] <span class="constant">=&gt;</span>
7067       <span class="keyword">if</span> ctx.ellipsis <span class="keyword">then</span>
7068         pushNewArg accessible ctx (Arg.stx (&#8592; `(<span class="preprocessor">_</span>)))
7069       <span class="keyword">else</span>
7070         throwError <span class="string">"explicit parameter is missing, unused named arguments {ctx.namedArgs.map fun narg =&gt; narg.name}"</span>
7071     | arg::args <span class="constant">=&gt;</span>
7072       pushNewArg accessible { ctx <span class="keyword">with</span> args <span class="constant">:=</span> args } arg
7073 
7074   processImplicitArg (accessible : Bool) (ctx : Context) : M Context <span class="constant">:=</span> <span class="keyword">do</span>
7075     <span class="keyword">if</span> ctx.explicit <span class="keyword">then</span>
7076       processExplicitArg accessible ctx
7077     <span class="keyword">else</span>
7078       pushNewArg accessible ctx (Arg.stx (&#8592; `(<span class="preprocessor">_</span>)))
7079 
7080   processCtorAppContext (ctx : Context) : M Syntax <span class="constant">:=</span> <span class="keyword">do</span>
7081     <span class="keyword">if</span> isDone ctx <span class="keyword">then</span>
7082       finalize ctx
7083     <span class="keyword">else</span>
7084       <span class="keyword">let</span> accessible <span class="constant">:=</span> isNextArgAccessible ctx
7085       <span class="keyword">let</span> (d, ctx)   <span class="constant">:=</span> getNextParam ctx
7086       <span class="keyword">match</span> ctx.namedArgs.findIdx? <span class="keyword">fun</span> namedArg <span class="constant">=&gt;</span> namedArg.name <span class="constant">==</span> d.<span class="constant">1</span> <span class="keyword">with</span>
7087       | some idx <span class="constant">=&gt;</span>
7088         <span class="keyword">let</span> arg <span class="constant">:=</span> ctx.namedArgs[idx]
7089         <span class="keyword">let</span> ctx <span class="constant">:=</span> { ctx <span class="keyword">with</span> namedArgs <span class="constant">:=</span> ctx.namedArgs.eraseIdx idx }
7090         <span class="keyword">let</span> ctx &#8592; pushNewArg accessible ctx arg.val
7091         processCtorAppContext ctx
7092       | none <span class="constant">=&gt;</span>
7093         <span class="keyword">let</span> ctx &#8592; <span class="keyword">match</span> d.<span class="constant">2</span> <span class="keyword">with</span>
7094           | BinderInfo.implicit     <span class="constant">=&gt;</span> processImplicitArg accessible ctx
7095           | BinderInfo.instImplicit <span class="constant">=&gt;</span> processImplicitArg accessible ctx
7096           | <span class="preprocessor">_</span>                       <span class="constant">=&gt;</span> processExplicitArg accessible ctx
7097         processCtorAppContext ctx
7098 
7099   processCtorAppCore (f : Syntax) (namedArgs : Array NamedArg) (args : Array Arg) (ellipsis : Bool) : M Syntax <span class="constant">:=</span> <span class="keyword">do</span>
7100     <span class="keyword">let</span> args <span class="constant">:=</span> args.toList
7101     <span class="keyword">let</span> (fId, explicit) &#8592; <span class="keyword">match</span> f <span class="keyword">with</span>
7102       | `(<span class="constant">$</span>fId:ident)  <span class="constant">=&gt;</span> pure (fId, false)
7103       | `(<span class="constant">@$</span>fId:ident) <span class="constant">=&gt;</span> pure (fId, true)
7104       | <span class="preprocessor">_</span>              <span class="constant">=&gt;</span> throwError <span class="string">"identifier expected"</span>
7105     <span class="keyword">let</span> some (Expr.const fName <span class="preprocessor">_</span> <span class="preprocessor">_</span>) &#8592; resolveId? fId <span class="string">"pattern"</span> | throwCtorExpected
7106     <span class="keyword">let</span> fInfo &#8592; getConstInfo fName
7107     <span class="keyword">let</span> paramDecls &#8592; forallTelescopeReducing fInfo.type <span class="keyword">fun</span> xs <span class="preprocessor">_</span> <span class="constant">=&gt;</span> xs.mapM <span class="keyword">fun</span> x <span class="constant">=&gt;</span> <span class="keyword">do</span>
7108       <span class="keyword">let</span> d &#8592; getFVarLocalDecl x
7109       <span class="keyword">return</span> (d.userName, d.binderInfo)
7110     <span class="keyword">match</span> fInfo <span class="keyword">with</span>
7111     | ConstantInfo.ctorInfo val <span class="constant">=&gt;</span>
7112       processCtorAppContext
7113         { funId <span class="constant">:=</span> fId, explicit <span class="constant">:=</span> explicit, ctorVal? <span class="constant">:=</span> val, paramDecls <span class="constant">:=</span> paramDecls, namedArgs <span class="constant">:=</span> namedArgs, args <span class="constant">:=</span> args, ellipsis <span class="constant">:=</span> ellipsis }
7114     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
7115       <span class="keyword">if</span> hasMatchPatternAttribute (&#8592; getEnv) fName <span class="keyword">then</span>
7116         processCtorAppContext
7117           { funId <span class="constant">:=</span> fId, explicit <span class="constant">:=</span> explicit, ctorVal? <span class="constant">:=</span> none, paramDecls <span class="constant">:=</span> paramDecls, namedArgs <span class="constant">:=</span> namedArgs, args <span class="constant">:=</span> args, ellipsis <span class="constant">:=</span> ellipsis }
7118       <span class="keyword">else</span>
7119         throwCtorExpected
7120 
<span class="keyword">7121 def</span> <span class="function-name">main</span> (alt : MatchAltView) : M MatchAltView <span class="constant">:=</span> <span class="keyword">do</span>
7122   <span class="keyword">let</span> patterns &#8592; alt.patterns.mapM <span class="keyword">fun</span> p <span class="constant">=&gt;</span> <span class="keyword">do</span>
7123     trace[Elab.<span class="keyword">match</span>] <span class="string">"collecting variables at pattern: {p}"</span>
7124     collect p
7125   <span class="keyword">return</span> { alt <span class="keyword">with</span> patterns <span class="constant">:=</span> patterns }
7126 
<span class="keyword">7127 end</span> CollectPatternVars
7128 
<span class="keyword">7129 private</span> <span class="keyword">def</span> <span class="function-name">collectPatternVars</span> (alt : MatchAltView) : TermElabM (Array PatternVar <span class="constant">&#215;</span> MatchAltView) <span class="constant">:=</span> <span class="keyword">do</span>
7130   <span class="keyword">let</span> (alt, s) &#8592; (CollectPatternVars.main alt).run {}
7131   <span class="keyword">return</span> (s.vars, alt)
7132 
<span class="comment-delimiter">7133 /- </span><span class="comment">Return the pattern variables in the given pattern.
7134   Remark: this method is not used here, but in other macros (e.g., at `Do.lean`). -/</span>
<span class="keyword">7135 def</span> <span class="function-name">getPatternVars</span> (patternStx : Syntax) : TermElabM (Array PatternVar) <span class="constant">:=</span> <span class="keyword">do</span>
7136   <span class="keyword">let</span> patternStx &#8592; liftMacroM <span class="constant">&lt;</span>| expandMacros patternStx
7137   <span class="keyword">let</span> (<span class="preprocessor">_</span>, s) &#8592; (CollectPatternVars.collect patternStx).run {}
7138   <span class="keyword">return</span> s.vars
7139 
<span class="keyword">7140 def</span> <span class="function-name">getPatternsVars</span> (patterns : Array Syntax) : TermElabM (Array PatternVar) <span class="constant">:=</span> <span class="keyword">do</span>
7141   <span class="keyword">let</span> collect : CollectPatternVars.M Unit <span class="constant">:=</span> <span class="keyword">do</span>
7142     <span class="keyword">for</span> pattern <span class="keyword">in</span> patterns <span class="keyword">do</span>
7143       discard <span class="constant">&lt;</span>| CollectPatternVars.collect (&#8592; liftMacroM <span class="constant">&lt;</span>| expandMacros pattern)
7144   <span class="keyword">let</span> (<span class="preprocessor">_</span>, s) &#8592; collect.run {}
7145   <span class="keyword">return</span> s.vars
7146 
<span class="comment-delimiter">7147 /- </span><span class="comment">We convert the collected `PatternVar`s intro `PatternVarDecl` -/</span>
<span class="keyword">7148 inductive</span> <span class="function-name">PatternVarDecl</span> <span class="keyword">where</span>
7149   <span class="comment-delimiter">/- </span><span class="comment">For `anonymousVar`, we create both a metavariable and a free variable. The free variable is used as an assignment for the metavariable
7150      when it is not assigned during pattern elaboration. -/</span>
7151   | anonymousVar (mvarId : MVarId) (fvarId : FVarId)
7152   | localVar     (fvarId : FVarId)
7153 
<span class="keyword">7154 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">withPatternVars</span> {&#945;} (pVars : Array PatternVar) (k : Array PatternVarDecl <span class="constant">&#8594;</span> TermElabM &#945;) : TermElabM &#945; <span class="constant">:=</span>
7155   <span class="keyword">let</span> <span class="keyword">rec</span> loop (i : Nat) (decls : Array PatternVarDecl) <span class="constant">:=</span> <span class="keyword">do</span>
7156     <span class="keyword">if</span> h : i <span class="constant">&lt;</span> pVars.size <span class="keyword">then</span>
7157       <span class="keyword">match</span> pVars.get &#10216;i, h&#10217; <span class="keyword">with</span>
7158       | PatternVar.anonymousVar mvarId <span class="constant">=&gt;</span>
7159         <span class="keyword">let</span> type &#8592; mkFreshTypeMVar
7160         <span class="keyword">let</span> userName &#8592; mkFreshBinderName
7161         withLocalDecl userName BinderInfo.default type <span class="keyword">fun</span> x <span class="constant">=&gt;</span>
7162           loop (i<span class="constant">+1</span>) (decls.push (PatternVarDecl.anonymousVar mvarId x.fvarId<span class="constant">!</span>))
7163       | PatternVar.localVar userName   <span class="constant">=&gt;</span>
7164         <span class="keyword">let</span> type &#8592; mkFreshTypeMVar
7165         withLocalDecl userName BinderInfo.default type <span class="keyword">fun</span> x <span class="constant">=&gt;</span>
7166           loop (i<span class="constant">+1</span>) (decls.push (PatternVarDecl.localVar x.fvarId<span class="constant">!</span>))
7167     <span class="keyword">else</span>
7168       <span class="comment-delimiter">/- </span><span class="comment">We must create the metavariables for `PatternVar.anonymousVar` AFTER we create the new local decls using `withLocalDecl`.
7169          Reason: their scope must include the new local decls since some of them are assigned by typing constraints. -/</span>
7170       decls.forM <span class="keyword">fun</span> decl <span class="constant">=&gt;</span> <span class="keyword">match</span> decl <span class="keyword">with</span>
7171         | PatternVarDecl.anonymousVar mvarId fvarId <span class="constant">=&gt;</span> <span class="keyword">do</span>
7172           <span class="keyword">let</span> type &#8592; inferType (mkFVar fvarId)
7173           discard <span class="constant">&lt;</span>| mkFreshExprMVarWithId mvarId type
7174         | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> pure ()
7175       k decls
7176   loop <span class="constant">0</span> <span class="constant">#</span>[]
7177 
<span class="comment-delimiter">7178 /-</span><span class="comment">
7179 Remark: when performing dependent pattern matching, we often had to write code such as
7180 
7181 ```lean
7182 def Vec.map' (f : &#945; &#8594; &#946;) (xs : Vec &#945; n) : Vec &#946; n :=
7183   match n, xs with
7184   | _, nil       =&gt; nil
7185   | _, cons a as =&gt; cons (f a) (map' f as)
7186 ```
7187 We had to include `n` and the `_`s because the type of `xs` depends on `n`.
7188 Moreover, `nil` and `cons a as` have different types.
7189 This was quite tedious. So, we have implemented an automatic "discriminant refinement procedure".
7190 The procedure is based on the observation that we get a type error whenenver we forget to include `_`s
7191 and the indices a discriminant depends on. So, we catch the exception, check whether the type of the discriminant
7192 is an indexed family, and add their indices as new discriminants.
7193 
7194 The current implementation, adds indices as they are found, and does not
7195 try to "sort" the new discriminants.
7196 
7197 If the refinement process fails, we report the original error message.
7198 -/</span>
7199 
<span class="comment-delimiter">7200 /- </span><span class="comment">Auxiliary structure for storing an type mismatch exception when processing the
7201    pattern #`idx` of some alternative. -/</span>
<span class="keyword">7202 structure</span> <span class="function-name">PatternElabException</span> <span class="keyword">where</span>
7203   ex  : Exception
7204   idx : Nat
7205 
<span class="keyword">7206 private</span> <span class="keyword">def</span> <span class="function-name">elabPatterns</span> (patternStxs : Array Syntax) (matchType : Expr) : ExceptT PatternElabException TermElabM (Array Expr <span class="constant">&#215;</span> Expr) <span class="constant">:=</span>
7207   withReader (<span class="keyword">fun</span> ctx <span class="constant">=&gt;</span> { ctx <span class="keyword">with</span> implicitLambda <span class="constant">:=</span> false }) <span class="keyword">do</span>
7208     <span class="keyword">let</span> <span class="keyword">mut</span> patterns  <span class="constant">:=</span> <span class="constant">#</span>[]
7209     <span class="keyword">let</span> <span class="keyword">mut</span> matchType <span class="constant">:=</span> matchType
7210     <span class="keyword">for</span> idx <span class="keyword">in</span> [:patternStxs.size] <span class="keyword">do</span>
7211       <span class="keyword">let</span> patternStx <span class="constant">:=</span> patternStxs[idx]
7212       matchType &#8592; whnf matchType
7213       <span class="keyword">match</span> matchType <span class="keyword">with</span>
7214       | Expr.forallE <span class="preprocessor">_</span> d b <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
7215           <span class="keyword">let</span> pattern &#8592;
7216             <span class="keyword">try</span>
7217               liftM <span class="constant">&lt;</span>| withSynthesize <span class="constant">&lt;</span>| withoutErrToSorry <span class="constant">&lt;</span>| elabTermEnsuringType patternStx d
7218             <span class="keyword">catch</span> ex <span class="constant">=&gt;</span>
7219               <span class="comment-delimiter">-- </span><span class="comment">Wrap the type mismatch exception for the "discriminant refinement" feature.
</span>7220               throwThe PatternElabException { ex <span class="constant">:=</span> ex, idx <span class="constant">:=</span> idx }
7221           matchType <span class="constant">:=</span> b.instantiate1 pattern
7222           patterns  <span class="constant">:=</span> patterns.push pattern
7223       | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwError <span class="string">"unexpected match type"</span>
7224     <span class="keyword">return</span> (patterns, matchType)
7225 
<span class="keyword">7226 def</span> <span class="function-name">finalizePatternDecls</span> (patternVarDecls : Array PatternVarDecl) : TermElabM (Array LocalDecl) <span class="constant">:=</span> <span class="keyword">do</span>
7227   <span class="keyword">let</span> <span class="keyword">mut</span> decls <span class="constant">:=</span> <span class="constant">#</span>[]
7228   <span class="keyword">for</span> pdecl <span class="keyword">in</span> patternVarDecls <span class="keyword">do</span>
7229     <span class="keyword">match</span> pdecl <span class="keyword">with</span>
7230     | PatternVarDecl.localVar fvarId <span class="constant">=&gt;</span>
7231       <span class="keyword">let</span> decl &#8592; getLocalDecl fvarId
7232       <span class="keyword">let</span> decl &#8592; instantiateLocalDeclMVars decl
7233       decls <span class="constant">:=</span> decls.push decl
7234     | PatternVarDecl.anonymousVar mvarId fvarId <span class="constant">=&gt;</span>
7235        <span class="keyword">let</span> e &#8592; instantiateMVars (mkMVar mvarId);
7236        trace[Elab.<span class="keyword">match</span>] <span class="string">"finalizePatternDecls: mvarId: {mvarId} := {e}, fvar: {mkFVar fvarId}"</span>
7237        <span class="keyword">match</span> e <span class="keyword">with</span>
7238        | Expr.mvar newMVarId <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
7239          <span class="comment-delimiter">/- </span><span class="comment">Metavariable was not assigned, or assigned to another metavariable. So,
7240             we assign to the auxiliary free variable we created at `withPatternVars` to `newMVarId`. -/</span>
7241          assignExprMVar newMVarId (mkFVar fvarId)
7242          trace[Elab.<span class="keyword">match</span>] <span class="string">"finalizePatternDecls: {mkMVar newMVarId} := {mkFVar fvarId}"</span>
7243          <span class="keyword">let</span> decl &#8592; getLocalDecl fvarId
7244          <span class="keyword">let</span> decl &#8592; instantiateLocalDeclMVars decl
7245          decls <span class="constant">:=</span> decls.push decl
7246        | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> pure ()
7247   <span class="comment-delimiter">/- </span><span class="comment">We perform a topological sort (dependecies) on `decls` because the pattern elaboration process may produce a sequence where a declaration d&#8321; may occur after d&#8322; when d&#8322; depends on d&#8321;. -/</span>
7248   sortLocalDecls decls
7249 
<span class="keyword">7250 open</span> Meta.Match (Pattern Pattern.var Pattern.inaccessible Pattern.ctor Pattern.as Pattern.val Pattern.arrayLit AltLHS MatcherResult)
7251 
<span class="keyword">7252 namespace</span> ToDepElimPattern
7253 
<span class="keyword">7254 structure</span> <span class="function-name">State</span> <span class="keyword">where</span>
7255   found      : NameSet <span class="constant">:=</span> {}
7256   localDecls : Array LocalDecl
7257   newLocals  : NameSet <span class="constant">:=</span> {}
7258 
<span class="keyword">7259 abbrev</span> M <span class="constant">:=</span> StateRefT State TermElabM
7260 
<span class="keyword">7261 private</span> <span class="keyword">def</span> <span class="function-name">alreadyVisited</span> (fvarId : FVarId) : M Bool <span class="constant">:=</span> <span class="keyword">do</span>
7262   <span class="keyword">let</span> s &#8592; get
7263   <span class="keyword">return</span> s.found.contains fvarId
7264 
<span class="keyword">7265 private</span> <span class="keyword">def</span> <span class="function-name">markAsVisited</span> (fvarId : FVarId) : M Unit <span class="constant">:=</span>
7266   modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> found <span class="constant">:=</span> s.found.insert fvarId }
7267 
<span class="keyword">7268 private</span> <span class="keyword">def</span> <span class="function-name">throwInvalidPattern</span> {&#945;} (e : Expr) : M &#945; <span class="constant">:=</span>
7269   throwError <span class="string">"invalid pattern {indentExpr e}"</span>
7270 
<span class="comment-delimiter">7271 /- </span><span class="comment">Create a new LocalDecl `x` for the metavariable `mvar`, and return `Pattern.var x` -/</span>
<span class="keyword">7272 private</span> <span class="keyword">def</span> <span class="function-name">mkLocalDeclFor</span> (mvar : Expr) : M Pattern <span class="constant">:=</span> <span class="keyword">do</span>
7273   <span class="keyword">let</span> mvarId <span class="constant">:=</span> mvar.mvarId<span class="constant">!</span>
7274   <span class="keyword">let</span> s &#8592; get
7275   <span class="keyword">match</span> (&#8592; getExprMVarAssignment? mvarId) <span class="keyword">with</span>
7276   | some val <span class="constant">=&gt;</span> <span class="keyword">return</span> Pattern.inaccessible val
7277   | none <span class="constant">=&gt;</span>
7278     <span class="keyword">let</span> fvarId &#8592; mkFreshId
7279     <span class="keyword">let</span> type   &#8592; inferType mvar
7280     <span class="comment-delimiter">/- </span><span class="comment">HACK: `fvarId` is not in the scope of `mvarId`
7281        If this generates problems in the future, we should update the metavariable declarations. -/</span>
7282     assignExprMVar mvarId (mkFVar fvarId)
7283     <span class="keyword">let</span> userName &#8592; mkFreshBinderName
7284     <span class="keyword">let</span> newDecl <span class="constant">:=</span> LocalDecl.cdecl arbitrary fvarId userName type BinderInfo.default;
7285     modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span>
7286       { s <span class="keyword">with</span>
7287         newLocals  <span class="constant">:=</span> s.newLocals.insert fvarId,
7288         localDecls <span class="constant">:=</span>
7289         <span class="keyword">match</span> s.localDecls.findIdx? <span class="keyword">fun</span> decl <span class="constant">=&gt;</span> mvar.occurs decl.type <span class="keyword">with</span>
7290         | none   <span class="constant">=&gt;</span> s.localDecls.push newDecl <span class="comment-delimiter">-- </span><span class="comment">None of the existing declarations depend on `mvar`
</span>7291         | some i <span class="constant">=&gt;</span> s.localDecls.insertAt i newDecl }
7292     <span class="keyword">return</span> Pattern.var fvarId
7293 
<span class="keyword">7294 partial</span> <span class="keyword">def</span> <span class="function-name">main</span> (e : Expr) : M Pattern <span class="constant">:=</span> <span class="keyword">do</span>
7295   <span class="keyword">let</span> isLocalDecl (fvarId : FVarId) : M Bool <span class="constant">:=</span> <span class="keyword">do</span>
7296     <span class="keyword">return</span> (&#8592; get).localDecls.any <span class="keyword">fun</span> d <span class="constant">=&gt;</span> d.fvarId <span class="constant">==</span> fvarId
7297   <span class="keyword">let</span> mkPatternVar (fvarId : FVarId) (e : Expr) : M Pattern <span class="constant">:=</span> <span class="keyword">do</span>
7298     <span class="keyword">if</span> (&#8592; alreadyVisited fvarId) <span class="keyword">then</span>
7299       <span class="keyword">return</span> Pattern.inaccessible e
7300     <span class="keyword">else</span>
7301       markAsVisited fvarId
7302       <span class="keyword">return</span> Pattern.var e.fvarId<span class="constant">!</span>
7303   <span class="keyword">let</span> mkInaccessible (e : Expr) : M Pattern <span class="constant">:=</span> <span class="keyword">do</span>
7304     <span class="keyword">match</span> e <span class="keyword">with</span>
7305     | Expr.fvar fvarId <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
7306       <span class="keyword">if</span> (&#8592; isLocalDecl fvarId) <span class="keyword">then</span>
7307         mkPatternVar fvarId e
7308       <span class="keyword">else</span>
7309         <span class="keyword">return</span> Pattern.inaccessible e
7310     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
7311       <span class="keyword">return</span> Pattern.inaccessible e
7312   <span class="keyword">match</span> inaccessible? e <span class="keyword">with</span>
7313   | some t <span class="constant">=&gt;</span> mkInaccessible t
7314   | none <span class="constant">=&gt;</span>
7315     <span class="keyword">match</span> e.arrayLit? <span class="keyword">with</span>
7316     | some (&#945;, lits) <span class="constant">=&gt;</span>
7317       <span class="keyword">return</span> Pattern.arrayLit &#945; (&#8592; lits.mapM main)
7318     | none <span class="constant">=&gt;</span>
7319       <span class="keyword">if</span> e.isAppOfArity `namedPattern <span class="constant">3</span> <span class="keyword">then</span>
7320         <span class="keyword">let</span> p &#8592; main <span class="constant">&lt;</span>| e.getArg<span class="constant">!</span> <span class="constant">2</span>
7321         <span class="keyword">match</span> e.getArg<span class="constant">!</span> <span class="constant">1</span> <span class="keyword">with</span>
7322         | Expr.fvar fvarId <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">return</span> Pattern.as fvarId p
7323         | <span class="preprocessor">_</span>                  <span class="constant">=&gt;</span> throwError <span class="string">"unexpected occurrence of auxiliary declaration 'namedPattern'"</span>
7324       <span class="keyword">else</span> <span class="keyword">if</span> e.isNatLit <span class="constant">||</span> e.isStringLit <span class="constant">||</span> e.isCharLit <span class="keyword">then</span>
7325         <span class="keyword">return</span> Pattern.val e
7326       <span class="keyword">else</span> <span class="keyword">if</span> e.isFVar <span class="keyword">then</span>
7327         <span class="keyword">let</span> fvarId <span class="constant">:=</span> e.fvarId<span class="constant">!</span>
7328         <span class="keyword">unless</span> (&#8592; isLocalDecl fvarId) <span class="keyword">do</span>
7329           throwInvalidPattern e
7330         mkPatternVar fvarId e
7331       <span class="keyword">else</span> <span class="keyword">if</span> e.isMVar <span class="keyword">then</span>
7332         mkLocalDeclFor e
7333       <span class="keyword">else</span>
7334         <span class="keyword">let</span> newE &#8592; whnf e
7335         <span class="keyword">if</span> newE <span class="constant">!=</span> e <span class="keyword">then</span>
7336           main newE
7337         <span class="keyword">else</span> matchConstCtor e.getAppFn (<span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwInvalidPattern e) <span class="keyword">fun</span> v us <span class="constant">=&gt;</span> <span class="keyword">do</span>
7338           <span class="keyword">let</span> args <span class="constant">:=</span> e.getAppArgs
7339           <span class="keyword">unless</span> args.size <span class="constant">==</span> v.numParams <span class="constant">+</span> v.numFields <span class="keyword">do</span>
7340             throwInvalidPattern e
7341           <span class="keyword">let</span> params <span class="constant">:=</span> args.extract <span class="constant">0</span> v.numParams
7342           <span class="keyword">let</span> fields <span class="constant">:=</span> args.extract v.numParams args.size
7343           <span class="keyword">let</span> fields &#8592; fields.mapM main
7344           <span class="keyword">return</span> Pattern.ctor v.name us params.toList fields.toList
7345 
<span class="keyword">7346 end</span> ToDepElimPattern
7347 
<span class="keyword">7348 def</span> <span class="function-name">withDepElimPatterns</span> {&#945;} (localDecls : Array LocalDecl) (ps : Array Expr) (k : Array LocalDecl <span class="constant">&#8594;</span> Array Pattern <span class="constant">&#8594;</span> TermElabM &#945;) : TermElabM &#945; <span class="constant">:=</span> <span class="keyword">do</span>
7349   <span class="keyword">let</span> (patterns, s) &#8592; (ps.mapM ToDepElimPattern.main).run { localDecls <span class="constant">:=</span> localDecls }
7350   <span class="keyword">let</span> localDecls &#8592; s.localDecls.mapM <span class="keyword">fun</span> d <span class="constant">=&gt;</span> instantiateLocalDeclMVars d
7351   <span class="comment-delimiter">/- </span><span class="comment">toDepElimPatterns may have added new localDecls. Thus, we must update the local context before we execute `k` -/</span>
7352   <span class="keyword">let</span> lctx &#8592; getLCtx
7353   <span class="keyword">let</span> lctx <span class="constant">:=</span> localDecls.foldl (<span class="keyword">fun</span> (lctx : LocalContext) d <span class="constant">=&gt;</span> lctx.erase d.fvarId) lctx
7354   <span class="keyword">let</span> lctx <span class="constant">:=</span> localDecls.foldl (<span class="keyword">fun</span> (lctx : LocalContext) d <span class="constant">=&gt;</span> lctx.addDecl d) lctx
7355   withTheReader Meta.Context (<span class="keyword">fun</span> ctx <span class="constant">=&gt;</span> { ctx <span class="keyword">with</span> lctx <span class="constant">:=</span> lctx }) <span class="keyword">do</span>
7356     k localDecls patterns
7357 
<span class="keyword">7358 private</span> <span class="keyword">def</span> <span class="function-name">withElaboratedLHS</span> {&#945;} (ref : Syntax) (patternVarDecls : Array PatternVarDecl) (patternStxs : Array Syntax) (matchType : Expr)
7359     (k : AltLHS <span class="constant">&#8594;</span> Expr <span class="constant">&#8594;</span> TermElabM &#945;) : ExceptT PatternElabException TermElabM &#945; <span class="constant">:=</span> <span class="keyword">do</span>
7360   <span class="keyword">let</span> (patterns, matchType) &#8592; withSynthesize <span class="constant">&lt;</span>| elabPatterns patternStxs matchType
7361   id (&#945; <span class="constant">:=</span> TermElabM &#945;) <span class="keyword">do</span>
7362     <span class="keyword">let</span> localDecls &#8592; finalizePatternDecls patternVarDecls
7363     <span class="keyword">let</span> patterns &#8592; patterns.mapM (instantiateMVars &#183;)
7364     withDepElimPatterns localDecls patterns <span class="keyword">fun</span> localDecls patterns <span class="constant">=&gt;</span>
7365       k { ref <span class="constant">:=</span> ref, fvarDecls <span class="constant">:=</span> localDecls.toList, patterns <span class="constant">:=</span> patterns.toList } matchType
7366 
<span class="keyword">7367 private</span> <span class="keyword">def</span> <span class="function-name">elabMatchAltView</span> (alt : MatchAltView) (matchType : Expr) : ExceptT PatternElabException TermElabM (AltLHS <span class="constant">&#215;</span> Expr) <span class="constant">:=</span> withRef alt.ref <span class="keyword">do</span>
7368   <span class="keyword">let</span> (patternVars, alt) &#8592; collectPatternVars alt
7369   trace[Elab.<span class="keyword">match</span>] <span class="string">"patternVars: {patternVars}"</span>
7370   withPatternVars patternVars <span class="keyword">fun</span> patternVarDecls <span class="constant">=&gt;</span> <span class="keyword">do</span>
7371     withElaboratedLHS alt.ref patternVarDecls alt.patterns matchType <span class="keyword">fun</span> altLHS matchType <span class="constant">=&gt;</span> <span class="keyword">do</span>
7372       <span class="keyword">let</span> rhs &#8592; elabTermEnsuringType alt.rhs matchType
7373       <span class="keyword">let</span> xs <span class="constant">:=</span> altLHS.fvarDecls.toArray.map LocalDecl.toExpr
7374       <span class="keyword">let</span> rhs &#8592; <span class="keyword">if</span> xs.isEmpty <span class="keyword">then</span> pure <span class="constant">&lt;</span>| mkSimpleThunk rhs <span class="keyword">else</span> mkLambdaFVars xs rhs
7375       trace[Elab.<span class="keyword">match</span>] <span class="string">"rhs: {rhs}"</span>
7376       <span class="keyword">return</span> (altLHS, rhs)
7377 
<span class="comment-delimiter">7378 /-</span><span class="comment">-
7379   Collect indices for the "discriminant refinement feature". This method is invoked
7380   when we detect a type mismatch at a pattern #`idx` of some alternative. -/</span>
<span class="keyword">7381 private</span> <span class="keyword">def</span> <span class="function-name">getIndicesToInclude</span> (discrs : Array Expr) (idx : Nat) : TermElabM (Array Expr) <span class="constant">:=</span> <span class="keyword">do</span>
7382   <span class="keyword">let</span> discrType &#8592; whnfD (&#8592; inferType discrs[idx])
7383   matchConstInduct discrType.getAppFn (<span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">return</span> <span class="constant">#</span>[]) <span class="keyword">fun</span> info <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">do</span>
7384     <span class="keyword">let</span> <span class="keyword">mut</span> result <span class="constant">:=</span> <span class="constant">#</span>[]
7385     <span class="keyword">let</span> args <span class="constant">:=</span> discrType.getAppArgs
7386     <span class="keyword">for</span> arg <span class="keyword">in</span> args[info.numParams : args.size] <span class="keyword">do</span>
7387       <span class="keyword">unless</span> (&#8592; discrs.anyM <span class="keyword">fun</span> discr <span class="constant">=&gt;</span> isDefEq discr arg) <span class="keyword">do</span>
7388         result <span class="constant">:=</span> result.push arg
7389     <span class="keyword">return</span> result
7390 
<span class="keyword">7391 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">elabMatchAltViews</span> (discrs : Array Expr) (matchType : Expr) (altViews : Array MatchAltView) : TermElabM (Array Expr <span class="constant">&#215;</span> Expr <span class="constant">&#215;</span> Array (AltLHS <span class="constant">&#215;</span> Expr) <span class="constant">&#215;</span> Bool) <span class="constant">:=</span> <span class="keyword">do</span>
7392   loop discrs matchType altViews none
<span class="keyword">7393 where</span>
7394   <span class="comment-delimiter">/-</span><span class="comment">
7395     "Discriminant refinement" main loop.
7396     `first?` contains the first error message we found before updated the `discrs`. -/</span>
7397   loop (discrs : Array Expr) (matchType : Expr) (altViews : Array MatchAltView) (first? : Option (SavedState <span class="constant">&#215;</span> Exception))
7398       : TermElabM (Array Expr <span class="constant">&#215;</span> Expr <span class="constant">&#215;</span> Array (AltLHS <span class="constant">&#215;</span> Expr) <span class="constant">&#215;</span> Bool) <span class="constant">:=</span> <span class="keyword">do</span>
7399     <span class="keyword">let</span> s &#8592; saveState
7400     <span class="keyword">match</span> &#8592; altViews.mapM (<span class="keyword">fun</span> alt <span class="constant">=&gt;</span> elabMatchAltView alt matchType) |<span class="constant">&gt;</span>.run <span class="keyword">with</span>
7401     | Except.ok alts <span class="constant">=&gt;</span> <span class="keyword">return</span> (discrs, matchType, alts, first?.isSome)
7402     | Except.error { idx <span class="constant">:=</span> idx, ex <span class="constant">:=</span> ex } <span class="constant">=&gt;</span>
7403       <span class="keyword">let</span> indices &#8592; getIndicesToInclude discrs idx
7404       <span class="keyword">if</span> indices.isEmpty <span class="keyword">then</span>
7405         throwEx (&#8592; updateFirst first? ex)
7406       <span class="keyword">else</span>
7407         <span class="keyword">let</span> first &#8592; updateFirst first? ex
7408         s.restore
7409         <span class="keyword">let</span> indices &#8592; collectDeps indices discrs
7410         <span class="keyword">let</span> matchType &#8592;
7411           <span class="keyword">try</span>
7412             updateMatchType indices matchType
7413           <span class="keyword">catch</span> ex <span class="constant">=&gt;</span>
7414             throwEx first
7415         <span class="keyword">let</span> altViews  &#8592; addWildcardPatterns indices.size altViews
7416         <span class="keyword">let</span> discrs    <span class="constant">:=</span> indices <span class="constant">++</span> discrs
7417         loop discrs matchType altViews first
7418 
7419   throwEx {&#945;} (p : SavedState <span class="constant">&#215;</span> Exception) : TermElabM &#945; <span class="constant">:=</span> <span class="keyword">do</span>
7420     p.<span class="constant">1</span>.restore; throw p.<span class="constant">2</span>
7421 
7422   updateFirst (first? : Option (SavedState <span class="constant">&#215;</span> Exception)) (ex : Exception) : TermElabM (SavedState <span class="constant">&#215;</span> Exception) <span class="constant">:=</span> <span class="keyword">do</span>
7423     <span class="keyword">match</span> first? <span class="keyword">with</span>
7424     | none       <span class="constant">=&gt;</span> <span class="keyword">return</span> (&#8592; saveState, ex)
7425     | some first <span class="constant">=&gt;</span> <span class="keyword">return</span> first
7426 
7427   containsFVar (es : Array Expr) (fvarId : FVarId) : Bool <span class="constant">:=</span>
7428     es.any <span class="keyword">fun</span> e <span class="constant">=&gt;</span> e.isFVar <span class="constant">&amp;&amp;</span> e.fvarId<span class="constant">!</span> <span class="constant">==</span> fvarId
7429 
7430   <span class="comment-delimiter">/- </span><span class="comment">Update `indices` by including any free variable `x` s.t.
7431      - Type of some `discr` depends on `x`.
7432      - Type of `x` depends on some free variable in `indices`.
7433 
7434      If we don't include these extra variables in indices, then
7435      `updateMatchType` will generate a type incorrect term.
7436      For example, suppose `discr` contains `h : @HEq &#945; a &#945; b`, and
7437      `indices` is `#[&#945;, b]`, and `matchType` is `@HEq &#945; a &#945; b &#8594; B`.
7438      `updateMatchType indices matchType` produces the type
7439      `(&#945;' : Type) &#8594; (b : &#945;') &#8594; @HEq &#945;' a &#945;' b &#8594; B` which is type incorrect
7440      because we have `a : &#945;`.
7441      The method `collectDeps` will include `a` into `indices`.
7442 
7443      This method does not handle dependencies among non-free variables.
7444      We rely on the type checking method `check` at `updateMatchType`. -/</span>
7445   collectDeps (indices : Array Expr) (discrs : Array Expr) : TermElabM (Array Expr) <span class="constant">:=</span> <span class="keyword">do</span>
7446     <span class="keyword">let</span> <span class="keyword">mut</span> s : CollectFVars.State <span class="constant">:=</span> {}
7447     <span class="keyword">for</span> discr <span class="keyword">in</span> discrs <span class="keyword">do</span>
7448       s <span class="constant">:=</span> collectFVars s (&#8592; instantiateMVars (&#8592; inferType discr))
7449     <span class="keyword">let</span> (indicesFVar, indicesNonFVar) <span class="constant">:=</span> indices.split Expr.isFVar
7450     <span class="keyword">let</span> indicesFVar <span class="constant">:=</span> indicesFVar.map Expr.fvarId<span class="constant">!</span>
7451     <span class="keyword">let</span> <span class="keyword">mut</span> toAdd <span class="constant">:=</span> <span class="constant">#</span>[]
7452     <span class="keyword">for</span> fvarId <span class="keyword">in</span> s.fvarSet.toList <span class="keyword">do</span>
7453       <span class="keyword">unless</span> containsFVar discrs fvarId <span class="constant">||</span> containsFVar indices fvarId <span class="keyword">do</span>
7454         <span class="keyword">let</span> localDecl &#8592; getLocalDecl fvarId
7455         <span class="keyword">let</span> mctx &#8592; getMCtx
7456         <span class="keyword">for</span> indexFVarId <span class="keyword">in</span> indicesFVar <span class="keyword">do</span>
7457           <span class="keyword">if</span> mctx.localDeclDependsOn localDecl indexFVarId <span class="keyword">then</span>
7458             toAdd <span class="constant">:=</span> toAdd.push fvarId
7459     <span class="keyword">let</span> lctx &#8592; getLCtx
7460     <span class="keyword">let</span> indicesFVar <span class="constant">:=</span> (indicesFVar <span class="constant">++</span> toAdd).qsort <span class="keyword">fun</span> fvarId&#8321; fvarId&#8322; <span class="constant">=&gt;</span>
7461       (lctx.get<span class="constant">!</span> fvarId&#8321;).index <span class="constant">&lt;</span> (lctx.get<span class="constant">!</span> fvarId&#8322;).index
7462     <span class="keyword">return</span> indicesFVar.map mkFVar <span class="constant">++</span> indicesNonFVar
7463 
7464   updateMatchType (indices : Array Expr) (matchType : Expr) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
7465     <span class="keyword">let</span> matchType &#8592; indices.foldrM (init <span class="constant">:=</span> matchType) <span class="keyword">fun</span> index matchType <span class="constant">=&gt;</span> <span class="keyword">do</span>
7466       <span class="keyword">let</span> indexType &#8592; inferType index
7467       <span class="keyword">let</span> matchTypeBody &#8592; kabstract matchType index
7468       <span class="keyword">let</span> userName &#8592; mkUserNameFor index
7469       <span class="keyword">return</span> Lean.mkForall userName BinderInfo.default indexType matchTypeBody
7470     check matchType
7471     <span class="keyword">return</span> matchType
7472 
7473   addWildcardPatterns (num : Nat) (altViews : Array MatchAltView) : TermElabM (Array MatchAltView) <span class="constant">:=</span> <span class="keyword">do</span>
7474     <span class="keyword">let</span> hole <span class="constant">:=</span> mkHole (&#8592; getRef)
7475     <span class="keyword">let</span> wildcards <span class="constant">:=</span> mkArray num hole
7476     <span class="keyword">return</span> altViews.map <span class="keyword">fun</span> altView <span class="constant">=&gt;</span> { altView <span class="keyword">with</span> patterns <span class="constant">:=</span> wildcards <span class="constant">++</span> altView.patterns }
7477 
<span class="keyword">7478 def</span> <span class="function-name">mkMatcher</span> (elimName : Name) (matchType : Expr) (numDiscrs : Nat) (lhss : List AltLHS) : TermElabM MatcherResult <span class="constant">:=</span>
7479   Meta.Match.mkMatcher elimName matchType numDiscrs lhss
7480 
<span class="keyword">7481 register_builtin_option</span> <span class="keyword">match</span>.ignoreUnusedAlts : Bool <span class="constant">:=</span> {
7482   defValue <span class="constant">:=</span> false
7483   descr <span class="constant">:=</span> <span class="string">"if true, do not generate error if an alternative is not used"</span>
7484 }
7485 
<span class="keyword">7486 def</span> <span class="function-name">reportMatcherResultErrors</span> (altLHSS : List AltLHS) (result : MatcherResult) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
7487   <span class="keyword">unless</span> result.counterExamples.isEmpty <span class="keyword">do</span>
7488     withHeadRefOnly <span class="constant">&lt;</span>| throwError <span class="string">"missing cases:\n{Meta.Match.counterExamplesToMessageData result.counterExamples}"</span>
7489   <span class="keyword">unless</span> <span class="keyword">match</span>.ignoreUnusedAlts.get (&#8592; getOptions) <span class="constant">||</span> result.unusedAltIdxs.isEmpty <span class="keyword">do</span>
7490     <span class="keyword">let</span> <span class="keyword">mut</span> i <span class="constant">:=</span> <span class="constant">0</span>
7491     <span class="keyword">for</span> alt <span class="keyword">in</span> altLHSS <span class="keyword">do</span>
7492       <span class="keyword">if</span> result.unusedAltIdxs.contains i <span class="keyword">then</span>
7493         withRef alt.ref <span class="keyword">do</span>
7494           logError <span class="string">"redundant alternative"</span>
7495       i <span class="constant">:=</span> i <span class="constant">+</span> <span class="constant">1</span>
7496 
<span class="comment-delimiter">7497 /-</span><span class="comment">-
7498   If `altLHSS + rhss` is encoding `| PUnit.unit =&gt; rhs[0]`, return `rhs[0]`
7499   Otherwise, return none.
7500 -/</span>
<span class="keyword">7501 private</span> <span class="keyword">def</span> <span class="function-name">isMatchUnit?</span> (altLHSS : List Match.AltLHS) (rhss : Array Expr) : MetaM (Option Expr) <span class="constant">:=</span> <span class="keyword">do</span>
7502   <span class="warning">assert</span><span class="constant">!</span> altLHSS.length <span class="constant">==</span> rhss.size
7503   <span class="keyword">match</span> altLHSS <span class="keyword">with</span>
7504   | [ { fvarDecls <span class="constant">:=</span> [], patterns <span class="constant">:=</span> [ Pattern.ctor `PUnit.unit .. ], .. } ] <span class="constant">=&gt;</span>
7505     <span class="comment-delimiter">/- </span><span class="comment">Recall that for alternatives of the form `| PUnit.unit =&gt; rhs`, `rhss[0]` is of the form `fun _ : Unit =&gt; b`. -/</span>
7506     <span class="keyword">match</span> rhss[<span class="constant">0</span>] <span class="keyword">with</span>
7507     | Expr.lam <span class="preprocessor">_</span> <span class="preprocessor">_</span> b <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">return</span> <span class="keyword">if</span> b.hasLooseBVars <span class="keyword">then</span> none <span class="keyword">else</span> b
7508     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">return</span> none
7509   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">return</span> none
7510 
<span class="comment-delimiter">7511 /-</span><span class="comment">-
7512   "Generalize" variables that depend on the discriminants.
7513 
7514   Remarks and limitations:
7515   - If `matchType` is a proposition, then we generalize even when the user did not provide `(generalizing := true)`.
7516     Motivation: users should have control about the actual `match`-expressions in their programs.
7517   - We currently do not generalize let-decls.
7518   - We abort generalization if the new `matchType` is type incorrect.
7519   - Only discriminants that are free variables are considered during specialization.
7520   - We "generalize" by adding new discriminants and pattern variables. We do not "clear" the generalized variables,
7521     but they become inaccessible since they are shadowed by the patterns variables. We assume this is ok since
7522     this is the exact behavior users would get if they had written it by hand. Recall there is no `clear` in term mode.
7523 -/</span>
<span class="keyword">7524 private</span> <span class="keyword">def</span> <span class="function-name">generalize</span> (discrs : Array Expr) (matchType : Expr) (altViews : Array MatchAltView) (generalizing? : Option Bool) : TermElabM (Array Expr <span class="constant">&#215;</span> Expr <span class="constant">&#215;</span> Array MatchAltView <span class="constant">&#215;</span> Bool) <span class="constant">:=</span> <span class="keyword">do</span>
7525   <span class="keyword">let</span> gen &#8592;
7526     <span class="keyword">match</span> generalizing? <span class="keyword">with</span>
7527     | some g <span class="constant">=&gt;</span> pure g
7528     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> isProp matchType
7529   <span class="keyword">if</span> <span class="constant">!</span>gen <span class="keyword">then</span>
7530     <span class="keyword">return</span> (discrs, matchType, altViews, false)
7531   <span class="keyword">else</span>
7532     <span class="keyword">let</span> ysFVarIds &#8592; getFVarsToGeneralize discrs
7533     <span class="comment-delimiter">/- </span><span class="comment">let-decls are currently being ignored by the generalizer. -/</span>
7534     <span class="keyword">let</span> ysFVarIds &#8592; ysFVarIds.filterM <span class="keyword">fun</span> fvarId <span class="constant">=&gt;</span> <span class="keyword">return</span> <span class="constant">!</span>(&#8592; getLocalDecl fvarId).isLet
7535     <span class="keyword">if</span> ysFVarIds.isEmpty <span class="keyword">then</span>
7536       <span class="keyword">return</span> (discrs, matchType, altViews, false)
7537     <span class="keyword">else</span>
7538       <span class="keyword">let</span> ys <span class="constant">:=</span> ysFVarIds.map mkFVar
7539       <span class="comment-delimiter">-- </span><span class="comment">trace[Meta.debug] "ys: {ys}, discrs: {discrs}"
</span>7540       <span class="keyword">let</span> matchType' &#8592; forallBoundedTelescope matchType discrs.size <span class="keyword">fun</span> ds type <span class="constant">=&gt;</span> <span class="keyword">do</span>
7541         <span class="keyword">let</span> type &#8592; mkForallFVars ys type
7542         <span class="keyword">let</span> (discrs', ds') <span class="constant">:=</span> Array.unzip <span class="constant">&lt;</span>| Array.zip discrs ds |<span class="constant">&gt;</span>.filter <span class="keyword">fun</span> (di, d) <span class="constant">=&gt;</span> di.isFVar
7543         <span class="keyword">let</span> type <span class="constant">:=</span> type.replaceFVars discrs' ds'
7544         mkForallFVars ds type
7545       <span class="comment-delimiter">-- </span><span class="comment">trace[Meta.debug] "matchType': {matchType'}"
</span>7546       <span class="keyword">if</span> (&#8592; isTypeCorrect matchType') <span class="keyword">then</span>
7547         <span class="keyword">let</span> discrs <span class="constant">:=</span> discrs <span class="constant">++</span> ys
7548         <span class="keyword">let</span> altViews &#8592; altViews.mapM <span class="keyword">fun</span> altView <span class="constant">=&gt;</span> <span class="keyword">do</span>
7549           <span class="keyword">let</span> patternVars &#8592; getPatternsVars altView.patterns
7550           <span class="comment-delimiter">-- </span><span class="comment">We traverse backwards because we want to keep the most recent names.
</span>7551           <span class="comment-delimiter">-- </span><span class="comment">For example, if `ys` contains `#[h, h]`, we want to make sure `mkFreshUsername is applied to the first `h`,
</span>7552           <span class="comment-delimiter">-- </span><span class="comment">since it is already shadowed by the second.
</span>7553           <span class="keyword">let</span> ysUserNames &#8592; ys.foldrM (init <span class="constant">:=</span> <span class="constant">#</span>[]) <span class="keyword">fun</span> ys ysUserNames <span class="constant">=&gt;</span> <span class="keyword">do</span>
7554             <span class="keyword">let</span> yDecl &#8592; getLocalDecl ys.fvarId<span class="constant">!</span>
7555             <span class="keyword">let</span> <span class="keyword">mut</span> yUserName <span class="constant">:=</span> yDecl.userName
7556             <span class="keyword">if</span> ysUserNames.contains yUserName <span class="keyword">then</span>
7557               yUserName &#8592; mkFreshUserName yUserName
7558             <span class="comment-delimiter">-- </span><span class="comment">Explicitly provided pattern variables shadow `y`
</span>7559             <span class="keyword">else</span> <span class="keyword">if</span> patternVars.any <span class="keyword">fun</span> | PatternVar.localVar x <span class="constant">=&gt;</span> x <span class="constant">==</span> yUserName | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> false <span class="keyword">then</span>
7560               yUserName &#8592; mkFreshUserName yUserName
7561             <span class="keyword">return</span> ysUserNames.push yUserName
7562           <span class="keyword">let</span> ysIds &#8592; ysUserNames.reverse.mapM <span class="keyword">fun</span> n <span class="constant">=&gt;</span> <span class="keyword">return</span> mkIdentFrom (&#8592; getRef) n
7563           <span class="keyword">return</span> { altView <span class="keyword">with</span> patterns <span class="constant">:=</span> altView.patterns <span class="constant">++</span> ysIds }
7564         <span class="keyword">return</span> (discrs, matchType', altViews, true)
7565       <span class="keyword">else</span>
7566         <span class="keyword">return</span> (discrs, matchType, altViews, true)
7567 
<span class="keyword">7568 private</span> <span class="keyword">def</span> <span class="function-name">elabMatchAux</span> (generalizing? : Option Bool) (discrStxs : Array Syntax) (altViews : Array MatchAltView) (matchOptType : Syntax) (expectedType : Expr)
7569     : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
7570   <span class="keyword">let</span> <span class="keyword">mut</span> generalizing? <span class="constant">:=</span> generalizing?
7571   <span class="keyword">if</span> <span class="constant">!</span>matchOptType.isNone <span class="keyword">then</span>
7572     <span class="keyword">if</span> generalizing? <span class="constant">==</span> some true <span class="keyword">then</span>
7573       throwError <span class="string">"the '(generalizing := true)' parameter is not supported when the 'match' type is explicitly provided"</span>
7574     generalizing? <span class="constant">:=</span> some false
7575   <span class="keyword">let</span> (discrs, matchType, altLHSS, isDep, rhss) &#8592; commitIfDidNotPostpone <span class="keyword">do</span>
7576     <span class="keyword">let</span> &#10216;discrs, matchType, isDep, altViews&#10217; &#8592; elabMatchTypeAndDiscrs discrStxs matchOptType altViews expectedType
7577     <span class="keyword">let</span> (discrs, matchType, altViews, gen) &#8592; generalize discrs matchType altViews generalizing?
7578     <span class="keyword">let</span> isDep <span class="constant">:=</span> isDep <span class="constant">||</span> gen
7579     <span class="keyword">let</span> matchAlts &#8592; liftMacroM <span class="constant">&lt;</span>| expandMacrosInPatterns altViews
7580     trace[Elab.<span class="keyword">match</span>] <span class="string">"matchType: {matchType}"</span>
7581     <span class="keyword">let</span> (discrs, matchType, alts, refined) &#8592; elabMatchAltViews discrs matchType matchAlts
7582     <span class="keyword">let</span> isDep <span class="constant">:=</span> isDep <span class="constant">||</span> refined
7583     <span class="comment-delimiter">/-</span><span class="comment">
7584      We should not use `synthesizeSyntheticMVarsNoPostponing` here. Otherwise, we will not be
7585      able to elaborate examples such as:
7586      ```
7587      def f (x : Nat) : Option Nat := none
7588 
7589      def g (xs : List (Nat &#215; Nat)) : IO Unit :=
7590      xs.forM fun x =&gt;
7591        match f x.fst with
7592        | _ =&gt; pure ()
7593      ```
7594      If `synthesizeSyntheticMVarsNoPostponing`, the example above fails at `x.fst` because
7595      the type of `x` is only available after we proces the last argument of `List.forM`.
7596 
7597      We apply pending default types to make sure we can process examples such as
7598      ```
7599      let (a, b) := (0, 0)
7600      ```
7601     -/</span>
7602     synthesizeSyntheticMVarsUsingDefault
7603     <span class="keyword">let</span> rhss <span class="constant">:=</span> alts.map Prod.snd
7604     <span class="keyword">let</span> matchType &#8592; instantiateMVars matchType
7605     <span class="keyword">let</span> altLHSS &#8592; alts.toList.mapM <span class="keyword">fun</span> alt <span class="constant">=&gt;</span> <span class="keyword">do</span>
7606       <span class="keyword">let</span> altLHS &#8592; Match.instantiateAltLHSMVars alt.<span class="constant">1</span>
7607       <span class="comment-delimiter">/- </span><span class="comment">Remark: we try to postpone before throwing an error.
7608          The combinator `commitIfDidNotPostpone` ensures we backtrack any updates that have been performed.
7609          The quick-check `waitExpectedTypeAndDiscrs` minimizes the number of scenarios where we have to postpone here.
7610          Here is an example that passes the `waitExpectedTypeAndDiscrs` test, but postpones here.
7611          ```
7612           def bad (ps : Array (Nat &#215; Nat)) : Array (Nat &#215; Nat) :=
7613             (ps.filter fun (p : Prod _ _) =&gt;
7614               match p with
7615               | (x, y) =&gt; x == 0)
7616             ++
7617             ps
7618          ```
7619          When we try to elaborate `fun (p : Prod _ _) =&gt; ...` for the first time, we haven't propagated the type of `ps` yet
7620          because `Array.filter` has type `{&#945; : Type u_1} &#8594; (&#945; &#8594; Bool) &#8594; (as : Array &#945;) &#8594; optParam Nat 0 &#8594; optParam Nat (Array.size as) &#8594; Array &#945;`
7621          However, the partial type annotation `(p : Prod _ _)` makes sure we succeed at the quick-check `waitExpectedTypeAndDiscrs`.
7622       -/</span>
7623       withRef altLHS.ref <span class="keyword">do</span>
7624         <span class="keyword">for</span> d <span class="keyword">in</span> altLHS.fvarDecls <span class="keyword">do</span>
7625             <span class="keyword">if</span> d.hasExprMVar <span class="keyword">then</span>
7626             withExistingLocalDecls altLHS.fvarDecls <span class="keyword">do</span>
7627               tryPostpone
7628               throwMVarError m<span class="constant">!</span><span class="string">"invalid match-expression, type of pattern variable '{d.toExpr}' contains metavariables{indentExpr d.type}"</span>
7629         <span class="keyword">for</span> p <span class="keyword">in</span> altLHS.patterns <span class="keyword">do</span>
7630           <span class="keyword">if</span> p.hasExprMVar <span class="keyword">then</span>
7631             withExistingLocalDecls altLHS.fvarDecls <span class="keyword">do</span>
7632               tryPostpone
7633               throwMVarError m<span class="constant">!</span><span class="string">"invalid match-expression, pattern contains metavariables{indentExpr (&#8592; p.toExpr)}"</span>
7634         pure altLHS
7635     <span class="keyword">return</span> (discrs, matchType, altLHSS, isDep, rhss)
7636   <span class="keyword">if</span> <span class="keyword">let</span> some r &#8592; <span class="keyword">if</span> isDep <span class="keyword">then</span> pure none <span class="keyword">else</span> isMatchUnit? altLHSS rhss <span class="keyword">then</span>
7637     <span class="keyword">return</span> r
7638   <span class="keyword">else</span>
7639     <span class="keyword">let</span> numDiscrs <span class="constant">:=</span> discrs.size
7640     <span class="keyword">let</span> matcherName &#8592; mkAuxName `<span class="keyword">match</span>
7641     <span class="keyword">let</span> matcherResult &#8592; mkMatcher matcherName matchType numDiscrs altLHSS
7642     <span class="keyword">let</span> motive &#8592; forallBoundedTelescope matchType numDiscrs <span class="keyword">fun</span> xs matchType <span class="constant">=&gt;</span> mkLambdaFVars xs matchType
7643     reportMatcherResultErrors altLHSS matcherResult
7644     <span class="keyword">let</span> r <span class="constant">:=</span> mkApp matcherResult.matcher motive
7645     <span class="keyword">let</span> r <span class="constant">:=</span> mkAppN r discrs
7646     <span class="keyword">let</span> r <span class="constant">:=</span> mkAppN r rhss
7647     trace[Elab.<span class="keyword">match</span>] <span class="string">"result: {r}"</span>
7648     <span class="keyword">return</span> r
7649 
<span class="keyword">7650 private</span> <span class="keyword">def</span> <span class="function-name">getDiscrs</span> (matchStx : Syntax) : Array Syntax <span class="constant">:=</span>
7651   matchStx[<span class="constant">2</span>].getSepArgs
7652 
<span class="keyword">7653 private</span> <span class="keyword">def</span> <span class="function-name">getMatchOptType</span> (matchStx : Syntax) : Syntax <span class="constant">:=</span>
7654   matchStx[<span class="constant">3</span>]
7655 
<span class="keyword">7656 private</span> <span class="keyword">def</span> <span class="function-name">expandNonAtomicDiscrs?</span> (matchStx : Syntax) : TermElabM (Option Syntax) <span class="constant">:=</span>
7657   <span class="keyword">let</span> matchOptType <span class="constant">:=</span> getMatchOptType matchStx;
7658   <span class="keyword">if</span> matchOptType.isNone <span class="keyword">then</span> <span class="keyword">do</span>
7659     <span class="keyword">let</span> discrs <span class="constant">:=</span> getDiscrs matchStx;
7660     <span class="keyword">let</span> allLocal &#8592; discrs.allM <span class="keyword">fun</span> discr <span class="constant">=&gt;</span> Option.isSome <span class="constant">&lt;$&gt;</span> isAtomicDiscr? discr[<span class="constant">1</span>]
7661     <span class="keyword">if</span> allLocal <span class="keyword">then</span>
7662       <span class="keyword">return</span> none
7663     <span class="keyword">else</span>
7664       <span class="comment-delimiter">-- </span><span class="comment">We use `foundFVars` to make sure the discriminants are distinct variables.
</span>7665       <span class="comment-delimiter">-- </span><span class="comment">See: code for computing "matchType" at `elabMatchTypeAndDiscrs`
</span>7666       <span class="keyword">let</span> <span class="keyword">rec</span> loop (discrs : List Syntax) (discrsNew : Array Syntax) (foundFVars : NameSet) <span class="constant">:=</span> <span class="keyword">do</span>
7667         <span class="keyword">match</span> discrs <span class="keyword">with</span>
7668         | [] <span class="constant">=&gt;</span>
7669           <span class="keyword">let</span> discrs <span class="constant">:=</span> Syntax.mkSep discrsNew (mkAtomFrom matchStx <span class="string">", "</span>);
7670           pure (matchStx.setArg <span class="constant">2</span> discrs)
7671         | discr :: discrs <span class="constant">=&gt;</span>
7672           <span class="comment-delimiter">-- </span><span class="comment">Recall that
</span>7673           <span class="comment-delimiter">-- </span><span class="comment">matchDiscr := leading_parser optional (ident &gt;&gt; ":") &gt;&gt; termParser
</span>7674           <span class="keyword">let</span> term <span class="constant">:=</span> discr[<span class="constant">1</span>]
7675           <span class="keyword">let</span> addAux : TermElabM Syntax <span class="constant">:=</span> withFreshMacroScope <span class="keyword">do</span>
7676             <span class="keyword">let</span> d &#8592; `(_discr);
7677             <span class="keyword">unless</span> isAuxDiscrName d.getId <span class="keyword">do</span> <span class="comment-delimiter">-- </span><span class="comment">Use assertion?
</span>7678               throwError <span class="string">"unexpected internal auxiliary discriminant name"</span>
7679             <span class="keyword">let</span> discrNew <span class="constant">:=</span> discr.setArg <span class="constant">1</span> d;
7680             <span class="keyword">let</span> r &#8592; loop discrs (discrsNew.push discrNew) foundFVars
7681             `(<span class="keyword">let</span> _discr <span class="constant">:=</span> <span class="constant">$</span>term; <span class="constant">$</span>r)
7682           <span class="keyword">match</span> (&#8592; isAtomicDiscr? term) <span class="keyword">with</span>
7683           | some x  <span class="constant">=&gt;</span> <span class="keyword">if</span> x.isFVar <span class="keyword">then</span> loop discrs (discrsNew.push discr) (foundFVars.insert x.fvarId<span class="constant">!</span>) <span class="keyword">else</span> addAux
7684           | none    <span class="constant">=&gt;</span> addAux
7685       <span class="keyword">return</span> some (&#8592; loop discrs.toList <span class="constant">#</span>[] {})
7686   <span class="keyword">else</span>
7687     <span class="comment-delimiter">-- </span><span class="comment">We do not pull non atomic discriminants when match type is provided explicitly by the user
</span>7688     <span class="keyword">return</span> none
7689 
<span class="keyword">7690 private</span> <span class="keyword">def</span> <span class="function-name">waitExpectedType</span> (expectedType? : Option Expr) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
7691   tryPostponeIfNoneOrMVar expectedType?
7692   <span class="keyword">match</span> expectedType? <span class="keyword">with</span>
7693     | some expectedType <span class="constant">=&gt;</span> pure expectedType
7694     | none              <span class="constant">=&gt;</span> mkFreshTypeMVar
7695 
<span class="keyword">7696 private</span> <span class="keyword">def</span> <span class="function-name">tryPostponeIfDiscrTypeIsMVar</span> (matchStx : Syntax) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
7697   <span class="comment-delimiter">-- </span><span class="comment">We don't wait for the discriminants types when match type is provided by user
</span>7698   <span class="keyword">if</span> getMatchOptType matchStx |<span class="constant">&gt;</span>.isNone <span class="keyword">then</span>
7699     <span class="keyword">let</span> discrs <span class="constant">:=</span> getDiscrs matchStx
7700     <span class="keyword">for</span> discr <span class="keyword">in</span> discrs <span class="keyword">do</span>
7701       <span class="keyword">let</span> term <span class="constant">:=</span> discr[<span class="constant">1</span>]
7702       <span class="keyword">match</span> (&#8592; isAtomicDiscr? term) <span class="keyword">with</span>
7703       | none   <span class="constant">=&gt;</span> throwErrorAt discr <span class="string">"unexpected discriminant"</span> <span class="comment-delimiter">-- </span><span class="comment">see `expandNonAtomicDiscrs?
</span>7704       | some d <span class="constant">=&gt;</span>
7705         <span class="keyword">let</span> dType &#8592; inferType d
7706         trace[Elab.<span class="keyword">match</span>] <span class="string">"discr {d} : {dType}"</span>
7707         tryPostponeIfMVar dType
7708 
<span class="comment-delimiter">7709 /-</span><span class="comment">
7710 We (try to) elaborate a `match` only when the expected type is available.
7711 If the `matchType` has not been provided by the user, we also try to postpone elaboration if the type
7712 of a discriminant is not available. That is, it is of the form `(?m ...)`.
7713 We use `expandNonAtomicDiscrs?` to make sure all discriminants are local variables.
7714 This is a standard trick we use in the elaborator, and it is also used to elaborate structure instances.
7715 Suppose, we are trying to elaborate
7716 ```
7717 match g x with
7718   | ... =&gt; ...
7719 ```
7720 `expandNonAtomicDiscrs?` converts it intro
7721 ```
7722 let _discr := g x
7723 match _discr with
7724   | ... =&gt; ...
7725 ```
7726 Thus, at `tryPostponeIfDiscrTypeIsMVar` we only need to check whether the type of `_discr` is not of the form `(?m ...)`.
7727 Note that, the auxiliary variable `_discr` is expanded at `elabAtomicDiscr`.
7728 
7729 This elaboration technique is needed to elaborate terms such as:
7730 ```lean
7731 xs.filter fun (a, b) =&gt; a &gt; b
7732 ```
7733 which are syntax sugar for
7734 ```lean
7735 List.filter (fun p =&gt; match p with | (a, b) =&gt; a &gt; b) xs
7736 ```
7737 When we visit `match p with | (a, b) =&gt; a &gt; b`, we don't know the type of `p` yet.
7738 -/</span>
<span class="keyword">7739 private</span> <span class="keyword">def</span> <span class="function-name">waitExpectedTypeAndDiscrs</span> (matchStx : Syntax) (expectedType? : Option Expr) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
7740   tryPostponeIfNoneOrMVar expectedType?
7741   tryPostponeIfDiscrTypeIsMVar matchStx
7742   <span class="keyword">match</span> expectedType? <span class="keyword">with</span>
7743   | some expectedType <span class="constant">=&gt;</span> <span class="keyword">return</span> expectedType
7744   | none              <span class="constant">=&gt;</span> mkFreshTypeMVar
7745 
<span class="comment-delimiter">7746 /-</span><span class="comment">
7747 ```
7748 leading_parser:leadPrec "match " &gt;&gt; sepBy1 matchDiscr ", " &gt;&gt; optType &gt;&gt; " with " &gt;&gt; matchAlts
7749 ```
7750 Remark the `optIdent` must be `none` at `matchDiscr`. They are expanded by `expandMatchDiscr?`.
7751 -/</span>
<span class="keyword">7752 private</span> <span class="keyword">def</span> <span class="function-name">elabMatchCore</span> (stx : Syntax) (expectedType? : Option Expr) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
7753   <span class="keyword">let</span> expectedType &#8592; waitExpectedTypeAndDiscrs stx expectedType?
7754   <span class="keyword">let</span> discrStxs <span class="constant">:=</span> (getDiscrs stx).map <span class="keyword">fun</span> d <span class="constant">=&gt;</span> d
7755   <span class="keyword">let</span> gen?         <span class="constant">:=</span> getMatchGeneralizing? stx
7756   <span class="keyword">let</span> altViews     <span class="constant">:=</span> getMatchAlts stx
7757   <span class="keyword">let</span> matchOptType <span class="constant">:=</span> getMatchOptType stx
7758   elabMatchAux gen? discrStxs altViews matchOptType expectedType
7759 
<span class="keyword">7760 private</span> <span class="keyword">def</span> <span class="function-name">isPatternVar</span> (stx : Syntax) : TermElabM Bool <span class="constant">:=</span> <span class="keyword">do</span>
7761   <span class="keyword">match</span> (&#8592; resolveId? stx <span class="string">"pattern"</span>) <span class="keyword">with</span>
7762   | none   <span class="constant">=&gt;</span> isAtomicIdent stx
7763   | some f <span class="constant">=&gt;</span> <span class="keyword">match</span> f <span class="keyword">with</span>
7764     | Expr.const fName <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
7765       <span class="keyword">match</span> (&#8592; getEnv).find? fName <span class="keyword">with</span>
7766       | some (ConstantInfo.ctorInfo <span class="preprocessor">_</span>) <span class="constant">=&gt;</span> <span class="keyword">return</span> false
7767       | some <span class="preprocessor">_</span>                         <span class="constant">=&gt;</span> <span class="keyword">return</span> <span class="constant">!</span>hasMatchPatternAttribute (&#8592; getEnv) fName
7768       | <span class="preprocessor">_</span>                              <span class="constant">=&gt;</span> isAtomicIdent stx
7769     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> isAtomicIdent stx
<span class="keyword">7770 where</span>
7771   isAtomicIdent (stx : Syntax) : Bool <span class="constant">:=</span>
7772     stx.isIdent <span class="constant">&amp;&amp;</span> stx.getId.eraseMacroScopes.isAtomic
7773 
<span class="comment-delimiter">7774 -- </span><span class="comment">leading_parser "match " &gt;&gt; sepBy1 termParser ", " &gt;&gt; optType &gt;&gt; " with " &gt;&gt; matchAlts
</span><span class="constant">7775 @</span>[builtinTermElab <span class="comment">&#171;</span>match<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabMatch</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span> <span class="keyword">do</span>
7776   <span class="keyword">match</span> stx <span class="keyword">with</span>
7777   | `(<span class="keyword">match</span> <span class="constant">$</span>discr:term <span class="keyword">with</span> | <span class="constant">$</span>y:ident <span class="constant">=&gt;</span> <span class="constant">$</span>rhs:term) <span class="constant">=&gt;</span>
7778      <span class="keyword">if</span> (&#8592; isPatternVar y) <span class="keyword">then</span> expandSimpleMatch stx discr y rhs expectedType? <span class="keyword">else</span> elabMatchDefault stx expectedType?
7779   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> elabMatchDefault stx expectedType?
<span class="keyword">7780 where</span>
7781   elabMatchDefault (stx : Syntax) (expectedType? : Option Expr) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
7782     <span class="keyword">match</span> (&#8592; expandNonAtomicDiscrs? stx) <span class="keyword">with</span>
7783     | some stxNew <span class="constant">=&gt;</span> withMacroExpansion stx stxNew <span class="constant">&lt;</span>| elabTerm stxNew expectedType?
7784     | none <span class="constant">=&gt;</span>
7785       <span class="keyword">let</span> discrs       <span class="constant">:=</span> getDiscrs stx;
7786       <span class="keyword">let</span> matchOptType <span class="constant">:=</span> getMatchOptType stx;
7787       <span class="keyword">if</span> <span class="constant">!</span>matchOptType.isNone <span class="constant">&amp;&amp;</span> discrs.any <span class="keyword">fun</span> d <span class="constant">=&gt;</span> <span class="constant">!</span>d[<span class="constant">0</span>].isNone <span class="keyword">then</span>
7788         throwErrorAt matchOptType <span class="string">"match expected type should not be provided when discriminants with equality proofs are used"</span>
7789       elabMatchCore stx expectedType?
7790 
<span class="keyword">7791 builtin_initialize</span>
7792   registerTraceClass `Elab.<span class="keyword">match</span>
7793 
<span class="comment-delimiter">7794 -- </span><span class="comment">leading_parser:leadPrec "nomatch " &gt;&gt; termParser
</span><span class="constant">7795 @</span>[builtinTermElab <span class="comment">&#171;</span>nomatch<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabNoMatch</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span> <span class="keyword">do</span>
7796   <span class="keyword">match</span> stx <span class="keyword">with</span>
7797   | `(<span class="keyword">nomatch</span> <span class="constant">$</span>discrExpr) <span class="constant">=&gt;</span>
7798     <span class="keyword">match</span> &#8592; isLocalIdent? discrExpr <span class="keyword">with</span>
7799     | some <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
7800       <span class="keyword">let</span> expectedType &#8592; waitExpectedType expectedType?
7801       <span class="keyword">let</span> discr <span class="constant">:=</span> Syntax.node ``Lean.Parser.Term.matchDiscr <span class="constant">#</span>[mkNullNode, discrExpr]
7802       elabMatchAux none <span class="constant">#</span>[discr] <span class="constant">#</span>[] mkNullNode expectedType
7803     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
7804       <span class="keyword">let</span> stxNew &#8592; `(<span class="keyword">let</span> _discr <span class="constant">:=</span> <span class="constant">$</span>discrExpr; <span class="keyword">nomatch</span> _discr)
7805       withMacroExpansion stx stxNew <span class="constant">&lt;</span>| elabTerm stxNew expectedType?
7806   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwUnsupportedSyntax
7807 
<span class="keyword">7808 end</span> Lean.Elab.Term
7809 ::::::::::::::
7810 Elab<span class="constant">/</span>MutualDef.lean
7811 ::::::::::::::
<span class="comment-delimiter">7812 /-</span><span class="comment">
7813 Copyright (c) 2020 Microsoft Corporation. All rights reserved.
7814 Released under Apache 2.0 license as described in the file LICENSE.
7815 Authors: Leonardo de Moura
7816 -/</span>
<span class="keyword">7817 import</span> Lean.Parser.Term
<span class="keyword">7818 import</span> Lean.Meta.Closure
<span class="keyword">7819 import</span> Lean.Meta.Check
<span class="keyword">7820 import</span> Lean.Elab.Command
<span class="keyword">7821 import</span> Lean.Elab.DefView
<span class="keyword">7822 import</span> Lean.Elab.PreDefinition
<span class="keyword">7823 import</span> Lean.Elab.DeclarationRange
7824 
<span class="keyword">7825 namespace</span> Lean.Elab
<span class="keyword">7826 open</span> Lean.Parser.Term
7827 
<span class="comment-delimiter">7828 /- </span><span class="comment">DefView after elaborating the header. -/</span>
<span class="keyword">7829 structure</span> <span class="function-name">DefViewElabHeader</span> <span class="keyword">where</span>
7830   ref           : Syntax
7831   modifiers     : Modifiers
7832   kind          : DefKind
7833   shortDeclName : Name
7834   declName      : Name
7835   levelNames    : List Name
7836   numParams     : Nat
7837   type          : Expr <span class="comment-delimiter">-- </span><span class="comment">including the parameters
</span>7838   valueStx      : Syntax
7839   <span class="keyword">deriving</span> Inhabited
7840 
<span class="keyword">7841 namespace</span> Term
7842 
<span class="keyword">7843 open</span> Meta
7844 
<span class="keyword">7845 private</span> <span class="keyword">def</span> <span class="function-name">checkModifiers</span> (m&#8321; m&#8322; : Modifiers) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
7846   <span class="keyword">unless</span> m&#8321;.isUnsafe <span class="constant">==</span> m&#8322;.isUnsafe <span class="keyword">do</span>
7847     throwError <span class="string">"cannot mix unsafe and safe definitions"</span>
7848   <span class="keyword">unless</span> m&#8321;.isNoncomputable <span class="constant">==</span> m&#8322;.isNoncomputable <span class="keyword">do</span>
7849     throwError <span class="string">"cannot mix computable and non-computable definitions"</span>
7850   <span class="keyword">unless</span> m&#8321;.isPartial <span class="constant">==</span> m&#8322;.isPartial <span class="keyword">do</span>
7851     throwError <span class="string">"cannot mix partial and non-partial definitions"</span>
7852 
<span class="keyword">7853 private</span> <span class="keyword">def</span> <span class="function-name">checkKinds</span> (k&#8321; k&#8322; : DefKind) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
7854   <span class="keyword">unless</span> k&#8321;.isExample <span class="constant">==</span> k&#8322;.isExample <span class="keyword">do</span>
7855     throwError <span class="string">"cannot mix examples and definitions"</span> <span class="comment-delimiter">-- </span><span class="comment">Reason: we should discard examples
</span>7856   <span class="keyword">unless</span> k&#8321;.isTheorem <span class="constant">==</span> k&#8322;.isTheorem <span class="keyword">do</span>
7857     throwError <span class="string">"cannot mix theorems and definitions"</span> <span class="comment-delimiter">-- </span><span class="comment">Reason: we will eventually elaborate theorems in `Task`s.
</span>7858 
<span class="keyword">7859 private</span> <span class="keyword">def</span> <span class="function-name">check</span> (prevHeaders : Array DefViewElabHeader) (newHeader : DefViewElabHeader) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
7860   <span class="keyword">if</span> newHeader.kind.isTheorem <span class="constant">&amp;&amp;</span> newHeader.modifiers.isUnsafe <span class="keyword">then</span>
7861     throwError <span class="string">"'unsafe' theorems are not allowed"</span>
7862   <span class="keyword">if</span> newHeader.kind.isTheorem <span class="constant">&amp;&amp;</span> newHeader.modifiers.isPartial <span class="keyword">then</span>
7863     throwError <span class="string">"'partial' theorems are not allowed, 'partial' is a code generation directive"</span>
7864   <span class="keyword">if</span> newHeader.kind.isTheorem <span class="constant">&amp;&amp;</span> newHeader.modifiers.isNoncomputable <span class="keyword">then</span>
7865     throwError <span class="string">"'theorem' subsumes 'noncomputable', code is not generated for theorems"</span>
7866   <span class="keyword">if</span> newHeader.modifiers.isNoncomputable <span class="constant">&amp;&amp;</span> newHeader.modifiers.isUnsafe <span class="keyword">then</span>
7867     throwError <span class="string">"'noncomputable unsafe' is not allowed"</span>
7868   <span class="keyword">if</span> newHeader.modifiers.isNoncomputable <span class="constant">&amp;&amp;</span> newHeader.modifiers.isPartial <span class="keyword">then</span>
7869     throwError <span class="string">"'noncomputable partial' is not allowed"</span>
7870   <span class="keyword">if</span> newHeader.modifiers.isPartial <span class="constant">&amp;&amp;</span> newHeader.modifiers.isUnsafe <span class="keyword">then</span>
7871     throwError <span class="string">"'unsafe' subsumes 'partial'"</span>
7872   <span class="keyword">if</span> h : <span class="constant">0</span> <span class="constant">&lt;</span> prevHeaders.size <span class="keyword">then</span>
7873     <span class="keyword">let</span> firstHeader <span class="constant">:=</span> prevHeaders.get &#10216;<span class="constant">0</span>, h&#10217;
7874     <span class="keyword">try</span>
7875       <span class="keyword">unless</span> newHeader.levelNames <span class="constant">==</span> firstHeader.levelNames <span class="keyword">do</span>
7876         throwError <span class="string">"universe parameters mismatch"</span>
7877       checkModifiers newHeader.modifiers firstHeader.modifiers
7878       checkKinds newHeader.kind firstHeader.kind
7879     <span class="keyword">catch</span>
7880        | Exception.error ref msg <span class="constant">=&gt;</span> throw (Exception.error ref m<span class="constant">!</span><span class="string">"invalid mutually recursive definitions, {msg}"</span>)
7881        | ex <span class="constant">=&gt;</span> throw ex
7882   <span class="keyword">else</span>
7883     pure ()
7884 
<span class="keyword">7885 private</span> <span class="keyword">def</span> <span class="function-name">registerFailedToInferDefTypeInfo</span> (type : Expr) (ref : Syntax) : TermElabM Unit <span class="constant">:=</span>
7886   registerCustomErrorIfMVar type ref <span class="string">"failed to infer definition type"</span>
7887 
<span class="keyword">7888 private</span> <span class="keyword">def</span> <span class="function-name">elabHeaders</span> (views : Array DefView) : TermElabM (Array DefViewElabHeader) <span class="constant">:=</span> <span class="keyword">do</span>
7889   <span class="keyword">let</span> <span class="keyword">mut</span> headers <span class="constant">:=</span> <span class="constant">#</span>[]
7890   <span class="keyword">for</span> view <span class="keyword">in</span> views <span class="keyword">do</span>
7891     <span class="keyword">let</span> newHeader &#8592; withRef view.ref <span class="keyword">do</span>
7892       <span class="keyword">let</span> &#10216;shortDeclName, declName, levelNames&#10217; &#8592; expandDeclId (&#8592; getCurrNamespace) (&#8592; getLevelNames) view.declId view.modifiers
7893       addDeclarationRanges declName view.ref
7894       applyAttributesAt declName view.modifiers.attrs AttributeApplicationTime.beforeElaboration
7895       withDeclName declName <span class="constant">&lt;</span>| withAutoBoundImplicit <span class="constant">&lt;</span>| withLevelNames levelNames <span class="constant">&lt;</span>|
7896         elabBinders view.binders.getArgs <span class="keyword">fun</span> xs <span class="constant">=&gt;</span> <span class="keyword">do</span>
7897           <span class="keyword">let</span> refForElabFunType <span class="constant">:=</span> view.value
7898           <span class="keyword">let</span> type &#8592; <span class="keyword">match</span> view.type? <span class="keyword">with</span>
7899             | some typeStx <span class="constant">=&gt;</span>
7900               <span class="keyword">let</span> type &#8592; elabType typeStx
7901               registerFailedToInferDefTypeInfo type typeStx
7902               pure type
7903             | none <span class="constant">=&gt;</span>
7904               <span class="keyword">let</span> hole <span class="constant">:=</span> mkHole refForElabFunType
7905               <span class="keyword">let</span> type &#8592; elabType hole
7906               registerFailedToInferDefTypeInfo type refForElabFunType
7907               pure type
7908           Term.synthesizeSyntheticMVarsNoPostponing
7909           <span class="keyword">let</span> type &#8592; mkForallFVars xs type
7910           <span class="keyword">let</span> type &#8592; mkForallFVars (&#8592; read).autoBoundImplicits.toArray type
7911           <span class="keyword">let</span> type &#8592; instantiateMVars type
7912           <span class="keyword">let</span> xs &#8592; addAutoBoundImplicits xs
7913           <span class="keyword">let</span> levelNames &#8592; getLevelNames
7914           <span class="keyword">if</span> view.type?.isSome <span class="keyword">then</span>
7915             <span class="keyword">let</span> pendingMVarIds &#8592; getMVars type
7916             discard <span class="constant">&lt;</span>| logUnassignedUsingErrorInfos pendingMVarIds <span class="constant">&lt;</span>|
7917               m<span class="constant">!</span><span class="string">"\nwhen the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed"</span>
7918           <span class="keyword">let</span> newHeader <span class="constant">:=</span> {
7919             ref           <span class="constant">:=</span> view.ref,
7920             modifiers     <span class="constant">:=</span> view.modifiers,
7921             kind          <span class="constant">:=</span> view.kind,
7922             shortDeclName <span class="constant">:=</span> shortDeclName,
7923             declName      <span class="constant">:=</span> declName,
7924             levelNames    <span class="constant">:=</span> levelNames,
7925             numParams     <span class="constant">:=</span> xs.size,
7926             type          <span class="constant">:=</span> type,
7927             valueStx      <span class="constant">:=</span> view.value : DefViewElabHeader }
7928           check headers newHeader
7929           pure newHeader
7930     headers <span class="constant">:=</span> headers.push newHeader
7931   pure headers
7932 
<span class="keyword">7933 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">withFunLocalDecls</span> {&#945;} (headers : Array DefViewElabHeader) (k : Array Expr <span class="constant">&#8594;</span> TermElabM &#945;) : TermElabM &#945; <span class="constant">:=</span>
7934   <span class="keyword">let</span> <span class="keyword">rec</span> loop (i : Nat) (fvars : Array Expr) <span class="constant">:=</span> <span class="keyword">do</span>
7935     <span class="keyword">if</span> h : i <span class="constant">&lt;</span> headers.size <span class="keyword">then</span>
7936       <span class="keyword">let</span> header <span class="constant">:=</span> headers.get &#10216;i, h&#10217;
7937       withLocalDecl header.shortDeclName BinderInfo.auxDecl header.type <span class="keyword">fun</span> fvar <span class="constant">=&gt;</span> loop (i<span class="constant">+1</span>) (fvars.push fvar)
7938     <span class="keyword">else</span>
7939       k fvars
7940   loop <span class="constant">0</span> <span class="constant">#</span>[]
7941 
<span class="keyword">7942 private</span> <span class="keyword">def</span> <span class="function-name">expandWhereDeclsAsStructInst</span> : Macro
7943   | `(whereDecls|<span class="keyword">where</span> <span class="constant">$</span>[<span class="constant">$</span>decls:letRecDecl<span class="constant">$</span>[;]?]<span class="constant">*</span>) <span class="constant">=&gt;</span> <span class="keyword">do</span>
7944     <span class="keyword">let</span> letIdDecls &#8592; decls.mapM <span class="keyword">fun</span> stx <span class="constant">=&gt;</span> <span class="keyword">match</span> stx <span class="keyword">with</span>
7945       | `(letRecDecl|<span class="constant">$</span>attrs:<span class="keyword">attributes</span> <span class="constant">$</span>decl:letDecl) <span class="constant">=&gt;</span> Macro.throwErrorAt stx <span class="string">"attributes are 'where' elements are currently not supported here"</span>
7946       | `(letRecDecl|<span class="constant">$</span>decl:letPatDecl)  <span class="constant">=&gt;</span> Macro.throwErrorAt stx <span class="string">"patterns are not allowed here"</span>
7947       | `(letRecDecl|<span class="constant">$</span>decl:letEqnsDecl) <span class="constant">=&gt;</span> expandLetEqnsDecl decl
7948       | `(letRecDecl|<span class="constant">$</span>decl:letIdDecl)   <span class="constant">=&gt;</span> pure decl
7949       | <span class="preprocessor">_</span>                               <span class="constant">=&gt;</span> Macro.throwUnsupported
7950     <span class="keyword">let</span> structInstFields &#8592; letIdDecls.mapM <span class="keyword">fun</span>
7951       | stx<span class="constant">@</span>`(letIdDecl|<span class="constant">$</span>id:ident <span class="constant">$</span>[<span class="constant">$</span>binders]<span class="constant">*</span> <span class="constant">$</span>[: <span class="constant">$</span>ty?]? <span class="constant">:=</span> <span class="constant">$</span>val) <span class="constant">=&gt;</span> withRef stx <span class="keyword">do</span>
7952         <span class="keyword">let</span> <span class="keyword">mut</span> val <span class="constant">:=</span> val
7953         <span class="keyword">if</span> <span class="keyword">let</span> some ty <span class="constant">:=</span> ty? <span class="keyword">then</span>
7954           val &#8592; `((<span class="constant">$</span>val : <span class="constant">$</span>ty))
7955         val &#8592; `(<span class="keyword">fun</span> <span class="constant">$</span>[<span class="constant">$</span>binders]<span class="constant">*</span> <span class="constant">=&gt;</span> <span class="constant">$</span>val:term)
7956         `(structInstField|<span class="constant">$</span>id:ident <span class="constant">:=</span> <span class="constant">$</span>val)
7957       | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> Macro.throwUnsupported
7958     `({ <span class="constant">$</span>[<span class="constant">$</span>structInstFields,]<span class="constant">*</span> })
7959   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> Macro.throwUnsupported
7960 
<span class="comment-delimiter">7961 /-</span><span class="comment">
7962 Recall that
7963 ```
7964 def declValSimple    := leading_parser " :=\n" &gt;&gt; termParser &gt;&gt; optional Term.whereDecls
7965 def declValEqns      := leading_parser Term.matchAltsWhereDecls
7966 def declVal          := declValSimple &lt;|&gt; declValEqns &lt;|&gt; Term.whereDecls
7967 ```
7968 -/</span>
<span class="keyword">7969 private</span> <span class="keyword">def</span> <span class="function-name">declValToTerm</span> (declVal : Syntax) : MacroM Syntax <span class="constant">:=</span> withRef declVal <span class="keyword">do</span>
7970   <span class="keyword">if</span> declVal.isOfKind `Lean.Parser.Command.declValSimple <span class="keyword">then</span>
7971     expandWhereDeclsOpt declVal[<span class="constant">2</span>] declVal[<span class="constant">1</span>]
7972   <span class="keyword">else</span> <span class="keyword">if</span> declVal.isOfKind `Lean.Parser.Command.declValEqns <span class="keyword">then</span>
7973     expandMatchAltsWhereDecls declVal[<span class="constant">0</span>]
7974   <span class="keyword">else</span> <span class="keyword">if</span> declVal.isOfKind `Lean.Parser.Term.whereDecls <span class="keyword">then</span>
7975     expandWhereDeclsAsStructInst declVal
7976   <span class="keyword">else</span> <span class="keyword">if</span> declVal.isMissing <span class="keyword">then</span>
7977     Macro.throwErrorAt declVal <span class="string">"declaration body is missing"</span>
7978   <span class="keyword">else</span>
7979     Macro.throwErrorAt declVal <span class="string">"unexpected declaration body"</span>
7980 
<span class="keyword">7981 private</span> <span class="keyword">def</span> <span class="function-name">elabFunValues</span> (headers : Array DefViewElabHeader) : TermElabM (Array Expr) <span class="constant">:=</span>
7982   headers.mapM <span class="keyword">fun</span> header <span class="constant">=&gt;</span> withDeclName header.declName <span class="constant">$</span> withLevelNames header.levelNames <span class="keyword">do</span>
7983     <span class="keyword">let</span> valStx &#8592; liftMacroM <span class="constant">$</span> declValToTerm header.valueStx
7984     forallBoundedTelescope header.type header.numParams <span class="keyword">fun</span> xs type <span class="constant">=&gt;</span> <span class="keyword">do</span>
7985       <span class="keyword">let</span> val &#8592; elabTermEnsuringType valStx type
7986       mkLambdaFVars xs val
7987 
<span class="keyword">7988 private</span> <span class="keyword">def</span> <span class="function-name">collectUsed</span> (headers : Array DefViewElabHeader) (values : Array Expr) (toLift : List LetRecToLift)
7989     : StateRefT CollectFVars.State MetaM Unit <span class="constant">:=</span> <span class="keyword">do</span>
7990   headers.forM <span class="keyword">fun</span> header <span class="constant">=&gt;</span> collectUsedFVars header.type
7991   values.forM collectUsedFVars
7992   toLift.forM <span class="keyword">fun</span> letRecToLift <span class="constant">=&gt;</span> <span class="keyword">do</span>
7993     collectUsedFVars letRecToLift.type
7994     collectUsedFVars letRecToLift.val
7995 
<span class="keyword">7996 private</span> <span class="keyword">def</span> <span class="function-name">removeUnusedVars</span> (vars : Array Expr) (headers : Array DefViewElabHeader) (values : Array Expr) (toLift : List LetRecToLift)
7997     : TermElabM (LocalContext <span class="constant">&#215;</span> LocalInstances <span class="constant">&#215;</span> Array Expr) <span class="constant">:=</span> <span class="keyword">do</span>
7998   <span class="keyword">let</span> (<span class="preprocessor">_</span>, used) &#8592; (collectUsed headers values toLift).run {}
7999   removeUnused vars used
8000 
<span class="keyword">8001 private</span> <span class="keyword">def</span> <span class="function-name">withUsed</span> {&#945;} (vars : Array Expr) (headers : Array DefViewElabHeader) (values : Array Expr) (toLift : List LetRecToLift)
8002     (k : Array Expr <span class="constant">&#8594;</span> TermElabM &#945;) : TermElabM &#945; <span class="constant">:=</span> <span class="keyword">do</span>
8003   <span class="keyword">let</span> (lctx, localInsts, vars) &#8592; removeUnusedVars vars headers values toLift
8004   withLCtx lctx localInsts <span class="constant">$</span> k vars
8005 
<span class="keyword">8006 private</span> <span class="keyword">def</span> <span class="function-name">isExample</span> (views : Array DefView) : Bool <span class="constant">:=</span>
8007   views.any (&#183;.kind.isExample)
8008 
<span class="keyword">8009 private</span> <span class="keyword">def</span> <span class="function-name">isTheorem</span> (views : Array DefView) : Bool <span class="constant">:=</span>
8010   views.any (&#183;.kind.isTheorem)
8011 
<span class="keyword">8012 private</span> <span class="keyword">def</span> <span class="function-name">instantiateMVarsAtHeader</span> (header : DefViewElabHeader) : TermElabM DefViewElabHeader <span class="constant">:=</span> <span class="keyword">do</span>
8013   <span class="keyword">let</span> type &#8592; instantiateMVars header.type
8014   pure { header <span class="keyword">with</span> type <span class="constant">:=</span> type }
8015 
<span class="keyword">8016 private</span> <span class="keyword">def</span> <span class="function-name">instantiateMVarsAtLetRecToLift</span> (toLift : LetRecToLift) : TermElabM LetRecToLift <span class="constant">:=</span> <span class="keyword">do</span>
8017   <span class="keyword">let</span> type &#8592; instantiateMVars toLift.type
8018   <span class="keyword">let</span> val &#8592; instantiateMVars toLift.val
8019   pure { toLift <span class="keyword">with</span> type <span class="constant">:=</span> type, val <span class="constant">:=</span> val }
8020 
<span class="keyword">8021 private</span> <span class="keyword">def</span> <span class="function-name">typeHasRecFun</span> (type : Expr) (funFVars : Array Expr) (letRecsToLift : List LetRecToLift) : Option FVarId <span class="constant">:=</span>
8022   <span class="keyword">let</span> occ? <span class="constant">:=</span> type.find? <span class="keyword">fun</span> e <span class="constant">=&gt;</span> <span class="keyword">match</span> e <span class="keyword">with</span>
8023     | Expr.fvar fvarId <span class="preprocessor">_</span> <span class="constant">=&gt;</span> funFVars.contains e <span class="constant">||</span> letRecsToLift.any <span class="keyword">fun</span> toLift <span class="constant">=&gt;</span> toLift.fvarId <span class="constant">==</span> fvarId
8024     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> false
8025   <span class="keyword">match</span> occ? <span class="keyword">with</span>
8026   | some (Expr.fvar fvarId <span class="preprocessor">_</span>) <span class="constant">=&gt;</span> some fvarId
8027   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> none
8028 
<span class="keyword">8029 private</span> <span class="keyword">def</span> <span class="function-name">getFunName</span> (fvarId : FVarId) (letRecsToLift : List LetRecToLift) : TermElabM Name <span class="constant">:=</span> <span class="keyword">do</span>
8030   <span class="keyword">match</span> (&#8592; findLocalDecl? fvarId) <span class="keyword">with</span>
8031   | some decl <span class="constant">=&gt;</span> pure decl.userName
8032   | none <span class="constant">=&gt;</span>
8033     <span class="comment-delimiter">/- </span><span class="comment">Recall that the FVarId of nested let-recs are not in the current local context. -/</span>
8034     <span class="keyword">match</span> letRecsToLift.findSome? <span class="keyword">fun</span> toLift <span class="constant">=&gt;</span> <span class="keyword">if</span> toLift.fvarId <span class="constant">==</span> fvarId <span class="keyword">then</span> some toLift.shortDeclName <span class="keyword">else</span> none <span class="keyword">with</span>
8035     | none   <span class="constant">=&gt;</span> throwError <span class="string">"unknown function"</span>
8036     | some n <span class="constant">=&gt;</span> pure n
8037 
<span class="comment-delimiter">8038 /-</span><span class="comment">
8039 Ensures that the of let-rec definition types do not contain functions being defined.
8040 In principle, this test can be improved. We could perform it after we separate the set of functions is strongly connected components.
8041 However, this extra complication doesn't seem worth it.
8042 -/</span>
<span class="keyword">8043 private</span> <span class="keyword">def</span> <span class="function-name">checkLetRecsToLiftTypes</span> (funVars : Array Expr) (letRecsToLift : List LetRecToLift) : TermElabM Unit <span class="constant">:=</span>
8044   letRecsToLift.forM <span class="keyword">fun</span> toLift <span class="constant">=&gt;</span>
8045     <span class="keyword">match</span> typeHasRecFun toLift.type funVars letRecsToLift <span class="keyword">with</span>
8046     | none        <span class="constant">=&gt;</span> pure ()
8047     | some fvarId <span class="constant">=&gt;</span> <span class="keyword">do</span>
8048       <span class="keyword">let</span> fnName &#8592; getFunName fvarId letRecsToLift
8049       throwErrorAt toLift.ref <span class="string">"invalid type in 'let rec', it uses '{fnName}' which is being defined simultaneously"</span>
8050 
<span class="keyword">8051 namespace</span> MutualClosure
8052 
<span class="comment-delimiter">8053 /- </span><span class="comment">A mapping from FVarId to Set of FVarIds. -/</span>
<span class="keyword">8054 abbrev</span> UsedFVarsMap <span class="constant">:=</span> NameMap NameSet
8055 
<span class="comment-delimiter">8056 /-</span><span class="comment">
8057 Create the `UsedFVarsMap` mapping that takes the variable id for the mutually recursive functions being defined to the set of
8058 free variables in its definition.
8059 
8060 For `mainFVars`, this is just the set of section variables `sectionVars` used.
8061 For nested let-rec functions, we collect their free variables.
8062 
8063 Recall that a `let rec` expressions are encoded as follows in the elaborator.
8064 ```lean
8065 let rec
8066   f : A := t,
8067   g : B := s;
8068 body
8069 ```
8070 is encoded as
8071 ```lean
8072 let f : A := ?m&#8321;;
8073 let g : B := ?m&#8322;;
8074 body
8075 ```
8076 where `?m&#8321;` and `?m&#8322;` are synthetic opaque metavariables. That are assigned by this module.
8077 We may have nested `let rec`s.
8078 ```lean
8079 let rec f : A :=
8080     let rec g : B := t;
8081     s;
8082 body
8083 ```
8084 is encoded as
8085 ```lean
8086 let f : A := ?m&#8321;;
8087 body
8088 ```
8089 and the body of `f` is stored the field `val` of a `LetRecToLift`. For the example above,
8090 we would have a `LetRecToLift` containing:
8091 ```
8092 {
8093   mvarId := m&#8321;,
8094   val    := `(let g : B := ?m&#8322;; body)
8095   ...
8096 }
8097 ```
8098 Note that `g` is not a free variable at `(let g : B := ?m&#8322;; body)`. We recover the fact that
8099 `f` depends on `g` because it contains `m&#8322;`
8100 -/</span>
<span class="keyword">8101 private</span> <span class="keyword">def</span> <span class="function-name">mkInitialUsedFVarsMap</span> (mctx : MetavarContext) (sectionVars : Array Expr) (mainFVarIds : Array FVarId) (letRecsToLift : List LetRecToLift)
8102     : UsedFVarsMap <span class="constant">:=</span> <span class="keyword">do</span>
8103   <span class="keyword">let</span> <span class="keyword">mut</span> sectionVarSet <span class="constant">:=</span> {}
8104   <span class="keyword">for</span> var <span class="keyword">in</span> sectionVars <span class="keyword">do</span>
8105     sectionVarSet <span class="constant">:=</span> sectionVarSet.insert var.fvarId<span class="constant">!</span>
8106   <span class="keyword">let</span> <span class="keyword">mut</span> usedFVarMap <span class="constant">:=</span> {}
8107   <span class="keyword">for</span> mainFVarId <span class="keyword">in</span> mainFVarIds <span class="keyword">do</span>
8108     usedFVarMap <span class="constant">:=</span> usedFVarMap.insert mainFVarId sectionVarSet
8109   <span class="keyword">for</span> toLift <span class="keyword">in</span> letRecsToLift <span class="keyword">do</span>
8110     <span class="keyword">let</span> state <span class="constant">:=</span> Lean.collectFVars {} toLift.val
8111     <span class="keyword">let</span> state <span class="constant">:=</span> Lean.collectFVars state toLift.type
8112     <span class="keyword">let</span> <span class="keyword">mut</span> set <span class="constant">:=</span> state.fvarSet
8113     <span class="comment-delimiter">/- </span><span class="comment">toLift.val may contain metavariables that are placeholders for nested let-recs. We should collect the fvarId
8114        for the associated let-rec because we need this information to compute the fixpoint later. -/</span>
8115     <span class="keyword">let</span> mvarIds <span class="constant">:=</span> (toLift.val.collectMVars {}).result
8116     <span class="keyword">for</span> mvarId <span class="keyword">in</span> mvarIds <span class="keyword">do</span>
8117       <span class="keyword">match</span> letRecsToLift.findSome? <span class="keyword">fun</span> (toLift : LetRecToLift) <span class="constant">=&gt;</span> <span class="keyword">if</span> toLift.mvarId <span class="constant">==</span> mctx.getDelayedRoot mvarId <span class="keyword">then</span> some toLift.fvarId <span class="keyword">else</span> none <span class="keyword">with</span>
8118       | some fvarId <span class="constant">=&gt;</span> set <span class="constant">:=</span> set.insert fvarId
8119       | none        <span class="constant">=&gt;</span> pure ()
8120     usedFVarMap <span class="constant">:=</span> usedFVarMap.insert toLift.fvarId set
8121   pure usedFVarMap
8122 
<span class="comment-delimiter">8123 /-</span><span class="comment">
8124 The let-recs may invoke each other. Example:
8125 ```
8126 let rec
8127   f (x : Nat) := g x + y
8128   g : Nat &#8594; Nat
8129     | 0   =&gt; 1
8130     | x+1 =&gt; f x + z
8131 ```
8132 `y` is free variable in `f`, and `z` is a free variable in `g`.
8133 To close `f` and `g`, `y` and `z` must be in the closure of both.
8134 That is, we need to generate the top-level definitions.
8135 ```
8136 def f (y z x : Nat) := g y z x + y
8137 def g (y z : Nat) : Nat &#8594; Nat
8138   | 0 =&gt; 1
8139   | x+1 =&gt; f y z x + z
8140 ```
8141 -/</span>
<span class="keyword">8142 namespace</span> FixPoint
8143 
<span class="keyword">8144 structure</span> <span class="function-name">State</span> <span class="keyword">where</span>
8145   usedFVarsMap : UsedFVarsMap <span class="constant">:=</span> {}
8146   modified     : Bool         <span class="constant">:=</span> false
8147 
<span class="keyword">8148 abbrev</span> M <span class="constant">:=</span> ReaderT (List FVarId) <span class="constant">$</span> StateM State
8149 
<span class="keyword">8150 private</span> <span class="keyword">def</span> <span class="function-name">isModified</span> : M Bool <span class="constant">:=</span> <span class="keyword">do</span> pure (&#8592; get).modified
<span class="keyword">8151 private</span> <span class="keyword">def</span> <span class="function-name">resetModified</span> : M Unit <span class="constant">:=</span> modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> modified <span class="constant">:=</span> false }
<span class="keyword">8152 private</span> <span class="keyword">def</span> <span class="function-name">markModified</span> : M Unit <span class="constant">:=</span> modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> modified <span class="constant">:=</span> true }
<span class="keyword">8153 private</span> <span class="keyword">def</span> <span class="function-name">getUsedFVarsMap</span> : M UsedFVarsMap <span class="constant">:=</span> <span class="keyword">do</span> pure (&#8592; get).usedFVarsMap
<span class="keyword">8154 private</span> <span class="keyword">def</span> <span class="function-name">modifyUsedFVars</span> (f : UsedFVarsMap <span class="constant">&#8594;</span> UsedFVarsMap) : M Unit <span class="constant">:=</span> modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> usedFVarsMap <span class="constant">:=</span> f s.usedFVarsMap }
8155 
<span class="comment-delimiter">8156 -- </span><span class="comment">merge s&#8322; into s&#8321;
</span><span class="keyword">8157 private</span> <span class="keyword">def</span> <span class="function-name">merge</span> (s&#8321; s&#8322; : NameSet) : M NameSet <span class="constant">:=</span>
8158   s&#8322;.foldM (init <span class="constant">:=</span> s&#8321;) <span class="keyword">fun</span> s&#8321; k <span class="constant">=&gt;</span> <span class="keyword">do</span>
8159     <span class="keyword">if</span> s&#8321;.contains k <span class="keyword">then</span>
8160       pure s&#8321;
8161     <span class="keyword">else</span>
8162       markModified
8163       pure <span class="constant">$</span> s&#8321;.insert k
8164 
<span class="keyword">8165 private</span> <span class="keyword">def</span> <span class="function-name">updateUsedVarsOf</span> (fvarId : FVarId) : M Unit <span class="constant">:=</span> <span class="keyword">do</span>
8166   <span class="keyword">let</span> usedFVarsMap &#8592; getUsedFVarsMap
8167   <span class="keyword">match</span> usedFVarsMap.find? fvarId <span class="keyword">with</span>
8168   | none         <span class="constant">=&gt;</span> pure ()
8169   | some fvarIds <span class="constant">=&gt;</span>
8170     <span class="keyword">let</span> fvarIdsNew &#8592; fvarIds.foldM (init <span class="constant">:=</span> fvarIds) <span class="keyword">fun</span> fvarIdsNew fvarId' <span class="constant">=&gt;</span>
8171       <span class="keyword">if</span> fvarId <span class="constant">==</span> fvarId' <span class="keyword">then</span>
8172         pure fvarIdsNew
8173       <span class="keyword">else</span>
8174         <span class="keyword">match</span> usedFVarsMap.find? fvarId' <span class="keyword">with</span>
8175         | none <span class="constant">=&gt;</span> pure fvarIdsNew
8176           <span class="comment-delimiter">/- </span><span class="comment">We are being sloppy here `otherFVarIds` may contain free variables that are
8177              not in the context of the let-rec associated with fvarId.
8178              We filter these out-of-context free variables later. -/</span>
8179         | some otherFVarIds <span class="constant">=&gt;</span> merge fvarIdsNew otherFVarIds
8180     modifyUsedFVars <span class="keyword">fun</span> usedFVars <span class="constant">=&gt;</span> usedFVars.insert fvarId fvarIdsNew
8181 
<span class="keyword">8182 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">fixpoint</span> : Unit <span class="constant">&#8594;</span> M Unit
8183   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">do</span>
8184     resetModified
8185     <span class="keyword">let</span> letRecFVarIds &#8592; read
8186     letRecFVarIds.forM updateUsedVarsOf
8187     <span class="keyword">if</span> (&#8592; isModified) <span class="keyword">then</span>
8188       fixpoint ()
8189 
<span class="keyword">8190 def</span> <span class="function-name">run</span> (letRecFVarIds : List FVarId) (usedFVarsMap : UsedFVarsMap) : UsedFVarsMap <span class="constant">:=</span>
8191   <span class="keyword">let</span> (<span class="preprocessor">_</span>, s) <span class="constant">:=</span> ((fixpoint ()).run letRecFVarIds).run { usedFVarsMap <span class="constant">:=</span> usedFVarsMap }
8192   s.usedFVarsMap
8193 
<span class="keyword">8194 end</span> FixPoint
8195 
<span class="keyword">8196 abbrev</span> FreeVarMap <span class="constant">:=</span> NameMap (Array FVarId)
8197 
<span class="keyword">8198 private</span> <span class="keyword">def</span> <span class="function-name">mkFreeVarMap</span>
8199     (mctx : MetavarContext) (sectionVars : Array Expr) (mainFVarIds : Array FVarId)
8200     (recFVarIds : Array FVarId) (letRecsToLift : List LetRecToLift) : FreeVarMap <span class="constant">:=</span> <span class="keyword">do</span>
8201   <span class="keyword">let</span> usedFVarsMap  <span class="constant">:=</span> mkInitialUsedFVarsMap mctx sectionVars mainFVarIds letRecsToLift
8202   <span class="keyword">let</span> letRecFVarIds <span class="constant">:=</span> letRecsToLift.map <span class="keyword">fun</span> toLift <span class="constant">=&gt;</span> toLift.fvarId
8203   <span class="keyword">let</span> usedFVarsMap  <span class="constant">:=</span> FixPoint.run letRecFVarIds usedFVarsMap
8204   <span class="keyword">let</span> <span class="keyword">mut</span> freeVarMap <span class="constant">:=</span> {}
8205   <span class="keyword">for</span> toLift <span class="keyword">in</span> letRecsToLift <span class="keyword">do</span>
8206     <span class="keyword">let</span> lctx       <span class="constant">:=</span> toLift.lctx
8207     <span class="keyword">let</span> fvarIdsSet <span class="constant">:=</span> (usedFVarsMap.find? toLift.fvarId).get<span class="constant">!</span>
8208     <span class="keyword">let</span> fvarIds    <span class="constant">:=</span> fvarIdsSet.fold (init <span class="constant">:=</span> <span class="constant">#</span>[]) <span class="keyword">fun</span> fvarIds fvarId <span class="constant">=&gt;</span>
8209       <span class="keyword">if</span> lctx.contains fvarId <span class="constant">&amp;&amp;</span> <span class="constant">!</span>recFVarIds.contains fvarId <span class="keyword">then</span>
8210         fvarIds.push fvarId
8211       <span class="keyword">else</span>
8212         fvarIds
8213     freeVarMap <span class="constant">:=</span> freeVarMap.insert toLift.fvarId fvarIds
8214   pure freeVarMap
8215 
<span class="keyword">8216 structure</span> <span class="function-name">ClosureState</span> <span class="keyword">where</span>
8217   newLocalDecls : Array LocalDecl <span class="constant">:=</span> <span class="constant">#</span>[]
8218   localDecls    : Array LocalDecl <span class="constant">:=</span> <span class="constant">#</span>[]
8219   newLetDecls   : Array LocalDecl <span class="constant">:=</span> <span class="constant">#</span>[]
8220   exprArgs      : Array Expr      <span class="constant">:=</span> <span class="constant">#</span>[]
8221 
<span class="keyword">8222 private</span> <span class="keyword">def</span> <span class="function-name">pickMaxFVar?</span> (lctx : LocalContext) (fvarIds : Array FVarId) : Option FVarId <span class="constant">:=</span>
8223   fvarIds.getMax? <span class="keyword">fun</span> fvarId&#8321; fvarId&#8322; <span class="constant">=&gt;</span> (lctx.get<span class="constant">!</span> fvarId&#8321;).index <span class="constant">&lt;</span> (lctx.get<span class="constant">!</span> fvarId&#8322;).index
8224 
<span class="keyword">8225 private</span> <span class="keyword">def</span> <span class="function-name">preprocess</span> (e : Expr) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
8226   <span class="keyword">let</span> e &#8592; instantiateMVars e
8227   <span class="comment-delimiter">-- </span><span class="comment">which let-decls are dependent. We say a let-decl is dependent if its lambda abstraction is type incorrect.
</span>8228   Meta.check e
8229   pure e
8230 
<span class="comment-delimiter">8231 /- </span><span class="comment">Push free variables in `s` to `toProcess` if they are not already there. -/</span>
<span class="keyword">8232 private</span> <span class="keyword">def</span> <span class="function-name">pushNewVars</span> (toProcess : Array FVarId) (s : CollectFVars.State) : Array FVarId <span class="constant">:=</span>
8233   s.fvarSet.fold (init <span class="constant">:=</span> toProcess) <span class="keyword">fun</span> toProcess fvarId <span class="constant">=&gt;</span>
8234     <span class="keyword">if</span> toProcess.contains fvarId <span class="keyword">then</span> toProcess <span class="keyword">else</span> toProcess.push fvarId
8235 
<span class="keyword">8236 private</span> <span class="keyword">def</span> <span class="function-name">pushLocalDecl</span> (toProcess : Array FVarId) (fvarId : FVarId) (userName : Name) (type : Expr) (bi <span class="constant">:=</span> BinderInfo.default)
8237     : StateRefT ClosureState TermElabM (Array FVarId) <span class="constant">:=</span> <span class="keyword">do</span>
8238   <span class="keyword">let</span> type &#8592; preprocess type
8239   modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span>
8240     newLocalDecls <span class="constant">:=</span> s.newLocalDecls.push <span class="constant">$</span> LocalDecl.cdecl arbitrary fvarId userName type bi,
8241     exprArgs      <span class="constant">:=</span> s.exprArgs.push (mkFVar fvarId)
8242   }
8243   pure <span class="constant">$</span> pushNewVars toProcess (collectFVars {} type)
8244 
<span class="keyword">8245 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">mkClosureForAux</span> (toProcess : Array FVarId) : StateRefT ClosureState TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
8246   <span class="keyword">let</span> lctx &#8592; getLCtx
8247   <span class="keyword">match</span> pickMaxFVar? lctx toProcess <span class="keyword">with</span>
8248   | none        <span class="constant">=&gt;</span> pure ()
8249   | some fvarId <span class="constant">=&gt;</span>
8250     trace[Elab.definition<span class="function-name">.mkClosure]</span> <span class="string">"toProcess: {toProcess.map mkFVar}, maxVar: {mkFVar fvarId}"</span>
8251     <span class="keyword">let</span> toProcess <span class="constant">:=</span> toProcess.erase fvarId
8252     <span class="keyword">let</span> localDecl &#8592; getLocalDecl fvarId
8253     <span class="keyword">match</span> localDecl <span class="keyword">with</span>
8254     | LocalDecl.cdecl <span class="preprocessor">_</span> <span class="preprocessor">_</span> userName type bi <span class="constant">=&gt;</span>
8255       <span class="keyword">let</span> toProcess &#8592; pushLocalDecl toProcess fvarId userName type bi
8256       mkClosureForAux toProcess
8257     | LocalDecl.ldecl <span class="preprocessor">_</span> <span class="preprocessor">_</span> userName type val <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
8258       <span class="keyword">let</span> zetaFVarIds &#8592; getZetaFVarIds
8259       <span class="keyword">if</span> <span class="constant">!</span>zetaFVarIds.contains fvarId <span class="keyword">then</span>
8260         <span class="comment-delimiter">/- </span><span class="comment">Non-dependent let-decl. See comment at src/Lean/Meta/Closure.lean -/</span>
8261         <span class="keyword">let</span> toProcess &#8592; pushLocalDecl toProcess fvarId userName type
8262         mkClosureForAux toProcess
8263       <span class="keyword">else</span>
8264         <span class="comment-delimiter">/- </span><span class="comment">Dependent let-decl. -/</span>
8265         <span class="keyword">let</span> type &#8592; preprocess type
8266         <span class="keyword">let</span> val  &#8592; preprocess val
8267         modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span>
8268           newLetDecls   <span class="constant">:=</span> s.newLetDecls.push <span class="constant">$</span> LocalDecl.ldecl arbitrary fvarId userName type val false,
8269           <span class="comment-delimiter">/- </span><span class="comment">We don't want to interleave let and lambda declarations in our closure. So, we expand any occurrences of fvarId
8270              at `newLocalDecls` and `localDecls` -/</span>
8271           newLocalDecls <span class="constant">:=</span> s.newLocalDecls.map (replaceFVarIdAtLocalDecl fvarId val),
8272           localDecls <span class="constant">:=</span> s.localDecls.map (replaceFVarIdAtLocalDecl fvarId val)
8273         }
8274         mkClosureForAux (pushNewVars toProcess (collectFVars (collectFVars {} type) val))
8275 
<span class="keyword">8276 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">mkClosureFor</span> (freeVars : Array FVarId) (localDecls : Array LocalDecl) : TermElabM ClosureState <span class="constant">:=</span> <span class="keyword">do</span>
8277   <span class="keyword">let</span> (<span class="preprocessor">_</span>, s) &#8592; (mkClosureForAux freeVars).run { localDecls <span class="constant">:=</span> localDecls }
8278   pure { s <span class="keyword">with</span>
8279     newLocalDecls <span class="constant">:=</span> s.newLocalDecls.reverse,
8280     newLetDecls   <span class="constant">:=</span> s.newLetDecls.reverse,
8281     exprArgs      <span class="constant">:=</span> s.exprArgs.reverse
8282   }
8283 
<span class="keyword">8284 structure</span> <span class="function-name">LetRecClosure</span> <span class="keyword">where</span>
8285   ref        : Syntax
8286   localDecls : Array LocalDecl
8287   closed     : Expr <span class="comment-delimiter">-- </span><span class="comment">expression used to replace occurrences of the let-rec FVarId
</span>8288   toLift     : LetRecToLift
8289 
<span class="keyword">8290 private</span> <span class="keyword">def</span> <span class="function-name">mkLetRecClosureFor</span> (toLift : LetRecToLift) (freeVars : Array FVarId) : TermElabM LetRecClosure <span class="constant">:=</span> <span class="keyword">do</span>
8291   <span class="keyword">let</span> lctx <span class="constant">:=</span> toLift.lctx
8292   withLCtx lctx toLift.localInstances <span class="keyword">do</span>
8293   lambdaTelescope toLift.val <span class="keyword">fun</span> xs val <span class="constant">=&gt;</span> <span class="keyword">do</span>
8294     <span class="keyword">let</span> type &#8592; instantiateForall toLift.type xs
8295     <span class="keyword">let</span> lctx &#8592; getLCtx
8296     <span class="keyword">let</span> s &#8592; mkClosureFor freeVars <span class="constant">$</span> xs.map <span class="keyword">fun</span> x <span class="constant">=&gt;</span> lctx.get<span class="constant">!</span> x.fvarId<span class="constant">!</span>
8297     <span class="keyword">let</span> type <span class="constant">:=</span> Closure.mkForall s.localDecls <span class="constant">$</span> Closure.mkForall s.newLetDecls type
8298     <span class="keyword">let</span> val  <span class="constant">:=</span> Closure.mkLambda s.localDecls <span class="constant">$</span> Closure.mkLambda s.newLetDecls val
8299     <span class="keyword">let</span> c    <span class="constant">:=</span> mkAppN (Lean.mkConst toLift.declName) s.exprArgs
8300     assignExprMVar toLift.mvarId c
8301     <span class="keyword">return</span> {
8302       ref        <span class="constant">:=</span> toLift.ref
8303       localDecls <span class="constant">:=</span> s.newLocalDecls
8304       closed     <span class="constant">:=</span> c
8305       toLift     <span class="constant">:=</span> { toLift <span class="keyword">with</span> val <span class="constant">:=</span> val, type <span class="constant">:=</span> type }
8306     }
8307 
<span class="keyword">8308 private</span> <span class="keyword">def</span> <span class="function-name">mkLetRecClosures</span> (letRecsToLift : List LetRecToLift) (freeVarMap : FreeVarMap) : TermElabM (List LetRecClosure) <span class="constant">:=</span>
8309   letRecsToLift.mapM <span class="keyword">fun</span> toLift <span class="constant">=&gt;</span> mkLetRecClosureFor toLift (freeVarMap.find? toLift.fvarId).get<span class="constant">!</span>
8310 
<span class="comment-delimiter">8311 /- </span><span class="comment">Mapping from FVarId of mutually recursive functions being defined to "closure" expression. -/</span>
<span class="keyword">8312 abbrev</span> Replacement <span class="constant">:=</span> NameMap Expr
8313 
<span class="keyword">8314 def</span> <span class="function-name">insertReplacementForMainFns</span> (r : Replacement) (sectionVars : Array Expr) (mainHeaders : Array DefViewElabHeader) (mainFVars : Array Expr) : Replacement <span class="constant">:=</span>
8315   mainFVars.size.fold (init <span class="constant">:=</span> r) <span class="keyword">fun</span> i r <span class="constant">=&gt;</span>
8316     r.insert mainFVars[i].fvarId<span class="constant">!</span> (mkAppN (Lean.mkConst mainHeaders[i].declName) sectionVars)
8317 
8318 
<span class="keyword">8319 def</span> <span class="function-name">insertReplacementForLetRecs</span> (r : Replacement) (letRecClosures : List LetRecClosure) : Replacement <span class="constant">:=</span>
8320   letRecClosures.foldl (init <span class="constant">:=</span> r) <span class="keyword">fun</span> r c <span class="constant">=&gt;</span>
8321     r.insert c.toLift.fvarId c.closed
8322 
<span class="keyword">8323 def</span> <span class="function-name">Replacement.apply</span> (r : Replacement) (e : Expr) : Expr <span class="constant">:=</span>
8324   e.replace <span class="keyword">fun</span> e <span class="constant">=&gt;</span> <span class="keyword">match</span> e <span class="keyword">with</span>
8325     | Expr.fvar fvarId <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">match</span> r.find? fvarId <span class="keyword">with</span>
8326       | some c <span class="constant">=&gt;</span> some c
8327       | <span class="preprocessor">_</span>      <span class="constant">=&gt;</span> none
8328     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> none
8329 
<span class="keyword">8330 def</span> <span class="function-name">pushMain</span> (preDefs : Array PreDefinition) (sectionVars : Array Expr) (mainHeaders : Array DefViewElabHeader) (mainVals : Array Expr)
8331     : TermElabM (Array PreDefinition) <span class="constant">:=</span>
8332   mainHeaders.size.foldM (init <span class="constant">:=</span> preDefs) <span class="keyword">fun</span> i preDefs <span class="constant">=&gt;</span> <span class="keyword">do</span>
8333     <span class="keyword">let</span> header <span class="constant">:=</span> mainHeaders[i]
8334     <span class="keyword">let</span> val  &#8592; mkLambdaFVars sectionVars mainVals[i]
8335     <span class="keyword">let</span> type &#8592; mkForallFVars sectionVars header.type
8336     <span class="keyword">return</span> preDefs.push {
8337       ref         <span class="constant">:=</span> getDeclarationSelectionRef header.ref
8338       kind        <span class="constant">:=</span> header.kind
8339       declName    <span class="constant">:=</span> header.declName
8340       levelParams <span class="constant">:=</span> [], <span class="comment-delimiter">-- </span><span class="comment">we set it later
</span>8341       modifiers   <span class="constant">:=</span> header.modifiers
8342       type        <span class="constant">:=</span> type
8343       value       <span class="constant">:=</span> val
8344     }
8345 
<span class="keyword">8346 def</span> <span class="function-name">pushLetRecs</span> (preDefs : Array PreDefinition) (letRecClosures : List LetRecClosure) (kind : DefKind) (modifiers : Modifiers) : Array PreDefinition <span class="constant">:=</span>
8347   letRecClosures.foldl (init <span class="constant">:=</span> preDefs) <span class="keyword">fun</span> preDefs c <span class="constant">=&gt;</span>
8348     <span class="keyword">let</span> type <span class="constant">:=</span> Closure.mkForall c.localDecls c.toLift.type
8349     <span class="keyword">let</span> val  <span class="constant">:=</span> Closure.mkLambda c.localDecls c.toLift.val
8350     preDefs.push {
8351       ref         <span class="constant">:=</span> c.ref
8352       kind        <span class="constant">:=</span> kind
8353       declName    <span class="constant">:=</span> c.toLift.declName
8354       levelParams <span class="constant">:=</span> [] <span class="comment-delimiter">-- </span><span class="comment">we set it later
</span>8355       modifiers   <span class="constant">:=</span> { modifiers <span class="keyword">with</span> attrs <span class="constant">:=</span> c.toLift.attrs }
8356       type        <span class="constant">:=</span> type
8357       value       <span class="constant">:=</span> val
8358     }
8359 
<span class="keyword">8360 def</span> <span class="function-name">getKindForLetRecs</span> (mainHeaders : Array DefViewElabHeader) : DefKind <span class="constant">:=</span>
8361   <span class="keyword">if</span> mainHeaders.any <span class="keyword">fun</span> h <span class="constant">=&gt;</span> h.kind.isTheorem <span class="keyword">then</span> DefKind.<span class="comment">&#171;</span>theorem<span class="comment">&#187;</span>
8362   <span class="keyword">else</span> DefKind.<span class="comment">&#171;</span>def<span class="comment">&#187;</span>
8363 
<span class="keyword">8364 def</span> <span class="function-name">getModifiersForLetRecs</span> (mainHeaders : Array DefViewElabHeader) : Modifiers <span class="constant">:=</span> {
8365   isNoncomputable <span class="constant">:=</span> mainHeaders.any <span class="keyword">fun</span> h <span class="constant">=&gt;</span> h.modifiers.isNoncomputable,
8366   isPartial       <span class="constant">:=</span> mainHeaders.any <span class="keyword">fun</span> h <span class="constant">=&gt;</span> h.modifiers.isPartial,
8367   isUnsafe        <span class="constant">:=</span> mainHeaders.any <span class="keyword">fun</span> h <span class="constant">=&gt;</span> h.modifiers.isUnsafe
8368 }
8369 
<span class="comment-delimiter">8370 /-</span><span class="comment">
8371 - `sectionVars`:   The section variables used in the `mutual` block.
8372 - `mainHeaders`:   The elaborated header of the top-level definitions being defined by the mutual block.
8373 - `mainFVars`:     The auxiliary variables used to represent the top-level definitions being defined by the mutual block.
8374 - `mainVals`:      The elaborated value for the top-level definitions
8375 - `letRecsToLift`: The let-rec's definitions that need to be lifted
8376 -/</span>
<span class="keyword">8377 def</span> <span class="function-name">main</span> (sectionVars : Array Expr) (mainHeaders : Array DefViewElabHeader) (mainFVars : Array Expr) (mainVals : Array Expr) (letRecsToLift : List LetRecToLift)
8378     : TermElabM (Array PreDefinition) <span class="constant">:=</span> <span class="keyword">do</span>
8379   <span class="comment-delimiter">-- </span><span class="comment">Store in recFVarIds the fvarId of every function being defined by the mutual block.
</span>8380   <span class="keyword">let</span> mainFVarIds <span class="constant">:=</span> mainFVars.map Expr.fvarId<span class="constant">!</span>
8381   <span class="keyword">let</span> recFVarIds  <span class="constant">:=</span> (letRecsToLift.toArray.map <span class="keyword">fun</span> toLift <span class="constant">=&gt;</span> toLift.fvarId) <span class="constant">++</span> mainFVarIds
8382   <span class="comment-delimiter">-- </span><span class="comment">Compute the set of free variables (excluding `recFVarIds`) for each let-rec.
</span>8383   <span class="keyword">let</span> mctx &#8592; getMCtx
8384   <span class="keyword">let</span> freeVarMap <span class="constant">:=</span> mkFreeVarMap mctx sectionVars mainFVarIds recFVarIds letRecsToLift
8385   resetZetaFVarIds
8386   withTrackingZeta <span class="keyword">do</span>
8387     <span class="comment-delimiter">-- </span><span class="comment">By checking `toLift.type` and `toLift.val` we populate `zetaFVarIds`. See comments at `src/Lean/Meta/Closure.lean`.
</span>8388     letRecsToLift.forM <span class="keyword">fun</span> toLift <span class="constant">=&gt;</span> withLCtx toLift.lctx toLift.localInstances <span class="keyword">do</span> Meta.check toLift.type; Meta.check toLift.val
8389     <span class="keyword">let</span> letRecClosures &#8592; mkLetRecClosures letRecsToLift freeVarMap
8390     <span class="comment-delimiter">-- </span><span class="comment">mkLetRecClosures assign metavariables that were placeholders for the lifted declarations.
</span>8391     <span class="keyword">let</span> mainVals    &#8592; mainVals.mapM (instantiateMVars &#183;)
8392     <span class="keyword">let</span> mainHeaders &#8592; mainHeaders.mapM instantiateMVarsAtHeader
8393     <span class="keyword">let</span> letRecClosures &#8592; letRecClosures.mapM <span class="keyword">fun</span> closure <span class="constant">=&gt;</span> <span class="keyword">do</span> pure { closure <span class="keyword">with</span> toLift <span class="constant">:=</span> (&#8592; instantiateMVarsAtLetRecToLift closure.toLift) }
8394     <span class="comment-delimiter">-- </span><span class="comment">Replace fvarIds for functions being defined with closed terms
</span>8395     <span class="keyword">let</span> r              <span class="constant">:=</span> insertReplacementForMainFns {} sectionVars mainHeaders mainFVars
8396     <span class="keyword">let</span> r              <span class="constant">:=</span> insertReplacementForLetRecs r letRecClosures
8397     <span class="keyword">let</span> mainVals       <span class="constant">:=</span> mainVals.map r.apply
8398     <span class="keyword">let</span> mainHeaders    <span class="constant">:=</span> mainHeaders.map <span class="keyword">fun</span> h <span class="constant">=&gt;</span> { h <span class="keyword">with</span> type <span class="constant">:=</span> r.apply h.type }
8399     <span class="keyword">let</span> letRecClosures <span class="constant">:=</span> letRecClosures.map <span class="keyword">fun</span> c <span class="constant">=&gt;</span> { c <span class="keyword">with</span> toLift <span class="constant">:=</span> { c.toLift <span class="keyword">with</span> type <span class="constant">:=</span> r.apply c.toLift.type, val <span class="constant">:=</span> r.apply c.toLift.val } }
8400     <span class="keyword">let</span> letRecKind     <span class="constant">:=</span> getKindForLetRecs mainHeaders
8401     <span class="keyword">let</span> letRecMods     <span class="constant">:=</span> getModifiersForLetRecs mainHeaders
8402     pushMain (pushLetRecs <span class="constant">#</span>[] letRecClosures letRecKind letRecMods) sectionVars mainHeaders mainVals
8403 
<span class="keyword">8404 end</span> MutualClosure
8405 
<span class="keyword">8406 private</span> <span class="keyword">def</span> <span class="function-name">getAllUserLevelNames</span> (headers : Array DefViewElabHeader) : List Name <span class="constant">:=</span>
8407   <span class="keyword">if</span> h : <span class="constant">0</span> <span class="constant">&lt;</span> headers.size <span class="keyword">then</span>
8408     <span class="comment-delimiter">-- </span><span class="comment">Recall that all top-level functions must have the same levels. See `check` method above
</span>8409     (headers.get &#10216;<span class="constant">0</span>, h&#10217;).levelNames
8410   <span class="keyword">else</span>
8411     []
8412 
<span class="comment-delimiter">8413 /-</span><span class="comment">- Eagerly convert universe metavariables occurring in theorem headers to universe parameters. -/</span>
<span class="keyword">8414 private</span> <span class="keyword">def</span> <span class="function-name">levelMVarToParamHeaders</span> (views : Array DefView) (headers : Array DefViewElabHeader) : TermElabM (Array DefViewElabHeader) <span class="constant">:=</span> <span class="keyword">do</span>
8415   <span class="keyword">let</span> <span class="keyword">rec</span> process : StateRefT Nat TermElabM (Array DefViewElabHeader) <span class="constant">:=</span> <span class="keyword">do</span>
8416     <span class="keyword">let</span> <span class="keyword">mut</span> newHeaders <span class="constant">:=</span> <span class="constant">#</span>[]
8417     <span class="keyword">for</span> view <span class="keyword">in</span> views, header <span class="keyword">in</span> headers <span class="keyword">do</span>
8418       <span class="keyword">if</span> view.kind.isTheorem <span class="keyword">then</span>
8419         newHeaders <span class="constant">:=</span> newHeaders.push { header <span class="keyword">with</span> type <span class="constant">:=</span> (&#8592; levelMVarToParam' header.type) }
8420       <span class="keyword">else</span>
8421         newHeaders <span class="constant">:=</span> newHeaders.push header
8422     <span class="keyword">return</span> newHeaders
8423   <span class="keyword">let</span> newHeaders &#8592; process.run' <span class="constant">1</span>
8424   newHeaders.mapM <span class="keyword">fun</span> header <span class="constant">=&gt;</span> <span class="keyword">return</span> { header <span class="keyword">with</span> type <span class="constant">:=</span> (&#8592; instantiateMVars header.type) }
8425 
<span class="keyword">8426 def</span> <span class="function-name">elabMutualDef</span> (vars : Array Expr) (views : Array DefView) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
8427   <span class="keyword">let</span> scopeLevelNames &#8592; getLevelNames
8428   <span class="keyword">let</span> headers &#8592; elabHeaders views
8429   <span class="keyword">let</span> headers &#8592; levelMVarToParamHeaders views headers
8430   <span class="keyword">let</span> allUserLevelNames <span class="constant">:=</span> getAllUserLevelNames headers
8431   withFunLocalDecls headers <span class="keyword">fun</span> funFVars <span class="constant">=&gt;</span> <span class="keyword">do</span>
8432     <span class="keyword">let</span> values &#8592; elabFunValues headers
8433     Term.synthesizeSyntheticMVarsNoPostponing
8434     <span class="keyword">let</span> values &#8592; values.mapM (instantiateMVars &#183;)
8435     <span class="keyword">let</span> headers &#8592; headers.mapM instantiateMVarsAtHeader
8436     <span class="keyword">let</span> letRecsToLift &#8592; getLetRecsToLift
8437     <span class="keyword">let</span> letRecsToLift &#8592; letRecsToLift.mapM instantiateMVarsAtLetRecToLift
8438     checkLetRecsToLiftTypes funFVars letRecsToLift
8439     withUsed vars headers values letRecsToLift <span class="keyword">fun</span> vars <span class="constant">=&gt;</span> <span class="keyword">do</span>
8440       <span class="keyword">let</span> preDefs &#8592; MutualClosure.main vars headers funFVars values letRecsToLift
8441       <span class="keyword">let</span> preDefs &#8592; levelMVarToParamPreDecls preDefs
8442       <span class="keyword">let</span> preDefs &#8592; instantiateMVarsAtPreDecls preDefs
8443       <span class="keyword">let</span> preDefs &#8592; fixLevelParams preDefs scopeLevelNames allUserLevelNames
8444       <span class="keyword">if</span> isExample views <span class="keyword">then</span>
8445         withoutModifyingEnv <span class="constant">&lt;</span>| addPreDefinitions preDefs
8446       <span class="keyword">else</span>
8447         addPreDefinitions preDefs
8448 
<span class="keyword">8449 end</span> Term
<span class="keyword">8450 namespace</span> Command
8451 
<span class="keyword">8452 def</span> <span class="function-name">elabMutualDef</span> (ds : Array Syntax) : CommandElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
8453   <span class="keyword">let</span> views &#8592; ds.mapM <span class="keyword">fun</span> d <span class="constant">=&gt;</span> <span class="keyword">do</span>
8454     <span class="keyword">let</span> modifiers &#8592; elabModifiers d[<span class="constant">0</span>]
8455     mkDefView modifiers d[<span class="constant">1</span>]
8456   runTermElabM none <span class="keyword">fun</span> vars <span class="constant">=&gt;</span> Term.elabMutualDef vars views
8457 
<span class="keyword">8458 end</span> Command
<span class="keyword">8459 end</span> Lean.Elab
8460 ::::::::::::::
8461 Elab<span class="constant">/</span>Open.lean
8462 ::::::::::::::
<span class="comment-delimiter">8463 /-</span><span class="comment">
8464 Copyright (c) 2021 Microsoft Corporation. All rights reserved.
8465 Released under Apache 2.0 license as described in the file LICENSE.
8466 Authors: Leonardo de Moura
8467 -/</span>
<span class="keyword">8468 import</span> Lean.Elab.Log
8469 
<span class="keyword">8470 namespace</span> Lean.Elab
<span class="keyword">8471 namespace</span> OpenDecl
8472 
<span class="keyword">8473 variable</span> [Monad m] [STWorld IO.RealWorld m] [MonadEnv m]
<span class="keyword">8474 variable</span> [MonadExceptOf Exception m] [MonadRef m] [AddErrorMessageContext m]
<span class="keyword">8475 variable</span> [AddMessageContext m] [MonadLiftT (ST IO.RealWorld) m] [MonadLog m]
8476 
<span class="keyword">8477 structure</span> <span class="function-name">State</span> <span class="keyword">where</span>
8478   openDecls     : List OpenDecl
8479   currNamespace : Name
8480 
<span class="keyword">8481 abbrev</span> M <span class="constant">:=</span> StateRefT State m
8482 
<span class="keyword">8483 instance</span> <span class="function-name">:</span> MonadResolveName (M (m <span class="constant">:=</span> m)) <span class="keyword">where</span>
8484   getCurrNamespace   <span class="constant">:=</span> <span class="keyword">return</span> (&#8592; get).currNamespace
8485   getOpenDecls       <span class="constant">:=</span> <span class="keyword">return</span> (&#8592; get).openDecls
8486 
<span class="keyword">8487 private</span> <span class="keyword">def</span> <span class="function-name">addOpenDecl</span> (decl : OpenDecl) : M (m<span class="constant">:=</span>m) Unit <span class="constant">:=</span>
8488   modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> openDecls <span class="constant">:=</span> decl :: s.openDecls }
8489 
<span class="keyword">8490 private</span> <span class="keyword">def</span> <span class="function-name">elabOpenSimple</span> (n : Syntax) : M (m<span class="constant">:=</span>m) Unit <span class="constant">:=</span>
8491   <span class="comment-delimiter">-- </span><span class="comment">`open` id+
</span>8492   <span class="keyword">for</span> ns <span class="keyword">in</span> n[<span class="constant">0</span>].getArgs <span class="keyword">do</span>
8493     <span class="keyword">let</span> ns &#8592; resolveNamespace ns.getId
8494     addOpenDecl (OpenDecl.simple ns [])
8495     activateScoped ns
8496 
<span class="comment-delimiter">8497 -- </span><span class="comment">`open` id `(` id+ `)`
</span><span class="keyword">8498 private</span> <span class="keyword">def</span> <span class="function-name">elabOpenOnly</span> (n : Syntax) : M (m<span class="constant">:=</span>m) Unit <span class="constant">:=</span> <span class="keyword">do</span>
8499   <span class="keyword">let</span> ns &#8592; resolveNamespace n[<span class="constant">0</span>].getId
8500   <span class="keyword">for</span> idStx <span class="keyword">in</span> n[<span class="constant">2</span>].getArgs <span class="keyword">do</span>
8501     <span class="keyword">let</span> id <span class="constant">:=</span> idStx.getId
8502     <span class="keyword">let</span> declName <span class="constant">:=</span> ns <span class="constant">++</span> id
8503     <span class="keyword">if</span> (&#8592; getEnv).contains declName <span class="keyword">then</span>
8504       addOpenDecl (OpenDecl.explicit id declName)
8505     <span class="keyword">else</span>
8506       withRef idStx <span class="constant">&lt;</span>| logUnknownDecl declName
8507 
<span class="comment-delimiter">8508 -- </span><span class="comment">`open` id `hiding` id+
</span><span class="keyword">8509 private</span> <span class="keyword">def</span> <span class="function-name">elabOpenHiding</span> (n : Syntax) : M (m<span class="constant">:=</span>m) Unit <span class="constant">:=</span> <span class="keyword">do</span>
8510   <span class="keyword">let</span> ns &#8592; resolveNamespace n[<span class="constant">0</span>].getId
8511   <span class="keyword">let</span> <span class="keyword">mut</span> ids : List Name <span class="constant">:=</span> []
8512   <span class="keyword">for</span> idStx <span class="keyword">in</span> n[<span class="constant">2</span>].getArgs <span class="keyword">do</span>
8513     <span class="keyword">let</span> id <span class="constant">:=</span> idStx.getId
8514     <span class="keyword">let</span> declName <span class="constant">:=</span> ns <span class="constant">++</span> id
8515     <span class="keyword">if</span> (&#8592; getEnv).contains declName <span class="keyword">then</span>
8516       ids <span class="constant">:=</span> id::ids
8517     <span class="keyword">else</span>
8518       withRef idStx <span class="constant">&lt;</span>| logUnknownDecl declName
8519   addOpenDecl (OpenDecl.simple ns ids)
8520 
<span class="comment-delimiter">8521 -- </span><span class="comment">`open` id `renaming` sepBy (id `-&gt;` id) `,`
</span><span class="keyword">8522 private</span> <span class="keyword">def</span> <span class="function-name">elabOpenRenaming</span> (n : Syntax) : M (m<span class="constant">:=</span>m) Unit <span class="constant">:=</span> <span class="keyword">do</span>
8523   <span class="keyword">let</span> ns &#8592; resolveNamespace n[<span class="constant">0</span>].getId
8524   <span class="keyword">for</span> stx <span class="keyword">in</span> n[<span class="constant">2</span>].getSepArgs <span class="keyword">do</span>
8525     <span class="keyword">let</span> fromId   <span class="constant">:=</span> stx[<span class="constant">0</span>].getId
8526     <span class="keyword">let</span> toId     <span class="constant">:=</span> stx[<span class="constant">2</span>].getId
8527     <span class="keyword">let</span> declName <span class="constant">:=</span> ns <span class="constant">++</span> fromId
8528     <span class="keyword">if</span> (&#8592; getEnv).contains declName <span class="keyword">then</span>
8529       addOpenDecl (OpenDecl.explicit toId declName)
8530     <span class="keyword">else</span>
8531       withRef stx <span class="keyword">do</span> logUnknownDecl declName
8532 
<span class="keyword">8533 def</span> <span class="function-name">elabOpenDecl</span> [MonadResolveName m] (openDeclStx : Syntax) : m (List OpenDecl) <span class="constant">:=</span> <span class="keyword">do</span>
8534   StateRefT'.run' (s <span class="constant">:=</span> { openDecls <span class="constant">:=</span> (&#8592; getOpenDecls), currNamespace <span class="constant">:=</span> (&#8592; getCurrNamespace) }) <span class="keyword">do</span>
8535     <span class="keyword">if</span> openDeclStx.getKind <span class="constant">==</span> ``Parser.Command.openSimple <span class="keyword">then</span>
8536       elabOpenSimple openDeclStx
8537     <span class="keyword">else</span> <span class="keyword">if</span> openDeclStx.getKind <span class="constant">==</span> ``Parser.Command.openOnly <span class="keyword">then</span>
8538       elabOpenOnly openDeclStx
8539     <span class="keyword">else</span> <span class="keyword">if</span> openDeclStx.getKind <span class="constant">==</span> ``Parser.Command.openHiding <span class="keyword">then</span>
8540       elabOpenHiding openDeclStx
8541     <span class="keyword">else</span>
8542       elabOpenRenaming openDeclStx
8543     <span class="keyword">return</span> (&#8592; get).openDecls
8544 
<span class="keyword">8545 end</span> OpenDecl
8546 
<span class="keyword">8547 export</span> OpenDecl (elabOpenDecl)
8548 
<span class="keyword">8549 end</span> Lean.Elab::::::::::::::
8550 Elab<span class="constant">/</span>PreDefinition.lean
8551 ::::::::::::::
<span class="comment-delimiter">8552 /-</span><span class="comment">
8553 Copyright (c) 2020 Microsoft Corporation. All rights reserved.
8554 Released under Apache 2.0 license as described in the file LICENSE.
8555 Authors: Leonardo de Moura
8556 -/</span>
<span class="keyword">8557 import</span> Lean.Elab.PreDefinition.Basic
<span class="keyword">8558 import</span> Lean.Elab.PreDefinition.Structural
<span class="keyword">8559 import</span> Lean.Elab.PreDefinition.Main
<span class="keyword">8560 import</span> Lean.Elab.PreDefinition.MkInhabitant
8561 ::::::::::::::
8562 Elab<span class="constant">/</span>Print.lean
8563 ::::::::::::::
<span class="comment-delimiter">8564 /-</span><span class="comment">
8565 Copyright (c) 2020 Microsoft Corporation. All rights reserved.
8566 Released under Apache 2.0 license as described in the file LICENSE.
8567 Authors: Leonardo de Moura
8568 -/</span>
<span class="keyword">8569 import</span> Lean.Util.FoldConsts
<span class="keyword">8570 import</span> Lean.Elab.Command
8571 
<span class="keyword">8572 namespace</span> Lean.Elab.Command
8573 
<span class="keyword">8574 private</span> <span class="keyword">def</span> <span class="function-name">throwUnknownId</span> (id : Name) : CommandElabM Unit <span class="constant">:=</span>
8575   throwError <span class="string">"unknown identifier '{mkConst id}'"</span>
8576 
<span class="keyword">8577 private</span> <span class="keyword">def</span> <span class="function-name">levelParamsToMessageData</span> (levelParams : List Name) : MessageData <span class="constant">:=</span>
8578   <span class="keyword">match</span> levelParams <span class="keyword">with</span>
8579   | []    <span class="constant">=&gt;</span> <span class="string">""</span>
8580   | u::us <span class="constant">=&gt;</span> <span class="keyword">do</span>
8581     <span class="keyword">let</span> <span class="keyword">mut</span> m <span class="constant">:=</span> m<span class="constant">!</span><span class="string">".\{{u}"</span>
8582     <span class="keyword">for</span> u <span class="keyword">in</span> us <span class="keyword">do</span>
8583       m <span class="constant">:=</span> m <span class="constant">++</span> <span class="string">", "</span> <span class="constant">++</span> u
8584     <span class="keyword">return</span> m <span class="constant">++</span> <span class="string">"}"</span>
8585 
<span class="keyword">8586 private</span> <span class="keyword">def</span> <span class="function-name">mkHeader</span> (kind : String) (id : Name) (levelParams : List Name) (type : Expr) (safety : DefinitionSafety) : CommandElabM MessageData <span class="constant">:=</span> <span class="keyword">do</span>
8587   <span class="keyword">let</span> m : MessageData <span class="constant">:=</span>
8588     <span class="keyword">match</span> safety <span class="keyword">with</span>
8589     | DefinitionSafety.<span class="keyword">unsafe</span>  <span class="constant">=&gt;</span> <span class="string">"unsafe "</span>
8590     | DefinitionSafety.<span class="keyword">partial</span> <span class="constant">=&gt;</span> <span class="string">"partial "</span>
8591     | DefinitionSafety.safe    <span class="constant">=&gt;</span> <span class="string">""</span>
8592   <span class="keyword">let</span> m <span class="constant">:=</span> <span class="keyword">if</span> isProtected (&#8592; getEnv) id <span class="keyword">then</span> m <span class="constant">++</span> <span class="string">"protected "</span> <span class="keyword">else</span> m
8593   <span class="keyword">let</span> (m, id) <span class="constant">:=</span> <span class="keyword">match</span> privateToUserName? id <span class="keyword">with</span>
8594     | some id <span class="constant">=&gt;</span> (m <span class="constant">++</span> <span class="string">"private "</span>, id)
8595     | none    <span class="constant">=&gt;</span> (m, id)
8596   <span class="keyword">let</span> m <span class="constant">:=</span> m <span class="constant">++</span> kind <span class="constant">++</span> <span class="string">" "</span> <span class="constant">++</span> id <span class="constant">++</span> levelParamsToMessageData levelParams <span class="constant">++</span> <span class="string">" : "</span> <span class="constant">++</span> type
8597   pure m
8598 
<span class="keyword">8599 private</span> <span class="keyword">def</span> <span class="function-name">mkHeader'</span> (kind : String) (id : Name) (levelParams : List Name) (type : Expr) (isUnsafe : Bool) : CommandElabM MessageData <span class="constant">:=</span>
8600   mkHeader kind id levelParams type (<span class="keyword">if</span> isUnsafe <span class="keyword">then</span> DefinitionSafety.<span class="keyword">unsafe</span> <span class="keyword">else</span> DefinitionSafety.safe)
8601 
<span class="keyword">8602 private</span> <span class="keyword">def</span> <span class="function-name">printDefLike</span> (kind : String) (id : Name) (levelParams : List Name) (type : Expr) (value : Expr) (safety <span class="constant">:=</span> DefinitionSafety.safe) : CommandElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
8603   <span class="keyword">let</span> m &#8592; mkHeader kind id levelParams type safety
8604   <span class="keyword">let</span> m <span class="constant">:=</span> m <span class="constant">++</span> <span class="string">" :="</span> <span class="constant">++</span> Format.line <span class="constant">++</span> value
8605   logInfo m
8606 
<span class="keyword">8607 private</span> <span class="keyword">def</span> <span class="function-name">printAxiomLike</span> (kind : String) (id : Name) (levelParams : List Name) (type : Expr) (isUnsafe <span class="constant">:=</span> false) : CommandElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
8608   logInfo (&#8592; mkHeader' kind id levelParams type isUnsafe)
8609 
<span class="keyword">8610 private</span> <span class="keyword">def</span> <span class="function-name">printQuot</span> (kind : QuotKind) (id : Name) (levelParams : List Name) (type : Expr) : CommandElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
8611   printAxiomLike <span class="string">"Quotient primitive"</span> id levelParams type
8612 
<span class="keyword">8613 private</span> <span class="keyword">def</span> <span class="function-name">printInduct</span> (id : Name) (levelParams : List Name) (numParams : Nat) (numIndices : Nat) (type : Expr)
8614     (ctors : List Name) (isUnsafe : Bool) : CommandElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
8615   <span class="keyword">let</span> <span class="keyword">mut</span> m &#8592; mkHeader' <span class="string">"inductive"</span> id levelParams type isUnsafe
8616   m <span class="constant">:=</span> m <span class="constant">++</span> Format.line <span class="constant">++</span> <span class="string">"constructors:"</span>
8617   <span class="keyword">for</span> ctor <span class="keyword">in</span> ctors <span class="keyword">do</span>
8618     <span class="keyword">let</span> cinfo &#8592; getConstInfo ctor
8619     m <span class="constant">:=</span> m <span class="constant">++</span> Format.line <span class="constant">++</span> ctor <span class="constant">++</span> <span class="string">" : "</span> <span class="constant">++</span> cinfo.type
8620   logInfo m
8621 
<span class="keyword">8622 private</span> <span class="keyword">def</span> <span class="function-name">printIdCore</span> (id : Name) : CommandElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
8623   <span class="keyword">match</span> (&#8592; getEnv).find? id <span class="keyword">with</span>
8624   | ConstantInfo.axiomInfo { levelParams <span class="constant">:=</span> us, type <span class="constant">:=</span> t, isUnsafe <span class="constant">:=</span> u, .. } <span class="constant">=&gt;</span> printAxiomLike <span class="string">"axiom"</span> id us t u
8625   | ConstantInfo.defnInfo  { levelParams <span class="constant">:=</span> us, type <span class="constant">:=</span> t, value <span class="constant">:=</span> v, safety <span class="constant">:=</span> s, .. } <span class="constant">=&gt;</span> printDefLike <span class="string">"def"</span> id us t v s
8626   | ConstantInfo.thmInfo  { levelParams <span class="constant">:=</span> us, type <span class="constant">:=</span> t, value <span class="constant">:=</span> v, .. } <span class="constant">=&gt;</span> printDefLike <span class="string">"theorem"</span> id us t v
8627   | ConstantInfo.opaqueInfo  { levelParams <span class="constant">:=</span> us, type <span class="constant">:=</span> t, isUnsafe <span class="constant">:=</span> u, .. } <span class="constant">=&gt;</span> printAxiomLike <span class="string">"constant"</span> id us t u
8628   | ConstantInfo.quotInfo  { kind <span class="constant">:=</span> kind, levelParams <span class="constant">:=</span> us, type <span class="constant">:=</span> t, .. } <span class="constant">=&gt;</span> printQuot kind id us t
8629   | ConstantInfo.ctorInfo { levelParams <span class="constant">:=</span> us, type <span class="constant">:=</span> t, isUnsafe <span class="constant">:=</span> u, .. } <span class="constant">=&gt;</span> printAxiomLike <span class="string">"constructor"</span> id us t u
8630   | ConstantInfo.recInfo { levelParams <span class="constant">:=</span> us, type <span class="constant">:=</span> t, isUnsafe <span class="constant">:=</span> u, .. } <span class="constant">=&gt;</span> printAxiomLike <span class="string">"recursor"</span> id us t u
8631   | ConstantInfo.inductInfo { levelParams <span class="constant">:=</span> us, numParams <span class="constant">:=</span> numParams, numIndices <span class="constant">:=</span> numIndices, type <span class="constant">:=</span> t, ctors <span class="constant">:=</span> ctors, isUnsafe <span class="constant">:=</span> u, .. } <span class="constant">=&gt;</span>
8632     printInduct id us numParams numIndices t ctors u
8633   | none <span class="constant">=&gt;</span> throwUnknownId id
8634 
<span class="keyword">8635 private</span> <span class="keyword">def</span> <span class="function-name">printId</span> (id : Syntax) : CommandElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
8636   <span class="keyword">let</span> cs &#8592; resolveGlobalConstWithInfos id
8637   cs.forM printIdCore
8638 
<span class="constant">8639 @</span>[builtinCommandElab <span class="comment">&#171;</span>print<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabPrint</span> : CommandElab
8640   | `(<span class="keyword">#print</span>%<span class="constant">$</span>tk <span class="constant">$</span>id:ident) <span class="constant">=&gt;</span> withRef tk <span class="constant">&lt;</span>| printId id
8641   | `(<span class="keyword">#print</span>%<span class="constant">$</span>tk <span class="constant">$</span>s:strLit) <span class="constant">=&gt;</span> logInfoAt tk s.isStrLit?.get<span class="constant">!</span>
8642   | <span class="preprocessor">_</span>                       <span class="constant">=&gt;</span> throwError <span class="string">"invalid #print command"</span>
8643 
<span class="keyword">8644 namespace</span> CollectAxioms
8645 
<span class="keyword">8646 structure</span> <span class="function-name">State</span> <span class="keyword">where</span>
8647   visited : NameSet    <span class="constant">:=</span> {}
8648   axioms  : Array Name <span class="constant">:=</span> <span class="constant">#</span>[]
8649 
<span class="keyword">8650 abbrev</span> M <span class="constant">:=</span> ReaderT Environment <span class="constant">$</span> StateM State
8651 
<span class="keyword">8652 partial</span> <span class="keyword">def</span> <span class="function-name">collect</span> (c : Name) : M Unit <span class="constant">:=</span> <span class="keyword">do</span>
8653   <span class="keyword">let</span> collectExpr (e : Expr) : M Unit <span class="constant">:=</span> e.getUsedConstants.forM collect
8654   <span class="keyword">let</span> s &#8592; get
8655   <span class="keyword">unless</span> s.visited.contains c <span class="keyword">do</span>
8656     modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> visited <span class="constant">:=</span> s.visited.insert c }
8657     <span class="keyword">let</span> env &#8592; read
8658     <span class="keyword">match</span> env.find? c <span class="keyword">with</span>
8659     | some (ConstantInfo.axiomInfo <span class="preprocessor">_</span>)  <span class="constant">=&gt;</span> modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> axioms <span class="constant">:=</span> s.axioms.push c }
8660     | some (ConstantInfo.defnInfo v)   <span class="constant">=&gt;</span> collectExpr v.type <span class="constant">*&gt;</span> collectExpr v.value
8661     | some (ConstantInfo.thmInfo v)    <span class="constant">=&gt;</span> collectExpr v.type <span class="constant">*&gt;</span> collectExpr v.value
8662     | some (ConstantInfo.opaqueInfo v) <span class="constant">=&gt;</span> collectExpr v.type <span class="constant">*&gt;</span> collectExpr v.value
8663     | some (ConstantInfo.quotInfo <span class="preprocessor">_</span>)   <span class="constant">=&gt;</span> pure ()
8664     | some (ConstantInfo.ctorInfo v)   <span class="constant">=&gt;</span> collectExpr v.type
8665     | some (ConstantInfo.recInfo v)    <span class="constant">=&gt;</span> collectExpr v.type
8666     | some (ConstantInfo.inductInfo v) <span class="constant">=&gt;</span> collectExpr v.type <span class="constant">*&gt;</span> v.ctors.forM collect
8667     | none                             <span class="constant">=&gt;</span> pure ()
8668 
<span class="keyword">8669 end</span> CollectAxioms
8670 
<span class="keyword">8671 private</span> <span class="keyword">def</span> <span class="function-name">printAxiomsOf</span> (constName : Name) : CommandElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
8672   <span class="keyword">let</span> env &#8592; getEnv
8673   <span class="keyword">let</span> (<span class="preprocessor">_</span>, s) <span class="constant">:=</span> ((CollectAxioms.collect constName).run env).run {}
8674   <span class="keyword">if</span> s.axioms.isEmpty <span class="keyword">then</span>
8675     logInfo m<span class="constant">!</span><span class="string">"'{constName}' does not depend on any axioms"</span>
8676   <span class="keyword">else</span>
8677     logInfo m<span class="constant">!</span><span class="string">"'{constName}' depends on axioms: {s.axioms.toList}"</span>
8678 
<span class="constant">8679 @</span>[builtinCommandElab <span class="comment">&#171;</span>printAxioms<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabPrintAxioms</span> : CommandElab
8680   | `(<span class="keyword">#print</span>%<span class="constant">$</span>tk axioms <span class="constant">$</span>id) <span class="constant">=&gt;</span> withRef tk <span class="keyword">do</span>
8681     <span class="keyword">let</span> cs &#8592; resolveGlobalConstWithInfos id
8682     cs.forM printAxiomsOf
8683   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwUnsupportedSyntax
8684 
<span class="keyword">8685 end</span> Lean.Elab.Command
8686 ::::::::::::::
8687 Elab<span class="constant">/</span>Quotation.lean
8688 ::::::::::::::
<span class="comment-delimiter">8689 /-</span><span class="comment">
8690 Copyright (c) 2019 Microsoft Corporation. All rights reserved.
8691 Released under Apache 2.0 license as described in the file LICENSE.
8692 Authors: Sebastian Ullrich
8693 
8694 Elaboration of syntax quotations as terms and patterns (in `match_syntax`). See also `./Hygiene.lean` for the basic
8695 hygiene workings and data types.
8696 -/</span>
<span class="keyword">8697 import</span> Lean.Syntax
<span class="keyword">8698 import</span> Lean.ResolveName
<span class="keyword">8699 import</span> Lean.Elab.Term
<span class="keyword">8700 import</span> Lean.Elab.Quotation.Util
<span class="keyword">8701 import</span> Lean.Parser.Term
8702 
<span class="keyword">8703 namespace</span> Lean.Elab.Term.Quotation
<span class="keyword">8704 open</span> Lean.Parser.Term
<span class="keyword">8705 open</span> Lean.Syntax
<span class="keyword">8706 open</span> Meta
8707 
<span class="keyword">8708 register_builtin_option</span> hygiene : Bool <span class="constant">:=</span> {
8709   defValue <span class="constant">:=</span> true
8710   descr    <span class="constant">:=</span> <span class="string">"Annotate identifiers in quotations such that they are resolved relative to the scope at their declaration, not that at their eventual use/expansion, to avoid accidental capturing. Note that quotations/notations already defined are unaffected."</span>
8711 }
8712 
<span class="comment-delimiter">8713 /-</span><span class="comment">- `C[$(e)]` ~&gt; `let a := e; C[$a]`. Used in the implementation of antiquot splices. -/</span>
<span class="keyword">8714 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">floatOutAntiquotTerms</span> : Syntax <span class="constant">&#8594;</span> StateT (Syntax <span class="constant">&#8594;</span> TermElabM Syntax) TermElabM Syntax
8715   | stx<span class="constant">@</span>(Syntax.node k args) <span class="constant">=&gt;</span> <span class="keyword">do</span>
8716     <span class="keyword">if</span> isAntiquot stx <span class="constant">&amp;&amp;</span> <span class="constant">!</span>isEscapedAntiquot stx <span class="keyword">then</span>
8717       <span class="keyword">let</span> e <span class="constant">:=</span> getAntiquotTerm stx
8718       <span class="keyword">if</span> <span class="constant">!</span>e.isIdent <span class="constant">||</span> <span class="constant">!</span>e.getId.isAtomic <span class="keyword">then</span>
8719         <span class="keyword">return</span> &#8592; withFreshMacroScope <span class="keyword">do</span>
8720           <span class="keyword">let</span> a &#8592; `(a)
8721           modify (<span class="keyword">fun</span> cont stx <span class="constant">=&gt;</span> (`(<span class="keyword">let</span> <span class="constant">$</span>a:ident <span class="constant">:=</span> <span class="constant">$</span>e; <span class="constant">$</span>stx) : TermElabM <span class="preprocessor">_</span>))
8722           stx.setArg <span class="constant">2</span> a
8723     Syntax.node k (&#8592; args.mapM floatOutAntiquotTerms)
8724   | stx <span class="constant">=&gt;</span> pure stx
8725 
<span class="keyword">8726 private</span> <span class="keyword">def</span> <span class="function-name">getSepFromSplice</span> (splice : Syntax) : Syntax <span class="constant">:=</span> <span class="keyword">do</span>
8727   <span class="keyword">let</span> Syntax.atom <span class="preprocessor">_</span> sep &#8592; getAntiquotSpliceSuffix splice | <span class="warning">unreachable</span><span class="constant">!</span>
8728   Syntax.mkStrLit (sep.dropRight <span class="constant">1</span>)
8729 
<span class="keyword">8730 partial</span> <span class="keyword">def</span> <span class="function-name">mkTuple</span> : Array Syntax <span class="constant">&#8594;</span> TermElabM Syntax
8731   | <span class="constant">#</span>[]  <span class="constant">=&gt;</span> `(Unit.unit)
8732   | <span class="constant">#</span>[e] <span class="constant">=&gt;</span> e
8733   | es   <span class="constant">=&gt;</span> <span class="keyword">do</span>
8734     <span class="keyword">let</span> stx &#8592; mkTuple (es.eraseIdx <span class="constant">0</span>)
8735     `(Prod.mk <span class="constant">$</span>(es[<span class="constant">0</span>]) <span class="constant">$</span>stx)
8736 
<span class="keyword">8737 def</span> <span class="function-name">resolveSectionVariable</span> (sectionVars : NameMap Name) (id : Name) : List (Name <span class="constant">&#215;</span> List String) <span class="constant">:=</span>
8738   <span class="comment-delimiter">-- </span><span class="comment">decode macro scopes from name before recursion
</span>8739   <span class="keyword">let</span> extractionResult <span class="constant">:=</span> extractMacroScopes id
8740   <span class="keyword">let</span> <span class="keyword">rec</span> loop : Name <span class="constant">&#8594;</span> List String <span class="constant">&#8594;</span> List (Name <span class="constant">&#215;</span> List String)
8741     | id<span class="constant">@</span>(Name.str p s <span class="preprocessor">_</span>), projs <span class="constant">=&gt;</span>
8742       <span class="comment-delimiter">-- </span><span class="comment">NOTE: we assume that macro scopes always belong to the projected constant, not the projections
</span>8743       <span class="keyword">let</span> id <span class="constant">:=</span> { extractionResult <span class="keyword">with</span> name <span class="constant">:=</span> id }.review
8744       <span class="keyword">match</span> sectionVars.find? id <span class="keyword">with</span>
8745       | some newId <span class="constant">=&gt;</span> [(newId, projs)]
8746       | none       <span class="constant">=&gt;</span> loop p (s::projs)
8747     | <span class="preprocessor">_</span>, <span class="preprocessor">_</span> <span class="constant">=&gt;</span> []
8748   loop extractionResult.name []
8749 
<span class="comment-delimiter">8750 -- </span><span class="comment">Elaborate the content of a syntax quotation term
</span><span class="keyword">8751 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">quoteSyntax</span> : Syntax <span class="constant">&#8594;</span> TermElabM Syntax
8752   | Syntax.ident info rawVal val preresolved <span class="constant">=&gt;</span> <span class="keyword">do</span>
8753     <span class="keyword">if</span> <span class="constant">!</span>hygiene.get (&#8592; getOptions) <span class="keyword">then</span>
8754       <span class="keyword">return</span> &#8592; `(Syntax.ident info <span class="constant">$</span>(quote rawVal) <span class="constant">$</span>(quote val) <span class="constant">$</span>(quote preresolved))
8755     <span class="comment-delimiter">-- </span><span class="comment">Add global scopes at compilation time (now), add macro scope at runtime (in the quotation).
</span>8756     <span class="comment-delimiter">-- </span><span class="comment">See the paper for details.
</span>8757     <span class="keyword">let</span> r &#8592; resolveGlobalName val
8758     <span class="comment-delimiter">-- </span><span class="comment">extension of the paper algorithm: also store unique section variable names as top-level scopes
</span>8759     <span class="comment-delimiter">-- </span><span class="comment">so they can be captured and used inside the section, but not outside
</span>8760     <span class="keyword">let</span> r' <span class="constant">:=</span> resolveSectionVariable (&#8592; read).sectionVars val
8761     <span class="keyword">let</span> preresolved <span class="constant">:=</span> r <span class="constant">++</span> r' <span class="constant">++</span> preresolved
8762     <span class="keyword">let</span> val <span class="constant">:=</span> quote val
8763     <span class="comment-delimiter">-- </span><span class="comment">`scp` is bound in stxQuot.expand
</span>8764     `(Syntax.ident info <span class="constant">$</span>(quote rawVal) (addMacroScope mainModule <span class="constant">$</span>val scp) <span class="constant">$</span>(quote preresolved))
8765   <span class="comment-delimiter">-- </span><span class="comment">if antiquotation, insert contents as-is, else recurse
</span>8766   | stx<span class="constant">@</span>(Syntax.node k <span class="preprocessor">_</span>) <span class="constant">=&gt;</span> <span class="keyword">do</span>
8767     <span class="keyword">if</span> isAntiquot stx <span class="constant">&amp;&amp;</span> <span class="constant">!</span>isEscapedAntiquot stx <span class="keyword">then</span>
8768       getAntiquotTerm stx
8769     <span class="keyword">else</span> <span class="keyword">if</span> isTokenAntiquot stx <span class="constant">&amp;&amp;</span> <span class="constant">!</span>isEscapedAntiquot stx <span class="keyword">then</span>
8770       <span class="keyword">match</span> stx[<span class="constant">0</span>] <span class="keyword">with</span>
8771       | Syntax.atom <span class="preprocessor">_</span> val <span class="constant">=&gt;</span> `(Syntax.atom (Option.getD (getHeadInfo <span class="constant">$</span>(getAntiquotTerm stx)) info) <span class="constant">$</span>(quote val))
8772       | <span class="preprocessor">_</span>                 <span class="constant">=&gt;</span> throwErrorAt stx <span class="string">"expected token"</span>
8773     <span class="keyword">else</span> <span class="keyword">if</span> isAntiquotSuffixSplice stx <span class="constant">&amp;&amp;</span> <span class="constant">!</span>isEscapedAntiquot stx <span class="keyword">then</span>
8774       <span class="comment-delimiter">-- </span><span class="comment">splices must occur in a `many` node
</span>8775       throwErrorAt stx <span class="string">"unexpected antiquotation splice"</span>
8776     <span class="keyword">else</span> <span class="keyword">if</span> isAntiquotSplice stx <span class="constant">&amp;&amp;</span> <span class="constant">!</span>isEscapedAntiquot stx <span class="keyword">then</span>
8777       throwErrorAt stx <span class="string">"unexpected antiquotation splice"</span>
8778     <span class="keyword">else</span>
8779       <span class="keyword">let</span> empty &#8592; `(Array.empty);
8780       <span class="comment-delimiter">-- </span><span class="comment">if escaped antiquotation, decrement by one escape level
</span>8781       <span class="keyword">let</span> stx <span class="constant">:=</span> unescapeAntiquot stx
8782       <span class="keyword">let</span> args &#8592; stx.getArgs.foldlM (<span class="keyword">fun</span> args arg <span class="constant">=&gt;</span> <span class="keyword">do</span>
8783         <span class="keyword">if</span> k <span class="constant">==</span> nullKind <span class="constant">&amp;&amp;</span> isAntiquotSuffixSplice arg <span class="keyword">then</span>
8784           <span class="keyword">let</span> antiquot <span class="constant">:=</span> getAntiquotSuffixSpliceInner arg
8785           <span class="keyword">match</span> antiquotSuffixSplice? arg <span class="keyword">with</span>
8786           | `optional <span class="constant">=&gt;</span> `(Array.appendCore <span class="constant">$</span>args (<span class="keyword">match</span> <span class="constant">$</span>(getAntiquotTerm antiquot):term <span class="keyword">with</span>
8787             | some x <span class="constant">=&gt;</span> Array.empty.push x
8788             | none   <span class="constant">=&gt;</span> Array.empty))
8789           | `many     <span class="constant">=&gt;</span> `(Array.appendCore <span class="constant">$</span>args <span class="constant">$</span>(getAntiquotTerm antiquot))
8790           | `sepBy    <span class="constant">=&gt;</span> `(Array.appendCore <span class="constant">$</span>args (<span class="constant">@</span>SepArray.elemsAndSeps <span class="constant">$</span>(getSepFromSplice arg) <span class="constant">$</span>(getAntiquotTerm antiquot)))
8791           | k         <span class="constant">=&gt;</span> throwErrorAt arg <span class="string">"invalid antiquotation suffix splice kind '{k}'"</span>
8792         <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> nullKind <span class="constant">&amp;&amp;</span> isAntiquotSplice arg <span class="keyword">then</span>
8793           <span class="keyword">let</span> k <span class="constant">:=</span> antiquotSpliceKind? arg
8794           <span class="keyword">let</span> (arg, bindLets) &#8592; floatOutAntiquotTerms arg |<span class="constant">&gt;</span>.run pure
8795           <span class="keyword">let</span> inner &#8592; (getAntiquotSpliceContents arg).mapM quoteSyntax
8796           <span class="keyword">let</span> ids &#8592; getAntiquotationIds arg
8797           <span class="keyword">if</span> ids.isEmpty <span class="keyword">then</span>
8798             throwErrorAt stx <span class="string">"antiquotation splice must contain at least one antiquotation"</span>
8799           <span class="keyword">let</span> arr &#8592; <span class="keyword">match</span> k <span class="keyword">with</span>
8800             | `optional <span class="constant">=&gt;</span> `(<span class="keyword">match</span> <span class="constant">$</span>[<span class="constant">$</span>ids:ident],<span class="constant">*</span> <span class="keyword">with</span>
8801                 | <span class="constant">$</span>[some <span class="constant">$</span>ids:ident],<span class="constant">*</span> <span class="constant">=&gt;</span> <span class="constant">$</span>(quote inner)
8802                 | none                 <span class="constant">=&gt;</span> Array.empty)
8803             | <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
8804               <span class="keyword">let</span> arr &#8592; ids[:ids.size<span class="constant">-1</span>].foldrM (<span class="keyword">fun</span> id arr <span class="constant">=&gt;</span> `(Array.zip <span class="constant">$</span>id <span class="constant">$</span>arr)) ids.back
8805               `(Array.map (<span class="keyword">fun</span> <span class="constant">$</span>(&#8592; mkTuple ids) <span class="constant">=&gt;</span> <span class="constant">$</span>(inner[<span class="constant">0</span>])) <span class="constant">$</span>arr)
8806           <span class="keyword">let</span> arr &#8592;
8807             <span class="keyword">if</span> k <span class="constant">==</span> `sepBy <span class="keyword">then</span>
8808               `(mkSepArray <span class="constant">$</span>arr (mkAtom <span class="constant">$</span>(getSepFromSplice arg)))
8809             <span class="keyword">else</span> arr
8810           <span class="keyword">let</span> arr &#8592; bindLets arr
8811           `(Array.appendCore <span class="constant">$</span>args <span class="constant">$</span>arr)
8812         <span class="keyword">else</span> <span class="keyword">do</span>
8813           <span class="keyword">let</span> arg &#8592; quoteSyntax arg;
8814           `(Array.push <span class="constant">$</span>args <span class="constant">$</span>arg)) empty
8815       `(Syntax.node <span class="constant">$</span>(quote k) <span class="constant">$</span>args)
8816   | Syntax.atom <span class="preprocessor">_</span> val <span class="constant">=&gt;</span>
8817     `(Syntax.atom info <span class="constant">$</span>(quote val))
8818   | Syntax.missing <span class="constant">=&gt;</span> throwUnsupportedSyntax
8819 
<span class="keyword">8820 def</span> <span class="function-name">stxQuot.expand</span> (stx : Syntax) : TermElabM Syntax <span class="constant">:=</span> <span class="keyword">do</span>
8821   <span class="comment-delimiter">/- </span><span class="comment">Syntax quotations are monadic values depending on the current macro scope. For efficiency, we bind
8822      the macro scope once for each quotation, then build the syntax tree in a completely pure computation
8823      depending on this binding. Note that regular function calls do not introduce a new macro scope (i.e.
8824      we preserve referential transparency), so we can refer to this same `scp` inside `quoteSyntax` by
8825      including it literally in a syntax quotation. -/</span>
8826   <span class="comment-delimiter">-- </span><span class="comment">TODO: simplify to `(do scp &#8592; getCurrMacroScope; pure $(quoteSyntax quoted))
</span>8827   <span class="keyword">let</span> stx &#8592; quoteSyntax stx.getQuotContent;
8828   `(Bind.bind MonadRef.mkInfoFromRefPos (<span class="keyword">fun</span> info <span class="constant">=&gt;</span>
8829       Bind.bind getCurrMacroScope (<span class="keyword">fun</span> scp <span class="constant">=&gt;</span>
8830         Bind.bind getMainModule (<span class="keyword">fun</span> mainModule <span class="constant">=&gt;</span> Pure.pure <span class="constant">$</span>stx))))
8831   <span class="comment-delimiter">/- </span><span class="comment">NOTE: It may seem like the newly introduced binding `scp` may accidentally
8832      capture identifiers in an antiquotation introduced by `quoteSyntax`. However,
8833      note that the syntax quotation above enjoys the same hygiene guarantees as
8834      anywhere else in Lean; that is, we implement hygienic quotations by making
8835      use of the hygienic quotation support of the bootstrapped Lean compiler!
8836 
8837      Aside: While this might sound "dangerous", it is in fact less reliant on a
8838      "chain of trust" than other bootstrapping parts of Lean: because this
8839      implementation itself never uses `scp` (or any other identifier) both inside
8840      and outside quotations, it can actually correctly be compiled by an
8841      unhygienic (but otherwise correct) implementation of syntax quotations. As
8842      long as it is then compiled again with the resulting executable (i.e. up to
8843      stage 2), the result is a correct hygienic implementation. In this sense the
8844      implementation is "self-stabilizing". It was in fact originally compiled
8845      by an unhygienic prototype implementation. -/</span>
8846 
<span class="keyword">8847 macro</span> <span class="string">"elab_stx_quot"</span> kind:ident : command <span class="constant">=&gt;</span>
8848   `(<span class="doc">@[builtinTermElab $kind:ident]</span> <span class="keyword">def</span> <span class="function-name">elabQuot</span> : TermElab <span class="constant">:=</span> adaptExpander stxQuot.expand)
8849 
<span class="comment-delimiter">8850 --</span><span class="comment">
</span>8851 
8852 elab_stx_quot Parser.Level.quot
8853 elab_stx_quot Parser.Term.quot
8854 elab_stx_quot Parser.Term.funBinder.quot
8855 elab_stx_quot Parser.Term.bracketedBinder.quot
8856 elab_stx_quot Parser.Term.matchDiscr.quot
8857 elab_stx_quot Parser.Tactic.quot
8858 elab_stx_quot Parser.Tactic.quotSeq
8859 elab_stx_quot Parser.Term.stx.quot
8860 elab_stx_quot Parser.Term.prec.quot
8861 elab_stx_quot Parser.Term.attr.quot
8862 elab_stx_quot Parser.Term.prio.quot
8863 elab_stx_quot Parser.Term.doElem.quot
8864 elab_stx_quot Parser.Term.dynamicQuot
8865 
<span class="comment-delimiter">8866 /- </span><span class="comment">match -/</span>
8867 
<span class="comment-delimiter">8868 -- </span><span class="comment">an "alternative" of patterns plus right-hand side
</span><span class="keyword">8869 private</span> <span class="keyword">abbrev</span> Alt <span class="constant">:=</span> List Syntax <span class="constant">&#215;</span> Syntax
8870 
<span class="comment-delimiter">8871 /-</span><span class="comment">-
8872   In a single match step, we match the first discriminant against the "head" of the first pattern of the first
8873   alternative. This datatype describes what kind of check this involves, which helps other patterns decide if
8874   they are covered by the same check and don't have to be checked again (see also `MatchResult`). -/</span>
<span class="keyword">8875 inductive</span> <span class="function-name">HeadCheck</span> <span class="keyword">where</span>
8876   <span class="comment-delimiter">-- </span><span class="comment">match step that always succeeds: _, x, `($x), ...
</span>8877   | unconditional
8878   <span class="comment-delimiter">-- </span><span class="comment">match step based on kind and, optionally, arity of discriminant
</span>8879   <span class="comment-delimiter">-- </span><span class="comment">If `arity` is given, that number of new discriminants is introduced. `covered` patterns should then introduce the
</span>8880   <span class="comment-delimiter">-- </span><span class="comment">same number of new patterns.
</span>8881   <span class="comment-delimiter">-- </span><span class="comment">We actually check the arity at run time only in the case of `null` nodes since it should otherwise by implied by
</span>8882   <span class="comment-delimiter">-- </span><span class="comment">the node kind.
</span>8883   <span class="comment-delimiter">-- </span><span class="comment">without arity: `($x:k)
</span>8884   <span class="comment-delimiter">-- </span><span class="comment">with arity: any quotation without an antiquotation head pattern
</span>8885   | shape (k : SyntaxNodeKind) (arity : Option Nat)
8886   <span class="comment-delimiter">-- </span><span class="comment">Match step that succeeds on `null` nodes of arity at least `numPrefix + numSuffix`, introducing discriminants
</span>8887   <span class="comment-delimiter">-- </span><span class="comment">for the first `numPrefix` children, one `null` node for those in between, and for the `numSuffix` last children.
</span>8888   <span class="comment-delimiter">-- </span><span class="comment">example: `([$x, $xs,*, $y]) is `slice 2 2`
</span>8889   | slice (numPrefix numSuffix : Nat)
8890   <span class="comment-delimiter">-- </span><span class="comment">other, complicated match step that will probably only cover identical patterns
</span>8891   <span class="comment-delimiter">-- </span><span class="comment">example: antiquotation splices `($[...]*)
</span>8892   | other (pat : Syntax)
8893 
<span class="keyword">8894 open</span> HeadCheck
8895 
<span class="comment-delimiter">8896 /-</span><span class="comment">- Describe whether a pattern is covered by a head check (induced by the pattern itself or a different pattern). -/</span>
<span class="keyword">8897 inductive</span> <span class="function-name">MatchResult</span> <span class="keyword">where</span>
8898   <span class="comment-delimiter">-- </span><span class="comment">Pattern agrees with head check, remove and transform remaining alternative.
</span>8899   <span class="comment-delimiter">-- </span><span class="comment">If `exhaustive` is `false`, *also* include unchanged alternative in the "no" branch.
</span>8900   | covered (f : Alt <span class="constant">&#8594;</span> TermElabM Alt) (exhaustive : Bool)
8901   <span class="comment-delimiter">-- </span><span class="comment">Pattern disagrees with head check, include in "no" branch only
</span>8902   | uncovered
8903   <span class="comment-delimiter">-- </span><span class="comment">Pattern is not quite sure yet; include unchanged in both branches
</span>8904   | undecided
8905 
<span class="keyword">8906 open</span> MatchResult
8907 
<span class="comment-delimiter">8908 /-</span><span class="comment">- All necessary information on a pattern head. -/</span>
<span class="keyword">8909 structure</span> <span class="function-name">HeadInfo</span> <span class="keyword">where</span>
8910   <span class="comment-delimiter">-- </span><span class="comment">check induced by the pattern
</span>8911   check : HeadCheck
8912   <span class="comment-delimiter">-- </span><span class="comment">compute compatibility of pattern with given head check
</span>8913   onMatch (taken : HeadCheck) : MatchResult
8914   <span class="comment-delimiter">-- </span><span class="comment">actually run the specified head check, with the discriminant bound to `discr`
</span>8915   doMatch (yes : (newDiscrs : List Syntax) <span class="constant">&#8594;</span> TermElabM Syntax) (no : TermElabM Syntax) : TermElabM Syntax
8916 
<span class="comment-delimiter">8917 /-</span><span class="comment">- Adapt alternatives that do not introduce new discriminants in `doMatch`, but are covered by those that do so. -/</span>
<span class="keyword">8918 private</span> <span class="keyword">def</span> <span class="function-name">noOpMatchAdaptPats</span> : HeadCheck <span class="constant">&#8594;</span> Alt <span class="constant">&#8594;</span> Alt
8919   | shape k (some sz), (pats, rhs) <span class="constant">=&gt;</span> (List.replicate sz (Unhygienic.run `(<span class="preprocessor">_</span>)) <span class="constant">++</span> pats, rhs)
8920   | slice p s,         (pats, rhs) <span class="constant">=&gt;</span> (List.replicate (p <span class="constant">+</span> <span class="constant">1</span> <span class="constant">+</span> s) (Unhygienic.run `(<span class="preprocessor">_</span>)) <span class="constant">++</span> pats, rhs)
8921   | <span class="preprocessor">_</span>,                 alt         <span class="constant">=&gt;</span> alt
8922 
<span class="keyword">8923 private</span> <span class="keyword">def</span> <span class="function-name">adaptRhs</span> (fn : Syntax <span class="constant">&#8594;</span> TermElabM Syntax) : Alt <span class="constant">&#8594;</span> TermElabM Alt
8924   | (pats, rhs) <span class="constant">=&gt;</span> <span class="keyword">do</span> (pats, &#8592; fn rhs)
8925 
<span class="keyword">8926 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">getHeadInfo</span> (alt : Alt) : TermElabM HeadInfo <span class="constant">:=</span>
8927   <span class="keyword">let</span> pat <span class="constant">:=</span> alt.fst.head<span class="constant">!</span>
8928   <span class="keyword">let</span> unconditionally (rhsFn) <span class="constant">:=</span> pure {
8929     check <span class="constant">:=</span> unconditional,
8930     doMatch <span class="constant">:=</span> <span class="keyword">fun</span> yes no <span class="constant">=&gt;</span> yes [],
8931     onMatch <span class="constant">:=</span> <span class="keyword">fun</span> taken <span class="constant">=&gt;</span> covered (adaptRhs rhsFn <span class="constant">&#8728;</span> noOpMatchAdaptPats taken) (<span class="keyword">match</span> taken <span class="keyword">with</span> | unconditional <span class="constant">=&gt;</span> true | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> false)
8932   }
8933   <span class="comment-delimiter">-- </span><span class="comment">quotation pattern
</span>8934   <span class="keyword">if</span> isQuot pat <span class="keyword">then</span>
8935     <span class="keyword">let</span> quoted <span class="constant">:=</span> getQuotContent pat
8936     <span class="keyword">if</span> quoted.isAtom <span class="keyword">then</span>
8937       <span class="comment-delimiter">-- </span><span class="comment">We assume that atoms are uniquely determined by the node kind and never have to be checked
</span>8938       unconditionally pure
8939     <span class="keyword">else</span> <span class="keyword">if</span> quoted.isTokenAntiquot <span class="keyword">then</span>
8940       unconditionally (`(<span class="keyword">let</span> <span class="constant">$</span>(quoted.getAntiquotTerm) <span class="constant">:=</span> discr; <span class="constant">$</span>(&#183;)))
8941     <span class="keyword">else</span> <span class="keyword">if</span> isAntiquot quoted <span class="constant">&amp;&amp;</span> <span class="constant">!</span>isEscapedAntiquot quoted <span class="keyword">then</span>
8942       <span class="comment-delimiter">-- </span><span class="comment">quotation contains a single antiquotation
</span>8943       <span class="keyword">let</span> k <span class="constant">:=</span> antiquotKind? quoted |<span class="constant">&gt;</span>.get<span class="constant">!</span>
8944       <span class="keyword">match</span> getAntiquotTerm quoted <span class="keyword">with</span>
8945       | `(<span class="preprocessor">_</span>) <span class="constant">=&gt;</span> unconditionally pure
8946       | `(<span class="constant">$</span>id:ident) <span class="constant">=&gt;</span>
8947         <span class="comment-delimiter">-- </span><span class="comment">Antiquotation kinds like `$id:ident` influence the parser, but also need to be considered by
</span>8948         <span class="comment-delimiter">-- </span><span class="comment">`match` (but not by quotation terms). For example, `($id:ident) and `($e) are not
</span>8949         <span class="comment-delimiter">-- </span><span class="comment">distinguishable without checking the kind of the node to be captured. Note that some
</span>8950         <span class="comment-delimiter">-- </span><span class="comment">antiquotations like the latter one for terms do not correspond to any actual node kind
</span>8951         <span class="comment-delimiter">-- </span><span class="comment">(signified by `k == Name.anonymous`), so we would only check for `ident` here.
</span>8952         <span class="comment-delimiter">--</span><span class="comment">
</span>8953         <span class="comment-delimiter">-- </span><span class="comment">if stx.isOfKind `ident then
</span>8954         <span class="comment-delimiter">--   </span><span class="comment">let id := stx; let e := stx; ...
</span>8955         <span class="comment-delimiter">-- </span><span class="comment">else
</span>8956         <span class="comment-delimiter">--   </span><span class="comment">let e := stx; ...
</span>8957         <span class="keyword">let</span> rhsFn <span class="constant">:=</span> (`(<span class="keyword">let</span> <span class="constant">$</span>id <span class="constant">:=</span> discr; <span class="constant">$</span>(&#183;)))
8958         <span class="keyword">if</span> k <span class="constant">==</span> Name.anonymous <span class="keyword">then</span> unconditionally rhsFn <span class="keyword">else</span> pure {
8959           check   <span class="constant">:=</span> shape k none,
8960           onMatch <span class="constant">:=</span> <span class="keyword">fun</span>
8961             | taken<span class="constant">@</span>(shape k' sz) <span class="constant">=&gt;</span>
8962               <span class="keyword">if</span> k' <span class="constant">==</span> k <span class="keyword">then</span>
8963                 covered (adaptRhs rhsFn <span class="constant">&#8728;</span> noOpMatchAdaptPats taken) (exhaustive <span class="constant">:=</span> sz.isNone)
8964               <span class="keyword">else</span> uncovered
8965             | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> uncovered,
8966           doMatch <span class="constant">:=</span> <span class="keyword">fun</span> yes no <span class="constant">=&gt;</span> <span class="keyword">do</span> `(cond (Syntax.isOfKind discr <span class="constant">$</span>(quote k)) <span class="constant">$</span>(&#8592; yes []) <span class="constant">$</span>(&#8592; no)),
8967         }
8968       | anti <span class="constant">=&gt;</span> throwErrorAt anti <span class="string">"unsupported antiquotation kind in pattern"</span>
8969     <span class="keyword">else</span> <span class="keyword">if</span> isAntiquotSuffixSplice quoted <span class="keyword">then</span> throwErrorAt quoted <span class="string">"unexpected antiquotation splice"</span>
8970     <span class="keyword">else</span> <span class="keyword">if</span> isAntiquotSplice quoted <span class="keyword">then</span> throwErrorAt quoted <span class="string">"unexpected antiquotation splice"</span>
8971     <span class="keyword">else</span> <span class="keyword">if</span> quoted.getArgs.size <span class="constant">==</span> <span class="constant">1</span> <span class="constant">&amp;&amp;</span> isAntiquotSuffixSplice quoted[<span class="constant">0</span>] <span class="keyword">then</span>
8972       <span class="keyword">let</span> anti <span class="constant">:=</span> getAntiquotTerm (getAntiquotSuffixSpliceInner quoted[<span class="constant">0</span>])
8973       unconditionally <span class="keyword">fun</span> rhs <span class="constant">=&gt;</span> <span class="keyword">match</span> antiquotSuffixSplice? quoted[<span class="constant">0</span>] <span class="keyword">with</span>
8974         | `optional <span class="constant">=&gt;</span> `(<span class="keyword">let</span> <span class="constant">$</span>anti <span class="constant">:=</span> Syntax.getOptional? discr; <span class="constant">$</span>rhs)
8975         | `many     <span class="constant">=&gt;</span> `(<span class="keyword">let</span> <span class="constant">$</span>anti <span class="constant">:=</span> Syntax.getArgs discr; <span class="constant">$</span>rhs)
8976         | `sepBy    <span class="constant">=&gt;</span> `(<span class="keyword">let</span> <span class="constant">$</span>anti <span class="constant">:=</span> <span class="constant">@</span>SepArray.mk <span class="constant">$</span>(getSepFromSplice quoted[<span class="constant">0</span>]) (Syntax.getArgs discr); <span class="constant">$</span>rhs)
8977         | k         <span class="constant">=&gt;</span> throwErrorAt quoted <span class="string">"invalid antiquotation suffix splice kind '{k}'"</span>
8978     <span class="keyword">else</span> <span class="keyword">if</span> quoted.getArgs.size <span class="constant">==</span> <span class="constant">1</span> <span class="constant">&amp;&amp;</span> isAntiquotSplice quoted[<span class="constant">0</span>] <span class="keyword">then</span> pure {
8979       check   <span class="constant">:=</span> other pat,
8980       onMatch <span class="constant">:=</span> <span class="keyword">fun</span>
8981         | other pat' <span class="constant">=&gt;</span> <span class="keyword">if</span> pat' <span class="constant">==</span> pat <span class="keyword">then</span> covered pure (exhaustive <span class="constant">:=</span> true) <span class="keyword">else</span> undecided
8982         | <span class="preprocessor">_</span>          <span class="constant">=&gt;</span> undecided,
8983       doMatch <span class="constant">:=</span> <span class="keyword">fun</span> yes no <span class="constant">=&gt;</span> <span class="keyword">do</span>
8984         <span class="keyword">let</span> splice <span class="constant">:=</span> quoted[<span class="constant">0</span>]
8985         <span class="keyword">let</span> k <span class="constant">:=</span> antiquotSpliceKind? splice
8986         <span class="keyword">let</span> contents <span class="constant">:=</span> getAntiquotSpliceContents splice
8987         <span class="keyword">let</span> ids &#8592; getAntiquotationIds splice
8988         <span class="keyword">let</span> yes &#8592; yes []
8989         <span class="keyword">let</span> no &#8592; no
8990         <span class="keyword">match</span> k <span class="keyword">with</span>
8991         | `optional <span class="constant">=&gt;</span>
8992           <span class="keyword">let</span> nones <span class="constant">:=</span> mkArray ids.size (&#8592; `(none))
8993           `(let_delayed yes <span class="preprocessor">_</span> <span class="constant">$</span>ids<span class="constant">*</span> <span class="constant">:=</span> <span class="constant">$</span>yes;
8994             <span class="keyword">if</span> discr.isNone <span class="keyword">then</span> yes () <span class="constant">$</span>[ <span class="constant">$</span>nones]<span class="constant">*</span>
8995             <span class="keyword">else</span> <span class="keyword">match</span> discr <span class="keyword">with</span>
8996               | `(<span class="constant">$</span>(mkNullNode contents)) <span class="constant">=&gt;</span> yes () <span class="constant">$</span>[ (some <span class="constant">$</span>ids)]<span class="constant">*</span>
8997               | <span class="preprocessor">_</span>                         <span class="constant">=&gt;</span> <span class="constant">$</span>no)
8998         | <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
8999           <span class="keyword">let</span> <span class="keyword">mut</span> discrs &#8592; `(Syntax.getArgs discr)
9000           <span class="keyword">if</span> k <span class="constant">==</span> `sepBy <span class="keyword">then</span>
9001             discrs &#8592; `(Array.getSepElems <span class="constant">$</span>discrs)
9002           <span class="keyword">let</span> tuple &#8592; mkTuple ids
9003           <span class="keyword">let</span> <span class="keyword">mut</span> yes <span class="constant">:=</span> yes
9004           <span class="keyword">let</span> resId &#8592; <span class="keyword">match</span> ids <span class="keyword">with</span>
9005             | <span class="constant">#</span>[id] <span class="constant">=&gt;</span> id
9006             | <span class="preprocessor">_</span>     <span class="constant">=&gt;</span>
9007               <span class="keyword">for</span> id <span class="keyword">in</span> ids <span class="keyword">do</span>
9008                 yes &#8592; `(<span class="keyword">let</span> <span class="constant">$</span>id <span class="constant">:=</span> tuples.map (<span class="keyword">fun</span> <span class="constant">$</span>tuple <span class="constant">=&gt;</span> <span class="constant">$</span>id); <span class="constant">$</span>yes)
9009               `(tuples)
9010           <span class="keyword">let</span> contents <span class="constant">:=</span> <span class="keyword">if</span> contents.size <span class="constant">==</span> <span class="constant">1</span>
9011             <span class="keyword">then</span> contents[<span class="constant">0</span>]
9012             <span class="keyword">else</span> mkNullNode contents
9013           `(<span class="keyword">match</span> OptionM.run (<span class="constant">$</span>(discrs).sequenceMap <span class="keyword">fun</span>
9014                 | `(<span class="constant">$</span>contents) <span class="constant">=&gt;</span> some <span class="constant">$</span>tuple
9015                 | <span class="preprocessor">_</span>            <span class="constant">=&gt;</span> none) <span class="keyword">with</span>
9016               | some <span class="constant">$</span>resId <span class="constant">=&gt;</span> <span class="constant">$</span>yes
9017               | none <span class="constant">=&gt;</span> <span class="constant">$</span>no)
9018     }
9019     <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> some idx <span class="constant">:=</span> quoted.getArgs.findIdx? (<span class="keyword">fun</span> arg <span class="constant">=&gt;</span> isAntiquotSuffixSplice arg <span class="constant">||</span> isAntiquotSplice arg) <span class="keyword">then</span> <span class="keyword">do</span>
9020       <span class="comment-delimiter">/-</span><span class="comment">
9021         pattern of the form `match discr, ... with | `(pat_0 ... pat_(idx-1) $[...]* pat_(idx+1) ...), ...`
9022         transform to
9023         ```
9024         if discr.getNumArgs &gt;= $quoted.getNumArgs - 1 then
9025           match discr[0], ..., discr[idx-1], mkNullNode (discr.getArgs.extract idx (discr.getNumArgs - $numSuffix))), ..., discr[quoted.getNumArgs - 1] with
9026             | `(pat_0), ... `(pat_(idx-1)), `($[...])*, `(pat_(idx+1)), ...
9027         ```
9028       -/</span>
9029       <span class="keyword">let</span> numSuffix <span class="constant">:=</span> quoted.getNumArgs <span class="constant">-</span> <span class="constant">1</span> <span class="constant">-</span> idx
9030       pure {
9031         check    <span class="constant">:=</span> slice idx numSuffix
9032         onMatch  <span class="constant">:=</span> <span class="keyword">fun</span>
9033           | slice p s <span class="constant">=&gt;</span>
9034             <span class="keyword">if</span> p <span class="constant">==</span> idx <span class="constant">&amp;&amp;</span> s <span class="constant">==</span> numSuffix <span class="keyword">then</span>
9035               <span class="keyword">let</span> argPats <span class="constant">:=</span> quoted.getArgs.mapIdx <span class="keyword">fun</span> i arg <span class="constant">=&gt;</span>
9036                 <span class="keyword">let</span> arg <span class="constant">:=</span> <span class="keyword">if</span> (i : Nat) <span class="constant">==</span> idx <span class="keyword">then</span> mkNullNode <span class="constant">#</span>[arg] <span class="keyword">else</span> arg
9037                 Unhygienic.run `(`(<span class="constant">$</span>(arg)))
9038               covered (<span class="keyword">fun</span> (pats, rhs) <span class="constant">=&gt;</span> (argPats.toList <span class="constant">++</span> pats, rhs)) (exhaustive <span class="constant">:=</span> true)
9039             <span class="keyword">else</span> uncovered
9040           | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> uncovered
9041         doMatch <span class="constant">:=</span> <span class="keyword">fun</span> yes no <span class="constant">=&gt;</span> <span class="keyword">do</span>
9042           <span class="keyword">let</span> prefixDiscrs &#8592; (List.range idx).mapM (`(Syntax.getArg discr <span class="constant">$</span>(quote &#183;)))
9043           <span class="keyword">let</span> sliceDiscr &#8592; `(mkNullNode (discr.getArgs.extract <span class="constant">$</span>(quote idx) (discr.getNumArgs <span class="constant">-</span> <span class="constant">$</span>(quote numSuffix))))
9044           <span class="keyword">let</span> suffixDiscrs &#8592; (List.range numSuffix).mapM <span class="keyword">fun</span> i <span class="constant">=&gt;</span>
9045             `(Syntax.getArg discr (discr.getNumArgs <span class="constant">-</span> <span class="constant">$</span>(quote (numSuffix <span class="constant">-</span> i))))
9046           `(ite (GE.ge discr.getNumArgs <span class="constant">$</span>(quote (quoted.getNumArgs <span class="constant">-</span> <span class="constant">1</span>)))
9047               <span class="constant">$</span>(&#8592; yes (prefixDiscrs <span class="constant">++</span> sliceDiscr :: suffixDiscrs))
9048               <span class="constant">$</span>(&#8592; no))
9049       }
9050     <span class="keyword">else</span>
9051       <span class="comment-delimiter">-- </span><span class="comment">not an antiquotation, or an escaped antiquotation: match head shape
</span>9052       <span class="keyword">let</span> quoted  <span class="constant">:=</span> unescapeAntiquot quoted
9053       <span class="keyword">let</span> kind <span class="constant">:=</span> quoted.getKind
9054       <span class="keyword">let</span> argPats <span class="constant">:=</span> quoted.getArgs.map <span class="keyword">fun</span> arg <span class="constant">=&gt;</span> Unhygienic.run `(`(<span class="constant">$</span>(arg)))
9055       pure {
9056         check <span class="constant">:=</span> shape kind argPats.size,
9057         onMatch <span class="constant">:=</span> <span class="keyword">fun</span> taken <span class="constant">=&gt;</span>
9058           <span class="keyword">if</span> (<span class="keyword">match</span> taken <span class="keyword">with</span> | shape k' sz <span class="constant">=&gt;</span> k' <span class="constant">==</span> kind <span class="constant">&amp;&amp;</span> sz <span class="constant">==</span> argPats.size | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> false : Bool) <span class="keyword">then</span>
9059             covered (<span class="keyword">fun</span> (pats, rhs) <span class="constant">=&gt;</span> (argPats.toList <span class="constant">++</span> pats, rhs)) (exhaustive <span class="constant">:=</span> true)
9060           <span class="keyword">else</span>
9061             uncovered,
9062         doMatch <span class="constant">:=</span> <span class="keyword">fun</span> yes no <span class="constant">=&gt;</span> <span class="keyword">do</span>
9063           <span class="keyword">let</span> cond &#8592; <span class="keyword">match</span> kind <span class="keyword">with</span>
9064           | `null <span class="constant">=&gt;</span> `(Syntax.matchesNull discr <span class="constant">$</span>(quote argPats.size))
9065           | `ident <span class="constant">=&gt;</span> `(Syntax.matchesIdent discr <span class="constant">$</span>(quote quoted.getId))
9066           | <span class="preprocessor">_</span>     <span class="constant">=&gt;</span> `(Syntax.isOfKind discr <span class="constant">$</span>(quote kind))
9067           <span class="keyword">let</span> newDiscrs &#8592; (List.range argPats.size).mapM <span class="keyword">fun</span> i <span class="constant">=&gt;</span> `(Syntax.getArg discr <span class="constant">$</span>(quote i))
9068           `(ite (Eq <span class="constant">$</span>cond true) <span class="constant">$</span>(&#8592; yes newDiscrs) <span class="constant">$</span>(&#8592; no))
9069       }
9070   <span class="keyword">else</span> <span class="keyword">match</span> pat <span class="keyword">with</span>
9071     | `(<span class="preprocessor">_</span>)              <span class="constant">=&gt;</span> unconditionally pure
9072     | `(<span class="constant">$</span>id:ident)      <span class="constant">=&gt;</span> unconditionally (`(<span class="keyword">let</span> <span class="constant">$</span>id <span class="constant">:=</span> discr; <span class="constant">$</span>(&#183;)))
9073     | `(<span class="constant">$</span>id:ident<span class="constant">@$</span>pat) <span class="constant">=&gt;</span> <span class="keyword">do</span>
9074       <span class="keyword">let</span> info &#8592; getHeadInfo (pat::alt.<span class="constant">1</span>.tail<span class="constant">!</span>, alt.<span class="constant">2</span>)
9075       { info <span class="keyword">with</span> onMatch <span class="constant">:=</span> <span class="keyword">fun</span> taken <span class="constant">=&gt;</span> <span class="keyword">match</span> info.onMatch taken <span class="keyword">with</span>
9076           | covered f exh <span class="constant">=&gt;</span> covered (<span class="keyword">fun</span> alt <span class="constant">=&gt;</span> f alt <span class="constant">&gt;&gt;=</span> adaptRhs (`(<span class="keyword">let</span> <span class="constant">$</span>id <span class="constant">:=</span> discr; <span class="constant">$</span>(&#183;)))) exh
9077           | r             <span class="constant">=&gt;</span> r }
9078     | <span class="preprocessor">_</span>               <span class="constant">=&gt;</span> throwErrorAt pat <span class="string">"match_syntax: unexpected pattern kind {pat}"</span>
9079 
<span class="comment-delimiter">9080 -- </span><span class="comment">Bind right-hand side to new `let_delayed` decl in order to prevent code duplication
</span><span class="keyword">9081 private</span> <span class="keyword">def</span> <span class="function-name">deduplicate</span> (floatedLetDecls : Array Syntax) : Alt <span class="constant">&#8594;</span> TermElabM (Array Syntax <span class="constant">&#215;</span> Alt)
9082   <span class="comment-delimiter">-- </span><span class="comment">NOTE: new macro scope so that introduced bindings do not collide
</span>9083   | (pats, rhs) <span class="constant">=&gt;</span> <span class="keyword">do</span>
9084     <span class="keyword">if</span> <span class="keyword">let</span> `(<span class="constant">$</span>f:ident <span class="constant">$</span>[ <span class="constant">$</span>args:ident]<span class="constant">*</span>) <span class="constant">:=</span> rhs <span class="keyword">then</span>
9085       <span class="comment-delimiter">-- </span><span class="comment">looks simple enough/created by this function, skip
</span>9086       <span class="keyword">return</span> (floatedLetDecls, (pats, rhs))
9087     withFreshMacroScope <span class="keyword">do</span>
9088       <span class="keyword">match</span> &#8592; getPatternsVars pats.toArray <span class="keyword">with</span>
9089       | <span class="constant">#</span>[] <span class="constant">=&gt;</span>
9090         <span class="comment-delimiter">-- </span><span class="comment">no antiquotations =&gt; introduce Unit parameter to preserve evaluation order
</span>9091         <span class="keyword">let</span> rhs' &#8592; `(rhs Unit.unit)
9092         (floatedLetDecls.push (&#8592; `(letDecl|rhs <span class="preprocessor">_</span> <span class="constant">:=</span> <span class="constant">$</span>rhs)), (pats, rhs'))
9093       | vars <span class="constant">=&gt;</span>
9094         <span class="keyword">let</span> rhs' &#8592; `(rhs <span class="constant">$</span>vars<span class="constant">*</span>)
9095         (floatedLetDecls.push (&#8592; `(letDecl|rhs <span class="constant">$</span>vars:ident<span class="constant">*</span> <span class="constant">:=</span> <span class="constant">$</span>rhs)), (pats, rhs'))
9096 
<span class="keyword">9097 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">compileStxMatch</span> (discrs : List Syntax) (alts : List Alt) : TermElabM Syntax <span class="constant">:=</span> <span class="keyword">do</span>
9098   trace[Elab.<span class="keyword">match_syntax</span>] <span class="string">"match {discrs} with {alts}"</span>
9099   <span class="keyword">match</span> discrs, alts <span class="keyword">with</span>
9100   | [],            ([], rhs)::<span class="preprocessor">_</span> <span class="constant">=&gt;</span> pure rhs  <span class="comment-delimiter">-- </span><span class="comment">nothing left to match
</span>9101   | <span class="preprocessor">_</span>,             []           <span class="constant">=&gt;</span> throwError <span class="string">"non-exhaustive 'match_syntax'"</span>
9102   | discr::discrs, alt::alts    <span class="constant">=&gt;</span> <span class="keyword">do</span>
9103     <span class="keyword">let</span> info &#8592; getHeadInfo alt
9104     <span class="keyword">let</span> pat  <span class="constant">:=</span> alt.<span class="constant">1</span>.head<span class="constant">!</span>
9105     <span class="keyword">let</span> alts &#8592; (alt::alts).mapM <span class="keyword">fun</span> alt <span class="constant">=&gt;</span> <span class="keyword">do</span> ((&#8592; getHeadInfo alt).onMatch info.check, alt)
9106     <span class="keyword">let</span> <span class="keyword">mut</span> yesAlts           <span class="constant">:=</span> <span class="constant">#</span>[]
9107     <span class="keyword">let</span> <span class="keyword">mut</span> undecidedAlts     <span class="constant">:=</span> <span class="constant">#</span>[]
9108     <span class="keyword">let</span> <span class="keyword">mut</span> nonExhaustiveAlts <span class="constant">:=</span> <span class="constant">#</span>[]
9109     <span class="keyword">let</span> <span class="keyword">mut</span> floatedLetDecls   <span class="constant">:=</span> <span class="constant">#</span>[]
9110     <span class="keyword">for</span> alt <span class="keyword">in</span> alts <span class="keyword">do</span>
9111       <span class="keyword">let</span> <span class="keyword">mut</span> alt <span class="constant">:=</span> alt
9112       <span class="keyword">match</span> alt <span class="keyword">with</span>
9113       | (covered f exh, alt) <span class="constant">=&gt;</span>
9114         <span class="comment-delimiter">-- </span><span class="comment">we can only factor out a common check if there are no undecided patterns in between;
</span>9115         <span class="comment-delimiter">-- </span><span class="comment">otherwise we would change the order of alternatives
</span>9116         <span class="keyword">if</span> undecidedAlts.isEmpty <span class="keyword">then</span>
9117           yesAlts &#8592; yesAlts.push <span class="constant">&lt;$&gt;</span> f (alt.<span class="constant">1</span>.tail<span class="constant">!</span>, alt.<span class="constant">2</span>)
9118           <span class="keyword">if</span> <span class="constant">!</span>exh <span class="keyword">then</span>
9119             nonExhaustiveAlts <span class="constant">:=</span> nonExhaustiveAlts.push alt
9120         <span class="keyword">else</span>
9121           (floatedLetDecls, alt) &#8592; deduplicate floatedLetDecls alt
9122           undecidedAlts <span class="constant">:=</span> undecidedAlts.push alt
9123           nonExhaustiveAlts <span class="constant">:=</span> nonExhaustiveAlts.push alt
9124       | (undecided, alt) <span class="constant">=&gt;</span>
9125         (floatedLetDecls, alt) &#8592; deduplicate floatedLetDecls alt
9126         undecidedAlts <span class="constant">:=</span> undecidedAlts.push alt
9127         nonExhaustiveAlts <span class="constant">:=</span> nonExhaustiveAlts.push alt
9128       | (uncovered, alt) <span class="constant">=&gt;</span>
9129         nonExhaustiveAlts <span class="constant">:=</span> nonExhaustiveAlts.push alt
9130     <span class="keyword">let</span> <span class="keyword">mut</span> stx &#8592; info.doMatch
9131       (yes <span class="constant">:=</span> <span class="keyword">fun</span> newDiscrs <span class="constant">=&gt;</span> <span class="keyword">do</span>
9132         <span class="keyword">let</span> <span class="keyword">mut</span> yesAlts <span class="constant">:=</span> yesAlts
9133         <span class="keyword">if</span> <span class="constant">!</span>undecidedAlts.isEmpty <span class="keyword">then</span>
9134           <span class="comment-delimiter">-- </span><span class="comment">group undecided alternatives in a new default case `| discr2, ... =&gt; match discr, discr2, ... with ...`
</span>9135           <span class="keyword">let</span> vars &#8592; discrs.mapM <span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> withFreshMacroScope `(discr)
9136           <span class="keyword">let</span> pats <span class="constant">:=</span> List.replicate newDiscrs.length (Unhygienic.run `(<span class="preprocessor">_</span>)) <span class="constant">++</span> vars
9137           <span class="keyword">let</span> alts &#8592; undecidedAlts.mapM <span class="keyword">fun</span> alt <span class="constant">=&gt;</span> `(matchAltExpr| | <span class="constant">$</span>(alt.<span class="constant">1</span>.toArray),<span class="constant">*</span> <span class="constant">=&gt;</span> <span class="constant">$</span>(alt.<span class="constant">2</span>))
9138           <span class="keyword">let</span> rhs  &#8592; `(<span class="keyword">match</span> discr, <span class="constant">$</span>[<span class="constant">$</span>(vars.toArray):term],<span class="constant">*</span> <span class="keyword">with</span> <span class="constant">$</span>alts:matchAlt<span class="constant">*</span>)
9139           yesAlts <span class="constant">:=</span> yesAlts.push (pats, rhs)
9140         withFreshMacroScope <span class="constant">$</span> compileStxMatch (newDiscrs <span class="constant">++</span> discrs) yesAlts.toList)
9141       (no <span class="constant">:=</span> withFreshMacroScope <span class="constant">$</span> compileStxMatch (discr::discrs) nonExhaustiveAlts.toList)
9142     <span class="keyword">for</span> d <span class="keyword">in</span> floatedLetDecls <span class="keyword">do</span>
9143       stx &#8592; `(let_delayed <span class="constant">$</span>d:letDecl; <span class="constant">$</span>stx)
9144     `(<span class="keyword">let</span> discr <span class="constant">:=</span> <span class="constant">$</span>discr; <span class="constant">$</span>stx)
9145   | <span class="preprocessor">_</span>, <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="warning">unreachable</span><span class="constant">!</span>
9146 
<span class="keyword">9147 def</span> <span class="function-name">match_syntax.expand</span> (stx : Syntax) : TermElabM Syntax <span class="constant">:=</span> <span class="keyword">do</span>
9148   <span class="keyword">match</span> stx <span class="keyword">with</span>
9149   | `(<span class="keyword">match</span> <span class="constant">$</span>[<span class="constant">$</span>discrs:term],<span class="constant">*</span> <span class="keyword">with</span> <span class="constant">$</span>[| <span class="constant">$</span>[<span class="constant">$</span>patss],<span class="constant">*</span> <span class="constant">=&gt;</span> <span class="constant">$</span>rhss]<span class="constant">*</span>) <span class="constant">=&gt;</span> <span class="keyword">do</span>
9150     <span class="keyword">if</span> <span class="constant">!</span>patss.any (&#183;.any (<span class="keyword">fun</span>
9151       | `(<span class="constant">$</span>id<span class="constant">@$</span>pat) <span class="constant">=&gt;</span> pat.isQuot
9152       | pat         <span class="constant">=&gt;</span> pat.isQuot)) <span class="keyword">then</span>
9153       <span class="comment-delimiter">-- </span><span class="comment">no quotations =&gt; fall back to regular `match`
</span>9154       throwUnsupportedSyntax
9155     <span class="keyword">let</span> stx &#8592; compileStxMatch discrs.toList (patss.map (&#183;.toList) |<span class="constant">&gt;</span>.zip rhss).toList
9156     trace[Elab.<span class="keyword">match_syntax</span>.result] <span class="string">"{stx}"</span>
9157     stx
9158   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwUnsupportedSyntax
9159 
<span class="constant">9160 @</span>[builtinTermElab <span class="comment">&#171;</span>match<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabMatchSyntax</span> : TermElab <span class="constant">:=</span>
9161   adaptExpander <span class="keyword">match_syntax</span>.expand
9162 
<span class="keyword">9163 builtin_initialize</span>
9164   registerTraceClass `Elab.<span class="keyword">match_syntax</span>
9165   registerTraceClass `Elab.<span class="keyword">match_syntax</span>.result
9166 
<span class="keyword">9167 end</span> Lean.Elab.Term.Quotation
9168 ::::::::::::::
9169 Elab<span class="constant">/</span>SetOption.lean
9170 ::::::::::::::
<span class="comment-delimiter">9171 /-</span><span class="comment">
9172 Copyright (c) 2021 Microsoft Corporation. All rights reserved.
9173 Released under Apache 2.0 license as described in the file LICENSE.
9174 Authors: Leonardo de Moura
9175 -/</span>
<span class="keyword">9176 import</span> Lean.Elab.Log
<span class="keyword">9177 import</span> Lean.Elab.InfoTree
<span class="keyword">9178 namespace</span> Lean.Elab
9179 
<span class="keyword">9180 variable</span> [Monad m] [MonadOptions m] [MonadExceptOf Exception m] [MonadRef m]
<span class="keyword">9181 variable</span> [AddErrorMessageContext m] [MonadLiftT (EIO Exception) m] [MonadInfoTree m]
9182 
<span class="keyword">9183 def</span> <span class="function-name">elabSetOption</span> (id : Syntax) (val : Syntax) : m Options <span class="constant">:=</span> <span class="keyword">do</span>
9184   <span class="keyword">let</span> optionName <span class="constant">:=</span> id.getId.eraseMacroScopes
9185   <span class="keyword">match</span> val.isStrLit? <span class="keyword">with</span>
9186   | some str <span class="constant">=&gt;</span> setOption optionName (DataValue.ofString str)
9187   | none     <span class="constant">=&gt;</span>
9188   <span class="keyword">match</span> val.isNatLit? <span class="keyword">with</span>
9189   | some num <span class="constant">=&gt;</span> setOption optionName (DataValue.ofNat num)
9190   | none     <span class="constant">=&gt;</span>
9191   <span class="keyword">match</span> val <span class="keyword">with</span>
9192   | Syntax.atom <span class="preprocessor">_</span> <span class="string">"true"</span>  <span class="constant">=&gt;</span> setOption optionName (DataValue.ofBool true)
9193   | Syntax.atom <span class="preprocessor">_</span> <span class="string">"false"</span> <span class="constant">=&gt;</span> setOption optionName (DataValue.ofBool false)
9194   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
9195     addCompletionInfo <span class="constant">&lt;</span>| CompletionInfo.option (&#8592; getRef)
9196     throwError <span class="string">"unexpected set_option value {val}"</span>
<span class="keyword">9197 where</span>
9198   setOption (optionName : Name) (val : DataValue) : m Options <span class="constant">:=</span> <span class="keyword">do</span>
9199     <span class="keyword">let</span> ref &#8592; getRef
9200     <span class="keyword">let</span> decl &#8592; IO.toEIO (<span class="keyword">fun</span> (ex : IO.Error) <span class="constant">=&gt;</span> Exception.error ref ex.toString) (getOptionDecl optionName)
9201     <span class="keyword">unless</span> decl.defValue.sameCtor val <span class="keyword">do</span> throwError <span class="string">"type mismatch at set_option"</span>
9202     <span class="keyword">return</span> (&#8592; getOptions).insert optionName val
9203 
<span class="keyword">9204 end</span> Lean.Elab
9205 ::::::::::::::
9206 Elab<span class="constant">/</span>StructInst.lean
9207 ::::::::::::::
<span class="comment-delimiter">9208 /-</span><span class="comment">
9209 Copyright (c) 2020 Microsoft Corporation. All rights reserved.
9210 Released under Apache 2.0 license as described in the file LICENSE.
9211 Authors: Leonardo de Moura
9212 -/</span>
<span class="keyword">9213 import</span> Lean.Util.FindExpr
<span class="keyword">9214 import</span> Lean.Parser.Term
<span class="keyword">9215 import</span> Lean.Elab.App
<span class="keyword">9216 import</span> Lean.Elab.Binders
9217 
<span class="keyword">9218 namespace</span> Lean.Elab.Term.StructInst
9219 
<span class="keyword">9220 open</span> Std (HashMap)
<span class="keyword">9221 open</span> Meta
9222 
<span class="comment-delimiter">9223 /-</span><span class="comment">
9224   Structure instances are of the form:
9225 
9226       "{" &gt;&gt; optional (atomic (termParser &gt;&gt; " with "))
9227           &gt;&gt; manyIndent (group (structInstField &gt;&gt; optional ", "))
9228           &gt;&gt; optEllipsis
9229           &gt;&gt; optional (" : " &gt;&gt; termParser)
9230           &gt;&gt; " }"
9231 -/</span>
9232 
<span class="doc">9233 @[builtinMacro Lean.Parser.Term.structInst]</span> <span class="keyword">def</span> <span class="function-name">expandStructInstExpectedType</span> : Macro <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="constant">=&gt;</span>
9234   <span class="keyword">let</span> expectedArg <span class="constant">:=</span> stx[<span class="constant">4</span>]
9235   <span class="keyword">if</span> expectedArg.isNone <span class="keyword">then</span>
9236     Macro.throwUnsupported
9237   <span class="keyword">else</span>
9238     <span class="keyword">let</span> expected <span class="constant">:=</span> expectedArg[<span class="constant">1</span>]
9239     <span class="keyword">let</span> stxNew   <span class="constant">:=</span> stx.setArg <span class="constant">4</span> mkNullNode
9240     `((<span class="constant">$</span>stxNew : <span class="constant">$</span>expected))
9241 
<span class="comment-delimiter">9242 /-</span><span class="comment">
9243 If `stx` is of the form `{ s with ... }` and `s` is not a local variable, expand into `let src := s; { src with ... }`.
9244 
9245 Note that this one is not a `Macro` because we need to access the local context.
9246 -/</span>
<span class="keyword">9247 private</span> <span class="keyword">def</span> <span class="function-name">expandNonAtomicExplicitSource</span> (stx : Syntax) : TermElabM (Option Syntax) <span class="constant">:=</span>
9248   withFreshMacroScope <span class="keyword">do</span>
9249     <span class="keyword">let</span> sourceOpt <span class="constant">:=</span> stx[<span class="constant">1</span>]
9250     <span class="keyword">if</span> sourceOpt.isNone <span class="keyword">then</span>
9251       pure none
9252     <span class="keyword">else</span>
9253       <span class="keyword">let</span> source <span class="constant">:=</span> sourceOpt[<span class="constant">0</span>]
9254       <span class="keyword">match</span> (&#8592; isLocalIdent? source) <span class="keyword">with</span>
9255       | some <span class="preprocessor">_</span> <span class="constant">=&gt;</span> pure none
9256       | none   <span class="constant">=&gt;</span>
9257         <span class="keyword">if</span> source.isMissing <span class="keyword">then</span>
9258           throwAbortTerm
9259         <span class="keyword">else</span>
9260           <span class="keyword">let</span> src &#8592; `(src)
9261           <span class="keyword">let</span> sourceOpt <span class="constant">:=</span> sourceOpt.setArg <span class="constant">0</span> src
9262           <span class="keyword">let</span> stxNew    <span class="constant">:=</span> stx.setArg <span class="constant">1</span> sourceOpt
9263           `(<span class="keyword">let</span> src <span class="constant">:=</span> <span class="constant">$</span>source; <span class="constant">$</span>stxNew)
9264 
<span class="keyword">9265 inductive</span> <span class="function-name">Source</span> <span class="keyword">where</span>
9266   | none     <span class="comment-delimiter">-- </span><span class="comment">structure instance source has not been provieded
</span>9267   | implicit (stx : Syntax) <span class="comment-delimiter">-- </span><span class="comment">`..`
</span>9268   | explicit (stx : Syntax) (src : Expr) <span class="comment-delimiter">-- </span><span class="comment">`src with`
</span>9269   <span class="keyword">deriving</span> Inhabited
9270 
<span class="keyword">9271 def</span> <span class="function-name">Source.isNone</span> : Source <span class="constant">&#8594;</span> Bool
9272   | Source.none <span class="constant">=&gt;</span> true
9273   | <span class="preprocessor">_</span>           <span class="constant">=&gt;</span> false
9274 
<span class="keyword">9275 def</span> <span class="function-name">setStructSourceSyntax</span> (structStx : Syntax) : Source <span class="constant">&#8594;</span> Syntax
9276   | Source.none           <span class="constant">=&gt;</span> (structStx.setArg <span class="constant">1</span> mkNullNode).setArg <span class="constant">3</span> mkNullNode
9277   | Source.implicit stx   <span class="constant">=&gt;</span> (structStx.setArg <span class="constant">1</span> mkNullNode).setArg <span class="constant">3</span> stx
9278   | Source.explicit stx <span class="preprocessor">_</span> <span class="constant">=&gt;</span> (structStx.setArg <span class="constant">1</span> stx).setArg <span class="constant">3</span> mkNullNode
9279 
<span class="keyword">9280 private</span> <span class="keyword">def</span> <span class="function-name">getStructSource</span> (stx : Syntax) : TermElabM Source <span class="constant">:=</span>
9281   withRef stx <span class="keyword">do</span>
9282     <span class="keyword">let</span> explicitSource <span class="constant">:=</span> stx[<span class="constant">1</span>]
9283     <span class="keyword">let</span> implicitSource <span class="constant">:=</span> stx[<span class="constant">3</span>]
9284     <span class="keyword">if</span> explicitSource.isNone <span class="constant">&amp;&amp;</span> implicitSource[<span class="constant">0</span>].isNone <span class="keyword">then</span>
9285       <span class="keyword">return</span> Source.none
9286     <span class="keyword">else</span> <span class="keyword">if</span> explicitSource.isNone <span class="keyword">then</span>
9287       <span class="keyword">return</span> Source.implicit implicitSource
9288     <span class="keyword">else</span> <span class="keyword">if</span> implicitSource[<span class="constant">0</span>].isNone <span class="keyword">then</span>
9289       <span class="keyword">let</span> fvar? &#8592; isLocalIdent? explicitSource[<span class="constant">0</span>]
9290       <span class="keyword">match</span> fvar? <span class="keyword">with</span>
9291       | none      <span class="constant">=&gt;</span> <span class="warning">unreachable</span><span class="constant">!</span> <span class="comment-delimiter">-- </span><span class="comment">expandNonAtomicExplicitSource must have been used when we get here
</span>9292       | some src  <span class="constant">=&gt;</span> <span class="keyword">return</span> Source.explicit explicitSource src
9293     <span class="keyword">else</span>
9294       throwError <span class="string">"invalid structure instance `with` and `..` cannot be used together"</span>
9295 
<span class="comment-delimiter">9296 /-</span><span class="comment">
9297   We say a `{ ... }` notation is a `modifyOp` if it contains only one
9298   ```
9299   def structInstArrayRef := leading_parser "[" &gt;&gt; termParser &gt;&gt;"]"
9300   ```
9301 -/</span>
<span class="keyword">9302 private</span> <span class="keyword">def</span> <span class="function-name">isModifyOp?</span> (stx : Syntax) : TermElabM (Option Syntax) <span class="constant">:=</span> <span class="keyword">do</span>
9303   <span class="keyword">let</span> s? &#8592; stx[<span class="constant">2</span>].getArgs.foldlM (init <span class="constant">:=</span> none) <span class="keyword">fun</span> s? p <span class="constant">=&gt;</span>
9304     <span class="comment-delimiter">/- </span><span class="comment">p is of the form `(group (structInstField &gt;&gt; optional ", "))` -/</span>
9305     <span class="keyword">let</span> arg <span class="constant">:=</span> p[<span class="constant">0</span>]
9306     <span class="comment-delimiter">/- </span><span class="comment">Remark: the syntax for `structInstField` is
9307        ```
9308        def structInstLVal   := leading_parser (ident &lt;|&gt; numLit &lt;|&gt; structInstArrayRef) &gt;&gt; many (group ("." &gt;&gt; (ident &lt;|&gt; numLit)) &lt;|&gt; structInstArrayRef)
9309        def structInstField  := leading_parser structInstLVal &gt;&gt; " := " &gt;&gt; termParser
9310        ```
9311     -/</span>
9312     <span class="keyword">let</span> lval <span class="constant">:=</span> arg[<span class="constant">0</span>]
9313     <span class="keyword">let</span> k    <span class="constant">:=</span> lval[<span class="constant">0</span>].getKind
9314     <span class="keyword">if</span> k <span class="constant">==</span> `Lean.Parser.Term.structInstArrayRef <span class="keyword">then</span>
9315       <span class="keyword">match</span> s? <span class="keyword">with</span>
9316       | none   <span class="constant">=&gt;</span> pure (some arg)
9317       | some s <span class="constant">=&gt;</span>
9318         <span class="keyword">if</span> s.getKind <span class="constant">==</span> `Lean.Parser.Term.structInstArrayRef <span class="keyword">then</span>
9319           throwErrorAt arg <span class="string">"invalid \{...} notation, at most one `[..]` at a given level"</span>
9320         <span class="keyword">else</span>
9321           throwErrorAt arg <span class="string">"invalid \{...} notation, can't mix field and `[..]` at a given level"</span>
9322     <span class="keyword">else</span>
9323       <span class="keyword">match</span> s? <span class="keyword">with</span>
9324       | none   <span class="constant">=&gt;</span> pure (some arg)
9325       | some s <span class="constant">=&gt;</span>
9326         <span class="keyword">if</span> s.getKind <span class="constant">==</span> `Lean.Parser.Term.structInstArrayRef <span class="keyword">then</span>
9327           throwErrorAt arg <span class="string">"invalid \{...} notation, can't mix field and `[..]` at a given level"</span>
9328         <span class="keyword">else</span>
9329           pure s?
9330   <span class="keyword">match</span> s? <span class="keyword">with</span>
9331   | none   <span class="constant">=&gt;</span> pure none
9332   | some s <span class="constant">=&gt;</span> <span class="keyword">if</span> s[<span class="constant">0</span>][<span class="constant">0</span>].getKind <span class="constant">==</span> `Lean.Parser.Term.structInstArrayRef <span class="keyword">then</span> pure s? <span class="keyword">else</span> pure none
9333 
<span class="keyword">9334 private</span> <span class="keyword">def</span> <span class="function-name">elabModifyOp</span> (stx modifyOp source : Syntax) (expectedType? : Option Expr) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
9335   <span class="keyword">let</span> cont (val : Syntax) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
9336     <span class="keyword">let</span> lval <span class="constant">:=</span> modifyOp[<span class="constant">0</span>][<span class="constant">0</span>]
9337     <span class="keyword">let</span> idx  <span class="constant">:=</span> lval[<span class="constant">1</span>]
9338     <span class="keyword">let</span> self <span class="constant">:=</span> source[<span class="constant">0</span>]
9339     <span class="keyword">let</span> stxNew &#8592; `(<span class="constant">$</span>(self).modifyOp (idx <span class="constant">:=</span> <span class="constant">$</span>idx) (<span class="keyword">fun</span> s <span class="constant">=&gt;</span> <span class="constant">$</span>val))
9340     trace[Elab.struct.modifyOp] <span class="string">"{stx}\n===&gt;\n{stxNew}"</span>
9341     withMacroExpansion stx stxNew <span class="constant">&lt;</span>| elabTerm stxNew expectedType?
9342   trace[Elab.struct.modifyOp] <span class="string">"{modifyOp}\nSource: {source}"</span>
9343   <span class="keyword">let</span> rest <span class="constant">:=</span> modifyOp[<span class="constant">0</span>][<span class="constant">1</span>]
9344   <span class="keyword">if</span> rest.isNone <span class="keyword">then</span>
9345     cont modifyOp[<span class="constant">2</span>]
9346   <span class="keyword">else</span>
9347     <span class="keyword">let</span> s &#8592; `(s)
9348     <span class="keyword">let</span> valFirst  <span class="constant">:=</span> rest[<span class="constant">0</span>]
9349     <span class="keyword">let</span> valFirst  <span class="constant">:=</span> <span class="keyword">if</span> valFirst.getKind <span class="constant">==</span> `Lean.Parser.Term.structInstArrayRef <span class="keyword">then</span> valFirst <span class="keyword">else</span> valFirst[<span class="constant">1</span>]
9350     <span class="keyword">let</span> restArgs  <span class="constant">:=</span> rest.getArgs
9351     <span class="keyword">let</span> valRest   <span class="constant">:=</span> mkNullNode restArgs[<span class="constant">1</span>:restArgs.size]
9352     <span class="keyword">let</span> valField  <span class="constant">:=</span> modifyOp.setArg <span class="constant">0</span> <span class="constant">&lt;</span>| Syntax.node ``Parser.Term.structInstLVal <span class="constant">#</span>[valFirst, valRest]
9353     <span class="keyword">let</span> valSource <span class="constant">:=</span> source.modifyArg <span class="constant">0</span> <span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> s
9354     <span class="keyword">let</span> val       <span class="constant">:=</span> stx.setArg <span class="constant">1</span> valSource
9355     <span class="keyword">let</span> val       <span class="constant">:=</span> val.setArg <span class="constant">2</span> <span class="constant">&lt;</span>| mkNullNode <span class="constant">#</span>[mkNullNode <span class="constant">#</span>[valField, mkNullNode]]
9356     trace[Elab.struct.modifyOp] <span class="string">"{stx}\nval: {val}"</span>
9357     cont val
9358 
<span class="comment-delimiter">9359 /- </span><span class="comment">Get structure name and elaborate explicit source (if available) -/</span>
<span class="keyword">9360 private</span> <span class="keyword">def</span> <span class="function-name">getStructName</span> (stx : Syntax) (expectedType? : Option Expr) (sourceView : Source) : TermElabM (Name <span class="constant">&#215;</span> Expr) <span class="constant">:=</span> <span class="keyword">do</span>
9361   tryPostponeIfNoneOrMVar expectedType?
9362   <span class="keyword">let</span> useSource : Unit <span class="constant">&#8594;</span> TermElabM (Name <span class="constant">&#215;</span> Expr) <span class="constant">:=</span> <span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
9363     <span class="keyword">match</span> sourceView, expectedType? <span class="keyword">with</span>
9364     | Source.explicit <span class="preprocessor">_</span> src, <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">do</span>
9365       <span class="keyword">let</span> srcType &#8592; inferType src
9366       <span class="keyword">let</span> srcType &#8592; whnf srcType
9367       tryPostponeIfMVar srcType
9368       <span class="keyword">match</span> srcType.getAppFn <span class="keyword">with</span>
9369       | Expr.const constName <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">return</span> (constName, srcType)
9370       | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwUnexpectedExpectedType srcType <span class="string">"source"</span>
9371     | <span class="preprocessor">_</span>, some expectedType <span class="constant">=&gt;</span> throwUnexpectedExpectedType expectedType
9372     | <span class="preprocessor">_</span>, none              <span class="constant">=&gt;</span> throwUnknownExpectedType
9373   <span class="keyword">match</span> expectedType? <span class="keyword">with</span>
9374   | none <span class="constant">=&gt;</span> useSource ()
9375   | some expectedType <span class="constant">=&gt;</span>
9376     <span class="keyword">let</span> expectedType &#8592; whnf expectedType
9377     <span class="keyword">match</span> expectedType.getAppFn <span class="keyword">with</span>
9378     | Expr.const constName <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">return</span> (constName, expectedType)
9379     | <span class="preprocessor">_</span>                        <span class="constant">=&gt;</span> useSource ()
<span class="keyword">9380 where</span>
9381   throwUnknownExpectedType <span class="constant">:=</span>
9382     throwError <span class="string">"invalid \{...} notation, expected type is not known"</span>
9383   throwUnexpectedExpectedType type (kind <span class="constant">:=</span> <span class="string">"expected"</span>) <span class="constant">:=</span> <span class="keyword">do</span>
9384     <span class="keyword">let</span> type &#8592; instantiateMVars type
9385     <span class="keyword">if</span> type.getAppFn.isMVar <span class="keyword">then</span>
9386       throwUnknownExpectedType
9387     <span class="keyword">else</span>
9388       throwError <span class="string">"invalid \{...} notation, {kind} type is not of the form (C ...){indentExpr type}"</span>
9389 
<span class="keyword">9390 inductive</span> <span class="function-name">FieldLHS</span> <span class="keyword">where</span>
9391   | fieldName  (ref : Syntax) (name : Name)
9392   | fieldIndex (ref : Syntax) (idx : Nat)
9393   | modifyOp   (ref : Syntax) (index : Syntax)
9394   <span class="keyword">deriving</span> Inhabited
9395 
<span class="keyword">9396 instance</span> <span class="function-name">:</span> ToFormat FieldLHS <span class="constant">:=</span> &#10216;<span class="keyword">fun</span> lhs <span class="constant">=&gt;</span>
9397   <span class="keyword">match</span> lhs <span class="keyword">with</span>
9398   | FieldLHS.fieldName <span class="preprocessor">_</span> n  <span class="constant">=&gt;</span> fmt n
9399   | FieldLHS.fieldIndex <span class="preprocessor">_</span> i <span class="constant">=&gt;</span> fmt i
9400   | FieldLHS.modifyOp <span class="preprocessor">_</span> i   <span class="constant">=&gt;</span> <span class="string">"["</span> <span class="constant">++</span> i.prettyPrint <span class="constant">++</span> <span class="string">"]"</span>&#10217;
9401 
<span class="keyword">9402 inductive</span> <span class="function-name">FieldVal</span> (&#963; : <span class="type">Type</span>) <span class="keyword">where</span>
9403   | term  (stx : Syntax) : FieldVal &#963;
9404   | nested (s : &#963;)       : FieldVal &#963;
9405   | default              : FieldVal &#963; <span class="comment-delimiter">-- </span><span class="comment">mark that field must be synthesized using default value
</span>9406   <span class="keyword">deriving</span> Inhabited
9407 
<span class="keyword">9408 structure</span> <span class="function-name">Field</span> (&#963; : <span class="type">Type</span>) <span class="keyword">where</span>
9409   ref : Syntax
9410   lhs : List FieldLHS
9411   val : FieldVal &#963;
9412   expr? : Option Expr <span class="constant">:=</span> none
9413   <span class="keyword">deriving</span> Inhabited
9414 
<span class="keyword">9415 def</span> <span class="function-name">Field.isSimple</span> {&#963;} : Field &#963; <span class="constant">&#8594;</span> Bool
9416   | { lhs <span class="constant">:=</span> [<span class="preprocessor">_</span>], .. } <span class="constant">=&gt;</span> true
9417   | <span class="preprocessor">_</span>                  <span class="constant">=&gt;</span> false
9418 
<span class="keyword">9419 inductive</span> <span class="function-name">Struct</span> <span class="keyword">where</span>
9420   | mk (ref : Syntax) (structName : Name) (fields : List (Field Struct)) (source : Source)
9421   <span class="keyword">deriving</span> Inhabited
9422 
<span class="keyword">9423 abbrev</span> Fields <span class="constant">:=</span> List (Field Struct)
9424 
<span class="comment-delimiter">9425 /- </span><span class="comment">true if all fields of the given structure are marked as `default` -/</span>
<span class="keyword">9426 partial</span> <span class="keyword">def</span> <span class="function-name">Struct.allDefault</span> : Struct <span class="constant">&#8594;</span> Bool
9427   | &#10216;<span class="preprocessor">_</span>, <span class="preprocessor">_</span>, fields, <span class="preprocessor">_</span>&#10217; <span class="constant">=&gt;</span> fields.all <span class="keyword">fun</span> &#10216;<span class="preprocessor">_</span>, <span class="preprocessor">_</span>, val, <span class="preprocessor">_</span>&#10217; <span class="constant">=&gt;</span> <span class="keyword">match</span> val <span class="keyword">with</span>
9428     | FieldVal.term <span class="preprocessor">_</span>   <span class="constant">=&gt;</span> false
9429     | FieldVal.default  <span class="constant">=&gt;</span> true
9430     | FieldVal.nested s <span class="constant">=&gt;</span> allDefault s
9431 
<span class="keyword">9432 def</span> <span class="function-name">Struct.ref</span> : Struct <span class="constant">&#8594;</span> Syntax
9433   | &#10216;ref, <span class="preprocessor">_</span>, <span class="preprocessor">_</span>, <span class="preprocessor">_</span>&#10217; <span class="constant">=&gt;</span> ref
9434 
<span class="keyword">9435 def</span> <span class="function-name">Struct.structName</span> : Struct <span class="constant">&#8594;</span> Name
9436   | &#10216;<span class="preprocessor">_</span>, structName, <span class="preprocessor">_</span>, <span class="preprocessor">_</span>&#10217; <span class="constant">=&gt;</span> structName
9437 
<span class="keyword">9438 def</span> <span class="function-name">Struct.fields</span> : Struct <span class="constant">&#8594;</span> Fields
9439   | &#10216;<span class="preprocessor">_</span>, <span class="preprocessor">_</span>, fields, <span class="preprocessor">_</span>&#10217; <span class="constant">=&gt;</span> fields
9440 
<span class="keyword">9441 def</span> <span class="function-name">Struct.source</span> : Struct <span class="constant">&#8594;</span> Source
9442   | &#10216;<span class="preprocessor">_</span>, <span class="preprocessor">_</span>, <span class="preprocessor">_</span>, s&#10217; <span class="constant">=&gt;</span> s
9443 
<span class="keyword">9444 def</span> <span class="function-name">formatField</span> (formatStruct : Struct <span class="constant">&#8594;</span> Format) (field : Field Struct) : Format <span class="constant">:=</span>
9445   Format.joinSep field.lhs <span class="string">" . "</span> <span class="constant">++</span> <span class="string">" := "</span> <span class="constant">++</span>
9446     <span class="keyword">match</span> field.val <span class="keyword">with</span>
9447     | FieldVal.term v   <span class="constant">=&gt;</span> v.prettyPrint
9448     | FieldVal.nested s <span class="constant">=&gt;</span> formatStruct s
9449     | FieldVal.default  <span class="constant">=&gt;</span> <span class="string">"&lt;default&gt;"</span>
9450 
<span class="keyword">9451 partial</span> <span class="keyword">def</span> <span class="function-name">formatStruct</span> : Struct <span class="constant">&#8594;</span> Format
9452   | &#10216;<span class="preprocessor">_</span>, structName, fields, source&#10217; <span class="constant">=&gt;</span>
9453     <span class="keyword">let</span> fieldsFmt <span class="constant">:=</span> Format.joinSep (fields.map (formatField formatStruct)) <span class="string">", "</span>
9454     <span class="keyword">match</span> source <span class="keyword">with</span>
9455     | Source.none           <span class="constant">=&gt;</span> <span class="string">"{"</span> <span class="constant">++</span> fieldsFmt <span class="constant">++</span> <span class="string">"}"</span>
9456     | Source.implicit <span class="preprocessor">_</span>     <span class="constant">=&gt;</span> <span class="string">"{"</span> <span class="constant">++</span> fieldsFmt <span class="constant">++</span> <span class="string">" .. }"</span>
9457     | Source.explicit <span class="preprocessor">_</span> src <span class="constant">=&gt;</span> <span class="string">"{"</span> <span class="constant">++</span> format src <span class="constant">++</span> <span class="string">" with "</span> <span class="constant">++</span> fieldsFmt <span class="constant">++</span> <span class="string">"}"</span>
9458 
<span class="keyword">9459 instance</span> <span class="function-name">:</span> ToFormat Struct     <span class="constant">:=</span> &#10216;formatStruct&#10217;
<span class="keyword">9460 instance</span> <span class="function-name">:</span> ToString Struct <span class="constant">:=</span> &#10216;toString <span class="constant">&#8728;</span> format&#10217;
9461 
<span class="keyword">9462 instance</span> <span class="function-name">:</span> ToFormat (Field Struct) <span class="constant">:=</span> &#10216;formatField formatStruct&#10217;
<span class="keyword">9463 instance</span> <span class="function-name">:</span> ToString (Field Struct) <span class="constant">:=</span> &#10216;toString <span class="constant">&#8728;</span> format&#10217;
9464 
<span class="comment-delimiter">9465 /-</span><span class="comment">
9466 Recall that `structInstField` elements have the form
9467 ```
9468    def structInstField  := leading_parser structInstLVal &gt;&gt; " := " &gt;&gt; termParser
9469    def structInstLVal   := leading_parser (ident &lt;|&gt; numLit &lt;|&gt; structInstArrayRef) &gt;&gt; many (("." &gt;&gt; (ident &lt;|&gt; numLit)) &lt;|&gt; structInstArrayRef)
9470    def structInstArrayRef := leading_parser "[" &gt;&gt; termParser &gt;&gt;"]"
9471 ```
9472 -/</span>
<span class="comment-delimiter">9473 -- </span><span class="comment">Remark: this code relies on the fact that `expandStruct` only transforms `fieldLHS.fieldName`
</span><span class="keyword">9474 def</span> <span class="function-name">FieldLHS.toSyntax</span> (first : Bool) : FieldLHS <span class="constant">&#8594;</span> Syntax
9475   | FieldLHS.modifyOp   stx <span class="preprocessor">_</span>    <span class="constant">=&gt;</span> stx
9476   | FieldLHS.fieldName  stx name <span class="constant">=&gt;</span> <span class="keyword">if</span> first <span class="keyword">then</span> mkIdentFrom stx name <span class="keyword">else</span> mkGroupNode <span class="constant">#</span>[mkAtomFrom stx <span class="string">"."</span>, mkIdentFrom stx name]
9477   | FieldLHS.fieldIndex stx <span class="preprocessor">_</span>    <span class="constant">=&gt;</span> <span class="keyword">if</span> first <span class="keyword">then</span> stx <span class="keyword">else</span> mkGroupNode <span class="constant">#</span>[mkAtomFrom stx <span class="string">"."</span>, stx]
9478 
<span class="keyword">9479 def</span> <span class="function-name">FieldVal.toSyntax</span> : FieldVal Struct <span class="constant">&#8594;</span> Syntax
9480   | FieldVal.term stx <span class="constant">=&gt;</span> stx
9481   | <span class="preprocessor">_</span>                 <span class="constant">=&gt;</span> <span class="warning">unreachable</span><span class="constant">!</span>
9482 
<span class="keyword">9483 def</span> <span class="function-name">Field.toSyntax</span> : Field Struct <span class="constant">&#8594;</span> Syntax
9484   | field <span class="constant">=&gt;</span>
9485     <span class="keyword">let</span> stx <span class="constant">:=</span> field.ref
9486     <span class="keyword">let</span> stx <span class="constant">:=</span> stx.setArg <span class="constant">2</span> field.val.toSyntax
9487     <span class="keyword">match</span> field.lhs <span class="keyword">with</span>
9488     | first::rest <span class="constant">=&gt;</span> stx.setArg <span class="constant">0</span> <span class="constant">&lt;</span>| mkNullNode <span class="constant">#</span>[first.toSyntax true, mkNullNode <span class="constant">&lt;</span>| rest.toArray.map (FieldLHS.toSyntax false) ]
9489     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="warning">unreachable</span><span class="constant">!</span>
9490 
<span class="keyword">9491 private</span> <span class="keyword">def</span> <span class="function-name">toFieldLHS</span> (stx : Syntax) : Except String FieldLHS <span class="constant">:=</span>
9492   <span class="keyword">if</span> stx.getKind <span class="constant">==</span> `Lean.Parser.Term.structInstArrayRef <span class="keyword">then</span>
9493     <span class="keyword">return</span> FieldLHS.modifyOp stx stx[<span class="constant">1</span>]
9494   <span class="keyword">else</span>
9495     <span class="comment-delimiter">-- </span><span class="comment">Note that the representation of the first field is different.
</span>9496     <span class="keyword">let</span> stx <span class="constant">:=</span> <span class="keyword">if</span> stx.getKind <span class="constant">==</span> groupKind <span class="keyword">then</span> stx[<span class="constant">1</span>] <span class="keyword">else</span> stx
9497     <span class="keyword">if</span> stx.isIdent <span class="keyword">then</span>
9498       <span class="keyword">return</span> FieldLHS.fieldName stx stx.getId.eraseMacroScopes
9499     <span class="keyword">else</span> <span class="keyword">match</span> stx.isFieldIdx? <span class="keyword">with</span>
9500       | some idx <span class="constant">=&gt;</span> <span class="keyword">return</span> FieldLHS.fieldIndex stx idx
9501       | none     <span class="constant">=&gt;</span> throw <span class="string">"unexpected structure syntax"</span>
9502 
<span class="keyword">9503 private</span> <span class="keyword">def</span> <span class="function-name">mkStructView</span> (stx : Syntax) (structName : Name) (source : Source) : Except String Struct <span class="constant">:=</span> <span class="keyword">do</span>
9504   <span class="comment-delimiter">/- </span><span class="comment">Recall that `stx` is of the form
9505      ```
9506      leading_parser "{" &gt;&gt; optional (atomic (termParser &gt;&gt; " with "))
9507                  &gt;&gt; manyIndent (group (structInstField &gt;&gt; optional ", "))
9508                  &gt;&gt; optional ".."
9509                  &gt;&gt; optional (" : " &gt;&gt; termParser)
9510                  &gt;&gt; " }"
9511      ```
9512   -/</span>
9513   <span class="keyword">let</span> fieldsStx <span class="constant">:=</span> stx[<span class="constant">2</span>].getArgs.map (&#183;[<span class="constant">0</span>])
9514   <span class="keyword">let</span> fields &#8592; fieldsStx.toList.mapM <span class="keyword">fun</span> fieldStx <span class="constant">=&gt;</span> <span class="keyword">do</span>
9515     <span class="keyword">let</span> val   <span class="constant">:=</span> fieldStx[<span class="constant">2</span>]
9516     <span class="keyword">let</span> first &#8592; toFieldLHS fieldStx[<span class="constant">0</span>][<span class="constant">0</span>]
9517     <span class="keyword">let</span> rest  &#8592; fieldStx[<span class="constant">0</span>][<span class="constant">1</span>].getArgs.toList.mapM toFieldLHS
9518     pure { ref <span class="constant">:=</span> fieldStx, lhs <span class="constant">:=</span> first :: rest, val <span class="constant">:=</span> FieldVal.term val : Field Struct }
9519   pure &#10216;stx, structName, fields, source&#10217;
9520 
<span class="keyword">9521 def</span> <span class="function-name">Struct.modifyFieldsM</span> {m : <span class="type">Type</span> <span class="constant">&#8594;</span> <span class="type">Type</span>} [Monad m] (s : Struct) (f : Fields <span class="constant">&#8594;</span> m Fields) : m Struct <span class="constant">:=</span>
9522   <span class="keyword">match</span> s <span class="keyword">with</span>
9523   | &#10216;ref, structName, fields, source&#10217; <span class="constant">=&gt;</span> <span class="keyword">return</span> &#10216;ref, structName, (&#8592; f fields), source&#10217;
9524 
<span class="doc">9525 @[inline]</span> <span class="keyword">def</span> <span class="function-name">Struct.modifyFields</span> (s : Struct) (f : Fields <span class="constant">&#8594;</span> Fields) : Struct <span class="constant">:=</span>
9526   Id.run <span class="constant">&lt;</span>| s.modifyFieldsM f
9527 
<span class="keyword">9528 def</span> <span class="function-name">Struct.setFields</span> (s : Struct) (fields : Fields) : Struct <span class="constant">:=</span>
9529   s.modifyFields <span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> fields
9530 
<span class="keyword">9531 private</span> <span class="keyword">def</span> <span class="function-name">expandCompositeFields</span> (s : Struct) : Struct <span class="constant">:=</span>
9532   s.modifyFields <span class="keyword">fun</span> fields <span class="constant">=&gt;</span> fields.map <span class="keyword">fun</span> field <span class="constant">=&gt;</span> <span class="keyword">match</span> field <span class="keyword">with</span>
9533     | { lhs <span class="constant">:=</span> FieldLHS.fieldName ref (Name.str Name.anonymous <span class="preprocessor">_</span> <span class="preprocessor">_</span>) :: rest, .. } <span class="constant">=&gt;</span> field
9534     | { lhs <span class="constant">:=</span> FieldLHS.fieldName ref n<span class="constant">@</span>(Name.str <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="preprocessor">_</span>) :: rest, .. } <span class="constant">=&gt;</span>
9535       <span class="keyword">let</span> newEntries <span class="constant">:=</span> n.components.map <span class="constant">&lt;</span>| FieldLHS.fieldName ref
9536       { field <span class="keyword">with</span> lhs <span class="constant">:=</span> newEntries <span class="constant">++</span> rest }
9537     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> field
9538 
<span class="keyword">9539 private</span> <span class="keyword">def</span> <span class="function-name">expandNumLitFields</span> (s : Struct) : TermElabM Struct <span class="constant">:=</span>
9540   s.modifyFieldsM <span class="keyword">fun</span> fields <span class="constant">=&gt;</span> <span class="keyword">do</span>
9541     <span class="keyword">let</span> env &#8592; getEnv
9542     <span class="keyword">let</span> fieldNames <span class="constant">:=</span> getStructureFields env s.structName
9543     fields.mapM <span class="keyword">fun</span> field <span class="constant">=&gt;</span> <span class="keyword">match</span> field <span class="keyword">with</span>
9544       | { lhs <span class="constant">:=</span> FieldLHS.fieldIndex ref idx :: rest, .. } <span class="constant">=&gt;</span>
9545         <span class="keyword">if</span> idx <span class="constant">==</span> <span class="constant">0</span> <span class="keyword">then</span> throwErrorAt ref <span class="string">"invalid field index, index must be greater than 0"</span>
9546         <span class="keyword">else</span> <span class="keyword">if</span> idx <span class="constant">&gt;</span> fieldNames.size <span class="keyword">then</span> throwErrorAt ref <span class="string">"invalid field index, structure has only #{fieldNames.size} fields"</span>
9547         <span class="keyword">else</span> pure { field <span class="keyword">with</span> lhs <span class="constant">:=</span> FieldLHS.fieldName ref fieldNames[idx <span class="constant">-</span> <span class="constant">1</span>] :: rest }
9548       | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> pure field
9549 
<span class="comment-delimiter">9550 /- </span><span class="comment">For example, consider the following structures:
9551    ```
9552    structure A where
9553      x : Nat
9554 
9555    structure B extends A where
9556      y : Nat
9557 
9558    structure C extends B where
9559      z : Bool
9560    ```
9561    This method expands parent structure fields using the path to the parent structure.
9562    For example,
9563    ```
9564    { x := 0, y := 0, z := true : C }
9565    ```
9566    is expanded into
9567    ```
9568    { toB.toA.x := 0, toB.y := 0, z := true : C }
9569    ```
9570 -/</span>
<span class="keyword">9571 private</span> <span class="keyword">def</span> <span class="function-name">expandParentFields</span> (s : Struct) : TermElabM Struct <span class="constant">:=</span> <span class="keyword">do</span>
9572   <span class="keyword">let</span> env &#8592; getEnv
9573   s.modifyFieldsM <span class="keyword">fun</span> fields <span class="constant">=&gt;</span> fields.mapM <span class="keyword">fun</span> field <span class="constant">=&gt;</span> <span class="keyword">match</span> field <span class="keyword">with</span>
9574     | { lhs <span class="constant">:=</span> FieldLHS.fieldName ref fieldName :: rest, .. } <span class="constant">=&gt;</span>
9575       <span class="keyword">match</span> findField? env s.structName fieldName <span class="keyword">with</span>
9576       | none <span class="constant">=&gt;</span> throwErrorAt ref <span class="string">"'{fieldName}' is not a field of structure '{s.structName}'"</span>
9577       | some baseStructName <span class="constant">=&gt;</span>
9578         <span class="keyword">if</span> baseStructName <span class="constant">==</span> s.structName <span class="keyword">then</span> pure field
9579         <span class="keyword">else</span> <span class="keyword">match</span> getPathToBaseStructure? env baseStructName s.structName <span class="keyword">with</span>
9580           | some path <span class="constant">=&gt;</span> <span class="keyword">do</span>
9581             <span class="keyword">let</span> path <span class="constant">:=</span> path.map <span class="keyword">fun</span> funName <span class="constant">=&gt;</span> <span class="keyword">match</span> funName <span class="keyword">with</span>
9582               | Name.str <span class="preprocessor">_</span> s <span class="preprocessor">_</span> <span class="constant">=&gt;</span> FieldLHS.fieldName ref (Name.mkSimple s)
9583               | <span class="preprocessor">_</span>              <span class="constant">=&gt;</span> <span class="warning">unreachable</span><span class="constant">!</span>
9584             pure { field <span class="keyword">with</span> lhs <span class="constant">:=</span> path <span class="constant">++</span> field.lhs }
9585           | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwErrorAt ref <span class="string">"failed to access field '{fieldName}' in parent structure"</span>
9586     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> pure field
9587 
<span class="keyword">9588 private</span> <span class="keyword">abbrev</span> FieldMap <span class="constant">:=</span> HashMap Name Fields
9589 
<span class="keyword">9590 private</span> <span class="keyword">def</span> <span class="function-name">mkFieldMap</span> (fields : Fields) : TermElabM FieldMap <span class="constant">:=</span>
9591   fields.foldlM (init <span class="constant">:=</span> {}) <span class="keyword">fun</span> fieldMap field <span class="constant">=&gt;</span>
9592     <span class="keyword">match</span> field.lhs <span class="keyword">with</span>
9593     | FieldLHS.fieldName <span class="preprocessor">_</span> fieldName :: rest <span class="constant">=&gt;</span>
9594       <span class="keyword">match</span> fieldMap.find? fieldName <span class="keyword">with</span>
9595       | some (prevField::restFields) <span class="constant">=&gt;</span>
9596         <span class="keyword">if</span> field.isSimple <span class="constant">||</span> prevField.isSimple <span class="keyword">then</span>
9597           throwErrorAt field.ref <span class="string">"field '{fieldName}' has already beed specified"</span>
9598         <span class="keyword">else</span>
9599           <span class="keyword">return</span> fieldMap.insert fieldName (field::prevField::restFields)
9600       | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">return</span> fieldMap.insert fieldName [field]
9601     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="warning">unreachable</span><span class="constant">!</span>
9602 
<span class="keyword">9603 private</span> <span class="keyword">def</span> <span class="function-name">isSimpleField?</span> : Fields <span class="constant">&#8594;</span> Option (Field Struct)
9604   | [field] <span class="constant">=&gt;</span> <span class="keyword">if</span> field.isSimple <span class="keyword">then</span> some field <span class="keyword">else</span> none
9605   | <span class="preprocessor">_</span>       <span class="constant">=&gt;</span> none
9606 
<span class="keyword">9607 private</span> <span class="keyword">def</span> <span class="function-name">getFieldIdx</span> (structName : Name) (fieldNames : Array Name) (fieldName : Name) : TermElabM Nat <span class="constant">:=</span> <span class="keyword">do</span>
9608   <span class="keyword">match</span> fieldNames.findIdx? <span class="keyword">fun</span> n <span class="constant">=&gt;</span> n <span class="constant">==</span> fieldName <span class="keyword">with</span>
9609   | some idx <span class="constant">=&gt;</span> pure idx
9610   | none     <span class="constant">=&gt;</span> throwError <span class="string">"field '{fieldName}' is not a valid field of '{structName}'"</span>
9611 
<span class="keyword">9612 private</span> <span class="keyword">def</span> <span class="function-name">mkProjStx</span> (s : Syntax) (fieldName : Name) : Syntax <span class="constant">:=</span>
9613   Syntax.node `Lean.Parser.Term.proj <span class="constant">#</span>[s, mkAtomFrom s <span class="string">"."</span>, mkIdentFrom s fieldName]
9614 
<span class="keyword">9615 private</span> <span class="keyword">def</span> <span class="function-name">mkSubstructSource</span> (structName : Name) (fieldNames : Array Name) (fieldName : Name) (src : Source) : TermElabM Source <span class="constant">:=</span>
9616   <span class="keyword">match</span> src <span class="keyword">with</span>
9617   | Source.explicit stx src <span class="constant">=&gt;</span> <span class="keyword">do</span>
9618     <span class="keyword">let</span> idx &#8592; getFieldIdx structName fieldNames fieldName
9619     <span class="keyword">let</span> stx <span class="constant">:=</span> stx.modifyArg <span class="constant">0</span> <span class="keyword">fun</span> stx <span class="constant">=&gt;</span> mkProjStx stx fieldName
9620     <span class="keyword">return</span> Source.explicit stx (mkProj structName idx src)
9621   | s <span class="constant">=&gt;</span> <span class="keyword">return</span> s
9622 
<span class="doc">9623 @[specialize]</span> <span class="keyword">private</span> <span class="keyword">def</span> <span class="function-name">groupFields</span> (expandStruct : Struct <span class="constant">&#8594;</span> TermElabM Struct) (s : Struct) : TermElabM Struct <span class="constant">:=</span> <span class="keyword">do</span>
9624   <span class="keyword">let</span> env &#8592; getEnv
9625   <span class="keyword">let</span> fieldNames <span class="constant">:=</span> getStructureFields env s.structName
9626   withRef s.ref <span class="keyword">do</span>
9627   s.modifyFieldsM <span class="keyword">fun</span> fields <span class="constant">=&gt;</span> <span class="keyword">do</span>
9628     <span class="keyword">let</span> fieldMap &#8592; mkFieldMap fields
9629     fieldMap.toList.mapM <span class="keyword">fun</span> &#10216;fieldName, fields&#10217; <span class="constant">=&gt;</span> <span class="keyword">do</span>
9630       <span class="keyword">match</span> isSimpleField? fields <span class="keyword">with</span>
9631       | some field <span class="constant">=&gt;</span> pure field
9632       | none <span class="constant">=&gt;</span>
9633         <span class="keyword">let</span> substructFields <span class="constant">:=</span> fields.map <span class="keyword">fun</span> field <span class="constant">=&gt;</span> { field <span class="keyword">with</span> lhs <span class="constant">:=</span> field.lhs.tail<span class="constant">!</span> }
9634         <span class="keyword">let</span> substructSource &#8592; mkSubstructSource s.structName fieldNames fieldName s.source
9635         <span class="keyword">let</span> field <span class="constant">:=</span> fields.head<span class="constant">!</span>
9636         <span class="keyword">match</span> Lean.isSubobjectField? env s.structName fieldName <span class="keyword">with</span>
9637         | some substructName <span class="constant">=&gt;</span>
9638           <span class="keyword">let</span> substruct <span class="constant">:=</span> Struct.mk s.ref substructName substructFields substructSource
9639           <span class="keyword">let</span> substruct &#8592; expandStruct substruct
9640           pure { field <span class="keyword">with</span> lhs <span class="constant">:=</span> [field.lhs.head<span class="constant">!</span>], val <span class="constant">:=</span> FieldVal.nested substruct }
9641         | none <span class="constant">=&gt;</span> <span class="keyword">do</span>
9642           <span class="comment-delimiter">-- </span><span class="comment">It is not a substructure field. Thus, we wrap fields using `Syntax`, and use `elabTerm` to process them.
</span>9643           <span class="keyword">let</span> valStx <span class="constant">:=</span> s.ref <span class="comment-delimiter">-- </span><span class="comment">construct substructure syntax using s.ref as template
</span>9644           <span class="keyword">let</span> valStx <span class="constant">:=</span> valStx.setArg <span class="constant">4</span> mkNullNode <span class="comment-delimiter">-- </span><span class="comment">erase optional expected type
</span>9645           <span class="keyword">let</span> args   <span class="constant">:=</span> substructFields.toArray.map <span class="keyword">fun</span> field <span class="constant">=&gt;</span> mkNullNode <span class="constant">#</span>[field.toSyntax, mkNullNode]
9646           <span class="keyword">let</span> valStx <span class="constant">:=</span> valStx.setArg <span class="constant">2</span> (mkNullNode args)
9647           <span class="keyword">let</span> valStx <span class="constant">:=</span> setStructSourceSyntax valStx substructSource
9648           pure { field <span class="keyword">with</span> lhs <span class="constant">:=</span> [field.lhs.head<span class="constant">!</span>], val <span class="constant">:=</span> FieldVal.term valStx }
9649 
<span class="keyword">9650 def</span> <span class="function-name">findField?</span> (fields : Fields) (fieldName : Name) : Option (Field Struct) <span class="constant">:=</span>
9651   fields.find? <span class="keyword">fun</span> field <span class="constant">=&gt;</span>
9652     <span class="keyword">match</span> field.lhs <span class="keyword">with</span>
9653     | [FieldLHS.fieldName <span class="preprocessor">_</span> n] <span class="constant">=&gt;</span> n <span class="constant">==</span> fieldName
9654     | <span class="preprocessor">_</span>                        <span class="constant">=&gt;</span> false
9655 
<span class="doc">9656 @[specialize]</span> <span class="keyword">private</span> <span class="keyword">def</span> <span class="function-name">addMissingFields</span> (expandStruct : Struct <span class="constant">&#8594;</span> TermElabM Struct) (s : Struct) : TermElabM Struct <span class="constant">:=</span> <span class="keyword">do</span>
9657   <span class="keyword">let</span> env &#8592; getEnv
9658   <span class="keyword">let</span> fieldNames <span class="constant">:=</span> getStructureFields env s.structName
9659   <span class="keyword">let</span> ref <span class="constant">:=</span> s.ref
9660   withRef ref <span class="keyword">do</span>
9661     <span class="keyword">let</span> fields &#8592; fieldNames.foldlM (init <span class="constant">:=</span> []) <span class="keyword">fun</span> fields fieldName <span class="constant">=&gt;</span> <span class="keyword">do</span>
9662       <span class="keyword">match</span> findField? s.fields fieldName <span class="keyword">with</span>
9663       | some field <span class="constant">=&gt;</span> <span class="keyword">return</span> field::fields
9664       | none       <span class="constant">=&gt;</span>
9665         <span class="keyword">let</span> addField (val : FieldVal Struct) : TermElabM Fields <span class="constant">:=</span> <span class="keyword">do</span>
9666           <span class="keyword">return</span> { ref <span class="constant">:=</span> s.ref, lhs <span class="constant">:=</span> [FieldLHS.fieldName s.ref fieldName], val <span class="constant">:=</span> val } :: fields
9667         <span class="keyword">match</span> Lean.isSubobjectField? env s.structName fieldName <span class="keyword">with</span>
9668         | some substructName <span class="constant">=&gt;</span> <span class="keyword">do</span>
9669           <span class="keyword">let</span> substructSource &#8592; mkSubstructSource s.structName fieldNames fieldName s.source
9670           <span class="keyword">let</span> substruct <span class="constant">:=</span> Struct.mk s.ref substructName [] substructSource
9671           <span class="keyword">let</span> substruct &#8592; expandStruct substruct
9672           addField (FieldVal.nested substruct)
9673         | none <span class="constant">=&gt;</span>
9674           <span class="keyword">match</span> s.source <span class="keyword">with</span>
9675           | Source.none           <span class="constant">=&gt;</span> addField FieldVal.default
9676           | Source.implicit <span class="preprocessor">_</span>     <span class="constant">=&gt;</span> addField (FieldVal.term (mkHole s.ref))
9677           | Source.explicit stx <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
9678             <span class="comment-delimiter">-- </span><span class="comment">stx is of the form `optional (try (termParser &gt;&gt; "with"))`
</span>9679             <span class="keyword">let</span> src <span class="constant">:=</span> stx[<span class="constant">0</span>]
9680             <span class="keyword">let</span> val <span class="constant">:=</span> mkProjStx src fieldName
9681             addField (FieldVal.term val)
9682     <span class="keyword">return</span> s.setFields fields.reverse
9683 
<span class="keyword">9684 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">expandStruct</span> (s : Struct) : TermElabM Struct <span class="constant">:=</span> <span class="keyword">do</span>
9685   <span class="keyword">let</span> s <span class="constant">:=</span> expandCompositeFields s
9686   <span class="keyword">let</span> s &#8592; expandNumLitFields s
9687   <span class="keyword">let</span> s &#8592; expandParentFields s
9688   <span class="keyword">let</span> s &#8592; groupFields expandStruct s
9689   addMissingFields expandStruct s
9690 
<span class="keyword">9691 structure</span> <span class="function-name">CtorHeaderResult</span> <span class="keyword">where</span>
9692   ctorFn     : Expr
9693   ctorFnType : Expr
9694   instMVars  : Array MVarId <span class="constant">:=</span> <span class="constant">#</span>[]
9695 
<span class="keyword">9696 private</span> <span class="keyword">def</span> <span class="function-name">mkCtorHeaderAux</span> : Nat <span class="constant">&#8594;</span> Expr <span class="constant">&#8594;</span> Expr <span class="constant">&#8594;</span> Array MVarId <span class="constant">&#8594;</span> TermElabM CtorHeaderResult
9697   | <span class="constant">0</span>,   type, ctorFn, instMVars <span class="constant">=&gt;</span> pure { ctorFn <span class="constant">:=</span> ctorFn, ctorFnType <span class="constant">:=</span> type, instMVars <span class="constant">:=</span> instMVars }
9698   | n<span class="constant">+1</span>, type, ctorFn, instMVars <span class="constant">=&gt;</span> <span class="keyword">do</span>
9699     <span class="keyword">let</span> type &#8592; whnfForall type
9700     <span class="keyword">match</span> type <span class="keyword">with</span>
9701     | Expr.forallE <span class="preprocessor">_</span> d b c <span class="constant">=&gt;</span>
9702       <span class="keyword">match</span> c.binderInfo <span class="keyword">with</span>
9703       | BinderInfo.instImplicit <span class="constant">=&gt;</span>
9704         <span class="keyword">let</span> a &#8592; mkFreshExprMVar d MetavarKind.synthetic
9705         mkCtorHeaderAux n (b.instantiate1 a) (mkApp ctorFn a) (instMVars.push a.mvarId<span class="constant">!</span>)
9706       | <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
9707         <span class="keyword">let</span> a &#8592; mkFreshExprMVar d
9708         mkCtorHeaderAux n (b.instantiate1 a) (mkApp ctorFn a) instMVars
9709     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwError <span class="string">"unexpected constructor type"</span>
9710 
<span class="keyword">9711 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">getForallBody</span> : Nat <span class="constant">&#8594;</span> Expr <span class="constant">&#8594;</span> Option Expr
9712   | i<span class="constant">+1</span>, Expr.forallE <span class="preprocessor">_</span> <span class="preprocessor">_</span> b <span class="preprocessor">_</span> <span class="constant">=&gt;</span> getForallBody i b
9713   | i<span class="constant">+1</span>, <span class="preprocessor">_</span>                    <span class="constant">=&gt;</span> none
9714   | <span class="constant">0</span>,   type                 <span class="constant">=&gt;</span> type
9715 
<span class="keyword">9716 private</span> <span class="keyword">def</span> <span class="function-name">propagateExpectedType</span> (type : Expr) (numFields : Nat) (expectedType? : Option Expr) : TermElabM Unit <span class="constant">:=</span>
9717   <span class="keyword">match</span> expectedType? <span class="keyword">with</span>
9718   | none              <span class="constant">=&gt;</span> pure ()
9719   | some expectedType <span class="constant">=&gt;</span> <span class="keyword">do</span>
9720     <span class="keyword">match</span> getForallBody numFields type <span class="keyword">with</span>
9721       | none           <span class="constant">=&gt;</span> pure ()
9722       | some typeBody <span class="constant">=&gt;</span>
9723         <span class="keyword">unless</span> typeBody.hasLooseBVars <span class="keyword">do</span>
9724           discard <span class="constant">&lt;</span>| isDefEq expectedType typeBody
9725 
<span class="keyword">9726 private</span> <span class="keyword">def</span> <span class="function-name">mkCtorHeader</span> (ctorVal : ConstructorVal) (expectedType? : Option Expr) : TermElabM CtorHeaderResult <span class="constant">:=</span> <span class="keyword">do</span>
9727   <span class="keyword">let</span> us &#8592; mkFreshLevelMVars ctorVal.levelParams.length
9728   <span class="keyword">let</span> val  <span class="constant">:=</span> Lean.mkConst ctorVal.name us
9729   <span class="keyword">let</span> type <span class="constant">:=</span> (ConstantInfo.ctorInfo ctorVal).instantiateTypeLevelParams us
9730   <span class="keyword">let</span> r &#8592; mkCtorHeaderAux ctorVal.numParams type val <span class="constant">#</span>[]
9731   propagateExpectedType r.ctorFnType ctorVal.numFields expectedType?
9732   synthesizeAppInstMVars r.instMVars
9733   pure r
9734 
<span class="keyword">9735 def</span> <span class="function-name">markDefaultMissing</span> (e : Expr) : Expr <span class="constant">:=</span>
9736   mkAnnotation `structInstDefault e
9737 
<span class="keyword">9738 def</span> <span class="function-name">defaultMissing?</span> (e : Expr) : Option Expr <span class="constant">:=</span>
9739   annotation? `structInstDefault e
9740 
<span class="keyword">9741 def</span> <span class="function-name">throwFailedToElabField</span> {&#945;} (fieldName : Name) (structName : Name) (msgData : MessageData) : TermElabM &#945; <span class="constant">:=</span>
9742   throwError <span class="string">"failed to elaborate field '{fieldName}' of '{structName}, {msgData}"</span>
9743 
<span class="keyword">9744 def</span> <span class="function-name">trySynthStructInstance?</span> (s : Struct) (expectedType : Expr) : TermElabM (Option Expr) <span class="constant">:=</span> <span class="keyword">do</span>
9745   <span class="keyword">if</span> <span class="constant">!</span>s.allDefault <span class="keyword">then</span>
9746     pure none
9747   <span class="keyword">else</span>
9748     <span class="keyword">try</span> synthInstance? expectedType <span class="keyword">catch</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> pure none
9749 
<span class="keyword">9750 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">elabStruct</span> (s : Struct) (expectedType? : Option Expr) : TermElabM (Expr <span class="constant">&#215;</span> Struct) <span class="constant">:=</span> withRef s.ref <span class="keyword">do</span>
9751   <span class="keyword">let</span> env &#8592; getEnv
9752   <span class="keyword">let</span> ctorVal <span class="constant">:=</span> getStructureCtor env s.structName
9753   <span class="keyword">let</span> { ctorFn <span class="constant">:=</span> ctorFn, ctorFnType <span class="constant">:=</span> ctorFnType, .. } &#8592; mkCtorHeader ctorVal expectedType?
9754   <span class="keyword">let</span> (e, <span class="preprocessor">_</span>, fields) &#8592; s.fields.foldlM (init <span class="constant">:=</span> (ctorFn, ctorFnType, [])) <span class="keyword">fun</span> (e, type, fields) field <span class="constant">=&gt;</span>
9755     <span class="keyword">match</span> field.lhs <span class="keyword">with</span>
9756     | [FieldLHS.fieldName ref fieldName] <span class="constant">=&gt;</span> <span class="keyword">do</span>
9757       <span class="keyword">let</span> type &#8592; whnfForall type
9758       <span class="keyword">match</span> type <span class="keyword">with</span>
9759       | Expr.forallE <span class="preprocessor">_</span> d b c <span class="constant">=&gt;</span>
9760         <span class="keyword">let</span> cont (val : Expr) (field : Field Struct) : TermElabM (Expr <span class="constant">&#215;</span> Expr <span class="constant">&#215;</span> Fields) <span class="constant">:=</span> <span class="keyword">do</span>
9761           pushInfoTree <span class="constant">&lt;</span>| InfoTree.node (children <span class="constant">:=</span> {}) <span class="constant">&lt;</span>| Info.ofFieldInfo { lctx <span class="constant">:=</span> (&#8592; getLCtx), val <span class="constant">:=</span> val, name <span class="constant">:=</span> fieldName, stx <span class="constant">:=</span> ref }
9762           <span class="keyword">let</span> e     <span class="constant">:=</span> mkApp e val
9763           <span class="keyword">let</span> type  <span class="constant">:=</span> b.instantiate1 val
9764           <span class="keyword">let</span> field <span class="constant">:=</span> { field <span class="keyword">with</span> expr? <span class="constant">:=</span> some val }
9765           pure (e, type, field::fields)
9766         <span class="keyword">match</span> field.val <span class="keyword">with</span>
9767         | FieldVal.term stx <span class="constant">=&gt;</span> cont (&#8592; elabTermEnsuringType stx d) field
9768         | FieldVal.nested s <span class="constant">=&gt;</span> <span class="keyword">do</span>
9769           <span class="comment-delimiter">-- </span><span class="comment">if all fields of `s` are marked as `default`, then try to synthesize instance
</span>9770           <span class="keyword">match</span> (&#8592; trySynthStructInstance? s d) <span class="keyword">with</span>
9771           | some val <span class="constant">=&gt;</span> cont val { field <span class="keyword">with</span> val <span class="constant">:=</span> FieldVal.term (mkHole field.ref) }
9772           | none     <span class="constant">=&gt;</span> <span class="keyword">do</span> <span class="keyword">let</span> (val, sNew) &#8592; elabStruct s (some d); <span class="keyword">let</span> val &#8592; ensureHasType d val; cont val { field <span class="keyword">with</span> val <span class="constant">:=</span> FieldVal.nested sNew }
9773         | FieldVal.default  <span class="constant">=&gt;</span> <span class="keyword">do</span> <span class="keyword">let</span> val &#8592; withRef field.ref <span class="constant">&lt;</span>| mkFreshExprMVar (some d); cont (markDefaultMissing val) field
9774       | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> withRef field.ref <span class="constant">&lt;</span>| throwFailedToElabField fieldName s.structName m<span class="constant">!</span><span class="string">"unexpected constructor type{indentExpr type}"</span>
9775     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwErrorAt field.ref <span class="string">"unexpected unexpanded structure field"</span>
9776   pure (e, s.setFields fields.reverse)
9777 
<span class="keyword">9778 namespace</span> DefaultFields
9779 
<span class="keyword">9780 structure</span> <span class="function-name">Context</span> <span class="keyword">where</span>
9781   <span class="comment-delimiter">-- </span><span class="comment">We must search for default values overriden in derived structures
</span>9782   structs : Array Struct <span class="constant">:=</span> <span class="constant">#</span>[]
9783   allStructNames : Array Name <span class="constant">:=</span> <span class="constant">#</span>[]
9784   <span class="comment-delimiter">/-</span><span class="comment">-
9785   Consider the following example:
9786   ```
9787   structure A where
9788     x : Nat := 1
9789 
9790   structure B extends A where
9791     y : Nat := x + 1
9792     x := y + 1
9793 
9794   structure C extends B where
9795     z : Nat := 2*y
9796     x := z + 3
9797   ```
9798   And we are trying to elaborate a structure instance for `C`. There are default values for `x` at `A`, `B`, and `C`.
9799   We say the default value at `C` has distance 0, the one at `B` distance 1, and the one at `A` distance 2.
9800   The field `maxDistance` specifies the maximum distance considered in a round of Default field computation.
9801   Remark: since `C` does not set a default value of `y`, the default value at `B` is at distance 0.
9802 
9803   The fixpoint for setting default values works in the following way.
9804   - Keep computing default values using `maxDistance == 0`.
9805   - We increase `maxDistance` whenever we failed to compute a new default value in a round.
9806   - If `maxDistance &gt; 0`, then we interrupt a round as soon as we compute some default value.
9807     We use depth-first search.
9808   - We sign an error if no progress is made when `maxDistance` == structure hierarchy depth (2 in the example above).
9809   -/</span>
9810   maxDistance : Nat <span class="constant">:=</span> <span class="constant">0</span>
9811 
<span class="keyword">9812 structure</span> <span class="function-name">State</span> <span class="keyword">where</span>
9813   progress : Bool <span class="constant">:=</span> false
9814 
<span class="keyword">9815 partial</span> <span class="keyword">def</span> <span class="function-name">collectStructNames</span> (struct : Struct) (names : Array Name) : Array Name <span class="constant">:=</span>
9816   <span class="keyword">let</span> names <span class="constant">:=</span> names.push struct.structName
9817   struct.fields.foldl (init <span class="constant">:=</span> names) <span class="keyword">fun</span> names field <span class="constant">=&gt;</span>
9818     <span class="keyword">match</span> field.val <span class="keyword">with</span>
9819     | FieldVal.nested struct <span class="constant">=&gt;</span> collectStructNames struct names
9820     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> names
9821 
<span class="keyword">9822 partial</span> <span class="keyword">def</span> <span class="function-name">getHierarchyDepth</span> (struct : Struct) : Nat <span class="constant">:=</span>
9823   struct.fields.foldl (init <span class="constant">:=</span> <span class="constant">0</span>) <span class="keyword">fun</span> max field <span class="constant">=&gt;</span>
9824     <span class="keyword">match</span> field.val <span class="keyword">with</span>
9825     | FieldVal.nested struct <span class="constant">=&gt;</span> Nat.max max (getHierarchyDepth struct <span class="constant">+</span> <span class="constant">1</span>)
9826     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> max
9827 
<span class="keyword">9828 partial</span> <span class="keyword">def</span> <span class="function-name">findDefaultMissing?</span> (mctx : MetavarContext) (struct : Struct) : Option (Field Struct) <span class="constant">:=</span>
9829   struct.fields.findSome? <span class="keyword">fun</span> field <span class="constant">=&gt;</span>
9830    <span class="keyword">match</span> field.val <span class="keyword">with</span>
9831    | FieldVal.nested struct <span class="constant">=&gt;</span> findDefaultMissing? mctx struct
9832    | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">match</span> field.expr? <span class="keyword">with</span>
9833      | none      <span class="constant">=&gt;</span> <span class="warning">unreachable</span><span class="constant">!</span>
9834      | some expr <span class="constant">=&gt;</span> <span class="keyword">match</span> defaultMissing? expr <span class="keyword">with</span>
9835        | some (Expr.mvar mvarId <span class="preprocessor">_</span>) <span class="constant">=&gt;</span> <span class="keyword">if</span> mctx.isExprAssigned mvarId <span class="keyword">then</span> none <span class="keyword">else</span> some field
9836        | <span class="preprocessor">_</span>                         <span class="constant">=&gt;</span> none
9837 
<span class="keyword">9838 def</span> <span class="function-name">getFieldName</span> (field : Field Struct) : Name <span class="constant">:=</span>
9839   <span class="keyword">match</span> field.lhs <span class="keyword">with</span>
9840   | [FieldLHS.fieldName <span class="preprocessor">_</span> fieldName] <span class="constant">=&gt;</span> fieldName
9841   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="warning">unreachable</span><span class="constant">!</span>
9842 
<span class="keyword">9843 abbrev</span> M <span class="constant">:=</span> ReaderT Context (StateRefT State TermElabM)
9844 
<span class="keyword">9845 def</span> <span class="function-name">isRoundDone</span> : M Bool <span class="constant">:=</span> <span class="keyword">do</span>
9846   <span class="keyword">return</span> (&#8592; get).progress <span class="constant">&amp;&amp;</span> (&#8592; read).maxDistance <span class="constant">&gt;</span> <span class="constant">0</span>
9847 
<span class="keyword">9848 def</span> <span class="function-name">getFieldValue?</span> (struct : Struct) (fieldName : Name) : Option Expr <span class="constant">:=</span>
9849   struct.fields.findSome? <span class="keyword">fun</span> field <span class="constant">=&gt;</span>
9850     <span class="keyword">if</span> getFieldName field <span class="constant">==</span> fieldName <span class="keyword">then</span>
9851       field.expr?
9852     <span class="keyword">else</span>
9853       none
9854 
<span class="keyword">9855 partial</span> <span class="keyword">def</span> <span class="function-name">mkDefaultValueAux?</span> (struct : Struct) : Expr <span class="constant">&#8594;</span> TermElabM (Option Expr)
9856   | Expr.lam n d b c <span class="constant">=&gt;</span> withRef struct.ref <span class="keyword">do</span>
9857     <span class="keyword">if</span> c.binderInfo.isExplicit <span class="keyword">then</span>
9858       <span class="keyword">let</span> fieldName <span class="constant">:=</span> n
9859       <span class="keyword">match</span> getFieldValue? struct fieldName <span class="keyword">with</span>
9860       | none     <span class="constant">=&gt;</span> pure none
9861       | some val <span class="constant">=&gt;</span>
9862         <span class="keyword">let</span> valType &#8592; inferType val
9863         <span class="keyword">if</span> (&#8592; isDefEq valType d) <span class="keyword">then</span>
9864           mkDefaultValueAux? struct (b.instantiate1 val)
9865         <span class="keyword">else</span>
9866           pure none
9867     <span class="keyword">else</span>
9868       <span class="keyword">let</span> arg &#8592; mkFreshExprMVar d
9869       mkDefaultValueAux? struct (b.instantiate1 arg)
9870   | e <span class="constant">=&gt;</span>
9871     <span class="keyword">if</span> e.isAppOfArity `id <span class="constant">2</span> <span class="keyword">then</span>
9872       pure (some e.appArg<span class="constant">!</span>)
9873     <span class="keyword">else</span>
9874       pure (some e)
9875 
<span class="keyword">9876 def</span> <span class="function-name">mkDefaultValue?</span> (struct : Struct) (cinfo : ConstantInfo) : TermElabM (Option Expr) <span class="constant">:=</span>
9877   withRef struct.ref <span class="keyword">do</span>
9878   <span class="keyword">let</span> us &#8592; mkFreshLevelMVarsFor cinfo
9879   mkDefaultValueAux? struct (cinfo.instantiateValueLevelParams us)
9880 
<span class="comment-delimiter">9881 /-</span><span class="comment">- If `e` is a projection function of one of the given structures, then reduce it -/</span>
<span class="keyword">9882 def</span> <span class="function-name">reduceProjOf?</span> (structNames : Array Name) (e : Expr) : MetaM (Option Expr) <span class="constant">:=</span> <span class="keyword">do</span>
9883   <span class="keyword">if</span> <span class="constant">!</span>e.isApp <span class="keyword">then</span> pure none
9884   <span class="keyword">else</span> <span class="keyword">match</span> e.getAppFn <span class="keyword">with</span>
9885     | Expr.const name <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">do</span>
9886       <span class="keyword">let</span> env &#8592; getEnv
9887       <span class="keyword">match</span> env.getProjectionStructureName? name <span class="keyword">with</span>
9888       | some structName <span class="constant">=&gt;</span>
9889         <span class="keyword">if</span> structNames.contains structName <span class="keyword">then</span>
9890           Meta.unfoldDefinition? e
9891         <span class="keyword">else</span>
9892           pure none
9893       | none <span class="constant">=&gt;</span> pure none
9894     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> pure none
9895 
<span class="comment-delimiter">9896 /-</span><span class="comment">- Reduce default value. It performs beta reduction and projections of the given structures. -/</span>
<span class="keyword">9897 partial</span> <span class="keyword">def</span> <span class="function-name">reduce</span> (structNames : Array Name) : Expr <span class="constant">&#8594;</span> MetaM Expr
9898   | e<span class="constant">@</span>(Expr.lam <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="preprocessor">_</span>)     <span class="constant">=&gt;</span> lambdaLetTelescope e <span class="keyword">fun</span> xs b <span class="constant">=&gt;</span> <span class="keyword">do</span> mkLambdaFVars xs (&#8592; reduce structNames b)
9899   | e<span class="constant">@</span>(Expr.forallE <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="preprocessor">_</span>) <span class="constant">=&gt;</span> forallTelescope e <span class="keyword">fun</span> xs b <span class="constant">=&gt;</span> <span class="keyword">do</span> mkForallFVars xs (&#8592; reduce structNames b)
9900   | e<span class="constant">@</span>(Expr.letE <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="preprocessor">_</span>)  <span class="constant">=&gt;</span> lambdaLetTelescope e <span class="keyword">fun</span> xs b <span class="constant">=&gt;</span> <span class="keyword">do</span> mkLetFVars xs (&#8592; reduce structNames b)
9901   | e<span class="constant">@</span>(Expr.proj <span class="preprocessor">_</span> i b <span class="preprocessor">_</span>)    <span class="constant">=&gt;</span> <span class="keyword">do</span>
9902     <span class="keyword">match</span> (&#8592; Meta.project? b i) <span class="keyword">with</span>
9903     | some r <span class="constant">=&gt;</span> reduce structNames r
9904     | none   <span class="constant">=&gt;</span> <span class="keyword">return</span> e.updateProj<span class="constant">!</span> (&#8592; reduce structNames b)
9905   | e<span class="constant">@</span>(Expr.app f <span class="preprocessor">_</span> <span class="preprocessor">_</span>) <span class="constant">=&gt;</span> <span class="keyword">do</span>
9906     <span class="keyword">match</span> (&#8592; reduceProjOf? structNames e) <span class="keyword">with</span>
9907     | some r <span class="constant">=&gt;</span> reduce structNames r
9908     | none   <span class="constant">=&gt;</span>
9909       <span class="keyword">let</span> f <span class="constant">:=</span> f.getAppFn
9910       <span class="keyword">let</span> f' &#8592; reduce structNames f
9911       <span class="keyword">if</span> f'.isLambda <span class="keyword">then</span>
9912         <span class="keyword">let</span> revArgs <span class="constant">:=</span> e.getAppRevArgs
9913         reduce structNames (f'.betaRev revArgs)
9914       <span class="keyword">else</span>
9915         <span class="keyword">let</span> args &#8592; e.getAppArgs.mapM (reduce structNames)
9916         <span class="keyword">return</span> (mkAppN f' args)
9917   | e<span class="constant">@</span>(Expr.mdata <span class="preprocessor">_</span> b <span class="preprocessor">_</span>) <span class="constant">=&gt;</span> <span class="keyword">do</span>
9918     <span class="keyword">let</span> b &#8592; reduce structNames b
9919     <span class="keyword">if</span> (defaultMissing? e).isSome <span class="constant">&amp;&amp;</span> <span class="constant">!</span>b.isMVar <span class="keyword">then</span>
9920       <span class="keyword">return</span> b
9921     <span class="keyword">else</span>
9922       <span class="keyword">return</span> e.updateMData<span class="constant">!</span> b
9923   | e<span class="constant">@</span>(Expr.mvar mvarId <span class="preprocessor">_</span>) <span class="constant">=&gt;</span> <span class="keyword">do</span>
9924     <span class="keyword">match</span> (&#8592; getExprMVarAssignment? mvarId) <span class="keyword">with</span>
9925     | some val <span class="constant">=&gt;</span> <span class="keyword">if</span> val.isMVar <span class="keyword">then</span> reduce structNames val <span class="keyword">else</span> pure val
9926     | none     <span class="constant">=&gt;</span> <span class="keyword">return</span> e
9927   | e <span class="constant">=&gt;</span> <span class="keyword">return</span> e
9928 
<span class="keyword">9929 partial</span> <span class="keyword">def</span> <span class="function-name">tryToSynthesizeDefault</span> (structs : Array Struct) (allStructNames : Array Name) (maxDistance : Nat) (fieldName : Name) (mvarId : MVarId) : TermElabM Bool <span class="constant">:=</span>
9930   <span class="keyword">let</span> <span class="keyword">rec</span> loop (i : Nat) (dist : Nat) <span class="constant">:=</span> <span class="keyword">do</span>
9931     <span class="keyword">if</span> dist <span class="constant">&gt;</span> maxDistance <span class="keyword">then</span>
9932       pure false
9933     <span class="keyword">else</span> <span class="keyword">if</span> h : i <span class="constant">&lt;</span> structs.size <span class="keyword">then</span> <span class="keyword">do</span>
9934       <span class="keyword">let</span> struct <span class="constant">:=</span> structs.get &#10216;i, h&#10217;
9935       <span class="keyword">let</span> defaultName <span class="constant">:=</span> struct.structName <span class="constant">++</span> fieldName <span class="constant">++</span> `_default
9936       <span class="keyword">let</span> env &#8592; getEnv
9937       <span class="keyword">match</span> env.find? defaultName <span class="keyword">with</span>
9938       | some cinfo<span class="constant">@</span>(ConstantInfo.defnInfo defVal) <span class="constant">=&gt;</span> <span class="keyword">do</span>
9939         <span class="keyword">let</span> mctx &#8592; getMCtx
9940         <span class="keyword">let</span> val? &#8592; mkDefaultValue? struct cinfo
9941         <span class="keyword">match</span> val? <span class="keyword">with</span>
9942         | none     <span class="constant">=&gt;</span> <span class="keyword">do</span> setMCtx mctx; loop (i<span class="constant">+1</span>) (dist<span class="constant">+1</span>)
9943         | some val <span class="constant">=&gt;</span> <span class="keyword">do</span>
9944           <span class="keyword">let</span> val &#8592; reduce allStructNames val
9945           <span class="keyword">match</span> val.find? <span class="keyword">fun</span> e <span class="constant">=&gt;</span> (defaultMissing? e).isSome <span class="keyword">with</span>
9946           | some <span class="preprocessor">_</span> <span class="constant">=&gt;</span> setMCtx mctx; loop (i<span class="constant">+1</span>) (dist<span class="constant">+1</span>)
9947           | none   <span class="constant">=&gt;</span>
9948             <span class="keyword">let</span> mvarDecl &#8592; getMVarDecl mvarId
9949             <span class="keyword">let</span> val &#8592; ensureHasType mvarDecl.type val
9950             assignExprMVar mvarId val
9951             pure true
9952       | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> loop (i<span class="constant">+1</span>) dist
9953     <span class="keyword">else</span>
9954       pure false
9955   loop <span class="constant">0</span> <span class="constant">0</span>
9956 
<span class="keyword">9957 partial</span> <span class="keyword">def</span> <span class="function-name">step</span> (struct : Struct) : M Unit <span class="constant">:=</span>
9958   <span class="keyword">unless</span> (&#8592; isRoundDone) <span class="keyword">do</span>
9959     withReader (<span class="keyword">fun</span> ctx <span class="constant">=&gt;</span> { ctx <span class="keyword">with</span> structs <span class="constant">:=</span> ctx.structs.push struct }) <span class="keyword">do</span>
9960       <span class="keyword">for</span> field <span class="keyword">in</span> struct.fields <span class="keyword">do</span>
9961         <span class="keyword">match</span> field.val <span class="keyword">with</span>
9962         | FieldVal.nested struct <span class="constant">=&gt;</span> step struct
9963         | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">match</span> field.expr? <span class="keyword">with</span>
9964           | none      <span class="constant">=&gt;</span> <span class="warning">unreachable</span><span class="constant">!</span>
9965           | some expr <span class="constant">=&gt;</span> <span class="keyword">match</span> defaultMissing? expr <span class="keyword">with</span>
9966             | some (Expr.mvar mvarId <span class="preprocessor">_</span>) <span class="constant">=&gt;</span>
9967               <span class="keyword">unless</span> (&#8592; isExprMVarAssigned mvarId) <span class="keyword">do</span>
9968                 <span class="keyword">let</span> ctx &#8592; read
9969                 <span class="keyword">if</span> (&#8592; withRef field.ref <span class="constant">&lt;</span>| tryToSynthesizeDefault ctx.structs ctx.allStructNames ctx.maxDistance (getFieldName field) mvarId) <span class="keyword">then</span>
9970                   modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> progress <span class="constant">:=</span> true }
9971             | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> pure ()
9972 
<span class="keyword">9973 partial</span> <span class="keyword">def</span> <span class="function-name">propagateLoop</span> (hierarchyDepth : Nat) (d : Nat) (struct : Struct) : M Unit <span class="constant">:=</span> <span class="keyword">do</span>
9974   <span class="keyword">match</span> findDefaultMissing? (&#8592; getMCtx) struct <span class="keyword">with</span>
9975   | none       <span class="constant">=&gt;</span> pure () <span class="comment-delimiter">-- </span><span class="comment">Done
</span>9976   | some field <span class="constant">=&gt;</span>
9977     <span class="keyword">if</span> d <span class="constant">&gt;</span> hierarchyDepth <span class="keyword">then</span>
9978       throwErrorAt field.ref <span class="string">"field '{getFieldName field}' is missing"</span>
9979     <span class="keyword">else</span> withReader (<span class="keyword">fun</span> ctx <span class="constant">=&gt;</span> { ctx <span class="keyword">with</span> maxDistance <span class="constant">:=</span> d }) <span class="keyword">do</span>
9980       modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> progress <span class="constant">:=</span> false }
9981       step struct
9982       <span class="keyword">if</span> (&#8592; get).progress <span class="keyword">then</span> <span class="keyword">do</span>
9983         propagateLoop hierarchyDepth <span class="constant">0</span> struct
9984       <span class="keyword">else</span>
9985         propagateLoop hierarchyDepth (d<span class="constant">+1</span>) struct
9986 
<span class="keyword">9987 def</span> <span class="function-name">propagate</span> (struct : Struct) : TermElabM Unit <span class="constant">:=</span>
9988   <span class="keyword">let</span> hierarchyDepth <span class="constant">:=</span> getHierarchyDepth struct
9989   <span class="keyword">let</span> structNames <span class="constant">:=</span> collectStructNames struct <span class="constant">#</span>[]
9990   (propagateLoop hierarchyDepth <span class="constant">0</span> struct { allStructNames <span class="constant">:=</span> structNames }).run' {}
9991 
<span class="keyword">9992 end</span> DefaultFields
9993 
<span class="keyword">9994 private</span> <span class="keyword">def</span> <span class="function-name">elabStructInstAux</span> (stx : Syntax) (expectedType? : Option Expr) (source : Source) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
9995   <span class="keyword">let</span> (structName, structType) &#8592; getStructName stx expectedType? source
9996   <span class="keyword">unless</span> isStructureLike (&#8592; getEnv) structName <span class="keyword">do</span>
9997     throwError <span class="string">"invalid \{...} notation, structure type expected{indentExpr structType}"</span>
9998   <span class="keyword">match</span> mkStructView stx structName source <span class="keyword">with</span>
9999   | Except.error ex  <span class="constant">=&gt;</span> throwError ex
10000   | Except.ok struct <span class="constant">=&gt;</span>
10001     <span class="keyword">let</span> struct &#8592; expandStruct struct
10002     trace[Elab.struct] <span class="string">"{struct}"</span>
10003     <span class="keyword">let</span> (r, struct) &#8592; elabStruct struct expectedType?
10004     DefaultFields.propagate struct
10005     pure r
10006 
<span class="doc">10007 @[builtinTermElab structInst]</span> <span class="keyword">def</span> <span class="function-name">elabStructInst</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span> <span class="keyword">do</span>
10008   <span class="keyword">match</span> (&#8592; expandNonAtomicExplicitSource stx) <span class="keyword">with</span>
10009   | some stxNew <span class="constant">=&gt;</span> withMacroExpansion stx stxNew <span class="constant">&lt;</span>| elabTerm stxNew expectedType?
10010   | none <span class="constant">=&gt;</span>
10011     <span class="keyword">let</span> sourceView &#8592; getStructSource stx
10012     <span class="keyword">match</span> (&#8592; isModifyOp? stx), sourceView <span class="keyword">with</span>
10013     | some modifyOp, Source.explicit source <span class="preprocessor">_</span> <span class="constant">=&gt;</span> elabModifyOp stx modifyOp source expectedType?
10014     | some <span class="preprocessor">_</span>,        <span class="preprocessor">_</span>                        <span class="constant">=&gt;</span> throwError <span class="string">"invalid \{...} notation, explicit source is required when using '[&lt;index&gt;] := &lt;value&gt;'"</span>
10015     | <span class="preprocessor">_</span>,             <span class="preprocessor">_</span>                        <span class="constant">=&gt;</span> elabStructInstAux stx expectedType? sourceView
10016 
<span class="keyword">10017 builtin_initialize</span> registerTraceClass `Elab.struct
10018 
<span class="keyword">10019 end</span> Lean.Elab.Term.StructInst
10020 ::::::::::::::
10021 Elab<span class="constant">/</span>Structure.lean
10022 ::::::::::::::
<span class="comment-delimiter">10023 /-</span><span class="comment">
10024 Copyright (c) 2020 Microsoft Corporation. All rights reserved.
10025 Released under Apache 2.0 license as described in the file LICENSE.
10026 Authors: Leonardo de Moura
10027 -/</span>
<span class="keyword">10028 import</span> Lean.Parser.Command
<span class="keyword">10029 import</span> Lean.Meta.Closure
<span class="keyword">10030 import</span> Lean.Meta.SizeOf
<span class="keyword">10031 import</span> Lean.Elab.Command
<span class="keyword">10032 import</span> Lean.Elab.DeclModifiers
<span class="keyword">10033 import</span> Lean.Elab.DeclUtil
<span class="keyword">10034 import</span> Lean.Elab.Inductive
<span class="keyword">10035 import</span> Lean.Elab.DeclarationRange
10036 
<span class="keyword">10037 namespace</span> Lean.Elab.Command
10038 
<span class="keyword">10039 open</span> Meta
10040 
<span class="comment-delimiter">10041 /- </span><span class="comment">Recall that the `structure command syntax is
10042 ```
10043 leading_parser (structureTk &lt;|&gt; classTk) &gt;&gt; declId &gt;&gt; many Term.bracketedBinder &gt;&gt; optional &#171;</span>extends<span class="comment">&#187; &gt;&gt; Term.optType &gt;&gt; optional (" := " &gt;&gt; optional structCtor &gt;&gt; structFields)
10044 ```
10045 -/</span>
10046 
<span class="keyword">10047 structure</span> <span class="function-name">StructCtorView</span> <span class="keyword">where</span>
10048   ref       : Syntax
10049   modifiers : Modifiers
10050   inferMod  : Bool  <span class="comment-delimiter">-- </span><span class="comment">true if `{}` is used in the constructor declaration
</span>10051   name      : Name
10052   declName  : Name
10053 
<span class="keyword">10054 structure</span> <span class="function-name">StructFieldView</span> <span class="keyword">where</span>
10055   ref        : Syntax
10056   modifiers  : Modifiers
10057   binderInfo : BinderInfo
10058   inferMod   : Bool
10059   declName   : Name
10060   name       : Name
10061   binders    : Syntax
10062   type?      : Option Syntax
10063   value?     : Option Syntax
10064 
<span class="keyword">10065 structure</span> <span class="function-name">StructView</span> <span class="keyword">where</span>
10066   ref               : Syntax
10067   modifiers         : Modifiers
10068   scopeLevelNames   : List Name  <span class="comment-delimiter">-- </span><span class="comment">All `universe` declarations in the current scope
</span>10069   allUserLevelNames : List Name  <span class="comment-delimiter">-- </span><span class="comment">`scopeLevelNames` ++ explicit universe parameters provided in the `structure` command
</span>10070   isClass           : Bool
10071   declName          : Name
10072   scopeVars         : Array Expr <span class="comment-delimiter">-- </span><span class="comment">All `variable` declaration in the current scope
</span>10073   params            : Array Expr <span class="comment-delimiter">-- </span><span class="comment">Explicit parameters provided in the `structure` command
</span>10074   parents           : Array Syntax
10075   type              : Syntax
10076   ctor              : StructCtorView
10077   fields            : Array StructFieldView
10078 
<span class="keyword">10079 inductive</span> <span class="function-name">StructFieldKind</span> <span class="keyword">where</span>
10080   | newField | fromParent | subobject
10081   <span class="keyword">deriving</span> Inhabited
10082 
<span class="keyword">10083 structure</span> <span class="function-name">StructFieldInfo</span> <span class="keyword">where</span>
10084   name     : Name
10085   declName : Name <span class="comment-delimiter">-- </span><span class="comment">Remark: this field value doesn't matter for fromParent fields.
</span>10086   fvar     : Expr
10087   kind     : StructFieldKind
10088   inferMod : Bool <span class="constant">:=</span> false
10089   value?   : Option Expr <span class="constant">:=</span> none
10090   <span class="keyword">deriving</span> Inhabited
10091 
<span class="keyword">10092 def</span> <span class="function-name">StructFieldInfo.isFromParent</span> (info : StructFieldInfo) : Bool <span class="constant">:=</span>
10093   <span class="keyword">match</span> info.kind <span class="keyword">with</span>
10094   | StructFieldKind.fromParent <span class="constant">=&gt;</span> true
10095   | <span class="preprocessor">_</span>                          <span class="constant">=&gt;</span> false
10096 
<span class="keyword">10097 def</span> <span class="function-name">StructFieldInfo.isSubobject</span> (info : StructFieldInfo) : Bool <span class="constant">:=</span>
10098   <span class="keyword">match</span> info.kind <span class="keyword">with</span>
10099   | StructFieldKind.subobject <span class="constant">=&gt;</span> true
10100   | <span class="preprocessor">_</span>                         <span class="constant">=&gt;</span> false
10101 
<span class="comment-delimiter">10102 /- </span><span class="comment">Auxiliary declaration for `mkProjections` -/</span>
<span class="keyword">10103 structure</span> <span class="function-name">ProjectionInfo</span> <span class="keyword">where</span>
10104   declName : Name
10105   inferMod : Bool
10106 
<span class="keyword">10107 structure</span> <span class="function-name">ElabStructResult</span> <span class="keyword">where</span>
10108   decl            : Declaration
10109   projInfos       : List ProjectionInfo
10110   projInstances   : List Name <span class="comment-delimiter">-- </span><span class="comment">projections (to parent classes) that must be marked as instances.
</span>10111   mctx            : MetavarContext
10112   lctx            : LocalContext
10113   localInsts      : LocalInstances
10114   defaultAuxDecls : Array (Name <span class="constant">&#215;</span> Expr <span class="constant">&#215;</span> Expr)
10115 
<span class="keyword">10116 private</span> <span class="keyword">def</span> <span class="function-name">defaultCtorName</span> <span class="constant">:=</span> `mk
10117 
<span class="comment-delimiter">10118 /-</span><span class="comment">
10119 The structure constructor syntax is
10120 ```
10121 leading_parser try (declModifiers &gt;&gt; ident &gt;&gt; optional inferMod &gt;&gt; " :: ")
10122 ```
10123 -/</span>
<span class="keyword">10124 private</span> <span class="keyword">def</span> <span class="function-name">expandCtor</span> (structStx : Syntax) (structModifiers : Modifiers) (structDeclName : Name) : TermElabM StructCtorView <span class="constant">:=</span> <span class="keyword">do</span>
10125   <span class="keyword">let</span> useDefault <span class="constant">:=</span> <span class="keyword">do</span>
10126     <span class="keyword">let</span> declName <span class="constant">:=</span> structDeclName <span class="constant">++</span> defaultCtorName
10127     addAuxDeclarationRanges declName structStx[<span class="constant">2</span>] structStx[<span class="constant">2</span>]
10128     pure { ref <span class="constant">:=</span> structStx, modifiers <span class="constant">:=</span> {}, inferMod <span class="constant">:=</span> false, name <span class="constant">:=</span> defaultCtorName, declName <span class="constant">:=</span> declName }
10129   <span class="keyword">if</span> structStx[<span class="constant">5</span>].isNone <span class="keyword">then</span>
10130     useDefault
10131   <span class="keyword">else</span>
10132     <span class="keyword">let</span> optCtor <span class="constant">:=</span> structStx[<span class="constant">5</span>][<span class="constant">1</span>]
10133     <span class="keyword">if</span> optCtor.isNone <span class="keyword">then</span>
10134       useDefault
10135     <span class="keyword">else</span>
10136       <span class="keyword">let</span> ctor <span class="constant">:=</span> optCtor[<span class="constant">0</span>]
10137       withRef ctor <span class="keyword">do</span>
10138       <span class="keyword">let</span> ctorModifiers &#8592; elabModifiers ctor[<span class="constant">0</span>]
10139       checkValidCtorModifier ctorModifiers
10140       <span class="keyword">if</span> ctorModifiers.isPrivate <span class="constant">&amp;&amp;</span> structModifiers.isPrivate <span class="keyword">then</span>
10141         throwError <span class="string">"invalid 'private' constructor in a 'private' structure"</span>
10142       <span class="keyword">if</span> ctorModifiers.isProtected <span class="constant">&amp;&amp;</span> structModifiers.isPrivate <span class="keyword">then</span>
10143         throwError <span class="string">"invalid 'protected' constructor in a 'private' structure"</span>
10144       <span class="keyword">let</span> inferMod <span class="constant">:=</span> <span class="constant">!</span>ctor[<span class="constant">2</span>].isNone
10145       <span class="keyword">let</span> name <span class="constant">:=</span> ctor[<span class="constant">1</span>].getId
10146       <span class="keyword">let</span> declName <span class="constant">:=</span> structDeclName <span class="constant">++</span> name
10147       <span class="keyword">let</span> declName &#8592; applyVisibility ctorModifiers.visibility declName
10148       addDocString' declName ctorModifiers.docString?
10149       addAuxDeclarationRanges declName ctor[<span class="constant">1</span>] ctor[<span class="constant">1</span>]
10150       pure { ref <span class="constant">:=</span> ctor, name <span class="constant">:=</span> name, modifiers <span class="constant">:=</span> ctorModifiers, inferMod <span class="constant">:=</span> inferMod, declName <span class="constant">:=</span> declName }
10151 
<span class="keyword">10152 def</span> <span class="function-name">checkValidFieldModifier</span> (modifiers : Modifiers) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
10153   <span class="keyword">if</span> modifiers.isNoncomputable <span class="keyword">then</span>
10154     throwError <span class="string">"invalid use of 'noncomputable' in field declaration"</span>
10155   <span class="keyword">if</span> modifiers.isPartial <span class="keyword">then</span>
10156     throwError <span class="string">"invalid use of 'partial' in field declaration"</span>
10157   <span class="keyword">if</span> modifiers.isUnsafe <span class="keyword">then</span>
10158     throwError <span class="string">"invalid use of 'unsafe' in field declaration"</span>
10159   <span class="keyword">if</span> modifiers.attrs.size <span class="constant">!=</span> <span class="constant">0</span> <span class="keyword">then</span>
10160     throwError <span class="string">"invalid use of attributes in field declaration"</span>
10161   <span class="keyword">if</span> modifiers.isPrivate <span class="keyword">then</span>
10162     throwError <span class="string">"private fields are not supported yet"</span>
10163 
<span class="comment-delimiter">10164 /-</span><span class="comment">
10165 ```
10166 def structExplicitBinder := leading_parser atomic (declModifiers true &gt;&gt; "(") &gt;&gt; many1 ident &gt;&gt; optional inferMod &gt;&gt; optDeclSig &gt;&gt; optional Term.binderDefault &gt;&gt; ")"
10167 def structImplicitBinder := leading_parser atomic (declModifiers true &gt;&gt; "{") &gt;&gt; many1 ident &gt;&gt; optional inferMod &gt;&gt; declSig &gt;&gt; "}"
10168 def structInstBinder     := leading_parser atomic (declModifiers true &gt;&gt; "[") &gt;&gt; many1 ident &gt;&gt; optional inferMod &gt;&gt; declSig &gt;&gt; "]"
10169 def structSimpleBinder   := leading_parser atomic (declModifiers true &gt;&gt; ident) &gt;&gt; optional inferMod &gt;&gt; optDeclSig &gt;&gt; optional Term.binderDefault
10170 def structFields         := leading_parser many (structExplicitBinder &lt;|&gt; structImplicitBinder &lt;|&gt; structInstBinder)
10171 ```
10172 -/</span>
<span class="keyword">10173 private</span> <span class="keyword">def</span> <span class="function-name">expandFields</span> (structStx : Syntax) (structModifiers : Modifiers) (structDeclName : Name) : TermElabM (Array StructFieldView) <span class="constant">:=</span>
10174   <span class="keyword">let</span> fieldBinders <span class="constant">:=</span> <span class="keyword">if</span> structStx[<span class="constant">5</span>].isNone <span class="keyword">then</span> <span class="constant">#</span>[] <span class="keyword">else</span> structStx[<span class="constant">5</span>][<span class="constant">2</span>][<span class="constant">0</span>].getArgs
10175   fieldBinders.foldlM (init <span class="constant">:=</span> <span class="constant">#</span>[]) <span class="keyword">fun</span> (views : Array StructFieldView) fieldBinder <span class="constant">=&gt;</span> withRef fieldBinder <span class="keyword">do</span>
10176     <span class="keyword">let</span> <span class="keyword">mut</span> fieldBinder <span class="constant">:=</span> fieldBinder
10177     <span class="keyword">if</span> fieldBinder.getKind <span class="constant">==</span> ``Parser.Command.structSimpleBinder <span class="keyword">then</span>
10178       fieldBinder <span class="constant">:=</span> Syntax.node ``Parser.Command.structExplicitBinder
10179         <span class="constant">#</span>[ fieldBinder[<span class="constant">0</span>], mkAtomFrom fieldBinder <span class="string">"("</span>, mkNullNode <span class="constant">#</span>[ fieldBinder[<span class="constant">1</span>] ], fieldBinder[<span class="constant">2</span>], fieldBinder[<span class="constant">3</span>], fieldBinder[<span class="constant">4</span>], mkAtomFrom fieldBinder <span class="string">")"</span> ]
10180     <span class="keyword">let</span> k <span class="constant">:=</span> fieldBinder.getKind
10181     <span class="keyword">let</span> binfo &#8592;
10182       <span class="keyword">if</span> k <span class="constant">==</span> ``Parser.Command.structExplicitBinder <span class="keyword">then</span> pure BinderInfo.default
10183       <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> ``Parser.Command.structImplicitBinder <span class="keyword">then</span> pure BinderInfo.implicit
10184       <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> ``Parser.Command.structInstBinder <span class="keyword">then</span> pure BinderInfo.instImplicit
10185       <span class="keyword">else</span> throwError <span class="string">"unexpected kind of structure field"</span>
10186     <span class="keyword">let</span> fieldModifiers &#8592; elabModifiers fieldBinder[<span class="constant">0</span>]
10187     checkValidFieldModifier fieldModifiers
10188     <span class="keyword">if</span> fieldModifiers.isPrivate <span class="constant">&amp;&amp;</span> structModifiers.isPrivate <span class="keyword">then</span>
10189       throwError <span class="string">"invalid 'private' field in a 'private' structure"</span>
10190     <span class="keyword">if</span> fieldModifiers.isProtected <span class="constant">&amp;&amp;</span> structModifiers.isPrivate <span class="keyword">then</span>
10191       throwError <span class="string">"invalid 'protected' field in a 'private' structure"</span>
10192     <span class="keyword">let</span> inferMod         <span class="constant">:=</span> <span class="constant">!</span>fieldBinder[<span class="constant">3</span>].isNone
10193     <span class="keyword">let</span> (binders, type?) <span class="constant">:=</span>
10194       <span class="keyword">if</span> binfo <span class="constant">==</span> BinderInfo.default <span class="keyword">then</span>
10195         expandOptDeclSig fieldBinder[<span class="constant">4</span>]
10196       <span class="keyword">else</span>
10197         <span class="keyword">let</span> (binders, type) <span class="constant">:=</span> expandDeclSig fieldBinder[<span class="constant">4</span>]
10198         (binders, some type)
10199     <span class="keyword">let</span> value? <span class="constant">:=</span>
10200       <span class="keyword">if</span> binfo <span class="constant">!=</span> BinderInfo.default <span class="keyword">then</span> none
10201       <span class="keyword">else</span>
10202         <span class="keyword">let</span> optBinderDefault <span class="constant">:=</span> fieldBinder[<span class="constant">5</span>]
10203         <span class="keyword">if</span> optBinderDefault.isNone <span class="keyword">then</span> none
10204         <span class="keyword">else</span>
10205           <span class="comment-delimiter">-- </span><span class="comment">binderDefault := leading_parser " := " &gt;&gt; termParser
</span>10206           some optBinderDefault[<span class="constant">0</span>][<span class="constant">1</span>]
10207     <span class="keyword">let</span> idents <span class="constant">:=</span> fieldBinder[<span class="constant">2</span>].getArgs
10208     idents.foldlM (init <span class="constant">:=</span> views) <span class="keyword">fun</span> (views : Array StructFieldView) ident <span class="constant">=&gt;</span> withRef ident <span class="keyword">do</span>
10209       <span class="keyword">let</span> name     <span class="constant">:=</span> ident.getId
10210       <span class="keyword">if</span> isInternalSubobjectFieldName name <span class="keyword">then</span>
10211         throwError <span class="string">"invalid field name '{name}', identifiers starting with '_' are reserved to the system"</span>
10212       <span class="keyword">let</span> declName <span class="constant">:=</span> structDeclName <span class="constant">++</span> name
10213       <span class="keyword">let</span> declName &#8592; applyVisibility fieldModifiers.visibility declName
10214       addDocString' declName fieldModifiers.docString?
10215       <span class="keyword">return</span> views.push {
10216         ref        <span class="constant">:=</span> ident,
10217         modifiers  <span class="constant">:=</span> fieldModifiers,
10218         binderInfo <span class="constant">:=</span> binfo,
10219         inferMod   <span class="constant">:=</span> inferMod,
10220         declName   <span class="constant">:=</span> declName,
10221         name       <span class="constant">:=</span> name,
10222         binders    <span class="constant">:=</span> binders,
10223         type?      <span class="constant">:=</span> type?,
10224         value?     <span class="constant">:=</span> value?
10225       }
10226 
<span class="keyword">10227 private</span> <span class="keyword">def</span> <span class="function-name">validStructType</span> (type : Expr) : Bool <span class="constant">:=</span>
10228   <span class="keyword">match</span> type <span class="keyword">with</span>
10229   | Expr.sort .. <span class="constant">=&gt;</span> true
10230   | <span class="preprocessor">_</span>            <span class="constant">=&gt;</span> false
10231 
<span class="keyword">10232 private</span> <span class="keyword">def</span> <span class="function-name">checkParentIsStructure</span> (parent : Expr) : TermElabM Name <span class="constant">:=</span>
10233   <span class="keyword">match</span> parent.getAppFn <span class="keyword">with</span>
10234   | Expr.const c <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">do</span>
10235     <span class="keyword">unless</span> isStructure (&#8592; getEnv) c <span class="keyword">do</span>
10236       throwError <span class="string">"'{c}' is not a structure"</span>
10237     pure c
10238   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwError <span class="string">"expected structure"</span>
10239 
<span class="keyword">10240 private</span> <span class="keyword">def</span> <span class="function-name">findFieldInfo?</span> (infos : Array StructFieldInfo) (fieldName : Name) : Option StructFieldInfo <span class="constant">:=</span>
10241   infos.find? <span class="keyword">fun</span> info <span class="constant">=&gt;</span> info.name <span class="constant">==</span> fieldName
10242 
<span class="keyword">10243 private</span> <span class="keyword">def</span> <span class="function-name">containsFieldName</span> (infos : Array StructFieldInfo) (fieldName : Name) : Bool <span class="constant">:=</span>
10244   (findFieldInfo? infos fieldName).isSome
10245 
<span class="keyword">10246 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">processSubfields</span> (structDeclName : Name) (parentFVar : Expr) (parentStructName : Name) (subfieldNames : Array Name)
10247     (infos : Array StructFieldInfo) (k : Array StructFieldInfo <span class="constant">&#8594;</span> TermElabM &#945;) : TermElabM &#945; <span class="constant">:=</span>
10248   <span class="keyword">let</span> <span class="keyword">rec</span> loop (i : Nat) (infos : Array StructFieldInfo) <span class="constant">:=</span> <span class="keyword">do</span>
10249     <span class="keyword">if</span> h : i <span class="constant">&lt;</span> subfieldNames.size <span class="keyword">then</span>
10250       <span class="keyword">let</span> subfieldName <span class="constant">:=</span> subfieldNames.get &#10216;i, h&#10217;
10251       <span class="keyword">if</span> containsFieldName infos subfieldName <span class="keyword">then</span>
10252         throwError <span class="string">"field '{subfieldName}' from '{parentStructName}' has already been declared"</span>
10253       <span class="keyword">let</span> val  &#8592; mkProjection parentFVar subfieldName
10254       <span class="keyword">let</span> type &#8592; inferType val
10255       withLetDecl subfieldName type val <span class="keyword">fun</span> subfieldFVar <span class="constant">=&gt;</span>
10256         <span class="comment-delimiter">/- </span><span class="comment">The following `declName` is only used for creating the `_default` auxiliary declaration name when
10257            its default value is overwritten in the structure. -/</span>
10258         <span class="keyword">let</span> declName <span class="constant">:=</span> structDeclName <span class="constant">++</span> subfieldName
10259         <span class="keyword">let</span> infos <span class="constant">:=</span> infos.push { name <span class="constant">:=</span> subfieldName, declName <span class="constant">:=</span> declName, fvar <span class="constant">:=</span> subfieldFVar, kind <span class="constant">:=</span> StructFieldKind.fromParent }
10260         loop (i<span class="constant">+1</span>) infos
10261     <span class="keyword">else</span>
10262       k infos
10263   loop <span class="constant">0</span> infos
10264 
<span class="keyword">10265 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">withParents</span> (view : StructView) (i : Nat) (infos : Array StructFieldInfo) (k : Array StructFieldInfo <span class="constant">&#8594;</span> TermElabM &#945;) : TermElabM &#945; <span class="constant">:=</span> <span class="keyword">do</span>
10266   <span class="keyword">if</span> h : i <span class="constant">&lt;</span> view.parents.size <span class="keyword">then</span>
10267     <span class="keyword">let</span> parentStx <span class="constant">:=</span> view.parents.get &#10216;i, h&#10217;
10268     withRef parentStx <span class="keyword">do</span>
10269     <span class="keyword">let</span> parent &#8592; Term.elabType parentStx
10270     <span class="keyword">let</span> parentName &#8592; checkParentIsStructure parent
10271     <span class="keyword">let</span> toParentName <span class="constant">:=</span> Name.mkSimple <span class="constant">$</span> <span class="string">"to"</span> <span class="constant">++</span> parentName.eraseMacroScopes.getString<span class="constant">!</span> <span class="comment-delimiter">-- </span><span class="comment">erase macro scopes?
</span>10272     <span class="keyword">if</span> containsFieldName infos toParentName <span class="keyword">then</span>
10273       throwErrorAt parentStx <span class="string">"field '{toParentName}' has already been declared"</span>
10274     <span class="keyword">let</span> env &#8592; getEnv
10275     <span class="keyword">let</span> binfo <span class="constant">:=</span> <span class="keyword">if</span> view.isClass <span class="constant">&amp;&amp;</span> isClass env parentName <span class="keyword">then</span> BinderInfo.instImplicit <span class="keyword">else</span> BinderInfo.default
10276     withLocalDecl toParentName binfo parent <span class="keyword">fun</span> parentFVar <span class="constant">=&gt;</span>
10277       <span class="keyword">let</span> infos <span class="constant">:=</span> infos.push { name <span class="constant">:=</span> toParentName, declName <span class="constant">:=</span> view.declName <span class="constant">++</span> toParentName, fvar <span class="constant">:=</span> parentFVar, kind <span class="constant">:=</span> StructFieldKind.subobject }
10278       <span class="keyword">let</span> subfieldNames <span class="constant">:=</span> getStructureFieldsFlattened env parentName
10279       processSubfields view.declName parentFVar parentName subfieldNames infos <span class="keyword">fun</span> infos <span class="constant">=&gt;</span> withParents view (i<span class="constant">+1</span>) infos k
10280   <span class="keyword">else</span>
10281     k infos
10282 
<span class="keyword">10283 private</span> <span class="keyword">def</span> <span class="function-name">elabFieldTypeValue</span> (view : StructFieldView) : TermElabM (Option Expr <span class="constant">&#215;</span> Option Expr) <span class="constant">:=</span> <span class="keyword">do</span>
10284   Term.withAutoBoundImplicit <span class="constant">&lt;</span>| Term.elabBinders view.binders.getArgs <span class="keyword">fun</span> params <span class="constant">=&gt;</span> <span class="keyword">do</span>
10285     <span class="keyword">match</span> view.type? <span class="keyword">with</span>
10286     | none         <span class="constant">=&gt;</span>
10287       <span class="keyword">match</span> view.value? <span class="keyword">with</span>
10288       | none        <span class="constant">=&gt;</span> <span class="keyword">return</span> (none, none)
10289       | some valStx <span class="constant">=&gt;</span>
10290         Term.synthesizeSyntheticMVarsNoPostponing
10291         <span class="keyword">let</span> params &#8592; Term.addAutoBoundImplicits params
10292         <span class="keyword">let</span> value &#8592; Term.elabTerm valStx none
10293         <span class="keyword">let</span> value &#8592; mkLambdaFVars params value
10294         <span class="keyword">return</span> (none, value)
10295     | some typeStx <span class="constant">=&gt;</span>
10296       <span class="keyword">let</span> type &#8592; Term.elabType typeStx
10297       Term.synthesizeSyntheticMVarsNoPostponing
10298       <span class="keyword">let</span> params &#8592; Term.addAutoBoundImplicits params
10299       <span class="keyword">match</span> view.value? <span class="keyword">with</span>
10300       | none        <span class="constant">=&gt;</span>
10301         <span class="keyword">let</span> type  &#8592; mkForallFVars params type
10302         <span class="keyword">return</span> (type, none)
10303       | some valStx <span class="constant">=&gt;</span>
10304         <span class="keyword">let</span> value &#8592; Term.elabTermEnsuringType valStx type
10305         Term.synthesizeSyntheticMVarsNoPostponing
10306         <span class="keyword">let</span> type  &#8592; mkForallFVars params type
10307         <span class="keyword">let</span> value &#8592; mkLambdaFVars params value
10308         <span class="keyword">return</span> (type, value)
10309 
<span class="keyword">10310 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">withFields</span>
10311     (views : Array StructFieldView) (i : Nat) (infos : Array StructFieldInfo) (k : Array StructFieldInfo <span class="constant">&#8594;</span> TermElabM &#945;) : TermElabM &#945; <span class="constant">:=</span> <span class="keyword">do</span>
10312   <span class="keyword">if</span> h : i <span class="constant">&lt;</span> views.size <span class="keyword">then</span>
10313     <span class="keyword">let</span> view <span class="constant">:=</span> views.get &#10216;i, h&#10217;
10314     withRef view.ref <span class="constant">$</span>
10315     <span class="keyword">match</span> findFieldInfo? infos view.name <span class="keyword">with</span>
10316     | none      <span class="constant">=&gt;</span> <span class="keyword">do</span>
10317       <span class="keyword">let</span> (type?, value?) &#8592; elabFieldTypeValue view
10318       <span class="keyword">match</span> type?, value? <span class="keyword">with</span>
10319       | none,      none <span class="constant">=&gt;</span> throwError <span class="string">"invalid field, type expected"</span>
10320       | some type, <span class="preprocessor">_</span>    <span class="constant">=&gt;</span>
10321         withLocalDecl view.name view.binderInfo type <span class="keyword">fun</span> fieldFVar <span class="constant">=&gt;</span>
10322           <span class="keyword">let</span> infos <span class="constant">:=</span> infos.push { name <span class="constant">:=</span> view.name, declName <span class="constant">:=</span> view.declName, fvar <span class="constant">:=</span> fieldFVar, value? <span class="constant">:=</span> value?,
10323                                     kind <span class="constant">:=</span> StructFieldKind.newField, inferMod <span class="constant">:=</span> view.inferMod }
10324           withFields views (i<span class="constant">+1</span>) infos k
10325       | none, some value <span class="constant">=&gt;</span>
10326         <span class="keyword">let</span> type &#8592; inferType value
10327         withLocalDecl view.name view.binderInfo type <span class="keyword">fun</span> fieldFVar <span class="constant">=&gt;</span>
10328           <span class="keyword">let</span> infos <span class="constant">:=</span> infos.push { name <span class="constant">:=</span> view.name, declName <span class="constant">:=</span> view.declName, fvar <span class="constant">:=</span> fieldFVar, value? <span class="constant">:=</span> value,
10329                                     kind <span class="constant">:=</span> StructFieldKind.newField, inferMod <span class="constant">:=</span> view.inferMod }
10330           withFields views (i<span class="constant">+1</span>) infos k
10331     | some info <span class="constant">=&gt;</span>
10332       <span class="keyword">match</span> info.kind <span class="keyword">with</span>
10333       | StructFieldKind.newField   <span class="constant">=&gt;</span> throwError <span class="string">"field '{view.name}' has already been declared"</span>
10334       | StructFieldKind.fromParent <span class="constant">=&gt;</span>
10335         <span class="keyword">match</span> view.value? <span class="keyword">with</span>
10336         | none       <span class="constant">=&gt;</span> throwError <span class="string">"field '{view.name}' has been declared in parent structure"</span>
10337         | some valStx <span class="constant">=&gt;</span> <span class="keyword">do</span>
10338           <span class="keyword">if</span> <span class="keyword">let</span> some type <span class="constant">:=</span> view.type? <span class="keyword">then</span>
10339             throwErrorAt type <span class="string">"omit field '{view.name}' type to set default value"</span>
10340           <span class="keyword">else</span>
10341             <span class="keyword">let</span> <span class="keyword">mut</span> valStx <span class="constant">:=</span> valStx
10342             <span class="keyword">if</span> view.binders.getArgs.size <span class="constant">&gt;</span> <span class="constant">0</span> <span class="keyword">then</span>
10343               valStx &#8592; `(<span class="keyword">fun</span> <span class="constant">$</span>(view.binders.getArgs)<span class="constant">*</span> <span class="constant">=&gt;</span> <span class="constant">$</span>valStx:term)
10344             <span class="keyword">let</span> fvarType &#8592; inferType info.fvar
10345             <span class="keyword">let</span> value &#8592; Term.elabTermEnsuringType valStx fvarType
10346             <span class="keyword">let</span> infos <span class="constant">:=</span> infos.push { info <span class="keyword">with</span> value? <span class="constant">:=</span> value }
10347             withFields views (i<span class="constant">+1</span>) infos k
10348       | StructFieldKind.subobject <span class="constant">=&gt;</span> <span class="warning">unreachable</span><span class="constant">!</span>
10349   <span class="keyword">else</span>
10350     k infos
10351 
<span class="keyword">10352 private</span> <span class="keyword">def</span> <span class="function-name">getResultUniverse</span> (type : Expr) : TermElabM Level <span class="constant">:=</span> <span class="keyword">do</span>
10353   <span class="keyword">let</span> type &#8592; whnf type
10354   <span class="keyword">match</span> type <span class="keyword">with</span>
10355   | Expr.sort u <span class="preprocessor">_</span> <span class="constant">=&gt;</span> pure u
10356   | <span class="preprocessor">_</span>             <span class="constant">=&gt;</span> throwError <span class="string">"unexpected structure resulting type"</span>
10357 
<span class="keyword">10358 private</span> <span class="keyword">def</span> <span class="function-name">collectUsed</span> (params : Array Expr) (fieldInfos : Array StructFieldInfo) : StateRefT CollectFVars.State MetaM Unit <span class="constant">:=</span> <span class="keyword">do</span>
10359   params.forM <span class="keyword">fun</span> p <span class="constant">=&gt;</span> <span class="keyword">do</span>
10360     <span class="keyword">let</span> type &#8592; inferType p
10361     Term.collectUsedFVars type
10362   fieldInfos.forM <span class="keyword">fun</span> info <span class="constant">=&gt;</span> <span class="keyword">do</span>
10363     <span class="keyword">let</span> fvarType &#8592; inferType info.fvar
10364     Term.collectUsedFVars fvarType
10365     <span class="keyword">match</span> info.value? <span class="keyword">with</span>
10366     | none       <span class="constant">=&gt;</span> pure ()
10367     | some value <span class="constant">=&gt;</span> Term.collectUsedFVars value
10368 
<span class="keyword">10369 private</span> <span class="keyword">def</span> <span class="function-name">removeUnused</span> (scopeVars : Array Expr) (params : Array Expr) (fieldInfos : Array StructFieldInfo)
10370     : TermElabM (LocalContext <span class="constant">&#215;</span> LocalInstances <span class="constant">&#215;</span> Array Expr) <span class="constant">:=</span> <span class="keyword">do</span>
10371   <span class="keyword">let</span> (<span class="preprocessor">_</span>, used) &#8592; (collectUsed params fieldInfos).run {}
10372   Term.removeUnused scopeVars used
10373 
<span class="keyword">10374 private</span> <span class="keyword">def</span> <span class="function-name">withUsed</span> {&#945;} (scopeVars : Array Expr) (params : Array Expr) (fieldInfos : Array StructFieldInfo) (k : Array Expr <span class="constant">&#8594;</span> TermElabM &#945;)
10375     : TermElabM &#945; <span class="constant">:=</span> <span class="keyword">do</span>
10376   <span class="keyword">let</span> (lctx, localInsts, vars) &#8592; removeUnused scopeVars params fieldInfos
10377   withLCtx lctx localInsts <span class="constant">$</span> k vars
10378 
<span class="keyword">10379 private</span> <span class="keyword">def</span> <span class="function-name">levelMVarToParamFVar</span> (fvar : Expr) : StateRefT Nat TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
10380   <span class="keyword">let</span> type &#8592; inferType fvar
10381   discard <span class="constant">&lt;</span>| Term.levelMVarToParam' type
10382 
<span class="keyword">10383 private</span> <span class="keyword">def</span> <span class="function-name">levelMVarToParamFVars</span> (fvars : Array Expr) : StateRefT Nat TermElabM Unit <span class="constant">:=</span>
10384   fvars.forM levelMVarToParamFVar
10385 
<span class="keyword">10386 private</span> <span class="keyword">def</span> <span class="function-name">levelMVarToParamAux</span> (scopeVars : Array Expr) (params : Array Expr) (fieldInfos : Array StructFieldInfo)
10387     : StateRefT Nat TermElabM (Array StructFieldInfo) <span class="constant">:=</span> <span class="keyword">do</span>
10388   levelMVarToParamFVars scopeVars
10389   levelMVarToParamFVars params
10390   fieldInfos.mapM <span class="keyword">fun</span> info <span class="constant">=&gt;</span> <span class="keyword">do</span>
10391     levelMVarToParamFVar info.fvar
10392     <span class="keyword">match</span> info.value? <span class="keyword">with</span>
10393     | none       <span class="constant">=&gt;</span> pure info
10394     | some value <span class="constant">=&gt;</span>
10395       <span class="keyword">let</span> value &#8592; Term.levelMVarToParam' value
10396       pure { info <span class="keyword">with</span> value? <span class="constant">:=</span> value }
10397 
<span class="keyword">10398 private</span> <span class="keyword">def</span> <span class="function-name">levelMVarToParam</span> (scopeVars : Array Expr) (params : Array Expr) (fieldInfos : Array StructFieldInfo) : TermElabM (Array StructFieldInfo) <span class="constant">:=</span>
10399   (levelMVarToParamAux scopeVars params fieldInfos).run' <span class="constant">1</span>
10400 
<span class="keyword">10401 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">collectUniversesFromFields</span> (r : Level) (rOffset : Nat) (fieldInfos : Array StructFieldInfo) : TermElabM (Array Level) <span class="constant">:=</span> <span class="keyword">do</span>
10402   fieldInfos.foldlM (init <span class="constant">:=</span> <span class="constant">#</span>[]) <span class="keyword">fun</span> (us : Array Level) (info : StructFieldInfo) <span class="constant">=&gt;</span> <span class="keyword">do</span>
10403     <span class="keyword">let</span> type &#8592; inferType info.fvar
10404     <span class="keyword">let</span> u &#8592; getLevel type
10405     <span class="keyword">let</span> u &#8592; instantiateLevelMVars u
10406     accLevelAtCtor u r rOffset us
10407 
<span class="keyword">10408 private</span> <span class="keyword">def</span> <span class="function-name">updateResultingUniverse</span> (fieldInfos : Array StructFieldInfo) (type : Expr) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
10409   <span class="keyword">let</span> r &#8592; getResultUniverse type
10410   <span class="keyword">let</span> rOffset : Nat   <span class="constant">:=</span> r.getOffset
10411   <span class="keyword">let</span> r       : Level <span class="constant">:=</span> r.getLevelOffset
10412   <span class="keyword">match</span> r <span class="keyword">with</span>
10413   | Level.mvar mvarId <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
10414     <span class="keyword">let</span> us &#8592; collectUniversesFromFields r rOffset fieldInfos
10415     <span class="keyword">let</span> rNew <span class="constant">:=</span> mkResultUniverse us rOffset
10416     assignLevelMVar mvarId rNew
10417     instantiateMVars type
10418   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwError <span class="string">"failed to compute resulting universe level of structure, provide universe explicitly"</span>
10419 
<span class="keyword">10420 private</span> <span class="keyword">def</span> <span class="function-name">collectLevelParamsInFVar</span> (s : CollectLevelParams.State) (fvar : Expr) : TermElabM CollectLevelParams.State <span class="constant">:=</span> <span class="keyword">do</span>
10421   <span class="keyword">let</span> type &#8592; inferType fvar
10422   <span class="keyword">let</span> type &#8592; instantiateMVars type
10423   pure <span class="constant">$</span> collectLevelParams s type
10424 
<span class="keyword">10425 private</span> <span class="keyword">def</span> <span class="function-name">collectLevelParamsInFVars</span> (fvars : Array Expr) (s : CollectLevelParams.State) : TermElabM CollectLevelParams.State <span class="constant">:=</span>
10426   fvars.foldlM collectLevelParamsInFVar s
10427 
<span class="keyword">10428 private</span> <span class="keyword">def</span> <span class="function-name">collectLevelParamsInStructure</span> (structType : Expr) (scopeVars : Array Expr) (params : Array Expr) (fieldInfos : Array StructFieldInfo)
10429     : TermElabM (Array Name) <span class="constant">:=</span> <span class="keyword">do</span>
10430   <span class="keyword">let</span> s <span class="constant">:=</span> collectLevelParams {} structType
10431   <span class="keyword">let</span> s &#8592; collectLevelParamsInFVars scopeVars s
10432   <span class="keyword">let</span> s &#8592; collectLevelParamsInFVars params s
10433   <span class="keyword">let</span> s &#8592; fieldInfos.foldlM (<span class="keyword">fun</span> (s : CollectLevelParams.State) info <span class="constant">=&gt;</span> collectLevelParamsInFVar s info.fvar) s
10434   pure s.params
10435 
<span class="keyword">10436 private</span> <span class="keyword">def</span> <span class="function-name">addCtorFields</span> (fieldInfos : Array StructFieldInfo) : Nat <span class="constant">&#8594;</span> Expr <span class="constant">&#8594;</span> TermElabM Expr
10437   | <span class="constant">0</span>,   type <span class="constant">=&gt;</span> pure type
10438   | i<span class="constant">+1</span>, type <span class="constant">=&gt;</span> <span class="keyword">do</span>
10439     <span class="keyword">let</span> info <span class="constant">:=</span> fieldInfos[i]
10440     <span class="keyword">let</span> decl &#8592; Term.getFVarLocalDecl<span class="constant">!</span> info.fvar
10441     <span class="keyword">let</span> type &#8592; instantiateMVars type
10442     <span class="keyword">let</span> type <span class="constant">:=</span> type.abstract <span class="constant">#</span>[info.fvar]
10443     <span class="keyword">match</span> info.kind <span class="keyword">with</span>
10444     | StructFieldKind.fromParent <span class="constant">=&gt;</span>
10445       <span class="keyword">let</span> val <span class="constant">:=</span> decl.value
10446       addCtorFields fieldInfos i (type.instantiate1 val)
10447     | StructFieldKind.subobject <span class="constant">=&gt;</span>
10448       <span class="keyword">let</span> n <span class="constant">:=</span> mkInternalSubobjectFieldName <span class="constant">$</span> decl.userName
10449       addCtorFields fieldInfos i (mkForall n decl.binderInfo decl.type type)
10450     | StructFieldKind.newField <span class="constant">=&gt;</span>
10451       addCtorFields fieldInfos i (mkForall decl.userName decl.binderInfo decl.type type)
10452 
<span class="keyword">10453 private</span> <span class="keyword">def</span> <span class="function-name">mkCtor</span> (view : StructView) (levelParams : List Name) (params : Array Expr) (fieldInfos : Array StructFieldInfo) : TermElabM Constructor <span class="constant">:=</span>
10454   withRef view.ref <span class="keyword">do</span>
10455   <span class="keyword">let</span> type <span class="constant">:=</span> mkAppN (mkConst view.declName (levelParams.map mkLevelParam)) params
10456   <span class="keyword">let</span> type &#8592; addCtorFields fieldInfos fieldInfos.size type
10457   <span class="keyword">let</span> type &#8592; mkForallFVars params type
10458   <span class="keyword">let</span> type &#8592; instantiateMVars type
10459   <span class="keyword">let</span> type <span class="constant">:=</span> type.inferImplicit params.size <span class="constant">!</span>view.ctor.inferMod
10460   pure { name <span class="constant">:=</span> view.ctor.declName, type <span class="constant">:=</span> type }
10461 
<span class="constant">10462 @</span>[extern <span class="string">"lean_mk_projections"</span>]
<span class="keyword">10463 private</span> <span class="keyword">constant</span> <span class="function-name">mkProjections</span> (env : Environment) (structName : Name) (projs : List ProjectionInfo) (isClass : Bool) : Except KernelException Environment
10464 
<span class="keyword">10465 private</span> <span class="keyword">def</span> <span class="function-name">addProjections</span> (structName : Name) (projs : List ProjectionInfo) (isClass : Bool) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
10466   <span class="keyword">let</span> env &#8592; getEnv
10467   <span class="keyword">match</span> mkProjections env structName projs isClass <span class="keyword">with</span>
10468   | Except.ok env   <span class="constant">=&gt;</span> setEnv env
10469   | Except.error ex <span class="constant">=&gt;</span> throwKernelException ex
10470 
<span class="keyword">10471 private</span> <span class="keyword">def</span> <span class="function-name">mkAuxConstructions</span> (declName : Name) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
10472   <span class="keyword">let</span> env &#8592; getEnv
10473   <span class="keyword">let</span> hasUnit <span class="constant">:=</span> env.contains `PUnit
10474   <span class="keyword">let</span> hasEq   <span class="constant">:=</span> env.contains `Eq
10475   <span class="keyword">let</span> hasHEq  <span class="constant">:=</span> env.contains `HEq
10476   mkRecOn declName
10477   <span class="keyword">if</span> hasUnit <span class="keyword">then</span> mkCasesOn declName
10478   <span class="keyword">if</span> hasUnit <span class="constant">&amp;&amp;</span> hasEq <span class="constant">&amp;&amp;</span> hasHEq <span class="keyword">then</span> mkNoConfusion declName
10479 
<span class="keyword">10480 private</span> <span class="keyword">def</span> <span class="function-name">addDefaults</span> (lctx : LocalContext) (defaultAuxDecls : Array (Name <span class="constant">&#215;</span> Expr <span class="constant">&#215;</span> Expr)) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
10481   <span class="keyword">let</span> localInsts &#8592; getLocalInstances
10482   withLCtx lctx localInsts <span class="keyword">do</span>
10483     defaultAuxDecls.forM <span class="keyword">fun</span> (declName, type, value) <span class="constant">=&gt;</span> <span class="keyword">do</span>
10484       <span class="keyword">let</span> value &#8592; instantiateMVars value
10485       <span class="keyword">if</span> value.hasExprMVar <span class="keyword">then</span>
10486         throwError <span class="string">"invalid default value for field, it contains metavariables{indentExpr value}"</span>
10487       <span class="comment-delimiter">/- </span><span class="comment">The identity function is used as "marker". -/</span>
10488       <span class="keyword">let</span> value &#8592; mkId value
10489       discard <span class="constant">&lt;</span>| mkAuxDefinition declName type value (zeta <span class="constant">:=</span> true)
10490       setReducibleAttribute declName
10491 
<span class="keyword">10492 private</span> <span class="keyword">def</span> <span class="function-name">elabStructureView</span> (view : StructView) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
10493   view.fields.forM <span class="keyword">fun</span> field <span class="constant">=&gt;</span> <span class="keyword">do</span>
10494     <span class="keyword">if</span> field.declName <span class="constant">==</span> view.ctor.declName <span class="keyword">then</span>
10495       throwErrorAt field.ref <span class="string">"invalid field name '{field.name}', it is equal to structure constructor name"</span>
10496     addAuxDeclarationRanges field.declName field.ref field.ref
10497   <span class="keyword">let</span> numExplicitParams <span class="constant">:=</span> view.params.size
10498   <span class="keyword">let</span> type &#8592; Term.elabType view.type
10499   <span class="keyword">unless</span> validStructType type <span class="keyword">do</span> throwErrorAt view.type <span class="string">"expected Type"</span>
10500   withRef view.ref <span class="keyword">do</span>
10501   withParents view <span class="constant">0</span> <span class="constant">#</span>[] <span class="keyword">fun</span> fieldInfos <span class="constant">=&gt;</span>
10502   withFields view.fields <span class="constant">0</span> fieldInfos <span class="keyword">fun</span> fieldInfos <span class="constant">=&gt;</span> <span class="keyword">do</span>
10503     Term.synthesizeSyntheticMVarsNoPostponing
10504     <span class="keyword">let</span> u &#8592; getResultUniverse type
10505     <span class="keyword">let</span> inferLevel &#8592; shouldInferResultUniverse u
10506     withUsed view.scopeVars view.params fieldInfos <span class="constant">$</span> <span class="keyword">fun</span> scopeVars <span class="constant">=&gt;</span> <span class="keyword">do</span>
10507       <span class="keyword">let</span> numParams <span class="constant">:=</span> scopeVars.size <span class="constant">+</span> numExplicitParams
10508       <span class="keyword">let</span> fieldInfos &#8592; levelMVarToParam scopeVars view.params fieldInfos
10509       <span class="keyword">let</span> type &#8592; withRef view.ref <span class="keyword">do</span>
10510         <span class="keyword">if</span> inferLevel <span class="keyword">then</span>
10511           updateResultingUniverse fieldInfos type
10512         <span class="keyword">else</span>
10513           checkResultingUniverse (&#8592; getResultUniverse type)
10514           pure type
10515       trace[Elab.<span class="keyword">structure</span><span class="function-name">]</span> <span class="string">"type: {type}"</span>
10516       <span class="keyword">let</span> usedLevelNames &#8592; collectLevelParamsInStructure type scopeVars view.params fieldInfos
10517       <span class="keyword">match</span> sortDeclLevelParams view.scopeLevelNames view.allUserLevelNames usedLevelNames <span class="keyword">with</span>
10518       | Except.error msg      <span class="constant">=&gt;</span> withRef view.ref <span class="constant">&lt;</span>| throwError msg
10519       | Except.ok levelParams <span class="constant">=&gt;</span>
10520         <span class="keyword">let</span> params <span class="constant">:=</span> scopeVars <span class="constant">++</span> view.params
10521         <span class="keyword">let</span> ctor &#8592; mkCtor view levelParams params fieldInfos
10522         <span class="keyword">let</span> type &#8592; mkForallFVars params type
10523         <span class="keyword">let</span> type &#8592; instantiateMVars type
10524         <span class="keyword">let</span> indType <span class="constant">:=</span> { name <span class="constant">:=</span> view.declName, type <span class="constant">:=</span> type, ctors <span class="constant">:=</span> [ctor] : InductiveType }
10525         <span class="keyword">let</span> decl    <span class="constant">:=</span> Declaration.inductDecl levelParams params.size [indType] view.modifiers.isUnsafe
10526         Term.ensureNoUnassignedMVars decl
10527         addDecl decl
10528         <span class="keyword">let</span> projInfos <span class="constant">:=</span> (fieldInfos.filter <span class="keyword">fun</span> (info : StructFieldInfo) <span class="constant">=&gt;</span> <span class="constant">!</span>info.isFromParent).toList.map <span class="keyword">fun</span> (info : StructFieldInfo) <span class="constant">=&gt;</span>
10529           { declName <span class="constant">:=</span> info.declName, inferMod <span class="constant">:=</span> info.inferMod : ProjectionInfo }
10530         addProjections view.declName projInfos view.isClass
10531         mkAuxConstructions view.declName
10532         <span class="keyword">let</span> instParents &#8592; fieldInfos.filterM <span class="keyword">fun</span> info <span class="constant">=&gt;</span> <span class="keyword">do</span>
10533           <span class="keyword">let</span> decl &#8592; Term.getFVarLocalDecl<span class="constant">!</span> info.fvar
10534           pure (info.isSubobject <span class="constant">&amp;&amp;</span> decl.binderInfo.isInstImplicit)
10535         <span class="keyword">let</span> projInstances <span class="constant">:=</span> instParents.toList.map <span class="keyword">fun</span> info <span class="constant">=&gt;</span> info.declName
10536         Term.applyAttributesAt view.declName view.modifiers.attrs AttributeApplicationTime.afterTypeChecking
10537         projInstances.forM <span class="keyword">fun</span> declName <span class="constant">=&gt;</span> addInstance declName AttributeKind.global (eval_prio default)
10538         <span class="keyword">let</span> lctx &#8592; getLCtx
10539         <span class="keyword">let</span> fieldsWithDefault <span class="constant">:=</span> fieldInfos.filter <span class="keyword">fun</span> info <span class="constant">=&gt;</span> info.value?.isSome
10540         <span class="keyword">let</span> defaultAuxDecls &#8592; fieldsWithDefault.mapM <span class="keyword">fun</span> info <span class="constant">=&gt;</span> <span class="keyword">do</span>
10541           <span class="keyword">let</span> type &#8592; inferType info.fvar
10542           pure (info.declName <span class="constant">++</span> `_default, type, info.value?.get<span class="constant">!</span>)
10543         <span class="comment-delimiter">/- </span><span class="comment">The `lctx` and `defaultAuxDecls` are used to create the auxiliary `_default` declarations
10544            The parameters `params` for these definitions must be marked as implicit, and all others as explicit. -/</span>
10545         <span class="keyword">let</span> lctx <span class="constant">:=</span>
10546           params.foldl (init <span class="constant">:=</span> lctx) <span class="keyword">fun</span> (lctx : LocalContext) (p : Expr) <span class="constant">=&gt;</span>
10547             lctx.setBinderInfo p.fvarId<span class="constant">!</span> BinderInfo.implicit
10548         <span class="keyword">let</span> lctx <span class="constant">:=</span>
10549           fieldInfos.foldl (init <span class="constant">:=</span> lctx) <span class="keyword">fun</span> (lctx : LocalContext) (info : StructFieldInfo) <span class="constant">=&gt;</span>
10550             <span class="keyword">if</span> info.isFromParent <span class="keyword">then</span> lctx <span class="comment-delimiter">-- </span><span class="comment">`fromParent` fields are elaborated as let-decls, and are zeta-expanded when creating `_default`.
</span>10551             <span class="keyword">else</span> lctx.setBinderInfo info.fvar.fvarId<span class="constant">!</span> BinderInfo.default
10552         addDefaults lctx defaultAuxDecls
10553 
<span class="comment-delimiter">10554 /-</span><span class="comment">
10555 leading_parser (structureTk &lt;|&gt; classTk) &gt;&gt; declId &gt;&gt; many Term.bracketedBinder &gt;&gt; optional &#171;</span>extends<span class="comment">&#187; &gt;&gt; Term.optType &gt;&gt; " := " &gt;&gt; optional structCtor &gt;&gt; structFields &gt;&gt; optDeriving
10556 
10557 where
10558 def &#171;</span>extends<span class="comment">&#187; := leading_parser " extends " &gt;&gt; sepBy1 termParser ", "
10559 def typeSpec := leading_parser " : " &gt;&gt; termParser
10560 def optType : Parser := optional typeSpec
10561 
10562 def structFields         := leading_parser many (structExplicitBinder &lt;|&gt; structImplicitBinder &lt;|&gt; structInstBinder)
10563 def structCtor           := leading_parser try (declModifiers &gt;&gt; ident &gt;&gt; optional inferMod &gt;&gt; " :: ")
10564 
10565 -/</span>
<span class="keyword">10566 def</span> <span class="function-name">elabStructure</span> (modifiers : Modifiers) (stx : Syntax) : CommandElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
10567   checkValidInductiveModifier modifiers
10568   <span class="keyword">let</span> isClass   <span class="constant">:=</span> stx[<span class="constant">0</span>].getKind <span class="constant">==</span> ``Parser.Command.classTk
10569   <span class="keyword">let</span> modifiers <span class="constant">:=</span> <span class="keyword">if</span> isClass <span class="keyword">then</span> modifiers.addAttribute { name <span class="constant">:=</span> `<span class="keyword">class</span> <span class="function-name">}</span> <span class="keyword">else</span> modifiers
10570   <span class="keyword">let</span> declId    <span class="constant">:=</span> stx[<span class="constant">1</span>]
10571   <span class="keyword">let</span> params    <span class="constant">:=</span> stx[<span class="constant">2</span>].getArgs
10572   <span class="keyword">let</span> exts      <span class="constant">:=</span> stx[<span class="constant">3</span>]
10573   <span class="keyword">let</span> parents   <span class="constant">:=</span> <span class="keyword">if</span> exts.isNone <span class="keyword">then</span> <span class="constant">#</span>[] <span class="keyword">else</span> exts[<span class="constant">0</span>][<span class="constant">1</span>].getSepArgs
10574   <span class="keyword">let</span> optType   <span class="constant">:=</span> stx[<span class="constant">4</span>]
10575   <span class="keyword">let</span> derivingClassViews &#8592; getOptDerivingClasses stx[<span class="constant">6</span>]
10576   <span class="keyword">let</span> type &#8592; <span class="keyword">if</span> optType.isNone <span class="keyword">then</span> `(<span class="type">Sort</span> <span class="preprocessor">_</span>) <span class="keyword">else</span> pure optType[<span class="constant">0</span>][<span class="constant">1</span>]
10577   <span class="keyword">let</span> declName &#8592;
10578     runTermElabM none <span class="keyword">fun</span> scopeVars <span class="constant">=&gt;</span> <span class="keyword">do</span>
10579       <span class="keyword">let</span> scopeLevelNames &#8592; Term.getLevelNames
10580       <span class="keyword">let</span> &#10216;name, declName, allUserLevelNames&#10217; &#8592; Elab.expandDeclId (&#8592; getCurrNamespace) scopeLevelNames declId modifiers
10581       addDeclarationRanges declName stx
10582       Term.withDeclName declName <span class="keyword">do</span>
10583         <span class="keyword">let</span> ctor &#8592; expandCtor stx modifiers declName
10584         <span class="keyword">let</span> fields &#8592; expandFields stx modifiers declName
10585         Term.withLevelNames allUserLevelNames <span class="constant">&lt;</span>| Term.withAutoBoundImplicit <span class="constant">&lt;</span>|
10586           Term.elabBinders params <span class="keyword">fun</span> params <span class="constant">=&gt;</span> <span class="keyword">do</span>
10587             Term.synthesizeSyntheticMVarsNoPostponing
10588             <span class="keyword">let</span> params &#8592; Term.addAutoBoundImplicits params
10589             <span class="keyword">let</span> allUserLevelNames &#8592; Term.getLevelNames
10590             elabStructureView {
10591               ref               <span class="constant">:=</span> stx
10592               modifiers         <span class="constant">:=</span> modifiers
10593               scopeLevelNames   <span class="constant">:=</span> scopeLevelNames
10594               allUserLevelNames <span class="constant">:=</span> allUserLevelNames
10595               declName          <span class="constant">:=</span> declName
10596               isClass           <span class="constant">:=</span> isClass
10597               scopeVars         <span class="constant">:=</span> scopeVars
10598               params            <span class="constant">:=</span> params
10599               parents           <span class="constant">:=</span> parents
10600               type              <span class="constant">:=</span> type
10601               ctor              <span class="constant">:=</span> ctor
10602               fields            <span class="constant">:=</span> fields
10603             }
10604             <span class="keyword">unless</span> isClass <span class="keyword">do</span>
10605               mkSizeOfInstances declName
10606             <span class="keyword">return</span> declName
10607   derivingClassViews.forM <span class="keyword">fun</span> view <span class="constant">=&gt;</span> view.applyHandlers <span class="constant">#</span>[declName]
10608 
<span class="keyword">10609 builtin_initialize</span> registerTraceClass `Elab.<span class="keyword">structure</span>
10610 
<span class="keyword">10611 end</span> Lean.Elab.Command
10612 ::::::::::::::
10613 Elab<span class="constant">/</span>Syntax.lean
10614 ::::::::::::::
<span class="comment-delimiter">10615 /-</span><span class="comment">
10616 Copyright (c) 2020 Microsoft Corporation. All rights reserved.
10617 Released under Apache 2.0 license as described in the file LICENSE.
10618 Authors: Leonardo de Moura
10619 -/</span>
<span class="keyword">10620 import</span> Lean.Elab.Command
<span class="keyword">10621 import</span> Lean.Parser.Syntax
10622 
<span class="keyword">10623 namespace</span> Lean.Elab.Term
<span class="comment-delimiter">10624 /-</span><span class="comment">
10625 Expand `optional &#171;</span>precedence<span class="comment">&#187;` where
10626  &#171;</span>precedence<span class="comment">&#187; := leading_parser " : " &gt;&gt; precedenceParser -/</span>
<span class="keyword">10627 def</span> <span class="function-name">expandOptPrecedence</span> (stx : Syntax) : MacroM (Option Nat) <span class="constant">:=</span>
10628   <span class="keyword">if</span> stx.isNone <span class="keyword">then</span>
10629     <span class="keyword">return</span> none
10630   <span class="keyword">else</span>
10631     <span class="keyword">return</span> some (&#8592; evalPrec stx[<span class="constant">0</span>][<span class="constant">1</span>])
10632 
<span class="keyword">10633 private</span> <span class="keyword">def</span> <span class="function-name">mkParserSeq</span> (ds : Array Syntax) : TermElabM Syntax <span class="constant">:=</span> <span class="keyword">do</span>
10634   <span class="keyword">if</span> ds.size <span class="constant">==</span> <span class="constant">0</span> <span class="keyword">then</span>
10635     throwUnsupportedSyntax
10636   <span class="keyword">else</span> <span class="keyword">if</span> ds.size <span class="constant">==</span> <span class="constant">1</span> <span class="keyword">then</span>
10637     pure ds[<span class="constant">0</span>]
10638   <span class="keyword">else</span>
10639     <span class="keyword">let</span> <span class="keyword">mut</span> r <span class="constant">:=</span> ds[<span class="constant">0</span>]
10640     <span class="keyword">for</span> d <span class="keyword">in</span> ds[<span class="constant">1</span>:ds.size] <span class="keyword">do</span>
10641       r &#8592; `(ParserDescr.binary `andthen <span class="constant">$</span>r <span class="constant">$</span>d)
10642     <span class="keyword">return</span> r
10643 
<span class="keyword">10644 structure</span> <span class="function-name">ToParserDescrContext</span> <span class="keyword">where</span>
10645   catName  : Name
10646   first    : Bool
10647   leftRec  : Bool <span class="comment-delimiter">-- </span><span class="comment">true iff left recursion is allowed
</span>10648   <span class="comment-delimiter">/- </span><span class="comment">See comment at `Parser.ParserCategory`. -/</span>
10649   behavior : Parser.LeadingIdentBehavior
10650 
<span class="keyword">10651 abbrev</span> ToParserDescrM <span class="constant">:=</span> ReaderT ToParserDescrContext (StateRefT (Option Nat) TermElabM)
<span class="keyword">10652 private</span> <span class="keyword">def</span> <span class="function-name">markAsTrailingParser</span> (lhsPrec : Nat) : ToParserDescrM Unit <span class="constant">:=</span> set (some lhsPrec)
10653 
<span class="doc">10654 @[inline]</span> <span class="keyword">private</span> <span class="keyword">def</span> <span class="function-name">withNotFirst</span> {&#945;} (x : ToParserDescrM &#945;) : ToParserDescrM &#945; <span class="constant">:=</span>
10655   withReader (<span class="keyword">fun</span> ctx <span class="constant">=&gt;</span> { ctx <span class="keyword">with</span> first <span class="constant">:=</span> false }) x
10656 
<span class="doc">10657 @[inline]</span> <span class="keyword">private</span> <span class="keyword">def</span> <span class="function-name">withNestedParser</span> {&#945;} (x : ToParserDescrM &#945;) : ToParserDescrM &#945; <span class="constant">:=</span>
10658   withReader (<span class="keyword">fun</span> ctx <span class="constant">=&gt;</span> { ctx <span class="keyword">with</span> leftRec <span class="constant">:=</span> false, first <span class="constant">:=</span> false }) x
10659 
<span class="keyword">10660 def</span> <span class="function-name">checkLeftRec</span> (stx : Syntax) : ToParserDescrM Bool <span class="constant">:=</span> <span class="keyword">do</span>
10661   <span class="keyword">let</span> ctx &#8592; read
10662   <span class="keyword">unless</span> ctx.first <span class="constant">&amp;&amp;</span> stx.getKind <span class="constant">==</span> `Lean.Parser.Syntax.cat <span class="keyword">do</span>
10663     <span class="keyword">return</span> false
10664   <span class="keyword">let</span> cat <span class="constant">:=</span> stx[<span class="constant">0</span>].getId.eraseMacroScopes
10665   <span class="keyword">unless</span> cat <span class="constant">==</span> ctx.catName <span class="keyword">do</span>
10666     <span class="keyword">return</span> false
10667   <span class="keyword">let</span> prec? &#8592; liftMacroM <span class="constant">&lt;</span>| expandOptPrecedence stx[<span class="constant">1</span>]
10668   <span class="keyword">unless</span> ctx.leftRec <span class="keyword">do</span>
10669     throwErrorAt stx[<span class="constant">3</span>] <span class="string">"invalid occurrence of '{cat}', parser algorithm does not allow this form of left recursion"</span>
10670   markAsTrailingParser (prec?.getD <span class="constant">0</span>)
10671   <span class="keyword">return</span> true
10672 
<span class="comment-delimiter">10673 /-</span><span class="comment">-
10674   Given a `stx` of category `syntax`, return a pair `(newStx, lhsPrec?)`,
10675   where `newStx` is of category `term`. After elaboration, `newStx` should have type
10676   `TrailingParserDescr` if `lhsPrec?.isSome`, and `ParserDescr` otherwise. -/</span>
<span class="keyword">10677 partial</span> <span class="keyword">def</span> <span class="function-name">toParserDescr</span> (stx : Syntax) (catName : Name) : TermElabM (Syntax <span class="constant">&#215;</span> Option Nat) <span class="constant">:=</span> <span class="keyword">do</span>
10678   <span class="keyword">let</span> env &#8592; getEnv
10679   <span class="keyword">let</span> behavior <span class="constant">:=</span> Parser.leadingIdentBehavior env catName
10680   (process stx { catName <span class="constant">:=</span> catName, first <span class="constant">:=</span> true, leftRec <span class="constant">:=</span> true, behavior <span class="constant">:=</span> behavior }).run none
<span class="keyword">10681 where</span>
10682   process (stx : Syntax) : ToParserDescrM Syntax <span class="constant">:=</span> withRef stx <span class="keyword">do</span>
10683     <span class="keyword">let</span> kind <span class="constant">:=</span> stx.getKind
10684     <span class="keyword">if</span> kind <span class="constant">==</span> nullKind <span class="keyword">then</span>
10685       processSeq stx
10686     <span class="keyword">else</span> <span class="keyword">if</span> kind <span class="constant">==</span> choiceKind <span class="keyword">then</span>
10687       process stx[<span class="constant">0</span>]
10688     <span class="keyword">else</span> <span class="keyword">if</span> kind <span class="constant">==</span> `Lean.Parser.Syntax.paren <span class="keyword">then</span>
10689       process stx[<span class="constant">1</span>]
10690     <span class="keyword">else</span> <span class="keyword">if</span> kind <span class="constant">==</span> `Lean.Parser.Syntax.cat <span class="keyword">then</span>
10691       processNullaryOrCat stx
10692     <span class="keyword">else</span> <span class="keyword">if</span> kind <span class="constant">==</span> `Lean.Parser.Syntax.unary <span class="keyword">then</span>
10693       processUnary stx
10694     <span class="keyword">else</span> <span class="keyword">if</span> kind <span class="constant">==</span> `Lean.Parser.Syntax.binary <span class="keyword">then</span>
10695       processBinary stx
10696     <span class="keyword">else</span> <span class="keyword">if</span> kind <span class="constant">==</span> `Lean.Parser.Syntax.sepBy <span class="keyword">then</span>
10697       processSepBy stx
10698     <span class="keyword">else</span> <span class="keyword">if</span> kind <span class="constant">==</span> `Lean.Parser.Syntax.sepBy1 <span class="keyword">then</span>
10699       processSepBy1 stx
10700     <span class="keyword">else</span> <span class="keyword">if</span> kind <span class="constant">==</span> `Lean.Parser.Syntax.atom <span class="keyword">then</span>
10701       processAtom stx
10702     <span class="keyword">else</span> <span class="keyword">if</span> kind <span class="constant">==</span> `Lean.Parser.Syntax.nonReserved <span class="keyword">then</span>
10703       processNonReserved stx
10704     <span class="keyword">else</span>
10705       <span class="keyword">let</span> stxNew? &#8592; liftM (liftMacroM (expandMacro? stx) : TermElabM <span class="preprocessor">_</span>)
10706       <span class="keyword">match</span> stxNew? <span class="keyword">with</span>
10707       | some stxNew <span class="constant">=&gt;</span> process stxNew
10708       | none <span class="constant">=&gt;</span> throwErrorAt stx <span class="string">"unexpected syntax kind of category `syntax`: {kind}"</span>
10709 
10710   <span class="comment-delimiter">/- </span><span class="comment">Sequence (aka NullNode) -/</span>
10711   processSeq (stx : Syntax) <span class="constant">:=</span> <span class="keyword">do</span>
10712     <span class="keyword">let</span> args <span class="constant">:=</span> stx.getArgs
10713     <span class="keyword">if</span> (&#8592; checkLeftRec stx[<span class="constant">0</span>]) <span class="keyword">then</span>
10714       <span class="keyword">if</span> args.size <span class="constant">==</span> <span class="constant">1</span> <span class="keyword">then</span> throwErrorAt stx <span class="string">"invalid atomic left recursive syntax"</span>
10715       <span class="keyword">let</span> args <span class="constant">:=</span> args.eraseIdx <span class="constant">0</span>
10716       <span class="keyword">let</span> args &#8592; args.mapM <span class="keyword">fun</span> arg <span class="constant">=&gt;</span> withNestedParser <span class="keyword">do</span> process arg
10717       mkParserSeq args
10718     <span class="keyword">else</span>
10719       <span class="keyword">let</span> args &#8592; args.mapIdxM <span class="keyword">fun</span> i arg <span class="constant">=&gt;</span> withReader (<span class="keyword">fun</span> ctx <span class="constant">=&gt;</span> { ctx <span class="keyword">with</span> first <span class="constant">:=</span> ctx.first <span class="constant">&amp;&amp;</span> i.val <span class="constant">==</span> <span class="constant">0</span> }) <span class="keyword">do</span> process arg
10720       mkParserSeq args
10721 
10722   <span class="comment-delimiter">/- </span><span class="comment">Resolve the given parser name and return a list of candidates.
10723      Each candidate is a pair `(resolvedParserName, isDescr)`.
10724      `isDescr == true` if the type of `resolvedParserName` is a `ParserDescr`. -/</span>
10725   resolveParserName (parserName : Name) : ToParserDescrM (List (Name <span class="constant">&#215;</span> Bool)) <span class="constant">:=</span> <span class="keyword">do</span>
10726     <span class="keyword">try</span>
10727       <span class="keyword">let</span> candidates &#8592; resolveGlobalConstWithInfos (&#8592; getRef) parserName
10728       <span class="comment-delimiter">/- </span><span class="comment">Convert `candidates` in a list of pairs `(c, isDescr)`, where `c` is the parser name,
10729          and `isDescr` is true iff `c` has type `Lean.ParserDescr` or `Lean.TrailingParser` -/</span>
10730       <span class="keyword">let</span> env &#8592; getEnv
10731       candidates.filterMap <span class="keyword">fun</span> c <span class="constant">=&gt;</span>
10732          <span class="keyword">match</span> env.find? c <span class="keyword">with</span>
10733          | none      <span class="constant">=&gt;</span> none
10734          | some info <span class="constant">=&gt;</span>
10735            <span class="keyword">match</span> info.type <span class="keyword">with</span>
10736           | Expr.const `Lean.Parser.TrailingParser <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> (c, false)
10737           | Expr.const `Lean.Parser.Parser <span class="preprocessor">_</span> <span class="preprocessor">_</span>         <span class="constant">=&gt;</span> (c, false)
10738           | Expr.const `Lean.ParserDescr <span class="preprocessor">_</span> <span class="preprocessor">_</span>           <span class="constant">=&gt;</span> (c, true)
10739           | Expr.const `Lean.TrailingParserDescr <span class="preprocessor">_</span> <span class="preprocessor">_</span>   <span class="constant">=&gt;</span> (c, true)
10740           | <span class="preprocessor">_</span>                                          <span class="constant">=&gt;</span> none
10741     <span class="keyword">catch</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">return</span> []
10742 
10743   ensureNoPrec (stx : Syntax) <span class="constant">:=</span>
10744     <span class="keyword">unless</span> stx[<span class="constant">1</span>].isNone <span class="keyword">do</span>
10745       throwErrorAt stx[<span class="constant">1</span>] <span class="string">"unexpected precedence"</span>
10746 
10747   processParserCategory (stx : Syntax) <span class="constant">:=</span> <span class="keyword">do</span>
10748     <span class="keyword">let</span> catName <span class="constant">:=</span> stx[<span class="constant">0</span>].getId.eraseMacroScopes
10749     <span class="keyword">if</span> (&#8592; read).first <span class="constant">&amp;&amp;</span> catName <span class="constant">==</span> (&#8592; read).catName <span class="keyword">then</span>
10750       throwErrorAt stx <span class="string">"invalid atomic left recursive syntax"</span>
10751     <span class="keyword">let</span> prec? &#8592; liftMacroM <span class="constant">&lt;</span>| expandOptPrecedence stx[<span class="constant">1</span>]
10752     <span class="keyword">let</span> prec <span class="constant">:=</span> prec?.getD <span class="constant">0</span>
10753     `(ParserDescr.cat <span class="constant">$</span>(quote catName) <span class="constant">$</span>(quote prec))
10754 
10755   processNullaryOrCat (stx : Syntax) <span class="constant">:=</span> <span class="keyword">do</span>
10756     <span class="keyword">let</span> id <span class="constant">:=</span> stx[<span class="constant">0</span>].getId.eraseMacroScopes
10757     <span class="keyword">match</span> (&#8592; withRef stx[<span class="constant">0</span>] <span class="constant">&lt;</span>| resolveParserName id) <span class="keyword">with</span>
10758     | [(c, true)]      <span class="constant">=&gt;</span> ensureNoPrec stx; <span class="keyword">return</span> mkIdentFrom stx c
10759     | [(c, false)]     <span class="constant">=&gt;</span> ensureNoPrec stx; `(ParserDescr.parser <span class="constant">$</span>(quote c))
10760     | cs<span class="constant">@</span>(<span class="preprocessor">_</span> :: <span class="preprocessor">_</span> :: <span class="preprocessor">_</span>) <span class="constant">=&gt;</span> throwError <span class="string">"ambiguous parser declaration {cs.map (&#183;.1)}"</span>
10761     | [] <span class="constant">=&gt;</span>
10762       <span class="keyword">if</span> Parser.isParserCategory (&#8592; getEnv) id <span class="keyword">then</span>
10763         processParserCategory stx
10764       <span class="keyword">else</span> <span class="keyword">if</span> (&#8592; Parser.isParserAlias id) <span class="keyword">then</span>
10765         ensureNoPrec stx
10766         Parser.ensureConstantParserAlias id
10767         `(ParserDescr.const <span class="constant">$</span>(quote id))
10768       <span class="keyword">else</span>
10769         throwError <span class="string">"unknown parser declaration/category/alias '{id}'"</span>
10770 
10771   processUnary (stx : Syntax) <span class="constant">:=</span> <span class="keyword">do</span>
10772     <span class="keyword">let</span> aliasName <span class="constant">:=</span> (stx[<span class="constant">0</span>].getId).eraseMacroScopes
10773     Parser.ensureUnaryParserAlias aliasName
10774     <span class="keyword">let</span> d &#8592; withNestedParser <span class="keyword">do</span> process stx[<span class="constant">2</span>]
10775     `(ParserDescr.unary <span class="constant">$</span>(quote aliasName) <span class="constant">$</span>d)
10776 
10777   processBinary (stx : Syntax) <span class="constant">:=</span> <span class="keyword">do</span>
10778     <span class="keyword">let</span> aliasName <span class="constant">:=</span> (stx[<span class="constant">0</span>].getId).eraseMacroScopes
10779     Parser.ensureBinaryParserAlias aliasName
10780     <span class="keyword">let</span> d&#8321; &#8592; withNestedParser <span class="keyword">do</span> process stx[<span class="constant">2</span>]
10781     <span class="keyword">let</span> d&#8322; &#8592; withNestedParser <span class="keyword">do</span> process stx[<span class="constant">4</span>]
10782     `(ParserDescr.binary <span class="constant">$</span>(quote aliasName) <span class="constant">$</span>d&#8321; <span class="constant">$</span>d&#8322;)
10783 
10784   processSepBy (stx : Syntax) <span class="constant">:=</span> <span class="keyword">do</span>
10785     <span class="keyword">let</span> p &#8592; withNestedParser <span class="constant">$</span> process stx[<span class="constant">1</span>]
10786     <span class="keyword">let</span> sep <span class="constant">:=</span> stx[<span class="constant">3</span>]
10787     <span class="keyword">let</span> psep &#8592; <span class="keyword">if</span> stx[<span class="constant">4</span>].isNone <span class="keyword">then</span> `(ParserDescr.symbol <span class="constant">$</span>sep) <span class="keyword">else</span> process stx[<span class="constant">4</span>][<span class="constant">1</span>]
10788     <span class="keyword">let</span> allowTrailingSep <span class="constant">:=</span> <span class="constant">!</span>stx[<span class="constant">5</span>].isNone
10789     `(ParserDescr.sepBy <span class="constant">$</span>p <span class="constant">$</span>sep <span class="constant">$</span>psep <span class="constant">$</span>(quote allowTrailingSep))
10790 
10791   processSepBy1 (stx : Syntax) <span class="constant">:=</span> <span class="keyword">do</span>
10792     <span class="keyword">let</span> p &#8592; withNestedParser <span class="keyword">do</span> process stx[<span class="constant">1</span>]
10793     <span class="keyword">let</span> sep <span class="constant">:=</span> stx[<span class="constant">3</span>]
10794     <span class="keyword">let</span> psep &#8592; <span class="keyword">if</span> stx[<span class="constant">4</span>].isNone <span class="keyword">then</span> `(ParserDescr.symbol <span class="constant">$</span>sep) <span class="keyword">else</span> process stx[<span class="constant">4</span>][<span class="constant">1</span>]
10795     <span class="keyword">let</span> allowTrailingSep <span class="constant">:=</span> <span class="constant">!</span>stx[<span class="constant">5</span>].isNone
10796     `(ParserDescr.sepBy1 <span class="constant">$</span>p <span class="constant">$</span>sep <span class="constant">$</span>psep <span class="constant">$</span>(quote allowTrailingSep))
10797 
10798   processAtom (stx : Syntax) <span class="constant">:=</span> <span class="keyword">do</span>
10799     <span class="keyword">match</span> stx[<span class="constant">0</span>].isStrLit? <span class="keyword">with</span>
10800     | some atom <span class="constant">=&gt;</span>
10801       <span class="comment-delimiter">/- </span><span class="comment">For syntax categories where initialized with `LeadingIdentBehavior` different from default (e.g., `tactic`), we automatically mark
10802          the first symbol as nonReserved. -/</span>
10803       <span class="keyword">if</span> (&#8592; read).behavior <span class="constant">!=</span> Parser.LeadingIdentBehavior.default <span class="constant">&amp;&amp;</span> (&#8592; read).first <span class="keyword">then</span>
10804         `(ParserDescr.nonReservedSymbol <span class="constant">$</span>(quote atom) false)
10805       <span class="keyword">else</span>
10806         `(ParserDescr.symbol <span class="constant">$</span>(quote atom))
10807     | none <span class="constant">=&gt;</span> throwUnsupportedSyntax
10808 
10809   processNonReserved (stx : Syntax) <span class="constant">:=</span> <span class="keyword">do</span>
10810     <span class="keyword">match</span> stx[<span class="constant">1</span>].isStrLit? <span class="keyword">with</span>
10811     | some atom <span class="constant">=&gt;</span> `(ParserDescr.nonReservedSymbol <span class="constant">$</span>(quote atom) false)
10812     | none      <span class="constant">=&gt;</span> throwUnsupportedSyntax
10813 
10814 
<span class="keyword">10815 end</span> Term
10816 
<span class="keyword">10817 namespace</span> Command
<span class="keyword">10818 open</span> Lean.Syntax
<span class="keyword">10819 open</span> Lean.Parser.Term <span class="keyword">hiding</span> macroArg
<span class="keyword">10820 open</span> Lean.Parser.Command
10821 
<span class="keyword">10822 private</span> <span class="keyword">def</span> <span class="function-name">getCatSuffix</span> (catName : Name) : String <span class="constant">:=</span>
10823   <span class="keyword">match</span> catName <span class="keyword">with</span>
10824   | Name.str <span class="preprocessor">_</span> s <span class="preprocessor">_</span> <span class="constant">=&gt;</span> s
10825   | <span class="preprocessor">_</span>              <span class="constant">=&gt;</span> <span class="warning">unreachable</span><span class="constant">!</span>
10826 
<span class="keyword">10827 private</span> <span class="keyword">def</span> <span class="function-name">declareSyntaxCatQuotParser</span> (catName : Name) : CommandElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
10828   <span class="keyword">let</span> quotSymbol <span class="constant">:=</span> <span class="string">"`("</span> <span class="constant">++</span> getCatSuffix catName <span class="constant">++</span> <span class="string">"|"</span>
10829   <span class="keyword">let</span> name <span class="constant">:=</span> catName <span class="constant">++</span> `quot
10830   <span class="comment-delimiter">-- </span><span class="comment">TODO(Sebastian): this might confuse the pretty printer, but it lets us reuse the elaborator
</span>10831   <span class="keyword">let</span> kind <span class="constant">:=</span> ``Lean.Parser.Term.quot
10832   <span class="keyword">let</span> cmd &#8592; `(
10833     <span class="doc">@[termParser]</span> <span class="keyword">def</span> <span class="function-name">$</span>(mkIdent name) : Lean.ParserDescr <span class="constant">:=</span>
10834       Lean.ParserDescr.node <span class="constant">$</span>(quote kind) <span class="constant">$</span>(quote Lean.Parser.maxPrec)
10835         (Lean.ParserDescr.binary `andthen (Lean.ParserDescr.symbol <span class="constant">$</span>(quote quotSymbol))
10836           (Lean.ParserDescr.binary `andthen (Lean.ParserDescr.cat <span class="constant">$</span>(quote catName) <span class="constant">0</span>) (Lean.ParserDescr.symbol <span class="string">")"</span>))))
10837   elabCommand cmd
10838 
<span class="doc">10839 @[builtinCommandElab syntaxCat]</span> <span class="keyword">def</span> <span class="function-name">elabDeclareSyntaxCat</span> : CommandElab <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="constant">=&gt;</span> <span class="keyword">do</span>
10840   <span class="keyword">let</span> catName  <span class="constant">:=</span> stx[<span class="constant">1</span>].getId
10841   <span class="keyword">let</span> attrName <span class="constant">:=</span> catName.appendAfter <span class="string">"Parser"</span>
10842   <span class="keyword">let</span> env &#8592; getEnv
10843   <span class="keyword">let</span> env &#8592; liftIO <span class="constant">$</span> Parser.registerParserCategory env attrName catName
10844   setEnv env
10845   declareSyntaxCatQuotParser catName
10846 
<span class="comment-delimiter">10847 /-</span><span class="comment">-
10848   Auxiliary function for creating declaration names from parser descriptions.
10849   Example:
10850   Given
10851   ```
10852   syntax term "+" term : term
10853   syntax "[" sepBy(term, ", ") "]"  : term
10854   ```
10855   It generates the names `term_+_` and `term[_,]`
10856 -/</span>
<span class="keyword">10857 partial</span> <span class="keyword">def</span> <span class="function-name">mkNameFromParserSyntax</span> (catName : Name) (stx : Syntax) : CommandElabM Name <span class="constant">:=</span>
10858   mkUnusedBaseName <span class="constant">&lt;</span>| Name.mkSimple <span class="constant">&lt;</span>| appendCatName <span class="constant">&lt;</span>| visit stx <span class="string">""</span>
<span class="keyword">10859 where</span>
10860   visit (stx : Syntax) (acc : String) : String <span class="constant">:=</span>
10861     <span class="keyword">match</span> stx.isStrLit? <span class="keyword">with</span>
10862     | some val <span class="constant">=&gt;</span> acc <span class="constant">++</span> (val.trim.map <span class="keyword">fun</span> c <span class="constant">=&gt;</span> <span class="keyword">if</span> c.isWhitespace <span class="keyword">then</span> '_' <span class="keyword">else</span> c).capitalize
10863     | none <span class="constant">=&gt;</span>
10864       <span class="keyword">match</span> stx <span class="keyword">with</span>
10865       | Syntax.node k args <span class="constant">=&gt;</span>
10866         <span class="keyword">if</span> k <span class="constant">==</span> `Lean.Parser.Syntax.cat <span class="keyword">then</span>
10867           acc <span class="constant">++</span> <span class="string">"_"</span>
10868         <span class="keyword">else</span>
10869           args.foldl (init <span class="constant">:=</span> acc) <span class="keyword">fun</span> acc arg <span class="constant">=&gt;</span> visit arg acc
10870       | Syntax.ident ..    <span class="constant">=&gt;</span> acc
10871       | Syntax.atom ..     <span class="constant">=&gt;</span> acc
10872       | Syntax.missing     <span class="constant">=&gt;</span> acc
10873 
10874   appendCatName (str : String) <span class="constant">:=</span>
10875     <span class="keyword">match</span> catName <span class="keyword">with</span>
10876     | Name.str <span class="preprocessor">_</span> s <span class="preprocessor">_</span> <span class="constant">=&gt;</span> s <span class="constant">++</span> str
10877     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> str
10878 
<span class="comment-delimiter">10879 /- </span><span class="comment">We assume a new syntax can be treated as an atom when it starts and ends with a token.
10880    Here are examples of atom-like syntax.
10881    ```
10882    syntax "(" term ")" : term
10883    syntax "[" (sepBy term ",") "]" : term
10884    syntax "foo" : term
10885    ```
10886  -/</span>
<span class="keyword">10887 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">isAtomLikeSyntax</span> (stx : Syntax) : Bool <span class="constant">:=</span>
10888   <span class="keyword">let</span> kind <span class="constant">:=</span> stx.getKind
10889   <span class="keyword">if</span> kind <span class="constant">==</span> nullKind <span class="keyword">then</span>
10890     isAtomLikeSyntax stx[<span class="constant">0</span>] <span class="constant">&amp;&amp;</span> isAtomLikeSyntax stx[stx.getNumArgs <span class="constant">-</span> <span class="constant">1</span>]
10891   <span class="keyword">else</span> <span class="keyword">if</span> kind <span class="constant">==</span> choiceKind <span class="keyword">then</span>
10892     isAtomLikeSyntax stx[<span class="constant">0</span>] <span class="comment-delimiter">-- </span><span class="comment">see toParserDescr
</span>10893   <span class="keyword">else</span> <span class="keyword">if</span> kind <span class="constant">==</span> `Lean.Parser.Syntax.paren <span class="keyword">then</span>
10894     isAtomLikeSyntax stx[<span class="constant">1</span>]
10895   <span class="keyword">else</span>
10896     kind <span class="constant">==</span> `Lean.Parser.Syntax.atom
10897 
<span class="constant">10898 @</span>[builtinCommandElab <span class="comment">&#171;</span>syntax<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabSyntax</span> : CommandElab <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="constant">=&gt;</span> <span class="keyword">do</span>
10899   <span class="keyword">let</span> `(<span class="constant">$</span>attrKind:attrKind <span class="keyword">syntax</span> <span class="constant">$</span>[: <span class="constant">$</span>prec? ]? <span class="constant">$</span>[(name <span class="constant">:=</span> <span class="constant">$</span>name?)]? <span class="constant">$</span>[(priority <span class="constant">:=</span> <span class="constant">$</span>prio?)]? <span class="constant">$</span>[<span class="constant">$</span>ps:stx]<span class="constant">*</span> : <span class="constant">$</span>catStx) &#8592; pure stx
10900     | throwUnsupportedSyntax
10901   <span class="keyword">let</span> cat <span class="constant">:=</span> catStx.getId.eraseMacroScopes
10902   <span class="keyword">unless</span> (Parser.isParserCategory (&#8592; getEnv) cat) <span class="keyword">do</span>
10903     throwErrorAt catStx <span class="string">"unknown category '{cat}'"</span>
10904   <span class="keyword">let</span> syntaxParser <span class="constant">:=</span> mkNullNode ps
10905   <span class="comment-delimiter">-- </span><span class="comment">If the user did not provide an explicit precedence, we assign `maxPrec` to atom-like syntax and `leadPrec` otherwise.
</span>10906   <span class="keyword">let</span> precDefault  <span class="constant">:=</span> <span class="keyword">if</span> isAtomLikeSyntax syntaxParser <span class="keyword">then</span> Parser.maxPrec <span class="keyword">else</span> Parser.leadPrec
10907   <span class="keyword">let</span> prec &#8592; <span class="keyword">match</span> prec? <span class="keyword">with</span>
10908     | some prec <span class="constant">=&gt;</span> liftMacroM <span class="constant">&lt;</span>| evalPrec prec
10909     | none      <span class="constant">=&gt;</span> precDefault
10910   <span class="keyword">let</span> name &#8592; <span class="keyword">match</span> name? <span class="keyword">with</span>
10911     | some name <span class="constant">=&gt;</span> pure name.getId
10912     | none <span class="constant">=&gt;</span> mkNameFromParserSyntax cat syntaxParser
10913   <span class="keyword">let</span> prio &#8592; liftMacroM <span class="constant">&lt;</span>| evalOptPrio prio?
10914   <span class="keyword">let</span> stxNodeKind <span class="constant">:=</span> (&#8592; getCurrNamespace) <span class="constant">++</span> name
10915   <span class="keyword">let</span> catParserId <span class="constant">:=</span> mkIdentFrom stx (cat.appendAfter <span class="string">"Parser"</span>)
10916   <span class="keyword">let</span> (val, lhsPrec?) &#8592; runTermElabM none <span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> Term.toParserDescr syntaxParser cat
10917   <span class="keyword">let</span> declName <span class="constant">:=</span> mkIdentFrom stx name
10918   <span class="keyword">let</span> d &#8592;
10919     <span class="keyword">if</span> <span class="keyword">let</span> some lhsPrec <span class="constant">:=</span> lhsPrec? <span class="keyword">then</span>
10920       `(<span class="doc">@[$attrKind:attrKind $catParserId:ident $(quote prio):numLit]</span> <span class="keyword">def</span> <span class="function-name">$declName</span> : Lean.TrailingParserDescr <span class="constant">:=</span>
10921         ParserDescr.trailingNode <span class="constant">$</span>(quote stxNodeKind) <span class="constant">$</span>(quote prec) <span class="constant">$</span>(quote lhsPrec) <span class="constant">$</span>val)
10922     <span class="keyword">else</span>
10923       `(<span class="doc">@[$attrKind:attrKind $catParserId:ident $(quote prio):numLit]</span> <span class="keyword">def</span> <span class="function-name">$declName</span> : Lean.ParserDescr <span class="constant">:=</span>
10924         ParserDescr.node <span class="constant">$</span>(quote stxNodeKind) <span class="constant">$</span>(quote prec) <span class="constant">$</span>val)
10925   trace `Elab <span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> d
10926   withMacroExpansion stx d <span class="constant">&lt;</span>| elabCommand d
10927 
<span class="comment-delimiter">10928 /-</span><span class="comment">
10929 def syntaxAbbrev  := leading_parser "syntax " &gt;&gt; ident &gt;&gt; " := " &gt;&gt; many1 syntaxParser
10930 -/</span>
<span class="constant">10931 @</span>[builtinCommandElab <span class="comment">&#171;</span>syntaxAbbrev<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabSyntaxAbbrev</span> : CommandElab <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="constant">=&gt;</span> <span class="keyword">do</span>
10932   <span class="keyword">let</span> declName <span class="constant">:=</span> stx[<span class="constant">1</span>]
10933   <span class="comment-delimiter">-- </span><span class="comment">TODO: nonatomic names
</span>10934   <span class="keyword">let</span> (val, <span class="preprocessor">_</span>) &#8592; runTermElabM none <span class="constant">$</span> <span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> Term.toParserDescr stx[<span class="constant">3</span>] Name.anonymous
10935   <span class="keyword">let</span> stxNodeKind <span class="constant">:=</span> (&#8592; getCurrNamespace) <span class="constant">++</span> declName.getId
10936   <span class="keyword">let</span> stx' &#8592; `(<span class="keyword">def</span> <span class="function-name">$declName</span> : Lean.ParserDescr <span class="constant">:=</span> ParserDescr.nodeWithAntiquot <span class="constant">$</span>(quote (toString declName.getId)) <span class="constant">$</span>(quote stxNodeKind) <span class="constant">$</span>val)
10937   withMacroExpansion stx stx' <span class="constant">$</span> elabCommand stx'
10938 
<span class="keyword">10939 private</span> <span class="keyword">def</span> <span class="function-name">checkRuleKind</span> (given expected : SyntaxNodeKind) : Bool <span class="constant">:=</span>
10940   given <span class="constant">==</span> expected <span class="constant">||</span> given <span class="constant">==</span> expected <span class="constant">++</span> `antiquot
10941 
<span class="comment-delimiter">10942 /-</span><span class="comment">
10943   Remark: `k` is the user provided kind with the current namespace included.
10944   Recall that syntax node kinds contain the current namespace.
10945 -/</span>
<span class="keyword">10946 def</span> <span class="function-name">elabMacroRulesAux</span> (k : SyntaxNodeKind) (alts : Array Syntax) : CommandElabM Syntax <span class="constant">:=</span> <span class="keyword">do</span>
10947   <span class="keyword">let</span> alts &#8592; alts.mapM <span class="keyword">fun</span> alt <span class="constant">=&gt;</span> <span class="keyword">match</span> alt <span class="keyword">with</span>
10948     | `(matchAltExpr| | <span class="constant">$</span>pats,<span class="constant">*</span> <span class="constant">=&gt;</span> <span class="constant">$</span>rhs) <span class="constant">=&gt;</span> <span class="keyword">do</span>
10949       <span class="keyword">let</span> pat <span class="constant">:=</span> pats.elemsAndSeps[<span class="constant">0</span>]
10950       <span class="keyword">if</span> <span class="constant">!</span>pat.isQuot <span class="keyword">then</span>
10951         throwUnsupportedSyntax
10952       <span class="keyword">let</span> quoted <span class="constant">:=</span> getQuotContent pat
10953       <span class="keyword">let</span> k' <span class="constant">:=</span> quoted.getKind
10954       <span class="keyword">if</span> checkRuleKind k' k <span class="keyword">then</span>
10955         pure alt
10956       <span class="keyword">else</span> <span class="keyword">if</span> k' <span class="constant">==</span> choiceKind <span class="keyword">then</span>
10957          <span class="keyword">match</span> quoted.getArgs.find? <span class="keyword">fun</span> quotAlt <span class="constant">=&gt;</span> checkRuleKind quotAlt.getKind k <span class="keyword">with</span>
10958          | none        <span class="constant">=&gt;</span> throwErrorAt alt <span class="string">"invalid macro_rules alternative, expected syntax node kind '{k}'"</span>
10959          | some quoted <span class="constant">=&gt;</span>
10960            <span class="keyword">let</span> pat <span class="constant">:=</span> pat.setArg <span class="constant">1</span> quoted
10961            <span class="keyword">let</span> pats <span class="constant">:=</span> pats.elemsAndSeps.set<span class="constant">!</span> <span class="constant">0</span> pat
10962            `(matchAltExpr| | <span class="constant">$</span>pats,<span class="constant">*</span> <span class="constant">=&gt;</span> <span class="constant">$</span>rhs)
10963       <span class="keyword">else</span>
10964         throwErrorAt alt <span class="string">"invalid macro_rules alternative, unexpected syntax node kind '{k'}'"</span>
10965     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwUnsupportedSyntax
10966   `(<span class="doc">@[macro $(Lean.mkIdent k)]</span> <span class="keyword">def</span> <span class="function-name">myMacro</span> : Macro <span class="constant">:=</span>
10967      <span class="keyword">fun</span> <span class="constant">$</span>alts:matchAlt<span class="constant">*</span> | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throw Lean.Macro.Exception.unsupportedSyntax)
10968 
<span class="keyword">10969 def</span> <span class="function-name">inferMacroRulesAltKind</span> : Syntax <span class="constant">&#8594;</span> CommandElabM SyntaxNodeKind
10970   | `(matchAltExpr| | <span class="constant">$</span>pats,<span class="constant">*</span> <span class="constant">=&gt;</span> <span class="constant">$</span>rhs) <span class="constant">=&gt;</span> <span class="keyword">do</span>
10971     <span class="keyword">let</span> pat <span class="constant">:=</span> pats.elemsAndSeps[<span class="constant">0</span>]
10972     <span class="keyword">if</span> <span class="constant">!</span>pat.isQuot <span class="keyword">then</span>
10973       throwUnsupportedSyntax
10974     <span class="keyword">let</span> quoted <span class="constant">:=</span> getQuotContent pat
10975     pure quoted.getKind
10976   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwUnsupportedSyntax
10977 
<span class="keyword">10978 def</span> <span class="function-name">elabNoKindMacroRulesAux</span> (alts : Array Syntax) : CommandElabM Syntax <span class="constant">:=</span> <span class="keyword">do</span>
10979   <span class="keyword">let</span> <span class="keyword">mut</span> k &#8592; inferMacroRulesAltKind alts[<span class="constant">0</span>]
10980   <span class="keyword">if</span> k.isStr <span class="constant">&amp;&amp;</span> k.getString<span class="constant">!</span> <span class="constant">==</span> <span class="string">"antiquot"</span> <span class="keyword">then</span>
10981     k <span class="constant">:=</span> k.getPrefix
10982   <span class="keyword">if</span> k <span class="constant">==</span> choiceKind <span class="keyword">then</span>
10983     throwErrorAt alts[<span class="constant">0</span>]
10984       <span class="string">"invalid macro_rules alternative, multiple interpretations for pattern (solution: specify node kind using `macro_rules [&lt;kind&gt;] ...`)"</span>
10985   <span class="keyword">else</span>
10986     <span class="keyword">let</span> altsK    &#8592; alts.filterM <span class="keyword">fun</span> alt <span class="constant">=&gt;</span> <span class="keyword">return</span> checkRuleKind (&#8592; inferMacroRulesAltKind alt) k
10987     <span class="keyword">let</span> altsNotK &#8592; alts.filterM <span class="keyword">fun</span> alt <span class="constant">=&gt;</span> <span class="keyword">return</span> <span class="constant">!</span>checkRuleKind (&#8592; inferMacroRulesAltKind alt) k
10988     <span class="keyword">let</span> defCmd   &#8592; elabMacroRulesAux k altsK
10989     <span class="keyword">if</span> altsNotK.isEmpty <span class="keyword">then</span>
10990       pure defCmd
10991     <span class="keyword">else</span>
10992       `(<span class="constant">$</span>defCmd:command <span class="keyword">macro_rules</span> <span class="constant">$</span>altsNotK:matchAlt<span class="constant">*</span>)
10993 
<span class="constant">10994 @</span>[builtinCommandElab <span class="comment">&#171;</span>macro_rules<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabMacroRules</span> : CommandElab <span class="constant">:=</span>
10995   adaptExpander <span class="keyword">fun</span> stx <span class="constant">=&gt;</span> <span class="keyword">match</span> stx <span class="keyword">with</span>
10996   | `(<span class="keyword">macro_rules</span> <span class="constant">$</span>alts:matchAlt<span class="constant">*</span>)                    <span class="constant">=&gt;</span> elabNoKindMacroRulesAux alts
10997   | `(<span class="keyword">macro_rules</span> (kind <span class="constant">:=</span> <span class="constant">$</span>kind) | <span class="constant">$</span>x:ident <span class="constant">=&gt;</span> <span class="constant">$</span>rhs) <span class="constant">=&gt;</span> `(<span class="doc">@[macro $kind]</span> <span class="keyword">def</span> <span class="function-name">myMacro</span> : Macro <span class="constant">:=</span> <span class="keyword">fun</span> <span class="constant">$</span>x:ident <span class="constant">=&gt;</span> <span class="constant">$</span>rhs)
10998   | `(<span class="keyword">macro_rules</span> (kind <span class="constant">:=</span> <span class="constant">$</span>kind) <span class="constant">$</span>alts:matchAlt<span class="constant">*</span>)    <span class="constant">=&gt;</span> <span class="keyword">do</span> elabMacroRulesAux ((&#8592; getCurrNamespace) <span class="constant">++</span> kind.getId) alts
10999   | <span class="preprocessor">_</span>                                                 <span class="constant">=&gt;</span> throwUnsupportedSyntax
11000 
<span class="doc">11001 @[builtinMacro Lean.Parser.Command.mixfix]</span> <span class="keyword">def</span> <span class="function-name">expandMixfix</span> : Macro <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="constant">=&gt;</span>
11002   withAttrKindGlobal stx <span class="keyword">fun</span> stx <span class="constant">=&gt;</span> <span class="keyword">do</span>
11003     <span class="keyword">match</span> stx <span class="keyword">with</span>
11004     | `(<span class="keyword">infixl</span> <span class="constant">$</span>[: <span class="constant">$</span>prec]? <span class="constant">$</span>[(name <span class="constant">:=</span> <span class="constant">$</span>name)]? <span class="constant">$</span>[(priority <span class="constant">:=</span> <span class="constant">$</span>prio)]? <span class="constant">$</span>op <span class="constant">=&gt;</span> <span class="constant">$</span>f) <span class="constant">=&gt;</span>
11005       <span class="keyword">let</span> prec1 <span class="constant">:=</span> quote <span class="constant">&lt;</span>| (&#8592; evalOptPrec prec) <span class="constant">+</span> <span class="constant">1</span>
11006       `(<span class="keyword">notation</span> <span class="constant">$</span>[: <span class="constant">$</span>prec]? <span class="constant">$</span>[(name <span class="constant">:=</span> <span class="constant">$</span>name)]? <span class="constant">$</span>[(priority <span class="constant">:=</span> <span class="constant">$</span>prio)]? lhs<span class="constant">$</span>[:<span class="constant">$</span>prec]? <span class="constant">$</span>op:strLit rhs:<span class="constant">$</span>prec1 <span class="constant">=&gt;</span> <span class="constant">$</span>f lhs rhs)
11007     | `(<span class="keyword">infix</span> <span class="constant">$</span>[: <span class="constant">$</span>prec]? <span class="constant">$</span>[(name <span class="constant">:=</span> <span class="constant">$</span>name)]? <span class="constant">$</span>[(priority <span class="constant">:=</span> <span class="constant">$</span>prio)]? <span class="constant">$</span>op <span class="constant">=&gt;</span> <span class="constant">$</span>f) <span class="constant">=&gt;</span>
11008       <span class="keyword">let</span> prec1 <span class="constant">:=</span> quote <span class="constant">&lt;</span>| (&#8592; evalOptPrec prec) <span class="constant">+</span> <span class="constant">1</span>
11009       `(<span class="keyword">notation</span> <span class="constant">$</span>[: <span class="constant">$</span>prec]? <span class="constant">$</span>[(name <span class="constant">:=</span> <span class="constant">$</span>name)]? <span class="constant">$</span>[(priority <span class="constant">:=</span> <span class="constant">$</span>prio)]? lhs:<span class="constant">$</span>prec1 <span class="constant">$</span>op:strLit rhs:<span class="constant">$</span>prec1 <span class="constant">=&gt;</span> <span class="constant">$</span>f lhs rhs)
11010     | `(<span class="keyword">infixr</span> <span class="constant">$</span>[: <span class="constant">$</span>prec]? <span class="constant">$</span>[(name <span class="constant">:=</span> <span class="constant">$</span>name)]? <span class="constant">$</span>[(priority <span class="constant">:=</span> <span class="constant">$</span>prio)]? <span class="constant">$</span>op <span class="constant">=&gt;</span> <span class="constant">$</span>f) <span class="constant">=&gt;</span>
11011       <span class="keyword">let</span> prec1 <span class="constant">:=</span> quote <span class="constant">&lt;</span>| (&#8592; evalOptPrec prec) <span class="constant">+</span> <span class="constant">1</span>
11012       `(<span class="keyword">notation</span> <span class="constant">$</span>[: <span class="constant">$</span>prec]? <span class="constant">$</span>[(name <span class="constant">:=</span> <span class="constant">$</span>name)]? <span class="constant">$</span>[(priority <span class="constant">:=</span> <span class="constant">$</span>prio)]? lhs:<span class="constant">$</span>prec1 <span class="constant">$</span>op:strLit rhs <span class="constant">$</span>[: <span class="constant">$</span>prec]? <span class="constant">=&gt;</span> <span class="constant">$</span>f lhs rhs)
11013     | `(<span class="keyword">prefix</span> <span class="constant">$</span>[: <span class="constant">$</span>prec]? <span class="constant">$</span>[(name <span class="constant">:=</span> <span class="constant">$</span>name)]? <span class="constant">$</span>[(priority <span class="constant">:=</span> <span class="constant">$</span>prio)]? <span class="constant">$</span>op <span class="constant">=&gt;</span> <span class="constant">$</span>f) <span class="constant">=&gt;</span>
11014       `(<span class="keyword">notation</span> <span class="constant">$</span>[: <span class="constant">$</span>prec]? <span class="constant">$</span>[(name <span class="constant">:=</span> <span class="constant">$</span>name)]? <span class="constant">$</span>[(priority <span class="constant">:=</span> <span class="constant">$</span>prio)]? <span class="constant">$</span>op:strLit arg <span class="constant">$</span>[: <span class="constant">$</span>prec]? <span class="constant">=&gt;</span> <span class="constant">$</span>f arg)
11015     | `(<span class="keyword">postfix</span> <span class="constant">$</span>[: <span class="constant">$</span>prec]? <span class="constant">$</span>[(name <span class="constant">:=</span> <span class="constant">$</span>name)]? <span class="constant">$</span>[(priority <span class="constant">:=</span> <span class="constant">$</span>prio)]? <span class="constant">$</span>op <span class="constant">=&gt;</span> <span class="constant">$</span>f) <span class="constant">=&gt;</span>
11016       `(<span class="keyword">notation</span> <span class="constant">$</span>[: <span class="constant">$</span>prec]? <span class="constant">$</span>[(name <span class="constant">:=</span> <span class="constant">$</span>name)]? <span class="constant">$</span>[(priority <span class="constant">:=</span> <span class="constant">$</span>prio)]? arg<span class="constant">$</span>[:<span class="constant">$</span>prec]? <span class="constant">$</span>op:strLit <span class="constant">=&gt;</span> <span class="constant">$</span>f arg)
11017     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> Macro.throwUnsupported
<span class="keyword">11018 where</span>
11019   <span class="comment-delimiter">-- </span><span class="comment">set "global" `attrKind`, apply `f`, and restore `attrKind` to result
</span>11020   withAttrKindGlobal stx f <span class="constant">:=</span> <span class="keyword">do</span>
11021     <span class="keyword">let</span> attrKind <span class="constant">:=</span> stx[<span class="constant">0</span>]
11022     <span class="keyword">let</span> stx  <span class="constant">:=</span> stx.setArg <span class="constant">0</span> mkAttrKindGlobal
11023     <span class="keyword">let</span> stx &#8592; f stx
11024     <span class="keyword">return</span> stx.setArg <span class="constant">0</span> attrKind
11025 
<span class="comment-delimiter">11026 /- </span><span class="comment">Wrap all occurrences of the given `ident` nodes in antiquotations -/</span>
<span class="keyword">11027 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">antiquote</span> (vars : Array Syntax) : Syntax <span class="constant">&#8594;</span> Syntax
11028   | stx <span class="constant">=&gt;</span> <span class="keyword">match</span> stx <span class="keyword">with</span>
11029   | `(<span class="constant">$</span>id:ident) <span class="constant">=&gt;</span>
11030     <span class="keyword">if</span> (vars.findIdx? (<span class="keyword">fun</span> var <span class="constant">=&gt;</span> var.getId <span class="constant">==</span> id.getId)).isSome <span class="keyword">then</span>
11031       mkAntiquotNode id
11032     <span class="keyword">else</span>
11033       stx
11034   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">match</span> stx <span class="keyword">with</span>
11035     | Syntax.node k args <span class="constant">=&gt;</span> Syntax.node k (args.map (antiquote vars))
11036     | stx <span class="constant">=&gt;</span> stx
11037 
<span class="comment-delimiter">11038 /- </span><span class="comment">Convert `notation` command lhs item into a `syntax` command item -/</span>
<span class="keyword">11039 def</span> <span class="function-name">expandNotationItemIntoSyntaxItem</span> (stx : Syntax) : CommandElabM Syntax <span class="constant">:=</span>
11040   <span class="keyword">let</span> k <span class="constant">:=</span> stx.getKind
11041   <span class="keyword">if</span> k <span class="constant">==</span> `Lean.Parser.Command.identPrec <span class="keyword">then</span>
11042     pure <span class="constant">$</span> Syntax.node `Lean.Parser.Syntax.cat <span class="constant">#</span>[mkIdentFrom stx `term,  stx[<span class="constant">1</span>]]
11043   <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> strLitKind <span class="keyword">then</span>
11044     pure <span class="constant">$</span> Syntax.node `Lean.Parser.Syntax.atom <span class="constant">#</span>[stx]
11045   <span class="keyword">else</span>
11046     throwUnsupportedSyntax
11047 
<span class="keyword">11048 def</span> <span class="function-name">strLitToPattern</span> (stx: Syntax) : MacroM Syntax <span class="constant">:=</span>
11049   <span class="keyword">match</span> stx.isStrLit? <span class="keyword">with</span>
11050   | some str <span class="constant">=&gt;</span> pure <span class="constant">$</span> mkAtomFrom stx str
11051   | none     <span class="constant">=&gt;</span> Macro.throwUnsupported
11052 
<span class="comment-delimiter">11053 /- </span><span class="comment">Convert `notation` command lhs item into a pattern element -/</span>
<span class="keyword">11054 def</span> <span class="function-name">expandNotationItemIntoPattern</span> (stx : Syntax) : CommandElabM Syntax <span class="constant">:=</span>
11055   <span class="keyword">let</span> k <span class="constant">:=</span> stx.getKind
11056   <span class="keyword">if</span> k <span class="constant">==</span> `Lean.Parser.Command.identPrec <span class="keyword">then</span>
11057     mkAntiquotNode stx[<span class="constant">0</span>]
11058   <span class="keyword">else</span> <span class="keyword">if</span> k <span class="constant">==</span> strLitKind <span class="keyword">then</span>
11059     liftMacroM <span class="constant">&lt;</span>| strLitToPattern stx
11060   <span class="keyword">else</span>
11061     throwUnsupportedSyntax
11062 
<span class="comment-delimiter">11063 /-</span><span class="comment">- Try to derive a `SimpleDelab` from a notation.
11064     The notation must be of the form `notation ... =&gt; c var_1 ... var_n`
11065     where `c` is a declaration in the current scope and the `var_i` are a permutation of the LHS vars. -/</span>
<span class="keyword">11066 def</span> <span class="function-name">mkSimpleDelab</span> (attrKind : Syntax) (vars : Array Syntax) (pat qrhs : Syntax) : OptionT CommandElabM Syntax <span class="constant">:=</span> <span class="keyword">do</span>
11067   <span class="keyword">match</span> qrhs <span class="keyword">with</span>
11068   | `(<span class="constant">$</span>c:ident <span class="constant">$</span>args<span class="constant">*</span>) <span class="constant">=&gt;</span>
11069     <span class="keyword">let</span> [(c, [])] &#8592; resolveGlobalName c.getId | failure
11070     guard <span class="constant">&lt;</span>| args.all (Syntax.isIdent <span class="constant">&#8728;</span> getAntiquotTerm)
11071     guard <span class="constant">&lt;</span>| args.allDiff
11072     <span class="comment-delimiter">-- </span><span class="comment">replace head constant with (unused) antiquotation so we're not dependent on the exact pretty printing of the head
</span>11073     <span class="keyword">let</span> qrhs &#8592; `(<span class="constant">$</span>(mkAntiquotNode (&#8592; `(<span class="preprocessor">_</span>))) <span class="constant">$</span>args<span class="constant">*</span>)
11074     `(<span class="doc">@[$attrKind:attrKind appUnexpander $(mkIdent c):ident]</span> <span class="keyword">def</span> <span class="function-name">unexpand</span> : Lean.PrettyPrinter.Unexpander <span class="constant">:=</span> <span class="keyword">fun</span>
11075        | `(<span class="constant">$</span>qrhs) <span class="constant">=&gt;</span> `(<span class="constant">$</span>pat)
11076        | <span class="preprocessor">_</span>        <span class="constant">=&gt;</span> throw ())
11077   | `(<span class="constant">$</span>c:ident)        <span class="constant">=&gt;</span>
11078     <span class="keyword">let</span> [(c, [])] &#8592; resolveGlobalName c.getId | failure
11079     `(<span class="doc">@[$attrKind:attrKind appUnexpander $(mkIdent c):ident]</span> <span class="keyword">def</span> <span class="function-name">unexpand</span> : Lean.PrettyPrinter.Unexpander <span class="constant">:=</span> <span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> `(<span class="constant">$</span>pat))
11080   | <span class="preprocessor">_</span>                  <span class="constant">=&gt;</span> failure
11081 
<span class="keyword">11082 private</span> <span class="keyword">def</span> <span class="function-name">expandNotationAux</span> (ref : Syntax)
11083     (currNamespace : Name) (attrKind : Syntax) (prec? : Option Syntax) (name? : Option Syntax) (prio? : Option Syntax) (items : Array Syntax) (rhs : Syntax) : CommandElabM Syntax <span class="constant">:=</span> <span class="keyword">do</span>
11084   <span class="keyword">let</span> prio &#8592; liftMacroM <span class="constant">&lt;</span>| evalOptPrio prio?
11085   <span class="comment-delimiter">-- </span><span class="comment">build parser
</span>11086   <span class="keyword">let</span> syntaxParts &#8592; items.mapM expandNotationItemIntoSyntaxItem
11087   <span class="keyword">let</span> cat <span class="constant">:=</span> mkIdentFrom ref `term
11088   <span class="keyword">let</span> name &#8592;
11089     <span class="keyword">match</span> name? <span class="keyword">with</span>
11090     | some name <span class="constant">=&gt;</span> pure name.getId
11091     | none <span class="constant">=&gt;</span> mkNameFromParserSyntax `term (mkNullNode syntaxParts)
11092   <span class="comment-delimiter">-- </span><span class="comment">build macro rules
</span>11093   <span class="keyword">let</span> vars <span class="constant">:=</span> items.filter <span class="keyword">fun</span> item <span class="constant">=&gt;</span> item.getKind <span class="constant">==</span> `Lean.Parser.Command.identPrec
11094   <span class="keyword">let</span> vars <span class="constant">:=</span> vars.map <span class="keyword">fun</span> var <span class="constant">=&gt;</span> var[<span class="constant">0</span>]
11095   <span class="keyword">let</span> qrhs <span class="constant">:=</span> antiquote vars rhs
11096   <span class="keyword">let</span> patArgs &#8592; items.mapM expandNotationItemIntoPattern
11097   <span class="comment-delimiter">/- </span><span class="comment">The command `syntax [&lt;kind&gt;] ...` adds the current namespace to the syntax node kind.
11098      So, we must include current namespace when we create a pattern for the following `macro_rules` commands. -/</span>
11099   <span class="keyword">let</span> fullName <span class="constant">:=</span> currNamespace <span class="constant">++</span> name
11100   <span class="keyword">let</span> pat <span class="constant">:=</span> Syntax.node fullName patArgs
11101   <span class="keyword">let</span> stxDecl &#8592; `(<span class="constant">$</span>attrKind:attrKind <span class="keyword">syntax</span> <span class="constant">$</span>[: <span class="constant">$</span>prec?]? (name <span class="constant">:=</span> <span class="constant">$</span>(mkIdent name)) (priority <span class="constant">:=</span> <span class="constant">$</span>(quote prio):numLit) <span class="constant">$</span>[<span class="constant">$</span>syntaxParts]<span class="constant">*</span> : <span class="constant">$</span>cat)
11102   <span class="keyword">let</span> macroDecl &#8592; `(<span class="keyword">macro_rules</span> | `(<span class="constant">$</span>pat) <span class="constant">=&gt;</span> `(<span class="constant">$</span>qrhs))
11103   <span class="keyword">match</span> (&#8592; mkSimpleDelab attrKind vars pat qrhs |<span class="constant">&gt;</span>.run) <span class="keyword">with</span>
11104   | some delabDecl <span class="constant">=&gt;</span> mkNullNode <span class="constant">#</span>[stxDecl, macroDecl, delabDecl]
11105   | none           <span class="constant">=&gt;</span> mkNullNode <span class="constant">#</span>[stxDecl, macroDecl]
11106 
<span class="constant">11107 @</span>[builtinCommandElab <span class="comment">&#171;</span>notation<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">expandNotation</span> : CommandElab <span class="constant">:=</span>
11108   adaptExpander <span class="keyword">fun</span> stx <span class="constant">=&gt;</span> <span class="keyword">do</span>
11109     <span class="keyword">let</span> currNamespace &#8592; getCurrNamespace
11110     <span class="keyword">match</span> stx <span class="keyword">with</span>
11111     | `(<span class="constant">$</span>attrKind:attrKind <span class="keyword">notation</span> <span class="constant">$</span>[: <span class="constant">$</span>prec? ]? <span class="constant">$</span>[(name <span class="constant">:=</span> <span class="constant">$</span>name?)]? <span class="constant">$</span>[(priority <span class="constant">:=</span> <span class="constant">$</span>prio?)]? <span class="constant">$</span>items<span class="constant">*</span> <span class="constant">=&gt;</span> <span class="constant">$</span>rhs) <span class="constant">=&gt;</span>
11112       <span class="comment-delimiter">-- </span><span class="comment">trigger scoped checks early and only once
</span>11113       <span class="keyword">let</span> <span class="preprocessor">_</span> &#8592; toAttributeKind attrKind
11114       expandNotationAux stx currNamespace attrKind prec? name? prio? items rhs
11115     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwUnsupportedSyntax
11116 
<span class="comment-delimiter">11117 /- </span><span class="comment">Convert `macro` argument into a `syntax` command item -/</span>
<span class="keyword">11118 def</span> <span class="function-name">expandMacroArgIntoSyntaxItem</span> : Macro
11119   | `(macroArg|<span class="constant">$</span>id:ident:<span class="constant">$</span>stx)    <span class="constant">=&gt;</span> stx
11120   <span class="comment-delimiter">-- </span><span class="comment">can't match against `$s:strLit%$id` because the latter part would be interpreted as an antiquotation on the token
</span>11121   <span class="comment-delimiter">-- </span><span class="comment">`strLit`.
</span>11122   | `(macroArg|<span class="constant">$</span>s:macroArgSymbol) <span class="constant">=&gt;</span> `(stx|<span class="constant">$</span>(s[<span class="constant">0</span>]):strLit)
11123   | <span class="preprocessor">_</span>                             <span class="constant">=&gt;</span> Macro.throwUnsupported
11124 
<span class="comment-delimiter">11125 /- </span><span class="comment">Convert `macro` arg into a pattern element -/</span>
<span class="keyword">11126 def</span> <span class="function-name">expandMacroArgIntoPattern</span> (stx : Syntax) : MacroM Syntax <span class="constant">:=</span> <span class="keyword">do</span>
11127   <span class="keyword">match</span> (&#8592; expandMacros stx) <span class="keyword">with</span>
11128   | `(macroArg|<span class="constant">$</span>id:ident:optional(<span class="constant">$</span>stx)) <span class="constant">=&gt;</span>
11129     mkSplicePat `optional id <span class="string">"?"</span>
11130   | `(macroArg|<span class="constant">$</span>id:ident:many(<span class="constant">$</span>stx)) <span class="constant">=&gt;</span>
11131     mkSplicePat `many id <span class="string">"*"</span>
11132   | `(macroArg|<span class="constant">$</span>id:ident:many1(<span class="constant">$</span>stx)) <span class="constant">=&gt;</span>
11133     mkSplicePat `many id <span class="string">"*"</span>
11134   | `(macroArg|<span class="constant">$</span>id:ident:sepBy(<span class="constant">$</span>stx, <span class="constant">$</span>sep:strLit <span class="constant">$</span>[, <span class="constant">$</span>stxsep]? <span class="constant">$</span>[, allowTrailingSep]?)) <span class="constant">=&gt;</span>
11135     mkSplicePat `sepBy id ((isStrLit? sep).get<span class="constant">!</span> <span class="constant">++</span> <span class="string">"*"</span>)
11136   | `(macroArg|<span class="constant">$</span>id:ident:sepBy1(<span class="constant">$</span>stx, <span class="constant">$</span>sep:strLit <span class="constant">$</span>[, <span class="constant">$</span>stxsep]? <span class="constant">$</span>[, allowTrailingSep]?)) <span class="constant">=&gt;</span>
11137     mkSplicePat `sepBy id ((isStrLit? sep).get<span class="constant">!</span> <span class="constant">++</span> <span class="string">"*"</span>)
11138   | `(macroArg|<span class="constant">$</span>id:ident:<span class="constant">$</span>stx) <span class="constant">=&gt;</span> mkAntiquotNode id
11139   | `(macroArg|<span class="constant">$</span>s:strLit) <span class="constant">=&gt;</span> strLitToPattern s
11140   <span class="comment-delimiter">-- </span><span class="comment">`"tk"%id` ~&gt; `"tk"%$id`
</span>11141   | `(macroArg|<span class="constant">$</span>s:macroArgSymbol) <span class="constant">=&gt;</span> mkNode `token_antiquot <span class="constant">#</span>[&#8592; strLitToPattern s[<span class="constant">0</span>], mkAtom <span class="string">"%"</span>, mkAtom <span class="string">"$"</span>, s[<span class="constant">1</span>][<span class="constant">1</span>]]
11142   | <span class="preprocessor">_</span>                          <span class="constant">=&gt;</span> Macro.throwUnsupported
11143   <span class="keyword">where</span> mkSplicePat kind id suffix <span class="constant">:=</span>
11144     mkNullNode <span class="constant">#</span>[mkAntiquotSuffixSpliceNode kind (mkAntiquotNode id) suffix]
11145 
11146 
<span class="comment-delimiter">11147 /- </span><span class="comment">&#171;</span>macro<span class="comment">&#187; := leading_parser suppressInsideQuot (Term.attrKind &gt;&gt; "macro " &gt;&gt; optPrecedence &gt;&gt; optNamedName &gt;&gt; optNamedPrio &gt;&gt; macroHead &gt;&gt; many macroArg &gt;&gt; macroTail) -/</span>
<span class="keyword">11148 def</span> <span class="function-name">expandMacro</span> (currNamespace : Name) (stx : Syntax) : CommandElabM Syntax <span class="constant">:=</span> <span class="keyword">do</span>
11149   <span class="keyword">let</span> attrKind <span class="constant">:=</span> stx[<span class="constant">0</span>]
11150   <span class="keyword">let</span> prec <span class="constant">:=</span> stx[<span class="constant">2</span>].getOptional?
11151   <span class="keyword">let</span> name? &#8592; liftMacroM <span class="constant">&lt;</span>| expandOptNamedName stx[<span class="constant">3</span>]
11152   <span class="keyword">let</span> prio  &#8592; liftMacroM <span class="constant">&lt;</span>| expandOptNamedPrio stx[<span class="constant">4</span>]
11153   <span class="keyword">let</span> head <span class="constant">:=</span> stx[<span class="constant">5</span>]
11154   <span class="keyword">let</span> args <span class="constant">:=</span> stx[<span class="constant">6</span>].getArgs
11155   <span class="keyword">let</span> cat  <span class="constant">:=</span> stx[<span class="constant">8</span>]
11156   <span class="comment-delimiter">-- </span><span class="comment">build parser
</span>11157   <span class="keyword">let</span> stxPart  &#8592; liftMacroM <span class="constant">&lt;</span>| expandMacroArgIntoSyntaxItem head
11158   <span class="keyword">let</span> stxParts &#8592; liftMacroM <span class="constant">&lt;</span>| args.mapM expandMacroArgIntoSyntaxItem
11159   <span class="keyword">let</span> stxParts <span class="constant">:=</span> <span class="constant">#</span>[stxPart] <span class="constant">++</span> stxParts
11160   <span class="comment-delimiter">-- </span><span class="comment">name
</span>11161   <span class="keyword">let</span> name &#8592; <span class="keyword">match</span> name? <span class="keyword">with</span>
11162     | some name <span class="constant">=&gt;</span> pure name
11163     | none <span class="constant">=&gt;</span> mkNameFromParserSyntax cat.getId (mkNullNode stxParts)
11164   <span class="comment-delimiter">-- </span><span class="comment">build macro rules
</span>11165   <span class="keyword">let</span> patHead &#8592; liftMacroM <span class="constant">&lt;</span>| expandMacroArgIntoPattern head
11166   <span class="keyword">let</span> patArgs &#8592; liftMacroM <span class="constant">&lt;</span>| args.mapM expandMacroArgIntoPattern
11167   <span class="comment-delimiter">/- </span><span class="comment">The command `syntax [&lt;kind&gt;] ...` adds the current namespace to the syntax node kind.
11168      So, we must include current namespace when we create a pattern for the following `macro_rules` commands. -/</span>
11169   <span class="keyword">let</span> pat <span class="constant">:=</span> Syntax.node (currNamespace <span class="constant">++</span> name) (<span class="constant">#</span>[patHead] <span class="constant">++</span> patArgs)
11170   <span class="keyword">if</span> stx.getArgs.size <span class="constant">==</span> <span class="constant">11</span> <span class="keyword">then</span>
11171     <span class="comment-delimiter">-- </span><span class="comment">`stx` is of the form `macro $head $args* : $cat =&gt; term`
</span>11172     <span class="keyword">let</span> rhs <span class="constant">:=</span> stx[<span class="constant">10</span>]
11173     <span class="keyword">let</span> stxCmd &#8592; `(Parser.Command.<span class="keyword">syntax</span>| <span class="constant">$</span>attrKind:attrKind <span class="keyword">syntax</span> <span class="constant">$</span>(prec)? (name <span class="constant">:=</span> <span class="constant">$</span>(mkIdentFrom stx name):ident) (priority <span class="constant">:=</span> <span class="constant">$</span>(quote prio):numLit) <span class="constant">$</span>[<span class="constant">$</span>stxParts]<span class="constant">*</span> : <span class="constant">$</span>cat)
11174     <span class="keyword">let</span> macroRulesCmd &#8592; `(<span class="keyword">macro_rules</span> | `(<span class="constant">$</span>pat) <span class="constant">=&gt;</span> <span class="constant">$</span>rhs)
11175     <span class="keyword">return</span> mkNullNode <span class="constant">#</span>[stxCmd, macroRulesCmd]
11176   <span class="keyword">else</span>
11177     <span class="comment-delimiter">-- </span><span class="comment">`stx` is of the form `macro $head $args* : $cat =&gt; `( $body )`
</span>11178     <span class="keyword">let</span> rhsBody <span class="constant">:=</span> stx[<span class="constant">11</span>]
11179     <span class="keyword">let</span> stxCmd &#8592; `(Parser.Command.<span class="keyword">syntax</span>| <span class="constant">$</span>attrKind:attrKind <span class="keyword">syntax</span> <span class="constant">$</span>(prec)? (name <span class="constant">:=</span> <span class="constant">$</span>(mkIdentFrom stx name):ident) (priority <span class="constant">:=</span> <span class="constant">$</span>(quote prio):numLit) <span class="constant">$</span>[<span class="constant">$</span>stxParts]<span class="constant">*</span> : <span class="constant">$</span>cat)
11180     <span class="keyword">let</span> macroRulesCmd &#8592; `(<span class="keyword">macro_rules</span> | `(<span class="constant">$</span>pat) <span class="constant">=&gt;</span> `(<span class="constant">$</span>rhsBody))
11181     <span class="keyword">return</span> mkNullNode <span class="constant">#</span>[stxCmd, macroRulesCmd]
11182 
<span class="constant">11183 @</span>[builtinCommandElab <span class="comment">&#171;</span>macro<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabMacro</span> : CommandElab <span class="constant">:=</span>
11184   adaptExpander <span class="keyword">fun</span> stx <span class="constant">=&gt;</span> <span class="keyword">do</span>
11185     expandMacro (&#8592; getCurrNamespace) stx
11186 
<span class="keyword">11187 builtin_initialize</span>
11188   registerTraceClass `Elab.<span class="keyword">syntax</span>
11189 
<span class="doc">11190 @[inline]</span> <span class="keyword">def</span> <span class="function-name">withExpectedType</span> (expectedType? : Option Expr) (x : Expr <span class="constant">&#8594;</span> TermElabM Expr) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
11191   Term.tryPostponeIfNoneOrMVar expectedType?
11192   <span class="keyword">let</span> some expectedType &#8592; pure expectedType?
11193     | throwError <span class="string">"expected type must be known"</span>
11194   x expectedType
11195 
<span class="comment-delimiter">11196 /-</span><span class="comment">
11197 def elabTail := try (" : " &gt;&gt; ident) &gt;&gt; darrow &gt;&gt; termParser
11198 def &#171;</span>elab<span class="comment">&#187; := leading_parser suppressInsideQuot (Term.attrKind &gt;&gt; "elab " &gt;&gt; optPrecedence &gt;&gt; optNamedName &gt;&gt; optNamedPrio &gt;&gt; elabHead &gt;&gt; many elabArg &gt;&gt; elabTail)
11199 -/</span>
<span class="keyword">11200 def</span> <span class="function-name">expandElab</span> (currNamespace : Name) (stx : Syntax) : CommandElabM Syntax <span class="constant">:=</span> <span class="keyword">do</span>
11201   <span class="keyword">let</span> ref <span class="constant">:=</span> stx
11202   <span class="keyword">let</span> attrKind <span class="constant">:=</span> stx[<span class="constant">0</span>]
11203   <span class="keyword">let</span> prec     <span class="constant">:=</span> stx[<span class="constant">2</span>].getOptional?
11204   <span class="keyword">let</span> name?   &#8592; liftMacroM <span class="constant">&lt;</span>| expandOptNamedName stx[<span class="constant">3</span>]
11205   <span class="keyword">let</span> prio    &#8592; liftMacroM <span class="constant">&lt;</span>| expandOptNamedPrio stx[<span class="constant">4</span>]
11206   <span class="keyword">let</span> head    <span class="constant">:=</span> stx[<span class="constant">5</span>]
11207   <span class="keyword">let</span> args    <span class="constant">:=</span> stx[<span class="constant">6</span>].getArgs
11208   <span class="keyword">let</span> cat     <span class="constant">:=</span> stx[<span class="constant">8</span>]
11209   <span class="keyword">let</span> expectedTypeSpec <span class="constant">:=</span> stx[<span class="constant">9</span>]
11210   <span class="keyword">let</span> rhs     <span class="constant">:=</span> stx[<span class="constant">11</span>]
11211   <span class="keyword">let</span> catName <span class="constant">:=</span> cat.getId
11212   <span class="comment-delimiter">-- </span><span class="comment">build parser
</span>11213   <span class="keyword">let</span> stxPart  &#8592; liftMacroM <span class="constant">&lt;</span>| expandMacroArgIntoSyntaxItem head
11214   <span class="keyword">let</span> stxParts &#8592; liftMacroM <span class="constant">&lt;</span>| args.mapM expandMacroArgIntoSyntaxItem
11215   <span class="keyword">let</span> stxParts <span class="constant">:=</span> <span class="constant">#</span>[stxPart] <span class="constant">++</span> stxParts
11216   <span class="comment-delimiter">-- </span><span class="comment">name
</span>11217   <span class="keyword">let</span> name &#8592; <span class="keyword">match</span> name? <span class="keyword">with</span>
11218     | some name <span class="constant">=&gt;</span> pure name
11219     | none <span class="constant">=&gt;</span> mkNameFromParserSyntax cat.getId (mkNullNode stxParts)
11220   <span class="comment-delimiter">-- </span><span class="comment">build pattern for `martch_syntax
</span>11221   <span class="keyword">let</span> patHead &#8592; liftMacroM <span class="constant">&lt;</span>| expandMacroArgIntoPattern head
11222   <span class="keyword">let</span> patArgs &#8592; liftMacroM <span class="constant">&lt;</span>| args.mapM expandMacroArgIntoPattern
11223   <span class="keyword">let</span> pat <span class="constant">:=</span> Syntax.node (currNamespace <span class="constant">++</span> name) (<span class="constant">#</span>[patHead] <span class="constant">++</span> patArgs)
11224   <span class="keyword">let</span> stxCmd &#8592; `(Parser.Command.<span class="keyword">syntax</span>|
11225     <span class="constant">$</span>attrKind:attrKind <span class="keyword">syntax</span> <span class="constant">$</span>(prec)? (name <span class="constant">:=</span> <span class="constant">$</span>(mkIdentFrom stx name):ident) (priority <span class="constant">:=</span> <span class="constant">$</span>(quote prio):numLit) <span class="constant">$</span>[<span class="constant">$</span>stxParts]<span class="constant">*</span> : <span class="constant">$</span>cat)
11226   <span class="keyword">let</span> elabCmd &#8592;
11227     <span class="keyword">if</span> expectedTypeSpec.hasArgs <span class="keyword">then</span>
11228       <span class="keyword">if</span> catName <span class="constant">==</span> `term <span class="keyword">then</span>
11229         <span class="keyword">let</span> expId <span class="constant">:=</span> expectedTypeSpec[<span class="constant">1</span>]
11230         `(<span class="doc">@[termElab $(mkIdentFrom stx name):ident]</span> <span class="keyword">def</span> <span class="function-name">elabFn</span> : Lean.Elab.Term.TermElab <span class="constant">:=</span>
11231           <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span> <span class="keyword">match</span> stx <span class="keyword">with</span>
11232             | `(<span class="constant">$</span>pat) <span class="constant">=&gt;</span> Lean.Elab.Command.withExpectedType expectedType? <span class="keyword">fun</span> <span class="constant">$</span>expId <span class="constant">=&gt;</span> <span class="constant">$</span>rhs
11233             | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwUnsupportedSyntax)
11234       <span class="keyword">else</span>
11235         throwErrorAt expectedTypeSpec <span class="string">"syntax category '{catName}' does not support expected type specification"</span>
11236     <span class="keyword">else</span> <span class="keyword">if</span> catName <span class="constant">==</span> `term <span class="keyword">then</span>
11237       `(<span class="doc">@[termElab $(mkIdentFrom stx name):ident]</span> <span class="keyword">def</span> <span class="function-name">elabFn</span> : Lean.Elab.Term.TermElab <span class="constant">:=</span>
11238         <span class="keyword">fun</span> stx <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">match</span> stx <span class="keyword">with</span>
11239           | `(<span class="constant">$</span>pat) <span class="constant">=&gt;</span> <span class="constant">$</span>rhs
11240           | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwUnsupportedSyntax)
11241     <span class="keyword">else</span> <span class="keyword">if</span> catName <span class="constant">==</span> `command <span class="keyword">then</span>
11242       `(<span class="doc">@[commandElab $(mkIdentFrom stx name):ident]</span> <span class="keyword">def</span> <span class="function-name">elabFn</span> : Lean.Elab.Command.CommandElab <span class="constant">:=</span>
11243         <span class="keyword">fun</span>
11244           | `(<span class="constant">$</span>pat) <span class="constant">=&gt;</span> <span class="constant">$</span>rhs
11245           | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwUnsupportedSyntax)
11246     <span class="keyword">else</span> <span class="keyword">if</span> catName <span class="constant">==</span> `tactic <span class="keyword">then</span>
11247       `(<span class="doc">@[tactic $(mkIdentFrom stx name):ident]</span> <span class="keyword">def</span> <span class="function-name">elabFn</span> : Lean.Elab.Tactic.Tactic <span class="constant">:=</span>
11248         <span class="keyword">fun</span>
11249           | `(tactic|<span class="constant">$</span>pat) <span class="constant">=&gt;</span> <span class="constant">$</span>rhs
11250           | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwUnsupportedSyntax)
11251     <span class="keyword">else</span>
11252       <span class="comment-delimiter">-- </span><span class="comment">We considered making the command extensible and support new user-defined categories. We think it is unnecessary.
</span>11253       <span class="comment-delimiter">-- </span><span class="comment">If users want this feature, they add their own `elab` macro that uses this one as a fallback.
</span>11254       throwError <span class="string">"unsupported syntax category '{catName}'"</span>
11255   <span class="keyword">return</span> mkNullNode <span class="constant">#</span>[stxCmd, elabCmd]
11256 
<span class="constant">11257 @</span>[builtinCommandElab <span class="comment">&#171;</span>elab<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabElab</span> : CommandElab <span class="constant">:=</span>
11258   adaptExpander <span class="keyword">fun</span> stx <span class="constant">=&gt;</span> <span class="keyword">do</span>
11259     expandElab (&#8592; getCurrNamespace) stx
11260 
<span class="keyword">11261 end</span> Lean.Elab.Command
11262 ::::::::::::::
11263 Elab<span class="constant">/</span>SyntheticMVars.lean
11264 ::::::::::::::
<span class="comment-delimiter">11265 /-</span><span class="comment">
11266 Copyright (c) 2020 Microsoft Corporation. All rights reserved.
11267 Released under Apache 2.0 license as described in the file LICENSE.
11268 Authors: Leonardo de Moura, Sebastian Ullrich
11269 -/</span>
<span class="keyword">11270 import</span> Lean.Util.ForEachExpr
<span class="keyword">11271 import</span> Lean.Elab.Term
<span class="keyword">11272 import</span> Lean.Elab.Tactic.Basic
11273 
<span class="keyword">11274 namespace</span> Lean.Elab.Term
<span class="keyword">11275 open</span> Tactic (TacticM evalTactic getUnsolvedGoals)
<span class="keyword">11276 open</span> Meta
11277 
<span class="comment-delimiter">11278 /-</span><span class="comment">- Auxiliary function used to implement `synthesizeSyntheticMVars`. -/</span>
<span class="keyword">11279 private</span> <span class="keyword">def</span> <span class="function-name">resumeElabTerm</span> (stx : Syntax) (expectedType? : Option Expr) (errToSorry <span class="constant">:=</span> true) : TermElabM Expr <span class="constant">:=</span>
11280   <span class="comment-delimiter">-- </span><span class="comment">Remark: if `ctx.errToSorry` is already false, then we don't enable it. Recall tactics disable `errToSorry`
</span>11281   withReader (<span class="keyword">fun</span> ctx <span class="constant">=&gt;</span> { ctx <span class="keyword">with</span> errToSorry <span class="constant">:=</span> ctx.errToSorry <span class="constant">&amp;&amp;</span> errToSorry }) <span class="keyword">do</span>
11282     elabTerm stx expectedType? false
11283 
<span class="comment-delimiter">11284 /-</span><span class="comment">-
11285   Try to elaborate `stx` that was postponed by an elaboration method using `Expection.postpone`.
11286   It returns `true` if it succeeded, and `false` otherwise.
11287   It is used to implement `synthesizeSyntheticMVars`. -/</span>
<span class="keyword">11288 private</span> <span class="keyword">def</span> <span class="function-name">resumePostponed</span> (savedContext : SavedContext) (stx : Syntax) (mvarId : MVarId) (postponeOnError : Bool) : TermElabM Bool <span class="constant">:=</span>
11289   withRef stx <span class="constant">&lt;</span>| withMVarContext mvarId <span class="keyword">do</span>
11290     <span class="keyword">let</span> s &#8592; get
11291     <span class="keyword">try</span>
11292       withSavedContext savedContext <span class="keyword">do</span>
11293         <span class="keyword">let</span> mvarDecl     &#8592; getMVarDecl mvarId
11294         <span class="keyword">let</span> expectedType &#8592; instantiateMVars mvarDecl.type
11295         withInfoHole mvarId <span class="keyword">do</span>
11296           <span class="keyword">let</span> result &#8592; resumeElabTerm stx expectedType (<span class="constant">!</span>postponeOnError)
11297           <span class="comment-delimiter">/- </span><span class="comment">We must ensure `result` has the expected type because it is the one expected by the method that postponed stx.
11298             That is, the method does not have an opportunity to check whether `result` has the expected type or not. -/</span>
11299           <span class="keyword">let</span> result &#8592; withRef stx <span class="constant">&lt;</span>| ensureHasType expectedType result
11300           <span class="comment-delimiter">/- </span><span class="comment">We must perform `occursCheck` here since `result` may contain `mvarId` when it has synthetic `sorry`s. -/</span>
11301           <span class="keyword">if</span> (&#8592; occursCheck mvarId result) <span class="keyword">then</span>
11302             assignExprMVar mvarId result
11303             <span class="keyword">return</span> true
11304           <span class="keyword">else</span>
11305             <span class="keyword">return</span> false
11306     <span class="keyword">catch</span>
11307      | ex<span class="constant">@</span>(Exception.internal id <span class="preprocessor">_</span>) <span class="constant">=&gt;</span>
11308        <span class="keyword">if</span> id <span class="constant">==</span> postponeExceptionId <span class="keyword">then</span>
11309          set s
11310          <span class="keyword">return</span> false
11311        <span class="keyword">else</span>
11312          throw ex
11313      | ex<span class="constant">@</span>(Exception.error <span class="preprocessor">_</span> <span class="preprocessor">_</span>) <span class="constant">=&gt;</span>
11314        <span class="keyword">if</span> postponeOnError <span class="keyword">then</span>
11315          set s
11316          <span class="keyword">return</span> false
11317        <span class="keyword">else</span>
11318          logException ex
11319          <span class="keyword">return</span> true
11320 
<span class="comment-delimiter">11321 /-</span><span class="comment">-
11322   Similar to `synthesizeInstMVarCore`, but makes sure that `instMVar` local context and instances
11323   are used. It also logs any error message produced. -/</span>
<span class="keyword">11324 private</span> <span class="keyword">def</span> <span class="function-name">synthesizePendingInstMVar</span> (instMVar : MVarId) : TermElabM Bool <span class="constant">:=</span>
11325   withMVarContext instMVar <span class="keyword">do</span>
11326     <span class="keyword">try</span>
11327       synthesizeInstMVarCore instMVar
11328     <span class="keyword">catch</span>
11329       | ex<span class="constant">@</span>(Exception.error <span class="preprocessor">_</span> <span class="preprocessor">_</span>) <span class="constant">=&gt;</span> logException ex; <span class="keyword">return</span> true
11330       | <span class="preprocessor">_</span>                        <span class="constant">=&gt;</span> <span class="warning">unreachable</span><span class="constant">!</span>
11331 
<span class="comment-delimiter">11332 /-</span><span class="comment">-
11333   Similar to `synthesizePendingInstMVar`, but generates type mismatch error message.
11334   Remark: `eNew` is of the form `@coe ... mvar`, where `mvar` is the metavariable for the `CoeT ...` instance.
11335   If `mvar` can be synthesized, then assign `auxMVarId := (expandCoe eNew)`.
11336 -/</span>
<span class="keyword">11337 private</span> <span class="keyword">def</span> <span class="function-name">synthesizePendingCoeInstMVar</span>
11338     (auxMVarId : MVarId) (errorMsgHeader? : Option String) (eNew : Expr) (expectedType : Expr) (eType : Expr) (e : Expr) (f? : Option Expr) : TermElabM Bool <span class="constant">:=</span> <span class="keyword">do</span>
11339   <span class="keyword">let</span> instMVarId <span class="constant">:=</span> eNew.appArg<span class="constant">!</span>.mvarId<span class="constant">!</span>
11340   withMVarContext instMVarId <span class="keyword">do</span>
11341     <span class="keyword">if</span> (&#8592; isDefEq expectedType eType) <span class="keyword">then</span>
11342       <span class="comment-delimiter">/- </span><span class="comment">This case may seem counterintuitive since we created the coercion
11343          because the `isDefEq expectedType eType` test failed before.
11344          However, it may succeed here because we have more information, for example, metavariables
11345          occurring at `expectedType` and `eType` may have been assigned. -/</span>
11346       <span class="keyword">if</span> (&#8592; occursCheck auxMVarId e) <span class="keyword">then</span>
11347         assignExprMVar auxMVarId e
11348         <span class="keyword">return</span> true
11349       <span class="keyword">else</span>
11350         <span class="keyword">return</span> false
11351     <span class="keyword">try</span>
11352       <span class="keyword">if</span> (&#8592; synthesizeCoeInstMVarCore instMVarId) <span class="keyword">then</span>
11353         <span class="keyword">let</span> eNew &#8592; expandCoe eNew
11354         <span class="keyword">if</span> (&#8592; occursCheck auxMVarId eNew) <span class="keyword">then</span>
11355           assignExprMVar auxMVarId eNew
11356           <span class="keyword">return</span> true
11357       <span class="keyword">return</span> false
11358     <span class="keyword">catch</span>
11359       | Exception.error <span class="preprocessor">_</span> msg <span class="constant">=&gt;</span> throwTypeMismatchError errorMsgHeader? expectedType eType e f? msg
11360       | <span class="preprocessor">_</span>                     <span class="constant">=&gt;</span> <span class="warning">unreachable</span><span class="constant">!</span>
11361 
<span class="comment-delimiter">11362 /-</span><span class="comment">-
11363   Try to synthesize a value for `mvarId` using the given default instance.
11364   Return `some (val, mvarDecls)` if successful, where `val` is the value assigned to `mvarId`, and `mvarDecls` is a list of new type class instances that need to be synthesized.
11365 -/</span>
<span class="keyword">11366 private</span> <span class="keyword">def</span> <span class="function-name">tryToSynthesizeUsingDefaultInstance</span> (mvarId : MVarId) (defaultInstance : Name) : TermElabM (Option (Expr <span class="constant">&#215;</span> List SyntheticMVarDecl)) <span class="constant">:=</span>
11367   commitWhenSome? <span class="keyword">do</span>
11368     <span class="keyword">let</span> candidate &#8592; mkConstWithFreshMVarLevels defaultInstance
11369     <span class="keyword">let</span> (mvars, bis, <span class="preprocessor">_</span>) &#8592; forallMetaTelescopeReducing (&#8592; inferType candidate)
11370     <span class="keyword">let</span> candidate <span class="constant">:=</span> mkAppN candidate mvars
11371     trace[Elab.resume] <span class="string">"trying default instance for {mkMVar mvarId} := {candidate}"</span>
11372     <span class="keyword">if</span> (&#8592; isDefEqGuarded (mkMVar mvarId) candidate) <span class="keyword">then</span>
11373       <span class="comment-delimiter">-- </span><span class="comment">Succeeded. Collect new TC problems
</span>11374       <span class="keyword">let</span> <span class="keyword">mut</span> result <span class="constant">:=</span> []
11375       <span class="keyword">for</span> i <span class="keyword">in</span> [:bis.size] <span class="keyword">do</span>
11376         <span class="keyword">if</span> bis[i] <span class="constant">==</span> BinderInfo.instImplicit <span class="keyword">then</span>
11377            result <span class="constant">:=</span> { mvarId <span class="constant">:=</span> mvars[i].mvarId<span class="constant">!</span>, stx <span class="constant">:=</span> (&#8592; getRef), kind <span class="constant">:=</span> SyntheticMVarKind.typeClass } :: result
11378       trace[Elab.resume] <span class="string">"worked"</span>
11379       <span class="keyword">return</span> some (candidate, result)
11380     <span class="keyword">else</span>
11381       <span class="keyword">return</span> none
11382 
<span class="keyword">11383 private</span> <span class="keyword">def</span> <span class="function-name">tryToSynthesizeUsingDefaultInstances</span> (mvarId : MVarId) (prio : Nat) : TermElabM (Option (Expr <span class="constant">&#215;</span> List SyntheticMVarDecl)) <span class="constant">:=</span>
11384   withMVarContext mvarId <span class="keyword">do</span>
11385     <span class="keyword">let</span> mvarType <span class="constant">:=</span> (&#8592; Meta.getMVarDecl mvarId).type
11386     <span class="keyword">match</span> (&#8592; isClass? mvarType) <span class="keyword">with</span>
11387     | none <span class="constant">=&gt;</span> <span class="keyword">return</span> none
11388     | some className <span class="constant">=&gt;</span>
11389       <span class="keyword">match</span> (&#8592; getDefaultInstances className) <span class="keyword">with</span>
11390       | [] <span class="constant">=&gt;</span> <span class="keyword">return</span> none
11391       | defaultInstances <span class="constant">=&gt;</span>
11392         <span class="keyword">for</span> (defaultInstance, instPrio) <span class="keyword">in</span> defaultInstances <span class="keyword">do</span>
11393           <span class="keyword">if</span> instPrio <span class="constant">==</span> prio <span class="keyword">then</span>
11394             <span class="keyword">match</span> (&#8592; tryToSynthesizeUsingDefaultInstance mvarId defaultInstance) <span class="keyword">with</span>
11395             | some result <span class="constant">=&gt;</span> <span class="keyword">return</span> some result
11396             | none <span class="constant">=&gt;</span> <span class="keyword">continue</span>
11397         <span class="keyword">return</span> none
11398 
<span class="comment-delimiter">11399 /- </span><span class="comment">Used to implement `synthesizeUsingDefault`. This method only consider default instances with the given priority. -/</span>
<span class="keyword">11400 private</span> <span class="keyword">def</span> <span class="function-name">synthesizeUsingDefaultPrio</span> (prio : Nat) : TermElabM Bool <span class="constant">:=</span> <span class="keyword">do</span>
11401   <span class="keyword">let</span> <span class="keyword">rec</span> visit (syntheticMVars : List SyntheticMVarDecl) (syntheticMVarsNew : List SyntheticMVarDecl) : TermElabM Bool <span class="constant">:=</span> <span class="keyword">do</span>
11402     <span class="keyword">match</span> syntheticMVars <span class="keyword">with</span>
11403     | [] <span class="constant">=&gt;</span> <span class="keyword">return</span> false
11404     | mvarDecl :: mvarDecls <span class="constant">=&gt;</span>
11405       <span class="keyword">match</span> mvarDecl.kind <span class="keyword">with</span>
11406       | SyntheticMVarKind.typeClass <span class="constant">=&gt;</span>
11407         <span class="keyword">match</span> (&#8592; withRef mvarDecl.stx <span class="constant">&lt;</span>| tryToSynthesizeUsingDefaultInstances mvarDecl.mvarId prio) <span class="keyword">with</span>
11408         | none <span class="constant">=&gt;</span> visit mvarDecls (mvarDecl :: syntheticMVarsNew)
11409         | some (val, newMVarDecls) <span class="constant">=&gt;</span>
11410           <span class="keyword">for</span> newMVarDecl <span class="keyword">in</span> newMVarDecls <span class="keyword">do</span>
11411             <span class="comment-delimiter">-- </span><span class="comment">Register that `newMVarDecl.mvarId`s are implicit arguments of the value assigned to `mvarDecl.mvarId`
</span>11412             registerMVarErrorImplicitArgInfo newMVarDecl.mvarId (&#8592; getRef) val
11413           <span class="keyword">let</span> syntheticMVarsNew <span class="constant">:=</span> newMVarDecls <span class="constant">++</span> syntheticMVarsNew
11414           <span class="keyword">let</span> syntheticMVarsNew <span class="constant">:=</span> mvarDecls.reverse <span class="constant">++</span> syntheticMVarsNew
11415           modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> syntheticMVars <span class="constant">:=</span> syntheticMVarsNew }
11416           <span class="keyword">return</span> true
11417       | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> visit mvarDecls (mvarDecl :: syntheticMVarsNew)
11418   <span class="comment-delimiter">/- </span><span class="comment">Recall that s.syntheticMVars is essentially a stack. The first metavariable was the last one created.
11419      We want to apply the default instance in reverse creation order. Otherwise,
11420      `toString 0` will produce a `OfNat String _` cannot be synthesized error. -/</span>
11421   visit (&#8592; get).syntheticMVars.reverse []
11422 
<span class="comment-delimiter">11423 /-</span><span class="comment">-
11424   Apply default value to any pending synthetic metavariable of kind `SyntheticMVarKind.withDefault`
11425   Return true if something was synthesized. -/</span>
<span class="keyword">11426 private</span> <span class="keyword">def</span> <span class="function-name">synthesizeUsingDefault</span> : TermElabM Bool <span class="constant">:=</span> <span class="keyword">do</span>
11427   <span class="keyword">let</span> prioSet &#8592; getDefaultInstancesPriorities
11428   <span class="comment-delimiter">/- </span><span class="comment">Recall that `prioSet` is stored in descending order -/</span>
11429   <span class="keyword">for</span> prio <span class="keyword">in</span> prioSet <span class="keyword">do</span>
11430     <span class="keyword">if</span> (&#8592; synthesizeUsingDefaultPrio prio) <span class="keyword">then</span>
11431       <span class="keyword">return</span> true
11432   <span class="keyword">return</span> false
11433 
<span class="comment-delimiter">11434 /-</span><span class="comment">- Report an error for each synthetic metavariable that could not be resolved. -/</span>
<span class="keyword">11435 private</span> <span class="keyword">def</span> <span class="function-name">reportStuckSyntheticMVars</span> : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
11436   <span class="keyword">let</span> syntheticMVars &#8592; modifyGet <span class="keyword">fun</span> s <span class="constant">=&gt;</span> (s.syntheticMVars, { s <span class="keyword">with</span> syntheticMVars <span class="constant">:=</span> [] })
11437   <span class="keyword">for</span> mvarSyntheticDecl <span class="keyword">in</span> syntheticMVars <span class="keyword">do</span>
11438     withRef mvarSyntheticDecl.stx <span class="keyword">do</span>
11439     <span class="keyword">match</span> mvarSyntheticDecl.kind <span class="keyword">with</span>
11440     | SyntheticMVarKind.typeClass <span class="constant">=&gt;</span>
11441       withMVarContext mvarSyntheticDecl.mvarId <span class="keyword">do</span>
11442         <span class="keyword">let</span> mvarDecl &#8592; getMVarDecl mvarSyntheticDecl.mvarId
11443         <span class="keyword">unless</span> (&#8592; get).messages.hasErrors <span class="keyword">do</span>
11444           throwError <span class="string">"typeclass instance problem is stuck, it is often due to metavariables{indentExpr mvarDecl.type}"</span>
11445     | SyntheticMVarKind.coe header eNew expectedType eType e f? <span class="constant">=&gt;</span>
11446       <span class="keyword">let</span> mvarId <span class="constant">:=</span> eNew.appArg<span class="constant">!</span>.mvarId<span class="constant">!</span>
11447       withMVarContext mvarId <span class="keyword">do</span>
11448         <span class="keyword">let</span> mvarDecl &#8592; getMVarDecl mvarId
11449         throwTypeMismatchError header expectedType eType e f? (some (<span class="string">"failed to create type class instance for "</span> <span class="constant">++</span> indentExpr mvarDecl.type))
11450     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="warning">unreachable</span><span class="constant">!</span> <span class="comment-delimiter">-- </span><span class="comment">TODO handle other cases.
</span>11451 
<span class="keyword">11452 private</span> <span class="keyword">def</span> <span class="function-name">getSomeSynthethicMVarsRef</span> : TermElabM Syntax <span class="constant">:=</span> <span class="keyword">do</span>
11453   <span class="keyword">let</span> s &#8592; get
11454   <span class="keyword">match</span> s.syntheticMVars.find? <span class="keyword">fun</span> (mvarDecl : SyntheticMVarDecl) <span class="constant">=&gt;</span> <span class="constant">!</span>mvarDecl.stx.getPos?.isNone <span class="keyword">with</span>
11455   | some mvarDecl <span class="constant">=&gt;</span> <span class="keyword">return</span> mvarDecl.stx
11456   | none          <span class="constant">=&gt;</span> <span class="keyword">return</span> Syntax.missing
11457 
<span class="keyword">11458 mutual</span>
11459 
11460   <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">liftTacticElabM</span> {&#945;} (mvarId : MVarId) (x : TacticM &#945;) : TermElabM &#945; <span class="constant">:=</span>
11461     withMVarContext mvarId <span class="keyword">do</span>
11462       <span class="keyword">let</span> savedSyntheticMVars <span class="constant">:=</span> (&#8592; get).syntheticMVars
11463       modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> syntheticMVars <span class="constant">:=</span> [] }
11464       <span class="keyword">try</span>
11465         <span class="keyword">let</span> a &#8592; x.run' { main <span class="constant">:=</span> mvarId } { goals <span class="constant">:=</span> [mvarId] }
11466         synthesizeSyntheticMVars (mayPostpone <span class="constant">:=</span> false)
11467         pure a
11468       <span class="keyword">finally</span>
11469         modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> syntheticMVars <span class="constant">:=</span> savedSyntheticMVars }
11470 
11471   <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">runTactic</span> (mvarId : MVarId) (tacticCode : Syntax) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
11472     <span class="comment-delimiter">/- </span><span class="comment">Recall, `tacticCode` is the whole `by ...` expression.
11473        We store the `by` because in the future we want to save the initial state information at the `by` position. -/</span>
11474     <span class="keyword">let</span> code <span class="constant">:=</span> tacticCode[<span class="constant">1</span>]
11475     modifyThe Meta.State <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> mctx <span class="constant">:=</span> s.mctx.instantiateMVarDeclMVars mvarId }
11476     <span class="keyword">let</span> remainingGoals &#8592; withInfoHole mvarId <span class="keyword">do</span> liftTacticElabM mvarId <span class="keyword">do</span> evalTactic code; getUnsolvedGoals
11477     <span class="keyword">unless</span> remainingGoals.isEmpty <span class="keyword">do</span> reportUnsolvedGoals remainingGoals
11478 
11479   <span class="comment-delimiter">/-</span><span class="comment">- Try to synthesize the given pending synthetic metavariable. -/</span>
11480   <span class="keyword">private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">synthesizeSyntheticMVar</span> (mvarSyntheticDecl : SyntheticMVarDecl) (postponeOnError : Bool) (runTactics : Bool) : TermElabM Bool <span class="constant">:=</span>
11481     withRef mvarSyntheticDecl.stx <span class="keyword">do</span>
11482     <span class="keyword">match</span> mvarSyntheticDecl.kind <span class="keyword">with</span>
11483     | SyntheticMVarKind.typeClass <span class="constant">=&gt;</span> synthesizePendingInstMVar mvarSyntheticDecl.mvarId
11484     | SyntheticMVarKind.coe header? eNew expectedType eType e f? <span class="constant">=&gt;</span> synthesizePendingCoeInstMVar mvarSyntheticDecl.mvarId header? eNew expectedType eType e f?
11485     <span class="comment-delimiter">-- </span><span class="comment">NOTE: actual processing at `synthesizeSyntheticMVarsAux`
</span>11486     | SyntheticMVarKind.postponed savedContext <span class="constant">=&gt;</span> resumePostponed savedContext mvarSyntheticDecl.stx mvarSyntheticDecl.mvarId postponeOnError
11487     | SyntheticMVarKind.tactic tacticCode savedContext <span class="constant">=&gt;</span>
11488       withSavedContext savedContext <span class="keyword">do</span>
11489         <span class="keyword">if</span> runTactics <span class="keyword">then</span>
11490           runTactic mvarSyntheticDecl.mvarId tacticCode
11491           <span class="keyword">return</span> true
11492         <span class="keyword">else</span>
11493           <span class="keyword">return</span> false
11494   <span class="comment-delimiter">/-</span><span class="comment">-
11495     Try to synthesize the current list of pending synthetic metavariables.
11496     Return `true` if at least one of them was synthesized. -/</span>
11497   <span class="keyword">private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">synthesizeSyntheticMVarsStep</span> (postponeOnError : Bool) (runTactics : Bool) : TermElabM Bool <span class="constant">:=</span> <span class="keyword">do</span>
11498     <span class="keyword">let</span> ctx &#8592; read
11499     traceAtCmdPos `Elab.resuming <span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
11500       m<span class="constant">!</span><span class="string">"resuming synthetic metavariables, mayPostpone: {ctx.mayPostpone}, postponeOnError: {postponeOnError}"</span>
11501     <span class="keyword">let</span> syntheticMVars    <span class="constant">:=</span> (&#8592; get).syntheticMVars
11502     <span class="keyword">let</span> numSyntheticMVars <span class="constant">:=</span> syntheticMVars.length
11503     <span class="comment-delimiter">-- </span><span class="comment">We reset `syntheticMVars` because new synthetic metavariables may be created by `synthesizeSyntheticMVar`.
</span>11504     modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> syntheticMVars <span class="constant">:=</span> [] }
11505     <span class="comment-delimiter">-- </span><span class="comment">Recall that `syntheticMVars` is a list where head is the most recent pending synthetic metavariable.
</span>11506     <span class="comment-delimiter">-- </span><span class="comment">We use `filterRevM` instead of `filterM` to make sure we process the synthetic metavariables using the order they were created.
</span>11507     <span class="comment-delimiter">-- </span><span class="comment">It would not be incorrect to use `filterM`.
</span>11508     <span class="keyword">let</span> remainingSyntheticMVars &#8592; syntheticMVars.filterRevM <span class="keyword">fun</span> mvarDecl <span class="constant">=&gt;</span> <span class="keyword">do</span>
11509        <span class="comment-delimiter">-- </span><span class="comment">We use `traceM` because we want to make sure the metavar local context is used to trace the message
</span>11510        traceM `Elab.postpone (withMVarContext mvarDecl.mvarId <span class="keyword">do</span> addMessageContext m<span class="constant">!</span><span class="string">"resuming {mkMVar mvarDecl.mvarId}"</span>)
11511        <span class="keyword">let</span> succeeded &#8592; synthesizeSyntheticMVar mvarDecl postponeOnError runTactics
11512        trace[Elab.postpone] <span class="keyword">if</span> succeeded <span class="keyword">then</span> fmt <span class="string">"succeeded"</span> <span class="keyword">else</span> fmt <span class="string">"not ready yet"</span>
11513        pure <span class="constant">!</span>succeeded
11514     <span class="comment-delimiter">-- </span><span class="comment">Merge new synthetic metavariables with `remainingSyntheticMVars`, i.e., metavariables that still couldn't be synthesized
</span>11515     modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> syntheticMVars <span class="constant">:=</span> s.syntheticMVars <span class="constant">++</span> remainingSyntheticMVars }
11516     <span class="keyword">return</span> numSyntheticMVars <span class="constant">!=</span> remainingSyntheticMVars.length
11517 
11518   <span class="comment-delimiter">/-</span><span class="comment">-
11519     Try to process pending synthetic metavariables. If `mayPostpone == false`,
11520     then `syntheticMVars` is `[]` after executing this method.
11521 
11522     It keeps executing `synthesizeSyntheticMVarsStep` while progress is being made.
11523     If `mayPostpone == false`, then it applies default instances to `SyntheticMVarKind.typeClass` (if available)
11524     metavariables that are still unresolved, and then tries to resolve metavariables
11525     with `mayPostpone == false`. That is, we force them to produce error messages and/or commit to
11526     a "best option". If, after that, we still haven't made progress, we report "stuck" errors. -/</span>
11527   <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">synthesizeSyntheticMVars</span> (mayPostpone <span class="constant">:=</span> true) : TermElabM Unit <span class="constant">:=</span>
11528     <span class="keyword">let</span> <span class="keyword">rec</span> loop (u : Unit) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
11529       withRef (&#8592; getSomeSynthethicMVarsRef) <span class="constant">&lt;</span>| withIncRecDepth <span class="keyword">do</span>
11530         <span class="keyword">unless</span> (&#8592; get).syntheticMVars.isEmpty <span class="keyword">do</span>
11531           <span class="keyword">if</span> &#8592; synthesizeSyntheticMVarsStep (postponeOnError <span class="constant">:=</span> false) (runTactics <span class="constant">:=</span> false) <span class="keyword">then</span>
11532             loop ()
11533           <span class="keyword">else</span> <span class="keyword">if</span> <span class="constant">!</span>mayPostpone <span class="keyword">then</span>
11534             <span class="comment-delimiter">/- </span><span class="comment">Resume pending metavariables with "elaboration postponement" disabled.
11535                We postpone elaboration errors in this step by setting `postponeOnError := true`.
11536                Example:
11537                ```
11538                #check let x := &#10216;1, 2&#10217;; Prod.fst x
11539                ```
11540                The term `&#10216;1, 2&#10217;` can't be elaborated because the expected type is not know.
11541                The `x` at `Prod.fst x` is not elaborated because the type of `x` is not known.
11542                When we execute the following step with "elaboration postponement" disabled,
11543                the elaborator fails at `&#10216;1, 2&#10217;` and postpones it, and succeeds at `x` and learns
11544                that its type must be of the form `Prod ?&#945; ?&#946;`.
11545 
11546                Recall that we postponed `x` at `Prod.fst x` because its type it is not known.
11547                We the type of `x` may learn later its type and it may contain implicit and/or auto arguments.
11548                By disabling postponement, we are essentially giving up the opportunity of learning `x`s type
11549                and assume it does not have implict and/or auto arguments. -/</span>
11550             <span class="keyword">if</span> &#8592; withoutPostponing <span class="constant">&lt;</span>| synthesizeSyntheticMVarsStep (postponeOnError <span class="constant">:=</span> true) (runTactics <span class="constant">:=</span> false) <span class="keyword">then</span>
11551               loop ()
11552             <span class="keyword">else</span> <span class="keyword">if</span> &#8592; synthesizeUsingDefault <span class="keyword">then</span>
11553               loop ()
11554             <span class="keyword">else</span> <span class="keyword">if</span> &#8592; withoutPostponing <span class="constant">&lt;</span>| synthesizeSyntheticMVarsStep (postponeOnError <span class="constant">:=</span> false) (runTactics <span class="constant">:=</span> false) <span class="keyword">then</span>
11555               loop ()
11556             <span class="keyword">else</span> <span class="keyword">if</span> &#8592; synthesizeSyntheticMVarsStep (postponeOnError <span class="constant">:=</span> false) (runTactics <span class="constant">:=</span> true) <span class="keyword">then</span>
11557               loop ()
11558             <span class="keyword">else</span>
11559               reportStuckSyntheticMVars
11560     loop ()
<span class="keyword">11561 end</span>
11562 
<span class="keyword">11563 def</span> <span class="function-name">synthesizeSyntheticMVarsNoPostponing</span> : TermElabM Unit <span class="constant">:=</span>
11564   synthesizeSyntheticMVars (mayPostpone <span class="constant">:=</span> false)
11565 
<span class="comment-delimiter">11566 /- </span><span class="comment">Keep invoking `synthesizeUsingDefault` until it returns false. -/</span>
<span class="keyword">11567 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">synthesizeUsingDefaultLoop</span> : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
11568   <span class="keyword">if</span> (&#8592; synthesizeUsingDefault) <span class="keyword">then</span>
11569     synthesizeSyntheticMVars (mayPostpone <span class="constant">:=</span> true)
11570     synthesizeUsingDefaultLoop
11571 
<span class="keyword">11572 def</span> <span class="function-name">synthesizeSyntheticMVarsUsingDefault</span> : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
11573   synthesizeSyntheticMVars (mayPostpone <span class="constant">:=</span> true)
11574   synthesizeUsingDefaultLoop
11575 
<span class="keyword">11576 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">withSynthesizeImp</span> {&#945;} (k : TermElabM &#945;) (mayPostpone : Bool) : TermElabM &#945; <span class="constant">:=</span> <span class="keyword">do</span>
11577   <span class="keyword">let</span> syntheticMVarsSaved <span class="constant">:=</span> (&#8592; get).syntheticMVars
11578   modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> syntheticMVars <span class="constant">:=</span> [] }
11579   <span class="keyword">try</span>
11580     <span class="keyword">let</span> a &#8592; k
11581     synthesizeSyntheticMVars mayPostpone
11582     <span class="keyword">if</span> mayPostpone <span class="keyword">then</span>
11583       synthesizeUsingDefaultLoop
11584     <span class="keyword">return</span> a
11585   <span class="keyword">finally</span>
11586     modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> syntheticMVars <span class="constant">:=</span> s.syntheticMVars <span class="constant">++</span> syntheticMVarsSaved }
11587 
<span class="comment-delimiter">11588 /-</span><span class="comment">-
11589   Execute `k`, and synthesize pending synthetic metavariables created while executing `k` are solved.
11590   If `mayPostpone == false`, then all of them must be synthesized.
11591   Remark: even if `mayPostpone == true`, the method still uses `synthesizeUsingDefault` -/</span>
<span class="doc">11592 @[inline]</span> <span class="keyword">def</span> <span class="function-name">withSynthesize</span> [MonadFunctorT TermElabM m] [Monad m] (k : m &#945;) (mayPostpone <span class="constant">:=</span> false) : m &#945; <span class="constant">:=</span>
11593   monadMap (m <span class="constant">:=</span> TermElabM) (withSynthesizeImp . mayPostpone) k
11594 
<span class="comment-delimiter">11595 /-</span><span class="comment">- Elaborate `stx`, and make sure all pending synthetic metavariables created while elaborating `stx` are solved. -/</span>
<span class="keyword">11596 def</span> <span class="function-name">elabTermAndSynthesize</span> (stx : Syntax) (expectedType? : Option Expr) : TermElabM Expr <span class="constant">:=</span>
11597   withRef stx <span class="keyword">do</span>
11598     instantiateMVars (&#8592; withSynthesize <span class="constant">&lt;</span>| elabTerm stx expectedType?)
11599 
<span class="keyword">11600 end</span> Lean.Elab.Term
11601 ::::::::::::::
11602 Elab<span class="constant">/</span>Tactic.lean
11603 ::::::::::::::
<span class="comment-delimiter">11604 /-</span><span class="comment">
11605 Copyright (c) 2020 Microsoft Corporation. All rights reserved.
11606 Released under Apache 2.0 license as described in the file LICENSE.
11607 Authors: Leonardo de Moura, Sebastian Ullrich
11608 -/</span>
<span class="keyword">11609 import</span> Lean.Elab.Term
<span class="keyword">11610 import</span> Lean.Elab.Tactic.Basic
<span class="keyword">11611 import</span> Lean.Elab.Tactic.ElabTerm
<span class="keyword">11612 import</span> Lean.Elab.Tactic.Induction
<span class="keyword">11613 import</span> Lean.Elab.Tactic.Generalize
<span class="keyword">11614 import</span> Lean.Elab.Tactic.Injection
<span class="keyword">11615 import</span> Lean.Elab.Tactic.Match
<span class="keyword">11616 import</span> Lean.Elab.Tactic.Rewrite
<span class="keyword">11617 import</span> Lean.Elab.Tactic.Location
<span class="keyword">11618 import</span> Lean.Elab.Tactic.Simp
11619 ::::::::::::::
11620 Elab<span class="constant">/</span>Term.lean
11621 ::::::::::::::
<span class="comment-delimiter">11622 /-</span><span class="comment">
11623 Copyright (c) 2019 Microsoft Corporation. All rights reserved.
11624 Released under Apache 2.0 license as described in the file LICENSE.
11625 Authors: Leonardo de Moura
11626 -/</span>
<span class="keyword">11627 import</span> Lean.ResolveName
<span class="keyword">11628 import</span> Lean.Util.Sorry
<span class="keyword">11629 import</span> Lean.Util.ReplaceExpr
<span class="keyword">11630 import</span> Lean.Structure
<span class="keyword">11631 import</span> Lean.Meta.ExprDefEq
<span class="keyword">11632 import</span> Lean.Meta.AppBuilder
<span class="keyword">11633 import</span> Lean.Meta.SynthInstance
<span class="keyword">11634 import</span> Lean.Meta.CollectMVars
<span class="keyword">11635 import</span> Lean.Meta.Coe
<span class="keyword">11636 import</span> Lean.Meta.Tactic.Util
<span class="keyword">11637 import</span> Lean.Hygiene
<span class="keyword">11638 import</span> Lean.Util.RecDepth
<span class="keyword">11639 import</span> Lean.Elab.Log
<span class="keyword">11640 import</span> Lean.Elab.Level
<span class="keyword">11641 import</span> Lean.Elab.Attributes
<span class="keyword">11642 import</span> Lean.Elab.AutoBound
<span class="keyword">11643 import</span> Lean.Elab.InfoTree
<span class="keyword">11644 import</span> Lean.Elab.Open
<span class="keyword">11645 import</span> Lean.Elab.SetOption
11646 
<span class="keyword">11647 namespace</span> Lean.Elab.Term
<span class="comment-delimiter">11648 /-</span><span class="comment">
11649   Set isDefEq configuration for the elaborator.
11650   Note that we enable all approximations but `quasiPatternApprox`
11651 
11652   In Lean3 and Lean 4, we used to use the quasi-pattern approximation during elaboration.
11653   The example:
11654   ```
11655   def ex : StateT &#948; (StateT &#963; Id) &#963; :=
11656   monadLift (get : StateT &#963; Id &#963;)
11657   ```
11658   demonstrates why it produces counterintuitive behavior.
11659   We have the `Monad-lift` application:
11660   ```
11661   @monadLift ?m ?n ?c ?&#945; (get : StateT &#963; id &#963;) : ?n ?&#945;
11662   ```
11663   It produces the following unification problem when we process the expected type:
11664   ```
11665   ?n ?&#945; =?= StateT &#948; (StateT &#963; id) &#963;
11666   ==&gt; (approximate using first-order unification)
11667   ?n := StateT &#948; (StateT &#963; id)
11668   ?&#945; := &#963;
11669   ```
11670   Then, we need to solve:
11671   ```
11672   ?m ?&#945; =?= StateT &#963; id &#963;
11673   ==&gt; instantiate metavars
11674   ?m &#963; =?= StateT &#963; id &#963;
11675   ==&gt; (approximate since it is a quasi-pattern unification constraint)
11676   ?m := fun &#963; =&gt; StateT &#963; id &#963;
11677   ```
11678   Note that the constraint is not a Milner pattern because &#963; is in
11679   the local context of `?m`. We are ignoring the other possible solutions:
11680   ```
11681   ?m := fun &#963;' =&gt; StateT &#963; id &#963;
11682   ?m := fun &#963;' =&gt; StateT &#963;' id &#963;
11683   ?m := fun &#963;' =&gt; StateT &#963; id &#963;'
11684   ```
11685 
11686   We need the quasi-pattern approximation for elaborating recursor-like expressions (e.g., dependent `match with` expressions).
11687 
11688   If we had use first-order unification, then we would have produced
11689   the right answer: `?m := StateT &#963; id`
11690 
11691   Haskell would work on this example since it always uses
11692   first-order unification.
11693 -/</span>
<span class="keyword">11694 def</span> <span class="function-name">setElabConfig</span> (cfg : Meta.Config) : Meta.Config <span class="constant">:=</span>
11695   { cfg <span class="keyword">with</span> foApprox <span class="constant">:=</span> true, ctxApprox <span class="constant">:=</span> true, constApprox <span class="constant">:=</span> false, quasiPatternApprox <span class="constant">:=</span> false }
11696 
<span class="keyword">11697 structure</span> <span class="function-name">Context</span> <span class="keyword">where</span>
11698   fileName        : String
11699   fileMap         : FileMap
11700   declName?       : Option Name     <span class="constant">:=</span> none
11701   macroStack      : MacroStack      <span class="constant">:=</span> []
11702   currMacroScope  : MacroScope      <span class="constant">:=</span> firstFrontendMacroScope
11703   <span class="comment-delimiter">/- </span><span class="comment">When `mayPostpone == true`, an elaboration function may interrupt its execution by throwing `Exception.postpone`.
11704      The function `elabTerm` catches this exception and creates fresh synthetic metavariable `?m`, stores `?m` in
11705      the list of pending synthetic metavariables, and returns `?m`. -/</span>
11706   mayPostpone     : Bool            <span class="constant">:=</span> true
11707   <span class="comment-delimiter">/- </span><span class="comment">When `errToSorry` is set to true, the method `elabTerm` catches
11708      exceptions and converts them into synthetic `sorry`s.
11709      The implementation of choice nodes and overloaded symbols rely on the fact
11710      that when `errToSorry` is set to false for an elaboration function `F`, then
11711      `errToSorry` remains `false` for all elaboration functions invoked by `F`.
11712      That is, it is safe to transition `errToSorry` from `true` to `false`, but
11713      we must not set `errToSorry` to `true` when it is currently set to `false`. -/</span>
11714   errToSorry      : Bool            <span class="constant">:=</span> true
11715   <span class="comment-delimiter">/- </span><span class="comment">When `autoBoundImplicit` is set to true, instead of producing
11716      an "unknown identifier" error for unbound variables, we generate an
11717      internal exception. This exception is caught at `elabBinders` and
11718      `elabTypeWithUnboldImplicit`. Both methods add implicit declarations
11719      for the unbound variable and try again. -/</span>
11720   autoBoundImplicit  : Bool            <span class="constant">:=</span> false
11721   autoBoundImplicits : Std.PArray Expr <span class="constant">:=</span> {}
11722   <span class="comment-delimiter">/-</span><span class="comment">- Map from user name to internal unique name -/</span>
11723   sectionVars        : NameMap Name    <span class="constant">:=</span> {}
11724   <span class="comment-delimiter">/-</span><span class="comment">- Map from internal name to fvar -/</span>
11725   sectionFVars       : NameMap Expr    <span class="constant">:=</span> {}
11726   <span class="comment-delimiter">/-</span><span class="comment">- Enable/disable implicit lambdas feature. -/</span>
11727   implicitLambda     : Bool            <span class="constant">:=</span> true
11728 
<span class="comment-delimiter">11729 /-</span><span class="comment">- Saved context for postponed terms and tactics to be executed. -/</span>
<span class="keyword">11730 structure</span> <span class="function-name">SavedContext</span> <span class="keyword">where</span>
11731   declName?  : Option Name
11732   options    : Options
11733   openDecls  : List OpenDecl
11734   macroStack : MacroStack
11735   errToSorry : Bool
11736 
<span class="comment-delimiter">11737 /-</span><span class="comment">- We use synthetic metavariables as placeholders for pending elaboration steps. -/</span>
<span class="keyword">11738 inductive</span> <span class="function-name">SyntheticMVarKind</span> <span class="keyword">where</span>
11739   <span class="comment-delimiter">-- </span><span class="comment">typeclass instance search
</span>11740   | typeClass
11741   <span class="comment-delimiter">/- </span><span class="comment">Similar to typeClass, but error messages are different.
11742      if `f?` is `some f`, we produce an application type mismatch error message.
11743      Otherwise, if `header?` is `some header`, we generate the error `(header ++ "has type" ++ eType ++ "but it is expected to have type" ++ expectedType)`
11744      Otherwise, we generate the error `("type mismatch" ++ e ++ "has type" ++ eType ++ "but it is expected to have type" ++ expectedType)` -/</span>
11745   | coe (header? : Option String) (eNew : Expr) (expectedType : Expr) (eType : Expr) (e : Expr) (f? : Option Expr)
11746   <span class="comment-delimiter">-- </span><span class="comment">tactic block execution
</span>11747   | tactic (tacticCode : Syntax) (ctx : SavedContext)
11748   <span class="comment-delimiter">-- </span><span class="comment">`elabTerm` call that threw `Exception.postpone` (input is stored at `SyntheticMVarDecl.ref`)
</span>11749   | postponed (ctx : SavedContext)
11750 
<span class="keyword">11751 instance</span> <span class="function-name">:</span> ToString SyntheticMVarKind <span class="keyword">where</span>
11752   toString
11753     | SyntheticMVarKind.typeClass    <span class="constant">=&gt;</span> <span class="string">"typeclass"</span>
11754     | SyntheticMVarKind.coe ..       <span class="constant">=&gt;</span> <span class="string">"coe"</span>
11755     | SyntheticMVarKind.tactic ..    <span class="constant">=&gt;</span> <span class="string">"tactic"</span>
11756     | SyntheticMVarKind.postponed .. <span class="constant">=&gt;</span> <span class="string">"postponed"</span>
11757 
<span class="keyword">11758 structure</span> <span class="function-name">SyntheticMVarDecl</span> <span class="keyword">where</span>
11759   mvarId : MVarId
11760   stx : Syntax
11761   kind : SyntheticMVarKind
11762 
<span class="keyword">11763 inductive</span> <span class="function-name">MVarErrorKind</span> <span class="keyword">where</span>
11764   | implicitArg (ctx : Expr)
11765   | hole
11766   | custom (msgData : MessageData)
11767 
<span class="keyword">11768 instance</span> <span class="function-name">:</span> ToString MVarErrorKind <span class="keyword">where</span>
11769   toString
11770     | MVarErrorKind.implicitArg ctx <span class="constant">=&gt;</span> <span class="string">"implicitArg"</span>
11771     | MVarErrorKind.hole            <span class="constant">=&gt;</span> <span class="string">"hole"</span>
11772     | MVarErrorKind.custom msg      <span class="constant">=&gt;</span> <span class="string">"custom"</span>
11773 
<span class="keyword">11774 structure</span> <span class="function-name">MVarErrorInfo</span> <span class="keyword">where</span>
11775   mvarId    : MVarId
11776   ref       : Syntax
11777   kind      : MVarErrorKind
11778 
<span class="keyword">11779 structure</span> <span class="function-name">LetRecToLift</span> <span class="keyword">where</span>
11780   ref            : Syntax
11781   fvarId         : FVarId
11782   attrs          : Array Attribute
11783   shortDeclName  : Name
11784   declName       : Name
11785   lctx           : LocalContext
11786   localInstances : LocalInstances
11787   type           : Expr
11788   val            : Expr
11789   mvarId         : MVarId
11790 
<span class="keyword">11791 structure</span> <span class="function-name">State</span> <span class="keyword">where</span>
11792   levelNames        : List Name       <span class="constant">:=</span> []
11793   syntheticMVars    : List SyntheticMVarDecl <span class="constant">:=</span> []
11794   mvarErrorInfos    : List MVarErrorInfo <span class="constant">:=</span> []
11795   messages          : MessageLog <span class="constant">:=</span> {}
11796   letRecsToLift     : List LetRecToLift <span class="constant">:=</span> []
11797   infoState         : InfoState <span class="constant">:=</span> {}
11798   <span class="keyword">deriving</span> Inhabited
11799 
<span class="keyword">11800 abbrev</span> TermElabM <span class="constant">:=</span> ReaderT Context <span class="constant">$</span> StateRefT State MetaM
<span class="keyword">11801 abbrev</span> TermElab  <span class="constant">:=</span> Syntax <span class="constant">&#8594;</span> Option Expr <span class="constant">&#8594;</span> TermElabM Expr
11802 
<span class="keyword">11803 open</span> Meta
11804 
<span class="keyword">11805 instance</span> <span class="function-name">:</span> Inhabited (TermElabM &#945;) <span class="keyword">where</span>
11806   default <span class="constant">:=</span> throw arbitrary
11807 
<span class="keyword">11808 structure</span> <span class="function-name">SavedState</span> <span class="keyword">where</span>
11809   meta   : Meta.SavedState
11810   <span class="comment">&#171;</span>elab<span class="comment">&#187;</span> : State
11811   <span class="keyword">deriving</span> Inhabited
11812 
<span class="keyword">11813 protected</span> <span class="keyword">def</span> <span class="function-name">saveState</span> : TermElabM SavedState <span class="constant">:=</span> <span class="keyword">do</span>
11814   pure { meta <span class="constant">:=</span> (&#8592; Meta.saveState), <span class="comment">&#171;</span>elab<span class="comment">&#187;</span> <span class="constant">:=</span> (&#8592; get) }
11815 
<span class="keyword">11816 def</span> <span class="function-name">SavedState.restore</span> (s : SavedState) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
11817   <span class="keyword">let</span> traceState &#8592; getTraceState <span class="comment-delimiter">-- </span><span class="comment">We never backtrack trace message
</span>11818   <span class="comment-delimiter">-- </span><span class="comment">We also preserve `TacticInfo` nodes to be able to display the tactic state of broken tactic scripts
</span>11819   <span class="keyword">let</span> infoStateNew <span class="constant">:=</span> (&#8592; get).infoState
11820   <span class="keyword">let</span> oldInfoSize  <span class="constant">:=</span> s.<span class="keyword">elab</span>.infoState.trees.size
11821   s.meta.restore
11822   set s.<span class="keyword">elab</span>
11823   setTraceState traceState
11824   <span class="comment-delimiter">-- </span><span class="comment">Add new `TacticInfo` nodes back to restored `infoState`
</span>11825   modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span>
11826     infoState.trees <span class="constant">:=</span> infoStateNew.trees.foldl (init <span class="constant">:=</span> s.infoState.trees) (start <span class="constant">:=</span> oldInfoSize) <span class="keyword">fun</span> trees info <span class="constant">=&gt;</span>
11827       <span class="keyword">match</span> info <span class="keyword">with</span>
11828       | InfoTree.node (Info.ofTacticInfo <span class="preprocessor">_</span>) <span class="preprocessor">_</span> <span class="constant">=&gt;</span> trees.push info
11829       | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> trees
11830   }
11831 
<span class="keyword">11832 instance</span> <span class="function-name">:</span> MonadBacktrack SavedState TermElabM <span class="keyword">where</span>
11833   saveState      <span class="constant">:=</span> Term.saveState
11834   restoreState b <span class="constant">:=</span> b.restore
11835 
<span class="keyword">11836 abbrev</span> TermElabResult (&#945; : <span class="type">Type</span>) <span class="constant">:=</span> EStateM.Result Exception SavedState &#945;
11837 
<span class="keyword">11838 instance</span> [Inhabited &#945;] : Inhabited (TermElabResult &#945;) <span class="keyword">where</span>
11839   default <span class="constant">:=</span> EStateM.Result.ok arbitrary arbitrary
11840 
<span class="keyword">11841 def</span> <span class="function-name">setMessageLog</span> (messages : MessageLog) : TermElabM Unit <span class="constant">:=</span>
11842   modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> messages <span class="constant">:=</span> messages }
11843 
<span class="keyword">11844 def</span> <span class="function-name">resetMessageLog</span> : TermElabM Unit <span class="constant">:=</span>
11845   setMessageLog {}
11846 
<span class="keyword">11847 def</span> <span class="function-name">getMessageLog</span> : TermElabM MessageLog <span class="constant">:=</span>
11848   <span class="keyword">return</span> (&#8592; get).messages
11849 
<span class="comment-delimiter">11850 /-</span><span class="comment">-
11851   Execute `x`, save resulting expression and new state.
11852   If `x` fails, then it also stores exception and new state.
11853   Remark: we do not capture `Exception.postpone`. -/</span>
<span class="doc">11854 @[inline]</span> <span class="keyword">def</span> <span class="function-name">observing</span> (x : TermElabM &#945;) : TermElabM (TermElabResult &#945;) <span class="constant">:=</span> <span class="keyword">do</span>
11855   <span class="keyword">let</span> s &#8592; saveState
11856   <span class="keyword">try</span>
11857     <span class="keyword">let</span> e &#8592; x
11858     <span class="keyword">let</span> sNew &#8592; saveState
11859     s.restore
11860     pure (EStateM.Result.ok e sNew)
11861   <span class="keyword">catch</span>
11862     | ex<span class="constant">@</span>(Exception.error <span class="preprocessor">_</span> <span class="preprocessor">_</span>) <span class="constant">=&gt;</span>
11863       <span class="keyword">let</span> sNew &#8592; saveState
11864       s.restore
11865       pure (EStateM.Result.error ex sNew)
11866     | ex<span class="constant">@</span>(Exception.internal id <span class="preprocessor">_</span>) <span class="constant">=&gt;</span>
11867       <span class="keyword">if</span> id <span class="constant">==</span> postponeExceptionId <span class="keyword">then</span> s.restore
11868       throw ex
11869 
<span class="comment-delimiter">11870 /-</span><span class="comment">-
11871   Apply the result/exception and state captured with `observing`.
11872   We use this method to implement overloaded notation and symbols. -/</span>
<span class="doc">11873 @[inline]</span> <span class="keyword">def</span> <span class="function-name">applyResult</span> (result : TermElabResult &#945;) : TermElabM &#945; <span class="constant">:=</span>
11874   <span class="keyword">match</span> result <span class="keyword">with</span>
11875   | EStateM.Result.ok a r     <span class="constant">=&gt;</span> <span class="keyword">do</span> r.restore; pure a
11876   | EStateM.Result.error ex r <span class="constant">=&gt;</span> <span class="keyword">do</span> r.restore; throw ex
11877 
<span class="comment-delimiter">11878 /-</span><span class="comment">-
11879   Execute `x`, but keep state modifications only if `x` did not postpone.
11880   This method is useful to implement elaboration functions that cannot decide whether
11881   they need to postpone or not without updating the state. -/</span>
<span class="keyword">11882 def</span> <span class="function-name">commitIfDidNotPostpone</span> (x : TermElabM &#945;) : TermElabM &#945; <span class="constant">:=</span> <span class="keyword">do</span>
11883   <span class="comment-delimiter">-- </span><span class="comment">We just reuse the implementation of `observing` and `applyResult`.
</span>11884   <span class="keyword">let</span> r &#8592; observing x
11885   applyResult r
11886 
<span class="comment-delimiter">11887 /-</span><span class="comment">-
11888   Execute `x` but discard changes performed at `Term.State` and `Meta.State`.
11889   Recall that the environment is at `Core.State`. Thus, any updates to it will
11890   be preserved. This method is useful for performing computations where all
11891   metavariable must be resolved or discarded. -/</span>
<span class="keyword">11892 def</span> <span class="function-name">withoutModifyingElabMetaState</span> (x : TermElabM &#945;) : TermElabM &#945; <span class="constant">:=</span> <span class="keyword">do</span>
11893   <span class="keyword">let</span> s &#8592; get
11894   <span class="keyword">let</span> sMeta &#8592; getThe Meta.State
11895   <span class="keyword">try</span>
11896     x
11897   <span class="keyword">finally</span>
11898     set s
11899     set sMeta
11900 
<span class="keyword">11901 def</span> <span class="function-name">getLevelNames</span> : TermElabM (List Name) <span class="constant">:=</span>
11902   <span class="keyword">return</span> (&#8592; get).levelNames
11903 
<span class="keyword">11904 def</span> <span class="function-name">getFVarLocalDecl!</span> (fvar : Expr) : TermElabM LocalDecl <span class="constant">:=</span> <span class="keyword">do</span>
11905   <span class="keyword">match</span> (&#8592; getLCtx).find? fvar.fvarId<span class="constant">!</span> <span class="keyword">with</span>
11906   | some d <span class="constant">=&gt;</span> pure d
11907   | none   <span class="constant">=&gt;</span> <span class="warning">unreachable</span><span class="constant">!</span>
11908 
<span class="keyword">11909 instance</span> <span class="function-name">:</span> AddErrorMessageContext TermElabM <span class="keyword">where</span>
11910   add ref msg <span class="constant">:=</span> <span class="keyword">do</span>
11911     <span class="keyword">let</span> ctx &#8592; read
11912     <span class="keyword">let</span> ref <span class="constant">:=</span> getBetterRef ref ctx.macroStack
11913     <span class="keyword">let</span> msg &#8592; addMessageContext msg
11914     <span class="keyword">let</span> msg &#8592; addMacroStack msg ctx.macroStack
11915     pure (ref, msg)
11916 
<span class="keyword">11917 instance</span> <span class="function-name">:</span> MonadLog TermElabM <span class="keyword">where</span>
11918   getRef      <span class="constant">:=</span> getRef
11919   getFileMap  <span class="constant">:=</span> <span class="keyword">return</span> (&#8592; read).fileMap
11920   getFileName <span class="constant">:=</span> <span class="keyword">return</span> (&#8592; read).fileName
11921   logMessage msg <span class="constant">:=</span> <span class="keyword">do</span>
11922     <span class="keyword">let</span> ctx &#8592; readThe Core.Context
11923     <span class="keyword">let</span> msg <span class="constant">:=</span> { msg <span class="keyword">with</span> data <span class="constant">:=</span> MessageData.withNamingContext { currNamespace <span class="constant">:=</span> ctx.currNamespace, openDecls <span class="constant">:=</span> ctx.openDecls } msg.data };
11924     modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> messages <span class="constant">:=</span> s.messages.add msg }
11925 
<span class="keyword">11926 protected</span> <span class="keyword">def</span> <span class="function-name">getCurrMacroScope</span> : TermElabM MacroScope <span class="constant">:=</span> <span class="keyword">do</span> pure (&#8592; read).currMacroScope
<span class="keyword">11927 protected</span> <span class="keyword">def</span> <span class="function-name">getMainModule</span>     : TermElabM Name <span class="constant">:=</span> <span class="keyword">do</span> pure (&#8592; getEnv).mainModule
11928 
<span class="doc">11929 @[inline]</span> <span class="keyword">protected</span> <span class="keyword">def</span> <span class="function-name">withFreshMacroScope</span> (x : TermElabM &#945;) : TermElabM &#945; <span class="constant">:=</span> <span class="keyword">do</span>
11930   <span class="keyword">let</span> fresh &#8592; modifyGetThe Core.State (<span class="keyword">fun</span> st <span class="constant">=&gt;</span> (st.nextMacroScope, { st <span class="keyword">with</span> nextMacroScope <span class="constant">:=</span> st.nextMacroScope <span class="constant">+</span> <span class="constant">1</span> }))
11931   withReader (<span class="keyword">fun</span> ctx <span class="constant">=&gt;</span> { ctx <span class="keyword">with</span> currMacroScope <span class="constant">:=</span> fresh }) x
11932 
<span class="keyword">11933 instance</span> <span class="function-name">:</span> MonadQuotation TermElabM <span class="keyword">where</span>
11934   getCurrMacroScope   <span class="constant">:=</span> Term.getCurrMacroScope
11935   getMainModule       <span class="constant">:=</span> Term.getMainModule
11936   withFreshMacroScope <span class="constant">:=</span> Term.withFreshMacroScope
11937 
<span class="keyword">11938 instance</span> <span class="function-name">:</span> MonadInfoTree TermElabM <span class="keyword">where</span>
11939   getInfoState      <span class="constant">:=</span> <span class="keyword">return</span> (&#8592; get).infoState
11940   modifyInfoState f <span class="constant">:=</span> modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> infoState <span class="constant">:=</span> f s.infoState }
11941 
<span class="keyword">11942 unsafe</span> <span class="keyword">def</span> <span class="function-name">mkTermElabAttributeUnsafe</span> : IO (KeyedDeclsAttribute TermElab) <span class="constant">:=</span>
11943   mkElabAttribute TermElab `Lean.Elab.Term.termElabAttribute `builtinTermElab `termElab `Lean.Parser.Term `Lean.Elab.Term.TermElab <span class="string">"term"</span>
11944 
<span class="doc">11945 @[implementedBy mkTermElabAttributeUnsafe]</span>
<span class="keyword">11946 constant</span> <span class="function-name">mkTermElabAttribute</span> : IO (KeyedDeclsAttribute TermElab)
11947 
<span class="keyword">11948 builtin_initialize</span> termElabAttribute : KeyedDeclsAttribute TermElab &#8592; mkTermElabAttribute
11949 
<span class="comment-delimiter">11950 /-</span><span class="comment">-
11951   Auxiliary datatatype for presenting a Lean lvalue modifier.
11952   We represent a unelaborated lvalue as a `Syntax` (or `Expr`) and `List LVal`.
11953   Example: `a.foo[i].1` is represented as the `Syntax` `a` and the list
11954   `[LVal.fieldName "foo", LVal.getOp i, LVal.fieldIdx 1]`.
11955   Recall that the notation `a[i]` is not just for accessing arrays in Lean. -/</span>
<span class="keyword">11956 inductive</span> <span class="function-name">LVal</span> <span class="keyword">where</span>
11957   | fieldIdx  (ref : Syntax) (i : Nat)
11958     <span class="comment-delimiter">/- </span><span class="comment">Field `suffix?` is for producing better error messages because `x.y` may be a field access or a hierachical/composite name.
11959        `ref` is the syntax object representing the field. `targetStx` is the target object being accessed. -/</span>
11960   | fieldName (ref : Syntax) (name : String) (suffix? : Option Name) (targetStx : Syntax)
11961   | getOp     (ref : Syntax) (idx : Syntax)
11962 
<span class="keyword">11963 def</span> <span class="function-name">LVal.getRef</span> : LVal <span class="constant">&#8594;</span> Syntax
11964   | LVal.fieldIdx ref <span class="preprocessor">_</span>    <span class="constant">=&gt;</span> ref
11965   | LVal.fieldName ref ..  <span class="constant">=&gt;</span> ref
11966   | LVal.getOp ref <span class="preprocessor">_</span>       <span class="constant">=&gt;</span> ref
11967 
<span class="keyword">11968 def</span> <span class="function-name">LVal.isFieldName</span> : LVal <span class="constant">&#8594;</span> Bool
11969   | LVal.fieldName .. <span class="constant">=&gt;</span> true
11970   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> false
11971 
<span class="keyword">11972 instance</span> <span class="function-name">:</span> ToString LVal <span class="keyword">where</span>
11973   toString
11974     | LVal.fieldIdx <span class="preprocessor">_</span> i     <span class="constant">=&gt;</span> toString i
11975     | LVal.fieldName <span class="preprocessor">_</span> n .. <span class="constant">=&gt;</span> n
11976     | LVal.getOp <span class="preprocessor">_</span> idx      <span class="constant">=&gt;</span> <span class="string">"["</span> <span class="constant">++</span> toString idx <span class="constant">++</span> <span class="string">"]"</span>
11977 
<span class="keyword">11978 def</span> <span class="function-name">getDeclName?</span> : TermElabM (Option Name) <span class="constant">:=</span> <span class="keyword">return</span> (&#8592; read).declName?
<span class="keyword">11979 def</span> <span class="function-name">getLetRecsToLift</span> : TermElabM (List LetRecToLift) <span class="constant">:=</span> <span class="keyword">return</span> (&#8592; get).letRecsToLift
<span class="keyword">11980 def</span> <span class="function-name">isExprMVarAssigned</span> (mvarId : MVarId) : TermElabM Bool <span class="constant">:=</span> <span class="keyword">return</span> (&#8592; getMCtx).isExprAssigned mvarId
<span class="keyword">11981 def</span> <span class="function-name">getMVarDecl</span> (mvarId : MVarId) : TermElabM MetavarDecl <span class="constant">:=</span> <span class="keyword">return</span> (&#8592; getMCtx).getDecl mvarId
<span class="keyword">11982 def</span> <span class="function-name">assignLevelMVar</span> (mvarId : MVarId) (val : Level) : TermElabM Unit <span class="constant">:=</span> modifyThe Meta.State <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> mctx <span class="constant">:=</span> s.mctx.assignLevel mvarId val }
11983 
<span class="keyword">11984 def</span> <span class="function-name">withDeclName</span> (name : Name) (x : TermElabM &#945;) : TermElabM &#945; <span class="constant">:=</span>
11985   withReader (<span class="keyword">fun</span> ctx <span class="constant">=&gt;</span> { ctx <span class="keyword">with</span> declName? <span class="constant">:=</span> name }) x
11986 
<span class="keyword">11987 def</span> <span class="function-name">setLevelNames</span> (levelNames : List Name) : TermElabM Unit <span class="constant">:=</span>
11988   modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> levelNames <span class="constant">:=</span> levelNames }
11989 
<span class="keyword">11990 def</span> <span class="function-name">withLevelNames</span> (levelNames : List Name) (x : TermElabM &#945;) : TermElabM &#945; <span class="constant">:=</span> <span class="keyword">do</span>
11991   <span class="keyword">let</span> levelNamesSaved &#8592; getLevelNames
11992   setLevelNames levelNames
11993   <span class="keyword">try</span> x <span class="keyword">finally</span> setLevelNames levelNamesSaved
11994 
<span class="keyword">11995 def</span> <span class="function-name">withoutErrToSorry</span> (x : TermElabM &#945;) : TermElabM &#945; <span class="constant">:=</span>
11996   withReader (<span class="keyword">fun</span> ctx <span class="constant">=&gt;</span> { ctx <span class="keyword">with</span> errToSorry <span class="constant">:=</span> false }) x
11997 
<span class="comment-delimiter">11998 /-</span><span class="comment">- For testing `TermElabM` methods. The #eval command will sign the error. -/</span>
<span class="keyword">11999 def</span> <span class="function-name">throwErrorIfErrors</span> : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
12000   <span class="keyword">if</span> (&#8592; get).messages.hasErrors <span class="keyword">then</span>
12001     throwError <span class="string">"Error(s)"</span>
12002 
<span class="doc">12003 @[inline]</span> <span class="keyword">def</span> <span class="function-name">traceAtCmdPos</span> (cls : Name) (msg : Unit <span class="constant">&#8594;</span> MessageData) : TermElabM Unit <span class="constant">:=</span>
12004 withRef Syntax.missing <span class="constant">$</span> trace cls msg
12005 
<span class="keyword">12006 def</span> <span class="function-name">ppGoal</span> (mvarId : MVarId) : TermElabM Format <span class="constant">:=</span>
12007   Meta.ppGoal mvarId
12008 
<span class="keyword">12009 open</span> Level (LevelElabM)
12010 
<span class="keyword">12011 def</span> <span class="function-name">liftLevelM</span> (x : LevelElabM &#945;) : TermElabM &#945; <span class="constant">:=</span> <span class="keyword">do</span>
12012   <span class="keyword">let</span> ctx &#8592; read
12013   <span class="keyword">let</span> ref &#8592; getRef
12014   <span class="keyword">let</span> mctx &#8592; getMCtx
12015   <span class="keyword">let</span> ngen &#8592; getNGen
12016   <span class="keyword">let</span> lvlCtx : Level.Context <span class="constant">:=</span> { options <span class="constant">:=</span> (&#8592; getOptions), ref <span class="constant">:=</span> ref, autoBoundImplicit <span class="constant">:=</span> ctx.autoBoundImplicit }
12017   <span class="keyword">match</span> (x lvlCtx).run { ngen <span class="constant">:=</span> ngen, mctx <span class="constant">:=</span> mctx, levelNames <span class="constant">:=</span> (&#8592; getLevelNames) } <span class="keyword">with</span>
12018   | EStateM.Result.ok a newS  <span class="constant">=&gt;</span> setMCtx newS.mctx; setNGen newS.ngen; setLevelNames newS.levelNames; pure a
12019   | EStateM.Result.error ex <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throw ex
12020 
<span class="keyword">12021 def</span> <span class="function-name">elabLevel</span> (stx : Syntax) : TermElabM Level <span class="constant">:=</span>
12022   liftLevelM <span class="constant">$</span> Level.elabLevel stx
12023 
<span class="comment-delimiter">12024 /- </span><span class="comment">Elaborate `x` with `stx` on the macro stack -/</span>
<span class="doc">12025 @[inline]</span> <span class="keyword">def</span> <span class="function-name">withMacroExpansion</span> (beforeStx afterStx : Syntax) (x : TermElabM &#945;) : TermElabM &#945; <span class="constant">:=</span>
12026   withMacroExpansionInfo beforeStx afterStx <span class="keyword">do</span>
12027     withReader (<span class="keyword">fun</span> ctx <span class="constant">=&gt;</span> { ctx <span class="keyword">with</span> macroStack <span class="constant">:=</span> { before <span class="constant">:=</span> beforeStx, after <span class="constant">:=</span> afterStx } :: ctx.macroStack }) x
12028 
<span class="comment-delimiter">12029 /-</span><span class="comment">
12030   Add the given metavariable to the list of pending synthetic metavariables.
12031   The method `synthesizeSyntheticMVars` is used to process the metavariables on this list. -/</span>
<span class="keyword">12032 def</span> <span class="function-name">registerSyntheticMVar</span> (stx : Syntax) (mvarId : MVarId) (kind : SyntheticMVarKind) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
12033   modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> syntheticMVars <span class="constant">:=</span> { mvarId <span class="constant">:=</span> mvarId, stx <span class="constant">:=</span> stx, kind <span class="constant">:=</span> kind } :: s.syntheticMVars }
12034 
<span class="keyword">12035 def</span> <span class="function-name">registerSyntheticMVarWithCurrRef</span> (mvarId : MVarId) (kind : SyntheticMVarKind) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
12036   registerSyntheticMVar (&#8592; getRef) mvarId kind
12037 
<span class="keyword">12038 def</span> <span class="function-name">registerMVarErrorHoleInfo</span> (mvarId : MVarId) (ref : Syntax) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
12039   modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> mvarErrorInfos <span class="constant">:=</span> { mvarId <span class="constant">:=</span> mvarId, ref <span class="constant">:=</span> ref, kind <span class="constant">:=</span> MVarErrorKind.hole } :: s.mvarErrorInfos }
12040 
<span class="keyword">12041 def</span> <span class="function-name">registerMVarErrorImplicitArgInfo</span> (mvarId : MVarId) (ref : Syntax) (app : Expr) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
12042   modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> mvarErrorInfos <span class="constant">:=</span> { mvarId <span class="constant">:=</span> mvarId, ref <span class="constant">:=</span> ref, kind <span class="constant">:=</span> MVarErrorKind.implicitArg app } :: s.mvarErrorInfos }
12043 
<span class="keyword">12044 def</span> <span class="function-name">registerMVarErrorCustomInfo</span> (mvarId : MVarId) (ref : Syntax) (msgData : MessageData) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
12045   modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> mvarErrorInfos <span class="constant">:=</span> { mvarId <span class="constant">:=</span> mvarId, ref <span class="constant">:=</span> ref, kind <span class="constant">:=</span> MVarErrorKind.custom msgData } :: s.mvarErrorInfos }
12046 
<span class="keyword">12047 def</span> <span class="function-name">registerCustomErrorIfMVar</span> (e : Expr) (ref : Syntax) (msgData : MessageData) : TermElabM Unit <span class="constant">:=</span>
12048   <span class="keyword">match</span> e.getAppFn <span class="keyword">with</span>
12049   | Expr.mvar mvarId <span class="preprocessor">_</span> <span class="constant">=&gt;</span> registerMVarErrorCustomInfo mvarId ref msgData
12050   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> pure ()
12051 
<span class="comment-delimiter">12052 /-</span><span class="comment">
12053   Auxiliary method for reporting errors of the form "... contains metavariables ...".
12054   This kind of error is thrown, for example, at `Match.lean` where elaboration
12055   cannot continue if there are metavariables in patterns.
12056   We only want to log it if we haven't logged any error so far. -/</span>
<span class="keyword">12057 def</span> <span class="function-name">throwMVarError</span> (m : MessageData) : TermElabM &#945; <span class="constant">:=</span> <span class="keyword">do</span>
12058   <span class="keyword">if</span> (&#8592; get).messages.hasErrors <span class="keyword">then</span>
12059     throwAbortTerm
12060   <span class="keyword">else</span>
12061     throwError m
12062 
<span class="keyword">12063 def</span> <span class="function-name">MVarErrorInfo.logError</span> (mvarErrorInfo : MVarErrorInfo) (extraMsg? : Option MessageData) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
12064   <span class="keyword">match</span> mvarErrorInfo.kind <span class="keyword">with</span>
12065   | MVarErrorKind.implicitArg app <span class="constant">=&gt;</span> <span class="keyword">do</span>
12066     <span class="keyword">let</span> app &#8592; instantiateMVars app
12067     <span class="keyword">let</span> msg : MessageData <span class="constant">:=</span> m<span class="constant">!</span><span class="string">"don't know how to synthesize implicit argument{indentExpr app.setAppPPExplicitForExposingMVars}"</span>
12068     <span class="keyword">let</span> msg <span class="constant">:=</span> msg <span class="constant">++</span> Format.line <span class="constant">++</span> <span class="string">"context:"</span> <span class="constant">++</span> Format.line <span class="constant">++</span> MessageData.ofGoal mvarErrorInfo.mvarId
12069     logErrorAt mvarErrorInfo.ref (appendExtra msg)
12070   | MVarErrorKind.hole <span class="constant">=&gt;</span> <span class="keyword">do</span>
12071     <span class="keyword">let</span> msg : MessageData <span class="constant">:=</span> <span class="string">"don't know how to synthesize placeholder"</span>
12072     <span class="keyword">let</span> msg <span class="constant">:=</span> msg <span class="constant">++</span> Format.line <span class="constant">++</span> <span class="string">"context:"</span> <span class="constant">++</span> Format.line <span class="constant">++</span> MessageData.ofGoal mvarErrorInfo.mvarId
12073     logErrorAt mvarErrorInfo.ref (MessageData.tagged `Elab.synthPlaceholder <span class="constant">&lt;</span>| appendExtra msg)
12074   | MVarErrorKind.custom msg <span class="constant">=&gt;</span>
12075     logErrorAt mvarErrorInfo.ref (appendExtra msg)
<span class="keyword">12076 where</span>
12077   appendExtra (msg : MessageData) : MessageData <span class="constant">:=</span>
12078     <span class="keyword">match</span> extraMsg? <span class="keyword">with</span>
12079     | none <span class="constant">=&gt;</span> msg
12080     | some extraMsg <span class="constant">=&gt;</span> msg <span class="constant">++</span> extraMsg
12081 
<span class="comment-delimiter">12082 /-</span><span class="comment">-
12083   Try to log errors for the unassigned metavariables `pendingMVarIds`.
12084 
12085   Return `true` if there were "unfilled holes", and we should "abort" declaration.
12086   TODO: try to fill "all" holes using synthetic "sorry's"
12087 
12088   Remark: We only log the "unfilled holes" as new errors if no error has been logged so far. -/</span>
<span class="keyword">12089 def</span> <span class="function-name">logUnassignedUsingErrorInfos</span> (pendingMVarIds : Array MVarId) (extraMsg? : Option MessageData <span class="constant">:=</span> none) : TermElabM Bool <span class="constant">:=</span> <span class="keyword">do</span>
12090   <span class="keyword">let</span> s &#8592; get
12091   <span class="keyword">let</span> hasOtherErrors <span class="constant">:=</span> s.messages.hasErrors
12092   <span class="keyword">let</span> <span class="keyword">mut</span> hasNewErrors <span class="constant">:=</span> false
12093   <span class="keyword">let</span> <span class="keyword">mut</span> alreadyVisited : NameSet <span class="constant">:=</span> {}
12094   <span class="keyword">for</span> mvarErrorInfo <span class="keyword">in</span> s.mvarErrorInfos <span class="keyword">do</span>
12095     <span class="keyword">let</span> mvarId <span class="constant">:=</span> mvarErrorInfo.mvarId
12096     <span class="keyword">unless</span> alreadyVisited.contains mvarId <span class="keyword">do</span>
12097       alreadyVisited <span class="constant">:=</span> alreadyVisited.insert mvarId
12098       <span class="keyword">let</span> foundError &#8592; withMVarContext mvarId <span class="keyword">do</span>
12099         <span class="comment-delimiter">/- </span><span class="comment">The metavariable `mvarErrorInfo.mvarId` may have been assigned or
12100            delayed assigned to another metavariable that is unassigned. -/</span>
12101         <span class="keyword">let</span> mvarDeps &#8592; getMVars (mkMVar mvarId)
12102         <span class="keyword">if</span> mvarDeps.any pendingMVarIds.contains <span class="keyword">then</span> <span class="keyword">do</span>
12103           <span class="keyword">unless</span> hasOtherErrors <span class="keyword">do</span>
12104             mvarErrorInfo.logError extraMsg?
12105           pure true
12106         <span class="keyword">else</span>
12107           pure false
12108       <span class="keyword">if</span> foundError <span class="keyword">then</span>
12109         hasNewErrors <span class="constant">:=</span> true
12110   <span class="keyword">return</span> hasNewErrors
12111 
<span class="comment-delimiter">12112 /-</span><span class="comment">- Ensure metavariables registered using `registerMVarErrorInfos` (and used in the given declaration) have been assigned. -/</span>
<span class="keyword">12113 def</span> <span class="function-name">ensureNoUnassignedMVars</span> (decl : Declaration) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
12114   <span class="keyword">let</span> pendingMVarIds &#8592; getMVarsAtDecl decl
12115   <span class="keyword">if</span> (&#8592; logUnassignedUsingErrorInfos pendingMVarIds) <span class="keyword">then</span>
12116     throwAbortCommand
12117 
<span class="comment-delimiter">12118 /-</span><span class="comment">
12119   Execute `x` without allowing it to postpone elaboration tasks.
12120   That is, `tryPostpone` is a noop. -/</span>
<span class="doc">12121 @[inline]</span> <span class="keyword">def</span> <span class="function-name">withoutPostponing</span> (x : TermElabM &#945;) : TermElabM &#945; <span class="constant">:=</span>
12122   withReader (<span class="keyword">fun</span> ctx <span class="constant">=&gt;</span> { ctx <span class="keyword">with</span> mayPostpone <span class="constant">:=</span> false }) x
12123 
<span class="comment-delimiter">12124 /-</span><span class="comment">- Creates syntax for `(` &lt;ident&gt; `:` &lt;type&gt; `)` -/</span>
<span class="keyword">12125 def</span> <span class="function-name">mkExplicitBinder</span> (ident : Syntax) (type : Syntax) : Syntax <span class="constant">:=</span>
12126   mkNode ``Lean.Parser.Term.explicitBinder <span class="constant">#</span>[mkAtom <span class="string">"("</span>, mkNullNode <span class="constant">#</span>[ident], mkNullNode <span class="constant">#</span>[mkAtom <span class="string">":"</span>, type], mkNullNode, mkAtom <span class="string">")"</span>]
12127 
<span class="comment-delimiter">12128 /-</span><span class="comment">-
12129   Convert unassigned universe level metavariables into parameters.
12130   The new parameter names are of the form `u_i` where `i &gt;= nextParamIdx`.
12131   The method returns the updated expression and new `nextParamIdx`.
12132 
12133   Remark: we make sure the generated parameter names do not clash with the universes at `ctx.levelNames`. -/</span>
<span class="keyword">12134 def</span> <span class="function-name">levelMVarToParam</span> (e : Expr) (nextParamIdx : Nat <span class="constant">:=</span> <span class="constant">1</span>) : TermElabM (Expr <span class="constant">&#215;</span> Nat) <span class="constant">:=</span> <span class="keyword">do</span>
12135   <span class="keyword">let</span> mctx &#8592; getMCtx
12136   <span class="keyword">let</span> levelNames &#8592; getLevelNames
12137   <span class="keyword">let</span> r <span class="constant">:=</span> mctx.levelMVarToParam (<span class="keyword">fun</span> n <span class="constant">=&gt;</span> levelNames.elem n) e `u nextParamIdx
12138   setMCtx r.mctx
12139   pure (r.expr, r.nextParamIdx)
12140 
<span class="comment-delimiter">12141 /-</span><span class="comment">- Variant of `levelMVarToParam` where `nextParamIdx` is stored in a state monad. -/</span>
<span class="keyword">12142 def</span> <span class="function-name">levelMVarToParam'</span> (e : Expr) : StateRefT Nat TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
12143   <span class="keyword">let</span> nextParamIdx &#8592; get
12144   <span class="keyword">let</span> (e, nextParamIdx) &#8592; levelMVarToParam e nextParamIdx
12145   set nextParamIdx
12146   pure e
12147 
<span class="comment-delimiter">12148 /-</span><span class="comment">-
12149   Auxiliary method for creating fresh binder names.
12150   Do not confuse with the method for creating fresh free/meta variable ids. -/</span>
<span class="keyword">12151 def</span> <span class="function-name">mkFreshBinderName</span> : TermElabM Name <span class="constant">:=</span>
12152   withFreshMacroScope <span class="constant">$</span> MonadQuotation.addMacroScope `x
12153 
<span class="comment-delimiter">12154 /-</span><span class="comment">-
12155   Auxiliary method for creating a `Syntax.ident` containing
12156   a fresh name. This method is intended for creating fresh binder names.
12157   It is just a thin layer on top of `mkFreshUserName`. -/</span>
<span class="keyword">12158 def</span> <span class="function-name">mkFreshIdent</span> (ref : Syntax) : TermElabM Syntax <span class="constant">:=</span>
12159   <span class="keyword">return</span> mkIdentFrom ref (&#8592; mkFreshBinderName)
12160 
<span class="keyword">12161 private</span> <span class="keyword">def</span> <span class="function-name">applyAttributesCore</span>
12162     (declName : Name) (attrs : Array Attribute)
12163     (applicationTime? : Option AttributeApplicationTime) : TermElabM Unit <span class="constant">:=</span>
12164   <span class="keyword">for</span> attr <span class="keyword">in</span> attrs <span class="keyword">do</span>
12165     <span class="keyword">let</span> env &#8592; getEnv
12166     <span class="keyword">match</span> getAttributeImpl env attr.name <span class="keyword">with</span>
12167     | Except.error errMsg <span class="constant">=&gt;</span> throwError errMsg
12168     | Except.ok attrImpl  <span class="constant">=&gt;</span>
12169       <span class="keyword">match</span> applicationTime? <span class="keyword">with</span>
12170       | none <span class="constant">=&gt;</span> attrImpl.add declName attr.stx attr.kind
12171       | some applicationTime <span class="constant">=&gt;</span>
12172         <span class="keyword">if</span> applicationTime <span class="constant">==</span> attrImpl.applicationTime <span class="keyword">then</span>
12173           attrImpl.add declName attr.stx attr.kind
12174 
<span class="comment-delimiter">12175 /-</span><span class="comment">- Apply given attributes **at** a given application time -/</span>
<span class="keyword">12176 def</span> <span class="function-name">applyAttributesAt</span> (declName : Name) (attrs : Array Attribute) (applicationTime : AttributeApplicationTime) : TermElabM Unit <span class="constant">:=</span>
12177   applyAttributesCore declName attrs applicationTime
12178 
<span class="keyword">12179 def</span> <span class="function-name">applyAttributes</span> (declName : Name) (attrs : Array Attribute) : TermElabM Unit <span class="constant">:=</span>
12180   applyAttributesCore declName attrs none
12181 
<span class="keyword">12182 def</span> <span class="function-name">mkTypeMismatchError</span> (header? : Option String) (e : Expr) (eType : Expr) (expectedType : Expr) : TermElabM MessageData <span class="constant">:=</span> <span class="keyword">do</span>
12183   <span class="keyword">let</span> header : MessageData <span class="constant">:=</span> <span class="keyword">match</span> header? <span class="keyword">with</span>
12184     | some header <span class="constant">=&gt;</span> m<span class="constant">!</span><span class="string">"{header} "</span>
12185     | none        <span class="constant">=&gt;</span> m<span class="constant">!</span><span class="string">"type mismatch{indentExpr e}\n"</span>
12186   <span class="keyword">return</span> m<span class="constant">!</span><span class="string">"{header}{&#8592; mkHasTypeButIsExpectedMsg eType expectedType}"</span>
12187 
<span class="keyword">12188 def</span> <span class="function-name">throwTypeMismatchError</span> (header? : Option String) (expectedType : Expr) (eType : Expr) (e : Expr)
12189     (f? : Option Expr <span class="constant">:=</span> none) (extraMsg? : Option MessageData <span class="constant">:=</span> none) : TermElabM &#945; <span class="constant">:=</span> <span class="keyword">do</span>
12190   <span class="comment-delimiter">/-</span><span class="comment">
12191     We ignore `extraMsg?` for now. In all our tests, it contained no useful information. It was
12192     always of the form:
12193     ```
12194     failed to synthesize instance
12195       CoeT &lt;eType&gt; &lt;e&gt; &lt;expectedType&gt;
12196     ```
12197     We should revisit this decision in the future and decide whether it may contain useful information
12198     or not. -/</span>
12199   <span class="keyword">let</span> extraMsg <span class="constant">:=</span> Format.nil
12200   <span class="comment-delimiter">/-</span><span class="comment">
12201   let extraMsg : MessageData := match extraMsg? with
12202     | none          =&gt; Format.nil
12203     | some extraMsg =&gt; Format.line ++ extraMsg;
12204   -/</span>
12205   <span class="keyword">match</span> f? <span class="keyword">with</span>
12206   | none   <span class="constant">=&gt;</span> throwError <span class="string">"{&#8592; mkTypeMismatchError header? e eType expectedType}{extraMsg}"</span>
12207   | some f <span class="constant">=&gt;</span> Meta.throwAppTypeMismatch f e extraMsg
12208 
<span class="doc">12209 @[inline]</span> <span class="keyword">def</span> <span class="function-name">withoutMacroStackAtErr</span> (x : TermElabM &#945;) : TermElabM &#945; <span class="constant">:=</span>
12210   withTheReader Core.Context (<span class="keyword">fun</span> (ctx : Core.Context) <span class="constant">=&gt;</span> { ctx <span class="keyword">with</span> options <span class="constant">:=</span> pp.macroStack.set ctx.options false }) x
12211 
<span class="comment-delimiter">12212 /- </span><span class="comment">Try to synthesize metavariable using type class resolution.
12213    This method assumes the local context and local instances of `instMVar` coincide
12214    with the current local context and local instances.
12215    Return `true` if the instance was synthesized successfully, and `false` if
12216    the instance contains unassigned metavariables that are blocking the type class
12217    resolution procedure. Throw an exception if resolution or assignment irrevocably fails. -/</span>
<span class="keyword">12218 def</span> <span class="function-name">synthesizeInstMVarCore</span> (instMVar : MVarId) (maxResultSize? : Option Nat <span class="constant">:=</span> none) : TermElabM Bool <span class="constant">:=</span> <span class="keyword">do</span>
12219   <span class="keyword">let</span> instMVarDecl &#8592; getMVarDecl instMVar
12220   <span class="keyword">let</span> type <span class="constant">:=</span> instMVarDecl.type
12221   <span class="keyword">let</span> type &#8592; instantiateMVars type
12222   <span class="keyword">let</span> result &#8592; trySynthInstance type maxResultSize?
12223   <span class="keyword">match</span> result <span class="keyword">with</span>
12224   | LOption.some val <span class="constant">=&gt;</span>
12225     <span class="keyword">if</span> (&#8592; isExprMVarAssigned instMVar) <span class="keyword">then</span>
12226       <span class="keyword">let</span> oldVal &#8592; instantiateMVars (mkMVar instMVar)
12227       <span class="keyword">unless</span> (&#8592; isDefEq oldVal val) <span class="keyword">do</span>
12228         <span class="keyword">let</span> oldValType &#8592; inferType oldVal
12229         <span class="keyword">let</span> valType &#8592; inferType val
12230         <span class="keyword">unless</span> (&#8592; isDefEq oldValType valType) <span class="keyword">do</span>
12231           throwError <span class="string">"synthesized type class instance type is not definitionally equal to expected type, synthesized{indentExpr val}\nhas type{indentExpr valType}\nexpected{indentExpr oldValType}"</span>
12232         throwError <span class="string">"synthesized type class instance is not definitionally equal to expression inferred by typing rules, synthesized{indentExpr val}\ninferred{indentExpr oldVal}"</span>
12233     <span class="keyword">else</span>
12234       <span class="keyword">unless</span> (&#8592; isDefEq (mkMVar instMVar) val) <span class="keyword">do</span>
12235         throwError <span class="string">"failed to assign synthesized type class instance{indentExpr val}"</span>
12236     pure true
12237   | LOption.undef    <span class="constant">=&gt;</span> pure false <span class="comment-delimiter">-- </span><span class="comment">we will try later
</span>12238   | LOption.none     <span class="constant">=&gt;</span> throwError <span class="string">"failed to synthesize instance{indentExpr type}"</span>
12239 
<span class="keyword">12240 register_builtin_option</span> autoLift : Bool <span class="constant">:=</span> {
12241   defValue <span class="constant">:=</span> true
12242   descr    <span class="constant">:=</span> <span class="string">"insert monadic lifts (i.e., `liftM` and `liftCoeM`) when needed"</span>
12243 }
12244 
<span class="keyword">12245 register_builtin_option</span> maxCoeSize : Nat <span class="constant">:=</span> {
12246   defValue <span class="constant">:=</span> <span class="constant">16</span>
12247   descr    <span class="constant">:=</span> <span class="string">"maximum number of instances used to construct an automatic coercion"</span>
12248 }
12249 
<span class="keyword">12250 def</span> <span class="function-name">synthesizeCoeInstMVarCore</span> (instMVar : MVarId) : TermElabM Bool <span class="constant">:=</span> <span class="keyword">do</span>
12251   synthesizeInstMVarCore instMVar (some (maxCoeSize.get (&#8592; getOptions)))
12252 
<span class="comment-delimiter">12253 /-</span><span class="comment">
12254 The coercion from `&#945;` to `Thunk &#945;` cannot be implemented using an instance because it would
12255 eagerly evaluate `e` -/</span>
<span class="keyword">12256 def</span> <span class="function-name">tryCoeThunk?</span> (expectedType : Expr) (eType : Expr) (e : Expr) : TermElabM (Option Expr) <span class="constant">:=</span> <span class="keyword">do</span>
12257   <span class="keyword">match</span> expectedType <span class="keyword">with</span>
12258   | Expr.app (Expr.const ``Thunk u <span class="preprocessor">_</span>) arg <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
12259     <span class="keyword">if</span> (&#8592; isDefEq eType arg) <span class="keyword">then</span>
12260       pure (some (mkApp2 (mkConst ``Thunk.mk u) arg (mkSimpleThunk e)))
12261     <span class="keyword">else</span>
12262       pure none
12263   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
12264     pure none
12265 
<span class="comment-delimiter">12266 /-</span><span class="comment">-
12267   Try to apply coercion to make sure `e` has type `expectedType`.
12268   Relevant definitions:
12269   ```
12270   class CoeT (&#945; : Sort u) (a : &#945;) (&#946; : Sort v)
12271   abbrev coe {&#945; : Sort u} {&#946; : Sort v} (a : &#945;) [CoeT &#945; a &#946;] : &#946;
12272   ```
12273 -/</span>
<span class="keyword">12274 private</span> <span class="keyword">def</span> <span class="function-name">tryCoe</span> (errorMsgHeader? : Option String) (expectedType : Expr) (eType : Expr) (e : Expr) (f? : Option Expr) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
12275   <span class="keyword">if</span> (&#8592; isDefEq expectedType eType) <span class="keyword">then</span>
12276     <span class="keyword">return</span> e
12277   <span class="keyword">else</span> <span class="keyword">match</span> (&#8592; tryCoeThunk? expectedType eType e) <span class="keyword">with</span>
12278     | some r <span class="constant">=&gt;</span> <span class="keyword">return</span> r
12279     | none   <span class="constant">=&gt;</span>
12280       <span class="keyword">let</span> u &#8592; getLevel eType
12281       <span class="keyword">let</span> v &#8592; getLevel expectedType
12282       <span class="keyword">let</span> coeTInstType <span class="constant">:=</span> mkAppN (mkConst ``CoeT [u, v]) <span class="constant">#</span>[eType, e, expectedType]
12283       <span class="keyword">let</span> mvar &#8592; mkFreshExprMVar coeTInstType MetavarKind.synthetic
12284       <span class="keyword">let</span> eNew <span class="constant">:=</span> mkAppN (mkConst ``coe [u, v]) <span class="constant">#</span>[eType, expectedType, e, mvar]
12285       <span class="keyword">let</span> mvarId <span class="constant">:=</span> mvar.mvarId<span class="constant">!</span>
12286       <span class="keyword">try</span>
12287         withoutMacroStackAtErr <span class="keyword">do</span>
12288           <span class="keyword">if</span> (&#8592; synthesizeCoeInstMVarCore mvarId) <span class="keyword">then</span>
12289             expandCoe eNew
12290           <span class="keyword">else</span>
12291             <span class="comment-delimiter">-- </span><span class="comment">We create an auxiliary metavariable to represent the result, because we need to execute `expandCoe`
</span>12292             <span class="comment-delimiter">-- </span><span class="comment">after we syntheze `mvar`
</span>12293             <span class="keyword">let</span> mvarAux &#8592; mkFreshExprMVar expectedType MetavarKind.syntheticOpaque
12294             registerSyntheticMVarWithCurrRef mvarAux.mvarId<span class="constant">!</span> (SyntheticMVarKind.coe errorMsgHeader? eNew expectedType eType e f?)
12295             <span class="keyword">return</span> mvarAux
12296       <span class="keyword">catch</span>
12297         | Exception.error <span class="preprocessor">_</span> msg <span class="constant">=&gt;</span> throwTypeMismatchError errorMsgHeader? expectedType eType e f? msg
12298         | <span class="preprocessor">_</span>                     <span class="constant">=&gt;</span> throwTypeMismatchError errorMsgHeader? expectedType eType e f?
12299 
<span class="keyword">12300 def</span> <span class="function-name">isTypeApp?</span> (type : Expr) : TermElabM (Option (Expr <span class="constant">&#215;</span> Expr)) <span class="constant">:=</span> <span class="keyword">do</span>
12301   <span class="keyword">let</span> type &#8592; withReducible <span class="constant">$</span> whnf type
12302   <span class="keyword">match</span> type <span class="keyword">with</span>
12303   | Expr.app m &#945; <span class="preprocessor">_</span> <span class="constant">=&gt;</span> pure (some ((&#8592; instantiateMVars m), (&#8592; instantiateMVars &#945;)))
12304   | <span class="preprocessor">_</span>              <span class="constant">=&gt;</span> pure none
12305 
<span class="keyword">12306 def</span> <span class="function-name">synthesizeInst</span> (type : Expr) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
12307   <span class="keyword">let</span> type &#8592; instantiateMVars type
12308   <span class="keyword">match</span> (&#8592; trySynthInstance type) <span class="keyword">with</span>
12309   | LOption.some val <span class="constant">=&gt;</span> pure val
12310   | LOption.undef    <span class="constant">=&gt;</span> throwError <span class="string">"failed to synthesize instance{indentExpr type}"</span>
12311   | LOption.none     <span class="constant">=&gt;</span> throwError <span class="string">"failed to synthesize instance{indentExpr type}"</span>
12312 
<span class="keyword">12313 def</span> <span class="function-name">isMonadApp</span> (type : Expr) : TermElabM Bool <span class="constant">:=</span> <span class="keyword">do</span>
12314   <span class="keyword">let</span> some (m, <span class="preprocessor">_</span>) &#8592; isTypeApp? type | pure false
12315   <span class="keyword">return</span> (&#8592; isMonad? m) |<span class="constant">&gt;</span>.isSome
12316 
<span class="comment-delimiter">12317 /-</span><span class="comment">-
12318   Try to coerce `a : &#945;` into `m &#946;` by first coercing `a : &#945;` into &#8245;&#946;`, and then using `pure`.
12319   The method is only applied if `&#945;` is not monadic (e.g., `Nat &#8594; IO Unit`), and the head symbol
12320   of the resulting type is not a metavariable (e.g., `?m Unit` or `Bool &#8594; ?m Nat`).
12321 
12322   The main limitation of the approach above is polymorphic code. As usual, coercions and polymorphism
12323   do not interact well. In the example above, the lift is successfully applied to `true`, `false` and `!y`
12324   since none of them is polymorphic
12325   ```
12326   def f (x : Bool) : IO Bool := do
12327   let y &#8592; if x == 0 then IO.println "hello"; true else false;
12328   !y
12329   ```
12330   On the other hand, the following fails since `+` is polymorphic
12331   ```
12332   def f (x : Bool) : IO Nat := do
12333   IO.prinln x
12334   x + x  -- Error: failed to synthesize `Add (IO Nat)`
12335   ```
12336 -/</span>
<span class="keyword">12337 private</span> <span class="keyword">def</span> <span class="function-name">tryPureCoe?</span> (errorMsgHeader? : Option String) (m &#946; &#945; a : Expr) : TermElabM (Option Expr) <span class="constant">:=</span>
12338   commitWhenSome? <span class="keyword">do</span>
12339     <span class="keyword">let</span> doIt : TermElabM (Option Expr) <span class="constant">:=</span> <span class="keyword">do</span>
12340       <span class="keyword">try</span>
12341         <span class="keyword">let</span> aNew &#8592; tryCoe errorMsgHeader? &#946; &#945; a none
12342         <span class="keyword">let</span> aNew &#8592; mkPure m aNew
12343         pure (some aNew)
12344       <span class="keyword">catch</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
12345         pure none
12346     forallTelescope &#945; <span class="keyword">fun</span> <span class="preprocessor">_</span> &#945; <span class="constant">=&gt;</span> <span class="keyword">do</span>
12347       <span class="keyword">if</span> (&#8592; isMonadApp &#945;) <span class="keyword">then</span>
12348         pure none
12349       <span class="keyword">else</span> <span class="keyword">if</span> <span class="constant">!</span>&#945;.getAppFn.isMVar  <span class="keyword">then</span>
12350         doIt
12351       <span class="keyword">else</span>
12352         pure none
12353 
<span class="comment-delimiter">12354 /-</span><span class="comment">
12355 Try coercions and monad lifts to make sure `e` has type `expectedType`.
12356 
12357 If `expectedType` is of the form `n &#946;`, we try monad lifts and other extensions.
12358 Otherwise, we just use the basic `tryCoe`.
12359 
12360 Extensions for monads.
12361 
12362 Given an expected type of the form `n &#946;`, if `eType` is of the form `&#945;`, but not `m &#945;`
12363 
12364 1 - Try to coerce &#8245;&#945;` into &#8245;&#946;`, and use `pure` to lift it to `n &#945;`.
12365     It only works if `n` implements `Pure`
12366 
12367 If `eType` is of the form `m &#945;`. We use the following approaches.
12368 
12369 1- Try to unify `n` and `m`. If it succeeds, then we use
12370    ```
12371    coeM {m : Type u &#8594; Type v} {&#945; &#946; : Type u} [&#8704; a, CoeT &#945; a &#946;] [Monad m] (x : m &#945;) : m &#946;
12372    ```
12373    `n` must be a `Monad` to use this one.
12374 
12375 2- If there is monad lift from `m` to `n` and we can unify `&#945;` and `&#946;`, we use
12376   ```
12377   liftM : &#8704; {m : Type u_1 &#8594; Type u_2} {n : Type u_1 &#8594; Type u_3} [self : MonadLiftT m n] {&#945; : Type u_1}, m &#945; &#8594; n &#945;
12378   ```
12379   Note that `n` may not be a `Monad` in this case. This happens quite a bit in code such as
12380   ```
12381   def g (x : Nat) : IO Nat := do
12382     IO.println x
12383     pure x
12384 
12385   def f {m} [MonadLiftT IO m] : m Nat :=
12386     g 10
12387 
12388   ```
12389 
12390 3- If there is a monad lif from `m` to `n` and a coercion from `&#945;` to `&#946;`, we use
12391   ```
12392   liftCoeM {m : Type u &#8594; Type v} {n : Type u &#8594; Type w} {&#945; &#946; : Type u} [MonadLiftT m n] [&#8704; a, CoeT &#945; a &#946;] [Monad n] (x : m &#945;) : n &#946;
12393   ```
12394 
12395 Note that approach 3 does not subsume 1 because it is only applicable if there is a coercion from `&#945;` to `&#946;` for all values in `&#945;`.
12396 This is not the case for example for `pure $ x &gt; 0` when the expected type is `IO Bool`. The given type is `IO Prop`, and
12397 we only have a coercion from decidable propositions.  Approach 1 works because it constructs the coercion `CoeT (m Prop) (pure $ x &gt; 0) (m Bool)`
12398 using the instance `pureCoeDepProp`.
12399 
12400 Note that, approach 2 is more powerful than `tryCoe`.
12401 Recall that type class resolution never assigns metavariables created by other modules.
12402 Now, consider the following scenario
12403 ```lean
12404 def g (x : Nat) : IO Nat := ...
12405 deg h (x : Nat) : StateT Nat IO Nat := do
12406 v &#8592; g x;
12407 IO.Println v;
12408 ...
12409 ```
12410 Let's assume there is no other occurrence of `v` in `h`.
12411 Thus, we have that the expected of `g x` is `StateT Nat IO ?&#945;`,
12412 and the given type is `IO Nat`. So, even if we add a coercion.
12413 ```
12414 instance {&#945; m n} [MonadLiftT m n] {&#945;} : Coe (m &#945;) (n &#945;) := ...
12415 ```
12416 It is not applicable because TC would have to assign `?&#945; := Nat`.
12417 On the other hand, TC can easily solve `[MonadLiftT IO (StateT Nat IO)]`
12418 since this goal does not contain any metavariables. And then, we
12419 convert `g x` into `liftM $ g x`.
12420 -/</span>
<span class="keyword">12421 private</span> <span class="keyword">def</span> <span class="function-name">tryLiftAndCoe</span> (errorMsgHeader? : Option String) (expectedType : Expr) (eType : Expr) (e : Expr) (f? : Option Expr) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
12422   <span class="keyword">let</span> expectedType &#8592; instantiateMVars expectedType
12423   <span class="keyword">let</span> eType &#8592; instantiateMVars eType
12424   <span class="keyword">let</span> throwMismatch {&#945;} : TermElabM &#945; <span class="constant">:=</span> throwTypeMismatchError errorMsgHeader? expectedType eType e f?
12425   <span class="keyword">let</span> tryCoeSimple : TermElabM Expr <span class="constant">:=</span>
12426     tryCoe errorMsgHeader? expectedType eType e f?
12427   <span class="keyword">let</span> some (n, &#946;) &#8592; isTypeApp? expectedType | tryCoeSimple
12428   <span class="keyword">let</span> tryPureCoeAndSimple : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
12429     <span class="keyword">if</span> autoLift.get (&#8592; getOptions) <span class="keyword">then</span>
12430       <span class="keyword">match</span> (&#8592; tryPureCoe? errorMsgHeader? n &#946; eType e) <span class="keyword">with</span>
12431       | some eNew <span class="constant">=&gt;</span> pure eNew
12432       | none      <span class="constant">=&gt;</span> tryCoeSimple
12433     <span class="keyword">else</span>
12434       tryCoeSimple
12435   <span class="keyword">let</span> some (m, &#945;) &#8592; isTypeApp? eType | tryPureCoeAndSimple
12436   <span class="keyword">if</span> (&#8592; isDefEq m n) <span class="keyword">then</span>
12437     <span class="keyword">let</span> some monadInst &#8592; isMonad? n | tryCoeSimple
12438     <span class="keyword">try</span> expandCoe (&#8592; mkAppOptM ``coeM <span class="constant">#</span>[m, &#945;, &#946;, none, monadInst, e]) <span class="keyword">catch</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwMismatch
12439   <span class="keyword">else</span> <span class="keyword">if</span> autoLift.get (&#8592; getOptions) <span class="keyword">then</span>
12440     <span class="keyword">try</span>
12441       <span class="comment-delimiter">-- </span><span class="comment">Construct lift from `m` to `n`
</span>12442       <span class="keyword">let</span> monadLiftType &#8592; mkAppM ``MonadLiftT <span class="constant">#</span>[m, n]
12443       <span class="keyword">let</span> monadLiftVal  &#8592; synthesizeInst monadLiftType
12444       <span class="keyword">let</span> u_1 &#8592; getDecLevel &#945;
12445       <span class="keyword">let</span> u_2 &#8592; getDecLevel eType
12446       <span class="keyword">let</span> u_3 &#8592; getDecLevel expectedType
12447       <span class="keyword">let</span> eNew <span class="constant">:=</span> mkAppN (Lean.mkConst ``liftM [u_1, u_2, u_3]) <span class="constant">#</span>[m, n, monadLiftVal, &#945;, e]
12448       <span class="keyword">let</span> eNewType &#8592; inferType eNew
12449       <span class="keyword">if</span> (&#8592; isDefEq expectedType eNewType) <span class="keyword">then</span>
12450         <span class="keyword">return</span> eNew <span class="comment-delimiter">-- </span><span class="comment">approach 2 worked
</span>12451       <span class="keyword">else</span>
12452         <span class="keyword">let</span> some monadInst &#8592; isMonad? n | tryCoeSimple
12453         <span class="keyword">let</span> u &#8592; getLevel &#945;
12454         <span class="keyword">let</span> v &#8592; getLevel &#946;
12455         <span class="keyword">let</span> coeTInstType <span class="constant">:=</span> Lean.mkForall `a BinderInfo.default &#945; <span class="constant">$</span> mkAppN (mkConst ``CoeT [u, v]) <span class="constant">#</span>[&#945;, mkBVar <span class="constant">0</span>, &#946;]
12456         <span class="keyword">let</span> coeTInstVal &#8592; synthesizeInst coeTInstType
12457         <span class="keyword">let</span> eNew &#8592; expandCoe (&#8592; mkAppN (Lean.mkConst ``liftCoeM [u_1, u_2, u_3]) <span class="constant">#</span>[m, n, &#945;, &#946;, monadLiftVal, coeTInstVal, monadInst, e])
12458         <span class="keyword">let</span> eNewType &#8592; inferType eNew
12459         <span class="keyword">unless</span> (&#8592; isDefEq expectedType eNewType) <span class="keyword">do</span> throwMismatch
12460         <span class="keyword">return</span> eNew <span class="comment-delimiter">-- </span><span class="comment">approach 3 worked
</span>12461     <span class="keyword">catch</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
12462       <span class="comment-delimiter">/-</span><span class="comment">
12463         If `m` is not a monad, then we try to use `tryPureCoe?` and then `tryCoe?`.
12464         Otherwise, we just try `tryCoe?`.
12465       -/</span>
12466       <span class="keyword">match</span> (&#8592; isMonad? m) <span class="keyword">with</span>
12467       | none   <span class="constant">=&gt;</span> tryPureCoeAndSimple
12468       | some <span class="preprocessor">_</span> <span class="constant">=&gt;</span> tryCoeSimple
12469   <span class="keyword">else</span>
12470     tryCoeSimple
12471 
<span class="comment-delimiter">12472 /-</span><span class="comment">-
12473   If `expectedType?` is `some t`, then ensure `t` and `eType` are definitionally equal.
12474   If they are not, then try coercions.
12475 
12476   Argument `f?` is used only for generating error messages. -/</span>
<span class="keyword">12477 def</span> <span class="function-name">ensureHasTypeAux</span> (expectedType? : Option Expr) (eType : Expr) (e : Expr)
12478     (f? : Option Expr <span class="constant">:=</span> none) (errorMsgHeader? : Option String <span class="constant">:=</span> none) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
12479   <span class="keyword">match</span> expectedType? <span class="keyword">with</span>
12480   | none              <span class="constant">=&gt;</span> pure e
12481   | some expectedType <span class="constant">=&gt;</span>
12482     <span class="keyword">if</span> (&#8592; isDefEq eType expectedType) <span class="keyword">then</span>
12483       pure e
12484     <span class="keyword">else</span>
12485       tryLiftAndCoe errorMsgHeader? expectedType eType e f?
12486 
<span class="comment-delimiter">12487 /-</span><span class="comment">-
12488   If `expectedType?` is `some t`, then ensure `t` and type of `e` are definitionally equal.
12489   If they are not, then try coercions. -/</span>
<span class="keyword">12490 def</span> <span class="function-name">ensureHasType</span> (expectedType? : Option Expr) (e : Expr) (errorMsgHeader? : Option String <span class="constant">:=</span> none) : TermElabM Expr <span class="constant">:=</span>
12491   <span class="keyword">match</span> expectedType? <span class="keyword">with</span>
12492   | none <span class="constant">=&gt;</span> pure e
12493   | <span class="preprocessor">_</span>    <span class="constant">=&gt;</span> <span class="keyword">do</span>
12494     <span class="keyword">let</span> eType &#8592; inferType e
12495     ensureHasTypeAux expectedType? eType e none errorMsgHeader?
12496 
<span class="keyword">12497 private</span> <span class="keyword">def</span> <span class="function-name">mkSyntheticSorryFor</span> (expectedType? : Option Expr) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
12498   <span class="keyword">let</span> expectedType &#8592; <span class="keyword">match</span> expectedType? <span class="keyword">with</span>
12499     | none              <span class="constant">=&gt;</span> mkFreshTypeMVar
12500     | some expectedType <span class="constant">=&gt;</span> pure expectedType
12501   mkSyntheticSorry expectedType
12502 
<span class="keyword">12503 private</span> <span class="keyword">def</span> <span class="function-name">exceptionToSorry</span> (ex : Exception) (expectedType? : Option Expr) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
12504   <span class="keyword">let</span> syntheticSorry &#8592; mkSyntheticSorryFor expectedType?
12505   logException ex
12506   pure syntheticSorry
12507 
<span class="comment-delimiter">12508 /-</span><span class="comment">- If `mayPostpone == true`, throw `Expection.postpone`. -/</span>
<span class="keyword">12509 def</span> <span class="function-name">tryPostpone</span> : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
12510   <span class="keyword">if</span> (&#8592; read).mayPostpone <span class="keyword">then</span>
12511     throwPostpone
12512 
<span class="comment-delimiter">12513 /-</span><span class="comment">- If `mayPostpone == true` and `e`'s head is a metavariable, throw `Exception.postpone`. -/</span>
<span class="keyword">12514 def</span> <span class="function-name">tryPostponeIfMVar</span> (e : Expr) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
12515   <span class="keyword">if</span> e.getAppFn.isMVar <span class="keyword">then</span>
12516     <span class="keyword">let</span> e &#8592; instantiateMVars e
12517     <span class="keyword">if</span> e.getAppFn.isMVar <span class="keyword">then</span>
12518       tryPostpone
12519 
<span class="keyword">12520 def</span> <span class="function-name">tryPostponeIfNoneOrMVar</span> (e? : Option Expr) : TermElabM Unit <span class="constant">:=</span>
12521   <span class="keyword">match</span> e? <span class="keyword">with</span>
12522   | some e <span class="constant">=&gt;</span> tryPostponeIfMVar e
12523   | none   <span class="constant">=&gt;</span> tryPostpone
12524 
<span class="keyword">12525 def</span> <span class="function-name">tryPostponeIfHasMVars</span> (expectedType? : Option Expr) (msg : String) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
12526   tryPostponeIfNoneOrMVar expectedType?
12527   <span class="keyword">let</span> some expectedType &#8592; pure expectedType? |
12528     throwError <span class="string">"{msg}, expected type must be known"</span>
12529   <span class="keyword">let</span> expectedType &#8592; instantiateMVars expectedType
12530   <span class="keyword">if</span> expectedType.hasExprMVar <span class="keyword">then</span>
12531     tryPostpone
12532     throwError <span class="string">"{msg}, expected type contains metavariables{indentExpr expectedType}"</span>
12533   pure expectedType
12534 
<span class="keyword">12535 private</span> <span class="keyword">def</span> <span class="function-name">saveContext</span> : TermElabM SavedContext <span class="constant">:=</span>
12536   <span class="keyword">return</span> {
12537     macroStack <span class="constant">:=</span> (&#8592; read).macroStack
12538     declName?  <span class="constant">:=</span> (&#8592; read).declName?
12539     options    <span class="constant">:=</span> (&#8592; getOptions)
12540     openDecls  <span class="constant">:=</span> (&#8592; getOpenDecls)
12541     errToSorry <span class="constant">:=</span> (&#8592; read).errToSorry
12542   }
12543 
<span class="keyword">12544 def</span> <span class="function-name">withSavedContext</span> (savedCtx : SavedContext) (x : TermElabM &#945;) : TermElabM &#945; <span class="constant">:=</span> <span class="keyword">do</span>
12545   withReader (<span class="keyword">fun</span> ctx <span class="constant">=&gt;</span> { ctx <span class="keyword">with</span> declName? <span class="constant">:=</span> savedCtx.declName?, macroStack <span class="constant">:=</span> savedCtx.macroStack, errToSorry <span class="constant">:=</span> savedCtx.errToSorry }) <span class="constant">&lt;</span>|
12546     withTheReader Core.Context (<span class="keyword">fun</span> ctx <span class="constant">=&gt;</span> { ctx <span class="keyword">with</span> options <span class="constant">:=</span> savedCtx.options, openDecls <span class="constant">:=</span> savedCtx.openDecls })
12547       x
12548 
<span class="keyword">12549 private</span> <span class="keyword">def</span> <span class="function-name">postponeElabTerm</span> (stx : Syntax) (expectedType? : Option Expr) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
12550   trace[Elab.postpone] <span class="string">"{stx} : {expectedType?}"</span>
12551   <span class="keyword">let</span> mvar &#8592; mkFreshExprMVar expectedType? MetavarKind.syntheticOpaque
12552   <span class="keyword">let</span> ctx &#8592; read
12553   registerSyntheticMVar stx mvar.mvarId<span class="constant">!</span> (SyntheticMVarKind.postponed (&#8592; saveContext))
12554   pure mvar
12555 
<span class="comment-delimiter">12556 /-</span><span class="comment">
12557   Helper function for `elabTerm` is tries the registered elaboration functions for `stxNode` kind until it finds one that supports the syntax or
12558   an error is found. -/</span>
<span class="keyword">12559 private</span> <span class="keyword">def</span> <span class="function-name">elabUsingElabFnsAux</span> (s : SavedState) (stx : Syntax) (expectedType? : Option Expr) (catchExPostpone : Bool)
12560     : List TermElab <span class="constant">&#8594;</span> TermElabM Expr
12561   | []                <span class="constant">=&gt;</span> <span class="keyword">do</span> throwError <span class="string">"unexpected syntax{indentD stx}"</span>
12562   | (elabFn::elabFns) <span class="constant">=&gt;</span> <span class="keyword">do</span>
12563     <span class="keyword">try</span>
12564       elabFn stx expectedType?
12565     <span class="keyword">catch</span> ex <span class="constant">=&gt;</span> <span class="keyword">match</span> ex <span class="keyword">with</span>
12566       | Exception.error <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
12567         <span class="keyword">if</span> (&#8592; read).errToSorry <span class="keyword">then</span>
12568           exceptionToSorry ex expectedType?
12569         <span class="keyword">else</span>
12570           throw ex
12571       | Exception.internal id <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
12572         <span class="keyword">if</span> (&#8592; read).errToSorry <span class="constant">&amp;&amp;</span> id <span class="constant">==</span> abortTermExceptionId <span class="keyword">then</span>
12573           exceptionToSorry ex expectedType?
12574         <span class="keyword">else</span> <span class="keyword">if</span> id <span class="constant">==</span> unsupportedSyntaxExceptionId <span class="keyword">then</span>
12575           s.restore
12576           elabUsingElabFnsAux s stx expectedType? catchExPostpone elabFns
12577         <span class="keyword">else</span> <span class="keyword">if</span> catchExPostpone <span class="constant">&amp;&amp;</span> id <span class="constant">==</span> postponeExceptionId <span class="keyword">then</span>
12578           <span class="comment-delimiter">/- </span><span class="comment">If `elab` threw `Exception.postpone`, we reset any state modifications.
12579              For example, we want to make sure pending synthetic metavariables created by `elab` before
12580              it threw `Exception.postpone` are discarded.
12581              Note that we are also discarding the messages created by `elab`.
12582 
12583              For example, consider the expression.
12584              `((f.x a1).x a2).x a3`
12585              Now, suppose the elaboration of `f.x a1` produces an `Exception.postpone`.
12586              Then, a new metavariable `?m` is created. Then, `?m.x a2` also throws `Exception.postpone`
12587              because the type of `?m` is not yet known. Then another, metavariable `?n` is created, and
12588             finally `?n.x a3` also throws `Exception.postpone`. If we did not restore the state, we would
12589             keep "dead" metavariables `?m` and `?n` on the pending synthetic metavariable list. This is
12590             wasteful because when we resume the elaboration of `((f.x a1).x a2).x a3`, we start it from scratch
12591             and new metavariables are created for the nested functions. -/</span>
12592             s.restore
12593             postponeElabTerm stx expectedType?
12594           <span class="keyword">else</span>
12595             throw ex
12596 
<span class="keyword">12597 private</span> <span class="keyword">def</span> <span class="function-name">elabUsingElabFns</span> (stx : Syntax) (expectedType? : Option Expr) (catchExPostpone : Bool) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
12598   <span class="keyword">let</span> s &#8592; saveState
12599   <span class="keyword">let</span> table <span class="constant">:=</span> termElabAttribute.ext.getState (&#8592; getEnv) |<span class="constant">&gt;</span>.table
12600   <span class="keyword">let</span> k <span class="constant">:=</span> stx.getKind
12601   <span class="keyword">match</span> table.find? k <span class="keyword">with</span>
12602   | some elabFns <span class="constant">=&gt;</span> elabUsingElabFnsAux s stx expectedType? catchExPostpone elabFns
12603   | none         <span class="constant">=&gt;</span> throwError <span class="string">"elaboration function for '{k}' has not been implemented{indentD stx}"</span>
12604 
<span class="keyword">12605 instance</span> <span class="function-name">:</span> MonadMacroAdapter TermElabM <span class="keyword">where</span>
12606   getCurrMacroScope <span class="constant">:=</span> getCurrMacroScope
12607   getNextMacroScope <span class="constant">:=</span> <span class="keyword">return</span> (&#8592; getThe Core.State).nextMacroScope
12608   setNextMacroScope next <span class="constant">:=</span> modifyThe Core.State <span class="keyword">fun</span> s <span class="constant">=&gt;</span> { s <span class="keyword">with</span> nextMacroScope <span class="constant">:=</span> next }
12609 
<span class="keyword">12610 private</span> <span class="keyword">def</span> <span class="function-name">isExplicit</span> (stx : Syntax) : Bool <span class="constant">:=</span>
12611   <span class="keyword">match</span> stx <span class="keyword">with</span>
12612   | `(<span class="constant">@$</span>f) <span class="constant">=&gt;</span> true
12613   | <span class="preprocessor">_</span>      <span class="constant">=&gt;</span> false
12614 
<span class="keyword">12615 private</span> <span class="keyword">def</span> <span class="function-name">isExplicitApp</span> (stx : Syntax) : Bool <span class="constant">:=</span>
12616   stx.getKind <span class="constant">==</span> ``Lean.Parser.Term.app <span class="constant">&amp;&amp;</span> isExplicit stx[<span class="constant">0</span>]
12617 
<span class="comment-delimiter">12618 /-</span><span class="comment">-
12619   Return true if `stx` if a lambda abstraction containing a `{}` or `[]` binder annotation.
12620   Example: `fun {&#945;} (a : &#945;) =&gt; a` -/</span>
<span class="keyword">12621 private</span> <span class="keyword">def</span> <span class="function-name">isLambdaWithImplicit</span> (stx : Syntax) : Bool <span class="constant">:=</span>
12622   <span class="keyword">match</span> stx <span class="keyword">with</span>
12623   | `(<span class="keyword">fun</span> <span class="constant">$</span>binders<span class="constant">*</span> <span class="constant">=&gt;</span> <span class="constant">$</span>body) <span class="constant">=&gt;</span> binders.any <span class="keyword">fun</span> b <span class="constant">=&gt;</span> b.isOfKind ``Lean.Parser.Term.implicitBinder <span class="constant">||</span> b.isOfKind `Lean.Parser.Term.instBinder
12624   | <span class="preprocessor">_</span>                         <span class="constant">=&gt;</span> false
12625 
<span class="keyword">12626 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">dropTermParens</span> : Syntax <span class="constant">&#8594;</span> Syntax <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="constant">=&gt;</span>
12627   <span class="keyword">match</span> stx <span class="keyword">with</span>
12628   | `((<span class="constant">$</span>stx)) <span class="constant">=&gt;</span> dropTermParens stx
12629   | <span class="preprocessor">_</span>         <span class="constant">=&gt;</span> stx
12630 
<span class="keyword">12631 private</span> <span class="keyword">def</span> <span class="function-name">isHole</span> (stx : Syntax) : Bool <span class="constant">:=</span>
12632   <span class="keyword">match</span> stx <span class="keyword">with</span>
12633   | `(<span class="preprocessor">_</span>)          <span class="constant">=&gt;</span> true
12634   | `(? <span class="preprocessor">_</span>)        <span class="constant">=&gt;</span> true
12635   | `(? <span class="constant">$</span>x:ident) <span class="constant">=&gt;</span> true
12636   | <span class="preprocessor">_</span>             <span class="constant">=&gt;</span> false
12637 
<span class="keyword">12638 private</span> <span class="keyword">def</span> <span class="function-name">isTacticBlock</span> (stx : Syntax) : Bool <span class="constant">:=</span>
12639   <span class="keyword">match</span> stx <span class="keyword">with</span>
12640   | `(<span class="keyword">by</span> <span class="constant">$</span>x:tacticSeq) <span class="constant">=&gt;</span> true
12641   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> false
12642 
<span class="keyword">12643 private</span> <span class="keyword">def</span> <span class="function-name">isNoImplicitLambda</span> (stx : Syntax) : Bool <span class="constant">:=</span>
12644   <span class="keyword">match</span> stx <span class="keyword">with</span>
12645   | `(noImplicitLambda% <span class="constant">$</span>x:term) <span class="constant">=&gt;</span> true
12646   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> false
12647 
<span class="keyword">12648 def</span> <span class="function-name">mkNoImplicitLambdaAnnotation</span> (type : Expr) : Expr <span class="constant">:=</span>
12649   mkAnnotation `noImplicitLambda type
12650 
<span class="keyword">12651 def</span> <span class="function-name">hasNoImplicitLambdaAnnotation</span> (type : Expr) : Bool <span class="constant">:=</span>
12652   annotation? `noImplicitLambda type |<span class="constant">&gt;</span>.isSome
12653 
<span class="comment-delimiter">12654 /-</span><span class="comment">- Block usage of implicit lambdas if `stx` is `@f` or `@f arg1 ...` or `fun` with an implicit binder annotation. -/</span>
<span class="keyword">12655 def</span> <span class="function-name">blockImplicitLambda</span> (stx : Syntax) : Bool <span class="constant">:=</span>
12656   <span class="keyword">let</span> stx <span class="constant">:=</span> dropTermParens stx
12657   <span class="comment-delimiter">-- </span><span class="comment">TODO: make it extensible
</span>12658   isExplicit stx <span class="constant">||</span> isExplicitApp stx <span class="constant">||</span> isLambdaWithImplicit stx <span class="constant">||</span> isHole stx <span class="constant">||</span> isTacticBlock stx <span class="constant">||</span> isNoImplicitLambda stx
12659 
<span class="comment-delimiter">12660 /-</span><span class="comment">-
12661   Return normalized expected type if it is of the form `{a : &#945;} &#8594; &#946;` or `[a : &#945;] &#8594; &#946;` and
12662   `blockImplicitLambda stx` is not true, else return `none`. -/</span>
<span class="keyword">12663 private</span> <span class="keyword">def</span> <span class="function-name">useImplicitLambda?</span> (stx : Syntax) (expectedType? : Option Expr) : TermElabM (Option Expr) <span class="constant">:=</span>
12664   <span class="keyword">if</span> blockImplicitLambda stx <span class="keyword">then</span>
12665     pure none
12666   <span class="keyword">else</span> <span class="keyword">match</span> expectedType? <span class="keyword">with</span>
12667     | some expectedType <span class="constant">=&gt;</span> <span class="keyword">do</span>
12668       <span class="keyword">if</span> hasNoImplicitLambdaAnnotation expectedType <span class="keyword">then</span>
12669         pure none
12670       <span class="keyword">else</span>
12671         <span class="keyword">let</span> expectedType &#8592; whnfForall expectedType
12672         <span class="keyword">match</span> expectedType <span class="keyword">with</span>
12673         | Expr.forallE <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="preprocessor">_</span> c <span class="constant">=&gt;</span> <span class="keyword">if</span> c.binderInfo.isExplicit <span class="keyword">then</span> pure none <span class="keyword">else</span> pure <span class="constant">$</span> some expectedType
12674         | <span class="preprocessor">_</span>                    <span class="constant">=&gt;</span> pure none
12675     | <span class="preprocessor">_</span>         <span class="constant">=&gt;</span> pure none
12676 
<span class="keyword">12677 private</span> <span class="keyword">def</span> <span class="function-name">elabImplicitLambdaAux</span> (stx : Syntax) (catchExPostpone : Bool) (expectedType : Expr) (fvars : Array Expr) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
12678   <span class="keyword">let</span> body &#8592; elabUsingElabFns stx expectedType catchExPostpone
12679   <span class="keyword">let</span> body &#8592; ensureHasType expectedType body
12680   <span class="keyword">let</span> r &#8592; mkLambdaFVars fvars body
12681   trace[Elab.implicitForall] r
12682   pure r
12683 
<span class="keyword">12684 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">elabImplicitLambda</span> (stx : Syntax) (catchExPostpone : Bool) : Expr <span class="constant">&#8594;</span> Array Expr <span class="constant">&#8594;</span> TermElabM Expr
12685   | type<span class="constant">@</span>(Expr.forallE n d b c), fvars <span class="constant">=&gt;</span>
12686     <span class="keyword">if</span> c.binderInfo.isExplicit <span class="keyword">then</span>
12687       elabImplicitLambdaAux stx catchExPostpone type fvars
12688     <span class="keyword">else</span> withFreshMacroScope <span class="keyword">do</span>
12689       <span class="keyword">let</span> n &#8592; MonadQuotation.addMacroScope n
12690       withLocalDecl n c.binderInfo d <span class="keyword">fun</span> fvar <span class="constant">=&gt;</span> <span class="keyword">do</span>
12691         <span class="keyword">let</span> type &#8592; whnfForall (b.instantiate1 fvar)
12692         elabImplicitLambda stx catchExPostpone type (fvars.push fvar)
12693   | type, fvars <span class="constant">=&gt;</span>
12694     elabImplicitLambdaAux stx catchExPostpone type fvars
12695 
<span class="comment-delimiter">12696 /- </span><span class="comment">Main loop for `elabTerm` -/</span>
<span class="keyword">12697 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">elabTermAux</span> (expectedType? : Option Expr) (catchExPostpone : Bool) (implicitLambda : Bool) : Syntax <span class="constant">&#8594;</span> TermElabM Expr
12698   | Syntax.missing <span class="constant">=&gt;</span> mkSyntheticSorryFor expectedType?
12699   | stx <span class="constant">=&gt;</span> withFreshMacroScope <span class="constant">&lt;</span>| withIncRecDepth <span class="keyword">do</span>
12700     trace[Elab.step] <span class="string">"expected type: {expectedType?}, term\n{stx}"</span>
12701     checkMaxHeartbeats <span class="string">"elaborator"</span>
12702     withNestedTraces <span class="keyword">do</span>
12703     <span class="keyword">let</span> env &#8592; getEnv
12704     <span class="keyword">let</span> stxNew? &#8592; catchInternalId unsupportedSyntaxExceptionId
12705       (<span class="keyword">do</span> <span class="keyword">let</span> newStx &#8592; adaptMacro (getMacros env) stx; pure (some newStx))
12706       (<span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> pure none)
12707     <span class="keyword">match</span> stxNew? <span class="keyword">with</span>
12708     | some stxNew <span class="constant">=&gt;</span> withMacroExpansion stx stxNew <span class="constant">$</span> elabTermAux expectedType? catchExPostpone implicitLambda stxNew
12709     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
12710       <span class="keyword">let</span> implicit? &#8592; <span class="keyword">if</span> implicitLambda <span class="constant">&amp;&amp;</span> (&#8592; read).implicitLambda <span class="keyword">then</span> useImplicitLambda? stx expectedType? <span class="keyword">else</span> pure none
12711       <span class="keyword">match</span> implicit? <span class="keyword">with</span>
12712       | some expectedType <span class="constant">=&gt;</span> elabImplicitLambda stx catchExPostpone expectedType <span class="constant">#</span>[]
12713       | none              <span class="constant">=&gt;</span> elabUsingElabFns stx expectedType? catchExPostpone
12714 
<span class="keyword">12715 def</span> <span class="function-name">addTermInfo</span> (stx : Syntax) (e : Expr) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
12716   <span class="keyword">if</span> (&#8592; getInfoState).enabled <span class="keyword">then</span>
12717     pushInfoLeaf <span class="constant">&lt;</span>| Info.ofTermInfo { lctx <span class="constant">:=</span> (&#8592; getLCtx), expr <span class="constant">:=</span> e, stx <span class="constant">:=</span> stx }
12718 
<span class="keyword">12719 def</span> <span class="function-name">getSyntheticMVarDecl?</span> (mvarId : MVarId) : TermElabM (Option SyntheticMVarDecl) <span class="constant">:=</span>
12720   <span class="keyword">return</span> (&#8592; get).syntheticMVars.find? <span class="keyword">fun</span> d <span class="constant">=&gt;</span> d.mvarId <span class="constant">==</span> mvarId
12721 
<span class="keyword">12722 def</span> <span class="function-name">mkTermInfo</span> (stx : Syntax) (e : Expr) : TermElabM (Sum Info MVarId) <span class="constant">:=</span> <span class="keyword">do</span>
12723   <span class="keyword">let</span> isHole? : TermElabM (Option MVarId) <span class="constant">:=</span> <span class="keyword">do</span>
12724     <span class="keyword">match</span> e <span class="keyword">with</span>
12725     | Expr.mvar mvarId <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
12726       <span class="keyword">match</span> (&#8592; getSyntheticMVarDecl? mvarId) <span class="keyword">with</span>
12727       | some { kind <span class="constant">:=</span> SyntheticMVarKind.tactic .., .. }    <span class="constant">=&gt;</span> <span class="keyword">return</span> mvarId
12728       | some { kind <span class="constant">:=</span> SyntheticMVarKind.postponed .., .. } <span class="constant">=&gt;</span> <span class="keyword">return</span> mvarId
12729       | <span class="preprocessor">_</span>                                                   <span class="constant">=&gt;</span> <span class="keyword">return</span> none
12730     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> pure none
12731   <span class="keyword">match</span> (&#8592; isHole?) <span class="keyword">with</span>
12732   | none        <span class="constant">=&gt;</span> <span class="keyword">return</span> Sum.inl <span class="constant">&lt;</span>| Info.ofTermInfo { lctx <span class="constant">:=</span> (&#8592; getLCtx), expr <span class="constant">:=</span> e, stx <span class="constant">:=</span> stx }
12733   | some mvarId <span class="constant">=&gt;</span> <span class="keyword">return</span> Sum.inr mvarId
12734 
<span class="comment-delimiter">12735 /-</span><span class="comment">- Store in the `InfoTree` that `e` is a "dot"-completion target. -/</span>
<span class="keyword">12736 def</span> <span class="function-name">addDotCompletionInfo</span> (stx : Syntax) (e : Expr) (expectedType? : Option Expr) (field? : Option Syntax <span class="constant">:=</span> none) : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
12737   addCompletionInfo <span class="constant">&lt;</span>| CompletionInfo.dot { expr <span class="constant">:=</span> e, stx <span class="constant">:=</span> stx, lctx <span class="constant">:=</span> (&#8592; getLCtx) } (field? <span class="constant">:=</span> field?) (expectedType? <span class="constant">:=</span> expectedType?)
12738 
<span class="comment-delimiter">12739 /-</span><span class="comment">-
12740   Main function for elaborating terms.
12741   It extracts the elaboration methods from the environment using the node kind.
12742   Recall that the environment has a mapping from `SyntaxNodeKind` to `TermElab` methods.
12743   It creates a fresh macro scope for executing the elaboration method.
12744   All unlogged trace messages produced by the elaboration method are logged using
12745   the position information at `stx`. If the elaboration method throws an `Exception.error` and `errToSorry == true`,
12746   the error is logged and a synthetic sorry expression is returned.
12747   If the elaboration throws `Exception.postpone` and `catchExPostpone == true`,
12748   a new synthetic metavariable of kind `SyntheticMVarKind.postponed` is created, registered,
12749   and returned.
12750   The option `catchExPostpone == false` is used to implement `resumeElabTerm`
12751   to prevent the creation of another synthetic metavariable when resuming the elaboration.
12752 
12753   If `implicitLambda == true`, then disable implicit lambdas feature for the given syntax, but not for its subterms.
12754   We use this flag to implement, for example, the `@` modifier. If `Context.implicitLambda == false`, then this parameter has no effect.
12755   -/</span>
<span class="keyword">12756 def</span> <span class="function-name">elabTerm</span> (stx : Syntax) (expectedType? : Option Expr) (catchExPostpone <span class="constant">:=</span> true) (implicitLambda <span class="constant">:=</span> true) : TermElabM Expr <span class="constant">:=</span>
12757   withInfoContext' (withRef stx <span class="constant">&lt;</span>| elabTermAux expectedType? catchExPostpone implicitLambda stx) (mkTermInfo stx)
12758 
<span class="keyword">12759 def</span> <span class="function-name">elabTermEnsuringType</span> (stx : Syntax) (expectedType? : Option Expr) (catchExPostpone <span class="constant">:=</span> true) (implicitLambda <span class="constant">:=</span> true) (errorMsgHeader? : Option String <span class="constant">:=</span> none) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
12760   <span class="keyword">let</span> e &#8592; elabTerm stx expectedType? catchExPostpone implicitLambda
12761   withRef stx <span class="constant">&lt;</span>| ensureHasType expectedType? e errorMsgHeader?
12762 
<span class="comment-delimiter">12763 /-</span><span class="comment">- Adapt a syntax transformation to a regular, term-producing elaborator. -/</span>
<span class="keyword">12764 def</span> <span class="function-name">adaptExpander</span> (exp : Syntax <span class="constant">&#8594;</span> TermElabM Syntax) : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span> <span class="keyword">do</span>
12765   <span class="keyword">let</span> stx' &#8592; exp stx
12766   withMacroExpansion stx stx' <span class="constant">$</span> elabTerm stx' expectedType?
12767 
<span class="keyword">12768 def</span> <span class="function-name">mkInstMVar</span> (type : Expr) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
12769   <span class="keyword">let</span> mvar &#8592; mkFreshExprMVar type MetavarKind.synthetic
12770   <span class="keyword">let</span> mvarId <span class="constant">:=</span> mvar.mvarId<span class="constant">!</span>
12771   <span class="keyword">unless</span> (&#8592; synthesizeInstMVarCore mvarId) <span class="keyword">do</span>
12772     registerSyntheticMVarWithCurrRef mvarId SyntheticMVarKind.typeClass
12773   pure mvar
12774 
<span class="comment-delimiter">12775 /-</span><span class="comment">
12776   Relevant definitions:
12777   ```
12778   class CoeSort (&#945; : Sort u) (&#946; : outParam (Sort v))
12779   abbrev coeSort {&#945; : Sort u} {&#946; : Sort v} (a : &#945;) [CoeSort &#945; &#946;] : &#946;
12780   ```
12781   -/</span>
<span class="keyword">12782 private</span> <span class="keyword">def</span> <span class="function-name">tryCoeSort</span> (&#945; : Expr) (a : Expr) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
12783   <span class="keyword">let</span> &#946; &#8592; mkFreshTypeMVar
12784   <span class="keyword">let</span> u &#8592; getLevel &#945;
12785   <span class="keyword">let</span> v &#8592; getLevel &#946;
12786   <span class="keyword">let</span> coeSortInstType <span class="constant">:=</span> mkAppN (Lean.mkConst ``CoeSort [u, v]) <span class="constant">#</span>[&#945;, &#946;]
12787   <span class="keyword">let</span> mvar &#8592; mkFreshExprMVar coeSortInstType MetavarKind.synthetic
12788   <span class="keyword">let</span> mvarId <span class="constant">:=</span> mvar.mvarId<span class="constant">!</span>
12789   <span class="keyword">try</span>
12790     withoutMacroStackAtErr <span class="keyword">do</span>
12791       <span class="keyword">if</span> (&#8592; synthesizeCoeInstMVarCore mvarId) <span class="keyword">then</span>
12792         expandCoe <span class="constant">&lt;</span>| mkAppN (Lean.mkConst ``coeSort [u, v]) <span class="constant">#</span>[&#945;, &#946;, a, mvar]
12793       <span class="keyword">else</span>
12794         throwError <span class="string">"type expected"</span>
12795   <span class="keyword">catch</span>
12796     | Exception.error <span class="preprocessor">_</span> msg <span class="constant">=&gt;</span> throwError <span class="string">"type expected\n{msg}"</span>
12797     | <span class="preprocessor">_</span>                     <span class="constant">=&gt;</span> throwError <span class="string">"type expected"</span>
12798 
<span class="comment-delimiter">12799 /-</span><span class="comment">-
12800   Make sure `e` is a type by inferring its type and making sure it is a `Expr.sort`
12801   or is unifiable with `Expr.sort`, or can be coerced into one. -/</span>
<span class="keyword">12802 def</span> <span class="function-name">ensureType</span> (e : Expr) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
12803   <span class="keyword">if</span> (&#8592; isType e) <span class="keyword">then</span>
12804     pure e
12805   <span class="keyword">else</span>
12806     <span class="keyword">let</span> eType &#8592; inferType e
12807     <span class="keyword">let</span> u &#8592; mkFreshLevelMVar
12808     <span class="keyword">if</span> (&#8592; isDefEq eType (mkSort u)) <span class="keyword">then</span>
12809       pure e
12810     <span class="keyword">else</span>
12811       tryCoeSort eType e
12812 
<span class="comment-delimiter">12813 /-</span><span class="comment">- Elaborate `stx` and ensure result is a type. -/</span>
<span class="keyword">12814 def</span> <span class="function-name">elabType</span> (stx : Syntax) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
12815   <span class="keyword">let</span> u &#8592; mkFreshLevelMVar
12816   <span class="keyword">let</span> type &#8592; elabTerm stx (mkSort u)
12817   withRef stx <span class="constant">$</span> ensureType type
12818 
<span class="comment-delimiter">12819 /-</span><span class="comment">-
12820   Enable auto-bound implicits, and execute `k` while catching auto bound implicit exceptions. When an exception is caught,
12821   a new local declaration is created, registered, and `k` is tried to be executed again. -/</span>
<span class="keyword">12822 partial</span> <span class="keyword">def</span> <span class="function-name">withAutoBoundImplicit</span> (k : TermElabM &#945;) : TermElabM &#945; <span class="constant">:=</span> <span class="keyword">do</span>
12823   <span class="keyword">let</span> flag <span class="constant">:=</span> autoBoundImplicitLocal.get (&#8592; getOptions)
12824   <span class="keyword">if</span> flag <span class="keyword">then</span>
12825     withReader (<span class="keyword">fun</span> ctx <span class="constant">=&gt;</span> { ctx <span class="keyword">with</span> autoBoundImplicit <span class="constant">:=</span> flag, autoBoundImplicits <span class="constant">:=</span> {} }) <span class="keyword">do</span>
12826       <span class="keyword">let</span> <span class="keyword">rec</span> loop (s : SavedState) : TermElabM &#945; <span class="constant">:=</span> <span class="keyword">do</span>
12827         <span class="keyword">try</span>
12828           k
12829         <span class="keyword">catch</span>
12830           | ex <span class="constant">=&gt;</span> <span class="keyword">match</span> isAutoBoundImplicitLocalException? ex <span class="keyword">with</span>
12831             | some n <span class="constant">=&gt;</span>
12832               <span class="comment-delimiter">-- </span><span class="comment">Restore state, declare `n`, and try again
</span>12833               s.restore
12834               withLocalDecl n BinderInfo.implicit (&#8592; mkFreshTypeMVar) <span class="keyword">fun</span> x <span class="constant">=&gt;</span>
12835                 withReader (<span class="keyword">fun</span> ctx <span class="constant">=&gt;</span> { ctx <span class="keyword">with</span> autoBoundImplicits <span class="constant">:=</span> ctx.autoBoundImplicits.push x } ) <span class="keyword">do</span>
12836                   loop (&#8592; saveState)
12837             | none   <span class="constant">=&gt;</span> throw ex
12838       loop (&#8592; saveState)
12839   <span class="keyword">else</span>
12840     k
12841 
<span class="keyword">12842 def</span> <span class="function-name">withoutAutoBoundImplicit</span> (k : TermElabM &#945;) : TermElabM &#945; <span class="constant">:=</span> <span class="keyword">do</span>
12843   withReader (<span class="keyword">fun</span> ctx <span class="constant">=&gt;</span> { ctx <span class="keyword">with</span> autoBoundImplicit <span class="constant">:=</span> false, autoBoundImplicits <span class="constant">:=</span> {} }) k
12844 
<span class="comment-delimiter">12845 /-</span><span class="comment">-
12846   Return `autoBoundImplicits ++ xs.
12847   This methoid throws an error if a variable in `autoBoundImplicits` depends on some `x` in `xs` -/</span>
<span class="keyword">12848 def</span> <span class="function-name">addAutoBoundImplicits</span> (xs : Array Expr) : TermElabM (Array Expr) <span class="constant">:=</span> <span class="keyword">do</span>
12849   <span class="keyword">let</span> autoBoundImplicits <span class="constant">:=</span> (&#8592; read).autoBoundImplicits
12850   <span class="keyword">for</span> auto <span class="keyword">in</span> autoBoundImplicits <span class="keyword">do</span>
12851     <span class="keyword">let</span> localDecl &#8592; getLocalDecl auto.fvarId<span class="constant">!</span>
12852     <span class="keyword">for</span> x <span class="keyword">in</span> xs <span class="keyword">do</span>
12853       <span class="keyword">if</span> (&#8592; getMCtx).localDeclDependsOn localDecl x.fvarId<span class="constant">!</span> <span class="keyword">then</span>
12854         throwError <span class="string">"invalid auto implicit argument '{auto}', it depends on explicitly provided argument '{x}'"</span>
12855   <span class="keyword">return</span> autoBoundImplicits.toArray <span class="constant">++</span> xs
12856 
<span class="keyword">12857 def</span> <span class="function-name">mkAuxName</span> (suffix : Name) : TermElabM Name <span class="constant">:=</span> <span class="keyword">do</span>
12858   <span class="keyword">match</span> (&#8592; read).declName? <span class="keyword">with</span>
12859   | none          <span class="constant">=&gt;</span> throwError <span class="string">"auxiliary declaration cannot be created when declaration name is not available"</span>
12860   | some declName <span class="constant">=&gt;</span> Lean.mkAuxName (declName <span class="constant">++</span> suffix) <span class="constant">1</span>
12861 
<span class="keyword">12862 builtin_initialize</span> registerTraceClass `Elab.letrec
12863 
<span class="comment-delimiter">12864 /- </span><span class="comment">Return true if mvarId is an auxiliary metavariable created for compiling `let rec` or it
12865    is delayed assigned to one. -/</span>
<span class="keyword">12866 def</span> <span class="function-name">isLetRecAuxMVar</span> (mvarId : MVarId) : TermElabM Bool <span class="constant">:=</span> <span class="keyword">do</span>
12867   trace[Elab.letrec] <span class="string">"mvarId: {mkMVar mvarId} letrecMVars: {(&#8592; get).letRecsToLift.map (mkMVar $ &#183;.mvarId)}"</span>
12868   <span class="keyword">let</span> mvarId <span class="constant">:=</span> (&#8592; getMCtx).getDelayedRoot mvarId
12869   trace[Elab.letrec] <span class="string">"mvarId root: {mkMVar mvarId}"</span>
12870   <span class="keyword">return</span> (&#8592; get).letRecsToLift.any (&#183;.mvarId <span class="constant">==</span> mvarId)
12871 
<span class="comment-delimiter">12872 /- </span><span class="comment">=======================================
12873        Builtin elaboration functions
12874    ======================================= -/</span>
12875 
<span class="constant">12876 @</span>[builtinTermElab <span class="comment">&#171;</span>prop<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabProp</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
12877   <span class="keyword">return</span> mkSort levelZero
12878 
<span class="keyword">12879 private</span> <span class="keyword">def</span> <span class="function-name">elabOptLevel</span> (stx : Syntax) : TermElabM Level <span class="constant">:=</span>
12880   <span class="keyword">if</span> stx.isNone <span class="keyword">then</span>
12881     pure levelZero
12882   <span class="keyword">else</span>
12883     elabLevel stx[<span class="constant">0</span>]
12884 
<span class="constant">12885 @</span>[builtinTermElab <span class="comment">&#171;</span>sort<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabSort</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
12886   <span class="keyword">return</span> mkSort (&#8592; elabOptLevel stx[<span class="constant">1</span>])
12887 
<span class="constant">12888 @</span>[builtinTermElab <span class="comment">&#171;</span>type<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabTypeStx</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
12889   <span class="keyword">return</span> mkSort (mkLevelSucc (&#8592; elabOptLevel stx[<span class="constant">1</span>]))
12890 
<span class="comment-delimiter">12891 /-</span><span class="comment">
12892  the method `resolveName` adds a completion point for it using the given
12893     expected type. Thus, we propagate the expected type if `stx[0]` is an identifier.
12894     It doesn't "hurt" if the identifier can be resolved because the expected type is not used in this case.
12895     Recall that if the name resolution fails a synthetic sorry is returned.-/</span>
12896 
<span class="constant">12897 @</span>[builtinTermElab <span class="comment">&#171;</span>pipeCompletion<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabPipeCompletion</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span> <span class="keyword">do</span>
12898   <span class="keyword">let</span> e &#8592; elabTerm stx[<span class="constant">0</span>] none
12899   <span class="keyword">unless</span> e.isSorry <span class="keyword">do</span>
12900     addDotCompletionInfo stx e expectedType?
12901   throwErrorAt stx[<span class="constant">1</span>] <span class="string">"invalid field notation, identifier or numeral expected"</span>
12902 
<span class="constant">12903 @</span>[builtinTermElab <span class="comment">&#171;</span>completion<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabCompletion</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span> <span class="keyword">do</span>
12904   <span class="comment-delimiter">/- </span><span class="comment">`ident.` is ambiguous in Lean, we may try to be completing a declaration name or access a "field". -/</span>
12905   <span class="keyword">if</span> stx[<span class="constant">0</span>].isIdent <span class="keyword">then</span>
12906     <span class="comment-delimiter">/- </span><span class="comment">If we can elaborate the identifier successfully, we assume it a dot-completion. Otherwise, we treat it as
12907        identifier completion with a dangling `.`.
12908        Recall that the server falls back to identifier completion when dot-completion fails. -/</span>
12909     <span class="keyword">let</span> s &#8592; saveState
12910     <span class="keyword">try</span>
12911       <span class="keyword">let</span> e &#8592; elabTerm stx[<span class="constant">0</span>] none
12912       addDotCompletionInfo stx e expectedType?
12913     <span class="keyword">catch</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
12914       s.restore
12915       addCompletionInfo <span class="constant">&lt;</span>| CompletionInfo.id stx stx[<span class="constant">0</span>].getId (danglingDot <span class="constant">:=</span> true) (&#8592; getLCtx) expectedType?
12916     throwErrorAt stx[<span class="constant">1</span>] <span class="string">"invalid field notation, identifier or numeral expected"</span>
12917   <span class="keyword">else</span>
12918     elabPipeCompletion stx expectedType?
12919 
<span class="constant">12920 @</span>[builtinTermElab <span class="comment">&#171;</span>hole<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabHole</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span> <span class="keyword">do</span>
12921   <span class="keyword">let</span> mvar &#8592; mkFreshExprMVar expectedType?
12922   registerMVarErrorHoleInfo mvar.mvarId<span class="constant">!</span> stx
12923   pure mvar
12924 
<span class="constant">12925 @</span>[builtinTermElab <span class="comment">&#171;</span>syntheticHole<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabSyntheticHole</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span> <span class="keyword">do</span>
12926   <span class="keyword">let</span> arg  <span class="constant">:=</span> stx[<span class="constant">1</span>]
12927   <span class="keyword">let</span> userName <span class="constant">:=</span> <span class="keyword">if</span> arg.isIdent <span class="keyword">then</span> arg.getId <span class="keyword">else</span> Name.anonymous
12928   <span class="keyword">let</span> mkNewHole : Unit <span class="constant">&#8594;</span> TermElabM Expr <span class="constant">:=</span> <span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">do</span>
12929     <span class="keyword">let</span> mvar &#8592; mkFreshExprMVar expectedType? MetavarKind.syntheticOpaque userName
12930     registerMVarErrorHoleInfo mvar.mvarId<span class="constant">!</span> stx
12931     pure mvar
12932   <span class="keyword">if</span> userName.isAnonymous <span class="keyword">then</span>
12933     mkNewHole ()
12934   <span class="keyword">else</span>
12935     <span class="keyword">let</span> mctx &#8592; getMCtx
12936     <span class="keyword">match</span> mctx.findUserName? userName <span class="keyword">with</span>
12937     | none <span class="constant">=&gt;</span> mkNewHole ()
12938     | some mvarId <span class="constant">=&gt;</span>
12939       <span class="keyword">let</span> mvar <span class="constant">:=</span> mkMVar mvarId
12940       <span class="keyword">let</span> mvarDecl &#8592; getMVarDecl mvarId
12941       <span class="keyword">let</span> lctx &#8592; getLCtx
12942       <span class="keyword">if</span> mvarDecl.lctx.isSubPrefixOf lctx <span class="keyword">then</span>
12943         pure mvar
12944       <span class="keyword">else</span> <span class="keyword">match</span> mctx.getExprAssignment? mvarId <span class="keyword">with</span>
12945       | some val <span class="constant">=&gt;</span>
12946         <span class="keyword">let</span> val &#8592; instantiateMVars val
12947         <span class="keyword">if</span> mctx.isWellFormed lctx val <span class="keyword">then</span>
12948           pure val
12949         <span class="keyword">else</span>
12950           withLCtx mvarDecl.lctx mvarDecl.localInstances <span class="keyword">do</span>
12951             throwError <span class="string">"synthetic hole has already been defined and assigned to value incompatible with the current context{indentExpr val}"</span>
12952       | none <span class="constant">=&gt;</span>
12953         <span class="keyword">if</span> mctx.isDelayedAssigned mvarId <span class="keyword">then</span>
12954           <span class="comment-delimiter">-- </span><span class="comment">We can try to improve this case if needed.
</span>12955           throwError <span class="string">"synthetic hole has already beend defined and delayed assigned with an incompatible local context"</span>
12956         <span class="keyword">else</span> <span class="keyword">if</span> lctx.isSubPrefixOf mvarDecl.lctx <span class="keyword">then</span>
12957           <span class="keyword">let</span> mvarNew &#8592; mkNewHole ()
12958           modifyMCtx <span class="keyword">fun</span> mctx <span class="constant">=&gt;</span> mctx.assignExpr mvarId mvarNew
12959           pure mvarNew
12960         <span class="keyword">else</span>
12961           throwError <span class="string">"synthetic hole has already been defined with an incompatible local context"</span>
12962 
<span class="keyword">12963 private</span> <span class="keyword">def</span> <span class="function-name">mkTacticMVar</span> (type : Expr) (tacticCode : Syntax) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
12964   <span class="keyword">let</span> mvar &#8592; mkFreshExprMVar type MetavarKind.syntheticOpaque
12965   <span class="keyword">let</span> mvarId <span class="constant">:=</span> mvar.mvarId<span class="constant">!</span>
12966   <span class="keyword">let</span> ref &#8592; getRef
12967   <span class="keyword">let</span> declName? &#8592; getDeclName?
12968   registerSyntheticMVar ref mvarId <span class="constant">&lt;</span>| SyntheticMVarKind.tactic tacticCode (&#8592; saveContext)
12969   <span class="keyword">return</span> mvar
12970 
<span class="doc">12971 @[builtinTermElab byTactic]</span> <span class="keyword">def</span> <span class="function-name">elabByTactic</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span>
12972   <span class="keyword">match</span> expectedType? <span class="keyword">with</span>
12973   | some expectedType <span class="constant">=&gt;</span> mkTacticMVar expectedType stx
12974   | none <span class="constant">=&gt;</span> throwError (<span class="string">"invalid 'by' tactic, expected type has not been provided"</span>)
12975 
<span class="doc">12976 @[builtinTermElab noImplicitLambda]</span> <span class="keyword">def</span> <span class="function-name">elabNoImplicitLambda</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span>
12977   elabTerm stx[<span class="constant">1</span>] (mkNoImplicitLambdaAnnotation <span class="constant">&lt;$&gt;</span> expectedType?)
12978 
<span class="keyword">12979 def</span> <span class="function-name">resolveLocalName</span> (n : Name) : TermElabM (Option (Expr <span class="constant">&#215;</span> List String)) <span class="constant">:=</span> <span class="keyword">do</span>
12980   <span class="keyword">let</span> lctx &#8592; getLCtx
12981   <span class="keyword">let</span> view <span class="constant">:=</span> extractMacroScopes n
12982   <span class="keyword">let</span> <span class="keyword">rec</span> loop (n : Name) (projs : List String) <span class="constant">:=</span>
12983     <span class="keyword">match</span> lctx.findFromUserName? { view <span class="keyword">with</span> name <span class="constant">:=</span> n }.review <span class="keyword">with</span>
12984     | some decl <span class="constant">=&gt;</span> some (decl.toExpr, projs)
12985     | none      <span class="constant">=&gt;</span> <span class="keyword">match</span> n <span class="keyword">with</span>
12986       | Name.str pre s <span class="preprocessor">_</span> <span class="constant">=&gt;</span> loop pre (s::projs)
12987       | <span class="preprocessor">_</span>                <span class="constant">=&gt;</span> none
12988   <span class="keyword">return</span> loop view.name []
12989 
<span class="comment-delimiter">12990 /- </span><span class="comment">Return true iff `stx` is a `Syntax.ident`, and it is a local variable. -/</span>
<span class="keyword">12991 def</span> <span class="function-name">isLocalIdent?</span> (stx : Syntax) : TermElabM (Option Expr) <span class="constant">:=</span>
12992   <span class="keyword">match</span> stx <span class="keyword">with</span>
12993   | Syntax.ident <span class="preprocessor">_</span> <span class="preprocessor">_</span> val <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">do</span>
12994     <span class="keyword">let</span> r? &#8592; resolveLocalName val
12995     <span class="keyword">match</span> r? <span class="keyword">with</span>
12996     | some (fvar, []) <span class="constant">=&gt;</span> pure (some fvar)
12997     | <span class="preprocessor">_</span>               <span class="constant">=&gt;</span> pure none
12998   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> pure none
12999 
<span class="comment-delimiter">13000 /-</span><span class="comment">-
13001   Create an `Expr.const` using the given name and explicit levels.
13002   Remark: fresh universe metavariables are created if the constant has more universe
13003   parameters than `explicitLevels`. -/</span>
<span class="keyword">13004 def</span> <span class="function-name">mkConst</span> (constName : Name) (explicitLevels : List Level <span class="constant">:=</span> []) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
13005   <span class="keyword">let</span> cinfo &#8592; getConstInfo constName
13006   <span class="keyword">if</span> explicitLevels.length <span class="constant">&gt;</span> cinfo.levelParams.length <span class="keyword">then</span>
13007     throwError <span class="string">"too many explicit universe levels"</span>
13008   <span class="keyword">else</span>
13009     <span class="keyword">let</span> numMissingLevels <span class="constant">:=</span> cinfo.levelParams.length <span class="constant">-</span> explicitLevels.length
13010     <span class="keyword">let</span> us &#8592; mkFreshLevelMVars numMissingLevels
13011     pure <span class="constant">$</span> Lean.mkConst constName (explicitLevels <span class="constant">++</span> us)
13012 
<span class="keyword">13013 private</span> <span class="keyword">def</span> <span class="function-name">mkConsts</span> (candidates : List (Name <span class="constant">&#215;</span> List String)) (explicitLevels : List Level) : TermElabM (List (Expr <span class="constant">&#215;</span> List String)) <span class="constant">:=</span> <span class="keyword">do</span>
13014   candidates.foldlM (init <span class="constant">:=</span> []) <span class="keyword">fun</span> result (constName, projs) <span class="constant">=&gt;</span> <span class="keyword">do</span>
13015     <span class="comment-delimiter">-- </span><span class="comment">TODO: better suppor for `mkConst` failure. We may want to cache the failures, and report them if all candidates fail.
</span>13016    <span class="keyword">let</span> const &#8592; mkConst constName explicitLevels
13017    <span class="keyword">return</span> (const, projs) :: result
13018 
<span class="keyword">13019 def</span> <span class="function-name">resolveName</span> (stx : Syntax) (n : Name) (preresolved : List (Name <span class="constant">&#215;</span> List String)) (explicitLevels : List Level) (expectedType? : Option Expr <span class="constant">:=</span> none) : TermElabM (List (Expr <span class="constant">&#215;</span> List String)) <span class="constant">:=</span> <span class="keyword">do</span>
13020   <span class="keyword">try</span>
13021     <span class="keyword">if</span> <span class="keyword">let</span> some (e, projs) &#8592; resolveLocalName n <span class="keyword">then</span>
13022       <span class="keyword">unless</span> explicitLevels.isEmpty <span class="keyword">do</span>
13023         throwError <span class="string">"invalid use of explicit universe parameters, '{e}' is a local"</span>
13024       <span class="keyword">return</span> [(e, projs)]
13025     <span class="comment-delimiter">-- </span><span class="comment">check for section variable capture by a quotation
</span>13026     <span class="keyword">let</span> ctx &#8592; read
13027     <span class="keyword">if</span> <span class="keyword">let</span> some (e, projs) <span class="constant">:=</span> preresolved.findSome? <span class="keyword">fun</span> (n, projs) <span class="constant">=&gt;</span> ctx.sectionFVars.find? n |<span class="constant">&gt;</span>.map (&#183;, projs) <span class="keyword">then</span>
13028       <span class="keyword">return</span> [(e, projs)]  <span class="comment-delimiter">-- </span><span class="comment">section variables should shadow global decls
</span>13029     <span class="keyword">if</span> preresolved.isEmpty <span class="keyword">then</span>
13030       process (&#8592; resolveGlobalName n)
13031     <span class="keyword">else</span>
13032       process preresolved
13033   <span class="keyword">catch</span> ex <span class="constant">=&gt;</span>
13034     <span class="keyword">if</span> preresolved.isEmpty <span class="constant">&amp;&amp;</span> explicitLevels.isEmpty <span class="keyword">then</span>
13035       addCompletionInfo <span class="constant">&lt;</span>| CompletionInfo.id stx stx.getId (danglingDot <span class="constant">:=</span> false) (&#8592; getLCtx) expectedType?
13036     throw ex
<span class="keyword">13037 where</span> process (candidates : List (Name <span class="constant">&#215;</span> List String)) : TermElabM (List (Expr <span class="constant">&#215;</span> List String)) <span class="constant">:=</span> <span class="keyword">do</span>
13038   <span class="keyword">if</span> candidates.isEmpty <span class="keyword">then</span>
13039     <span class="keyword">if</span> (&#8592; read).autoBoundImplicit <span class="constant">&amp;&amp;</span> isValidAutoBoundImplicitName n <span class="keyword">then</span>
13040       throwAutoBoundImplicitLocal n
13041     <span class="keyword">else</span>
13042       throwError <span class="string">"unknown identifier '{Lean.mkConst n}'"</span>
13043   <span class="keyword">if</span> preresolved.isEmpty <span class="constant">&amp;&amp;</span> explicitLevels.isEmpty <span class="keyword">then</span>
13044     addCompletionInfo <span class="constant">&lt;</span>| CompletionInfo.id stx stx.getId (danglingDot <span class="constant">:=</span> false) (&#8592; getLCtx) expectedType?
13045   mkConsts candidates explicitLevels
13046 
<span class="comment-delimiter">13047 /-</span><span class="comment">-
13048   Similar to `resolveName`, but creates identifiers for the main part and each projection with position information derived from `ident`.
13049   Example: Assume resolveName `v.head.bla.boo` produces `(v.head, ["bla", "boo"])`, then this method produces
13050   `(v.head, id, [f&#8321;, f&#8322;])` where `id` is an identifier for `v.head`, and `f&#8321;` and `f&#8322;` are identifiers for fields `"bla"` and `"boo"`. -/</span>
<span class="keyword">13051 def</span> <span class="function-name">resolveName'</span> (ident : Syntax) (explicitLevels : List Level) (expectedType? : Option Expr <span class="constant">:=</span> none) : TermElabM (List (Expr <span class="constant">&#215;</span> Syntax <span class="constant">&#215;</span> List Syntax)) <span class="constant">:=</span> <span class="keyword">do</span>
13052   <span class="keyword">match</span> ident <span class="keyword">with</span>
13053   | Syntax.ident info rawStr n preresolved <span class="constant">=&gt;</span>
13054     <span class="keyword">let</span> r &#8592; resolveName ident n preresolved explicitLevels expectedType?
13055     r.mapM <span class="keyword">fun</span> (c, fields) <span class="constant">=&gt;</span> <span class="keyword">do</span>
13056       <span class="keyword">let</span> (cSstr, fields) <span class="constant">:=</span> fields.foldr (init <span class="constant">:=</span> (rawStr, [])) <span class="keyword">fun</span> field (restSstr, fs) <span class="constant">=&gt;</span>
13057         <span class="keyword">let</span> fieldSstr <span class="constant">:=</span> restSstr.takeRightWhile (&#183; <span class="constant">&#8800;</span> '.')
13058         ({ restSstr <span class="keyword">with</span> stopPos <span class="constant">:=</span> restSstr.stopPos <span class="constant">-</span> (fieldSstr.bsize <span class="constant">+</span> <span class="constant">1</span>) }, (field, fieldSstr) :: fs)
13059       <span class="keyword">let</span> mkIdentFromPos pos rawVal val <span class="constant">:=</span>
13060         <span class="keyword">let</span> info <span class="constant">:=</span> <span class="keyword">match</span> info <span class="keyword">with</span>
13061         | SourceInfo.original .. <span class="constant">=&gt;</span> SourceInfo.original <span class="string">""</span>.toSubstring pos <span class="string">""</span>.toSubstring
13062         | <span class="preprocessor">_</span>                      <span class="constant">=&gt;</span> SourceInfo.synthetic pos (pos <span class="constant">+</span> rawVal.bsize)
13063         Syntax.ident info rawVal val []
13064       <span class="keyword">let</span> id <span class="constant">:=</span> <span class="keyword">match</span> c <span class="keyword">with</span>
13065         | Expr.const id <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> id
13066         | Expr.fvar id <span class="preprocessor">_</span>    <span class="constant">=&gt;</span> id
13067         | <span class="preprocessor">_</span>                 <span class="constant">=&gt;</span> <span class="warning">unreachable</span><span class="constant">!</span>
13068       <span class="keyword">let</span> id <span class="constant">:=</span> mkIdentFromPos (ident.getPos?.getD <span class="constant">0</span>) cSstr id
13069       <span class="keyword">match</span> info.getPos? <span class="keyword">with</span>
13070       | none <span class="constant">=&gt;</span>
13071         <span class="keyword">return</span> (c, id, fields.map <span class="keyword">fun</span> (field, <span class="preprocessor">_</span>) <span class="constant">=&gt;</span> mkIdentFrom ident (Name.mkSimple field))
13072       | some pos <span class="constant">=&gt;</span>
13073         <span class="keyword">let</span> <span class="keyword">mut</span> pos <span class="constant">:=</span> pos <span class="constant">+</span> cSstr.bsize <span class="constant">+</span> <span class="constant">1</span>
13074         <span class="keyword">let</span> <span class="keyword">mut</span> newFields <span class="constant">:=</span> <span class="constant">#</span>[]
13075         <span class="keyword">for</span> (field, fieldSstr) <span class="keyword">in</span> fields <span class="keyword">do</span>
13076           newFields <span class="constant">:=</span> newFields.push <span class="constant">&lt;</span>| mkIdentFromPos pos fieldSstr (Name.mkSimple field)
13077           pos <span class="constant">:=</span> pos <span class="constant">+</span> fieldSstr.bsize <span class="constant">+</span> <span class="constant">1</span>
13078         <span class="keyword">return</span> (c, id, newFields.toList)
13079   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwError <span class="string">"identifier expected"</span>
13080 
<span class="keyword">13081 def</span> <span class="function-name">resolveId?</span> (stx : Syntax) (kind <span class="constant">:=</span> <span class="string">"term"</span>) : TermElabM (Option Expr) <span class="constant">:=</span>
13082   <span class="keyword">match</span> stx <span class="keyword">with</span>
13083   | Syntax.ident <span class="preprocessor">_</span> <span class="preprocessor">_</span> val preresolved <span class="constant">=&gt;</span> <span class="keyword">do</span>
13084     <span class="keyword">let</span> rs &#8592; <span class="keyword">try</span> resolveName stx val preresolved [] <span class="keyword">catch</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> pure []
13085     <span class="keyword">let</span> rs <span class="constant">:=</span> rs.filter <span class="keyword">fun</span> &#10216;f, projs&#10217; <span class="constant">=&gt;</span> projs.isEmpty
13086     <span class="keyword">let</span> fs <span class="constant">:=</span> rs.map <span class="keyword">fun</span> (f, <span class="preprocessor">_</span>) <span class="constant">=&gt;</span> f
13087     <span class="keyword">match</span> fs <span class="keyword">with</span>
13088     | []  <span class="constant">=&gt;</span> pure none
13089     | [f] <span class="constant">=&gt;</span> pure (some f)
13090     | <span class="preprocessor">_</span>   <span class="constant">=&gt;</span>   throwError <span class="string">"ambiguous {kind}, use fully qualified name, possible interpretations {fs}"</span>
13091   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwError <span class="string">"identifier expected"</span>
13092 
<span class="doc">13093 @[builtinTermElab cdot]</span> <span class="keyword">def</span> <span class="function-name">elabBadCDot</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
13094   throwError <span class="string">"invalid occurrence of `&#183;` notation, it must be surrounded by parentheses (e.g. `(&#183; + 1)`)"</span>
13095 
<span class="doc">13096 @[builtinTermElab strLit]</span> <span class="keyword">def</span> <span class="function-name">elabStrLit</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">do</span>
13097   <span class="keyword">match</span> stx.isStrLit? <span class="keyword">with</span>
13098   | some val <span class="constant">=&gt;</span> pure <span class="constant">$</span> mkStrLit val
13099   | none     <span class="constant">=&gt;</span> throwIllFormedSyntax
13100 
<span class="keyword">13101 private</span> <span class="keyword">def</span> <span class="function-name">mkFreshTypeMVarFor</span> (expectedType? : Option Expr) : TermElabM Expr <span class="constant">:=</span> <span class="keyword">do</span>
13102   <span class="keyword">let</span> typeMVar &#8592; mkFreshTypeMVar MetavarKind.synthetic
13103   <span class="keyword">match</span> expectedType? <span class="keyword">with</span>
13104   | some expectedType <span class="constant">=&gt;</span> discard <span class="constant">&lt;</span>| isDefEq expectedType typeMVar
13105   | <span class="preprocessor">_</span>                 <span class="constant">=&gt;</span> pure ()
13106   <span class="keyword">return</span> typeMVar
13107 
<span class="doc">13108 @[builtinTermElab numLit]</span> <span class="keyword">def</span> <span class="function-name">elabNumLit</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span> <span class="keyword">do</span>
13109   <span class="keyword">let</span> val &#8592; <span class="keyword">match</span> stx.isNatLit? <span class="keyword">with</span>
13110     | some val <span class="constant">=&gt;</span> pure val
13111     | none     <span class="constant">=&gt;</span> throwIllFormedSyntax
13112   <span class="keyword">let</span> typeMVar &#8592; mkFreshTypeMVarFor expectedType?
13113   <span class="keyword">let</span> u &#8592; getDecLevel typeMVar
13114   <span class="keyword">let</span> mvar &#8592; mkInstMVar (mkApp2 (Lean.mkConst ``OfNat [u]) typeMVar (mkNatLit val))
13115   <span class="keyword">let</span> r <span class="constant">:=</span> mkApp3 (Lean.mkConst ``OfNat.ofNat [u]) typeMVar (mkNatLit val) mvar
13116   registerMVarErrorImplicitArgInfo mvar.mvarId<span class="constant">!</span> stx r
13117   <span class="keyword">return</span> r
13118 
<span class="doc">13119 @[builtinTermElab rawNatLit]</span> <span class="keyword">def</span> <span class="function-name">elabRawNatLit</span> : TermElab <span class="constant">:=</span>  <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span> <span class="keyword">do</span>
13120   <span class="keyword">match</span> stx[<span class="constant">1</span>].isNatLit? <span class="keyword">with</span>
13121   | some val <span class="constant">=&gt;</span> <span class="keyword">return</span> mkNatLit val
13122   | none     <span class="constant">=&gt;</span> throwIllFormedSyntax
13123 
<span class="doc">13124 @[builtinTermElab scientificLit]</span>
<span class="keyword">13125 def</span> <span class="function-name">elabScientificLit</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span> <span class="keyword">do</span>
13126   <span class="keyword">match</span> stx.isScientificLit? <span class="keyword">with</span>
13127   | none        <span class="constant">=&gt;</span> throwIllFormedSyntax
13128   | some (m, sign, e) <span class="constant">=&gt;</span>
13129     <span class="keyword">let</span> typeMVar &#8592; mkFreshTypeMVarFor expectedType?
13130     <span class="keyword">let</span> u &#8592; getDecLevel typeMVar
13131     <span class="keyword">let</span> mvar &#8592; mkInstMVar (mkApp (Lean.mkConst ``OfScientific [u]) typeMVar)
13132     <span class="keyword">return</span> mkApp5 (Lean.mkConst ``OfScientific.ofScientific [u]) typeMVar mvar (mkNatLit m) (toExpr sign) (mkNatLit e)
13133 
<span class="doc">13134 @[builtinTermElab charLit]</span> <span class="keyword">def</span> <span class="function-name">elabCharLit</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">do</span>
13135   <span class="keyword">match</span> stx.isCharLit? <span class="keyword">with</span>
13136   | some val <span class="constant">=&gt;</span> <span class="keyword">return</span> mkApp (Lean.mkConst ``Char.ofNat) (mkNatLit val.toNat)
13137   | none     <span class="constant">=&gt;</span> throwIllFormedSyntax
13138 
<span class="doc">13139 @[builtinTermElab quotedName]</span> <span class="keyword">def</span> <span class="function-name">elabQuotedName</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
13140   <span class="keyword">match</span> stx[<span class="constant">0</span>].isNameLit? <span class="keyword">with</span>
13141   | some val <span class="constant">=&gt;</span> pure <span class="constant">$</span> toExpr val
13142   | none     <span class="constant">=&gt;</span> throwIllFormedSyntax
13143 
<span class="doc">13144 @[builtinTermElab doubleQuotedName]</span> <span class="keyword">def</span> <span class="function-name">elabDoubleQuotedName</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">do</span>
13145   <span class="keyword">match</span> stx[<span class="constant">1</span>].isNameLit? <span class="keyword">with</span>
13146   | some val <span class="constant">=&gt;</span> toExpr (&#8592; resolveGlobalConstNoOverloadWithInfo stx[<span class="constant">1</span>] val)
13147   | none     <span class="constant">=&gt;</span> throwIllFormedSyntax
13148 
<span class="doc">13149 @[builtinTermElab typeOf]</span> <span class="keyword">def</span> <span class="function-name">elabTypeOf</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">do</span>
13150   inferType (&#8592; elabTerm stx[<span class="constant">1</span>] none)
13151 
<span class="doc">13152 @[builtinTermElab ensureTypeOf]</span> <span class="keyword">def</span> <span class="function-name">elabEnsureTypeOf</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span>
13153   <span class="keyword">match</span> stx[<span class="constant">2</span>].isStrLit? <span class="keyword">with</span>
13154   | none     <span class="constant">=&gt;</span> throwIllFormedSyntax
13155   | some msg <span class="constant">=&gt;</span> <span class="keyword">do</span>
13156     <span class="keyword">let</span> refTerm &#8592; elabTerm stx[<span class="constant">1</span>] none
13157     <span class="keyword">let</span> refTermType &#8592; inferType refTerm
13158     elabTermEnsuringType stx[<span class="constant">3</span>] refTermType (errorMsgHeader? <span class="constant">:=</span> msg)
13159 
<span class="doc">13160 @[builtinTermElab ensureExpectedType]</span> <span class="keyword">def</span> <span class="function-name">elabEnsureExpectedType</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span>
13161   <span class="keyword">match</span> stx[<span class="constant">1</span>].isStrLit? <span class="keyword">with</span>
13162   | none     <span class="constant">=&gt;</span> throwIllFormedSyntax
13163   | some msg <span class="constant">=&gt;</span> elabTermEnsuringType stx[<span class="constant">2</span>] expectedType? (errorMsgHeader? <span class="constant">:=</span> msg)
13164 
<span class="constant">13165 @</span>[builtinTermElab <span class="comment">&#171;</span>open<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabOpen</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span> <span class="keyword">do</span>
13166   <span class="keyword">try</span>
13167     pushScope
13168     <span class="keyword">let</span> openDecls &#8592; elabOpenDecl stx[<span class="constant">1</span>]
13169     withTheReader Core.Context (<span class="keyword">fun</span> ctx <span class="constant">=&gt;</span> { ctx <span class="keyword">with</span> openDecls <span class="constant">:=</span> openDecls }) <span class="keyword">do</span>
13170       elabTerm stx[<span class="constant">3</span>] expectedType?
13171   <span class="keyword">finally</span>
13172     popScope
13173 
<span class="constant">13174 @</span>[builtinTermElab <span class="comment">&#171;</span>set_option<span class="comment">&#187;</span>] <span class="keyword">def</span> <span class="function-name">elabSetOption</span> : TermElab <span class="constant">:=</span> <span class="keyword">fun</span> stx expectedType? <span class="constant">=&gt;</span> <span class="keyword">do</span>
13175   <span class="keyword">let</span> options &#8592; Elab.elabSetOption stx[<span class="constant">1</span>] stx[<span class="constant">2</span>]
13176   withTheReader Core.Context (<span class="keyword">fun</span> ctx <span class="constant">=&gt;</span> { ctx <span class="keyword">with</span> maxRecDepth <span class="constant">:=</span> maxRecDepth.get options, options <span class="constant">:=</span> options }) <span class="keyword">do</span>
13177     elabTerm stx[<span class="constant">4</span>] expectedType?
13178 
<span class="keyword">13179 private</span> <span class="keyword">def</span> <span class="function-name">mkSomeContext</span> : Context <span class="constant">:=</span> {
13180   fileName      <span class="constant">:=</span> <span class="string">"&lt;TermElabM&gt;"</span>
13181   fileMap       <span class="constant">:=</span> arbitrary
13182 }
13183 
<span class="doc">13184 @[inline]</span> <span class="keyword">def</span> <span class="function-name">TermElabM.run</span> (x : TermElabM &#945;) (ctx : Context <span class="constant">:=</span> mkSomeContext) (s : State <span class="constant">:=</span> {}) : MetaM (&#945; <span class="constant">&#215;</span> State) <span class="constant">:=</span>
13185   withConfig setElabConfig (x ctx |<span class="constant">&gt;</span>.run s)
13186 
<span class="doc">13187 @[inline]</span> <span class="keyword">def</span> <span class="function-name">TermElabM.run'</span> (x : TermElabM &#945;) (ctx : Context <span class="constant">:=</span> mkSomeContext) (s : State <span class="constant">:=</span> {}) : MetaM &#945; <span class="constant">:=</span>
13188   (&#183;.<span class="constant">1</span>) <span class="constant">&lt;$&gt;</span> x.run ctx s
13189 
<span class="doc">13190 @[inline]</span> <span class="keyword">def</span> <span class="function-name">TermElabM.toIO</span> (x : TermElabM &#945;)
13191     (ctxCore : Core.Context) (sCore : Core.State)
13192     (ctxMeta : Meta.Context) (sMeta : Meta.State)
13193     (ctx : Context) (s : State) : IO (&#945; <span class="constant">&#215;</span> Core.State <span class="constant">&#215;</span> Meta.State <span class="constant">&#215;</span> State) <span class="constant">:=</span> <span class="keyword">do</span>
13194   <span class="keyword">let</span> ((a, s), sCore, sMeta) &#8592; (x.run ctx s).toIO ctxCore sCore ctxMeta sMeta
13195   pure (a, sCore, sMeta, s)
13196 
<span class="keyword">13197 instance</span> [MetaEval &#945;] : MetaEval (TermElabM &#945;) <span class="keyword">where</span>
13198   eval env opts x <span class="preprocessor">_</span> <span class="constant">:=</span>
13199     <span class="keyword">let</span> x : TermElabM &#945; <span class="constant">:=</span> <span class="keyword">do</span>
13200       <span class="keyword">try</span> x <span class="keyword">finally</span>
13201         <span class="keyword">let</span> s &#8592; get
13202         s.messages.forM <span class="keyword">fun</span> msg <span class="constant">=&gt;</span> <span class="keyword">do</span> IO.println (&#8592; msg.toString)
13203     MetaEval.eval env opts (hideUnit <span class="constant">:=</span> true) <span class="constant">$</span> x.run' mkSomeContext
13204 
<span class="keyword">13205 unsafe</span> <span class="keyword">def</span> <span class="function-name">evalExpr</span> (&#945;) (typeName : Name) (value : Expr) : TermElabM &#945; <span class="constant">:=</span>
13206   withoutModifyingEnv <span class="keyword">do</span>
13207     <span class="keyword">let</span> name &#8592; mkFreshUserName `_tmp
13208     <span class="keyword">let</span> type &#8592; inferType value
13209     <span class="keyword">let</span> type &#8592; whnfD type
13210     <span class="keyword">unless</span> type.isConstOf typeName <span class="keyword">do</span>
13211       throwError <span class="string">"unexpected type at evalExpr{indentExpr type}"</span>
13212     <span class="keyword">let</span> decl <span class="constant">:=</span> Declaration.defnDecl {
13213        name <span class="constant">:=</span> name, levelParams <span class="constant">:=</span> [], type <span class="constant">:=</span> type,
13214        value <span class="constant">:=</span> value, hints <span class="constant">:=</span> ReducibilityHints.opaque,
13215        safety <span class="constant">:=</span> DefinitionSafety.<span class="keyword">unsafe</span>
13216     }
13217     ensureNoUnassignedMVars decl
13218     addAndCompile decl
13219     evalConst &#945; name
13220 
<span class="keyword">13221 private</span> <span class="keyword">def</span> <span class="function-name">throwStuckAtUniverseCnstr</span> : TermElabM Unit <span class="constant">:=</span> <span class="keyword">do</span>
13222   <span class="keyword">let</span> entries &#8592; getPostponed
13223   <span class="keyword">let</span> <span class="keyword">mut</span> found : Std.HashSet (Level <span class="constant">&#215;</span> Level) <span class="constant">:=</span> {}
13224   <span class="keyword">let</span> <span class="keyword">mut</span> uniqueEntries <span class="constant">:=</span> <span class="constant">#</span>[]
13225   <span class="keyword">for</span> entry <span class="keyword">in</span> entries <span class="keyword">do</span>
13226     <span class="keyword">let</span> <span class="keyword">mut</span> lhs <span class="constant">:=</span> entry.lhs
13227     <span class="keyword">let</span> <span class="keyword">mut</span> rhs <span class="constant">:=</span> entry.rhs
13228     <span class="keyword">if</span> Level.normLt rhs lhs <span class="keyword">then</span>
13229       (lhs, rhs) <span class="constant">:=</span> (rhs, lhs)
13230     <span class="keyword">unless</span> found.contains (lhs, rhs) <span class="keyword">do</span>
13231       found <span class="constant">:=</span> found.insert (lhs, rhs)
13232       uniqueEntries <span class="constant">:=</span> uniqueEntries.push entry
13233   <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="constant">1</span>:uniqueEntries.size] <span class="keyword">do</span>
13234     logErrorAt uniqueEntries[i].ref (&#8592; mkMessage uniqueEntries[i])
13235   throwErrorAt uniqueEntries[<span class="constant">0</span>].ref (&#8592; mkMessage uniqueEntries[<span class="constant">0</span>])
<span class="keyword">13236 where</span>
13237   <span class="comment-delimiter">/- </span><span class="comment">Annotate any constant and sort in `e` that satisfies `p` with `pp.universes true` -/</span>
13238   exposeRelevantUniverses (e : Expr) (p : Level <span class="constant">&#8594;</span> Bool) : Expr <span class="constant">:=</span>
13239     e.replace <span class="keyword">fun</span> e <span class="constant">=&gt;</span>
13240       <span class="keyword">match</span> e <span class="keyword">with</span>
13241       | Expr.const <span class="preprocessor">_</span> us <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">if</span> us.any p <span class="keyword">then</span> some (e.setPPUniverses true) <span class="keyword">else</span> none
13242       | Expr.sort u <span class="preprocessor">_</span>     <span class="constant">=&gt;</span> <span class="keyword">if</span> p u <span class="keyword">then</span> some (e.setPPUniverses true) <span class="keyword">else</span> none
13243       | <span class="preprocessor">_</span>                 <span class="constant">=&gt;</span> none
13244 
13245   mkMessage (entry : PostponedEntry) : TermElabM MessageData <span class="constant">:=</span> <span class="keyword">do</span>
13246     <span class="keyword">match</span> entry.ctx? <span class="keyword">with</span>
13247     | none <span class="constant">=&gt;</span>
13248       <span class="keyword">return</span> m<span class="constant">!</span><span class="string">"stuck at solving universe constraints{indentD m!"</span>{entry.lhs} <span class="constant">=</span>?<span class="constant">=</span> {entry.rhs}<span class="string">"}"</span>
13249     | some ctx <span class="constant">=&gt;</span>
13250       withLCtx ctx.lctx ctx.localInstances <span class="keyword">do</span>
13251         <span class="keyword">let</span> s   <span class="constant">:=</span> entry.lhs.collectMVars entry.rhs.collectMVars
13252         <span class="comment-delimiter">/- </span><span class="comment">`p u` is true if it contains a universe metavariable in `s` -/</span>
13253         <span class="keyword">let</span> p (u : Level) <span class="constant">:=</span> u.any <span class="keyword">fun</span> | Level.mvar m <span class="preprocessor">_</span> <span class="constant">=&gt;</span> s.contains m | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> false
13254         <span class="keyword">let</span> lhs <span class="constant">:=</span> exposeRelevantUniverses (&#8592; instantiateMVars ctx.lhs) p
13255         <span class="keyword">let</span> rhs <span class="constant">:=</span> exposeRelevantUniverses (&#8592; instantiateMVars ctx.rhs) p
13256         addMessageContext m<span class="constant">!</span><span class="string">"stuck at solving universe constraints{indentD m!"</span>{entry.lhs} <span class="constant">=</span>?<span class="constant">=</span> {entry.rhs}<span class="string">"}\nwhile trying to unify{indentExpr lhs}\nwith{indentExpr rhs}"</span>
13257 
<span class="doc">13258 @[specialize]</span> <span class="keyword">def</span> <span class="function-name">withoutPostponingUniverseConstraints</span> (x : TermElabM &#945;) : TermElabM &#945; <span class="constant">:=</span> <span class="keyword">do</span>
13259   <span class="keyword">let</span> postponed &#8592; getResetPostponed
13260   <span class="keyword">try</span>
13261     <span class="keyword">let</span> a &#8592; x
13262     <span class="keyword">unless</span> (&#8592; processPostponed (mayPostpone <span class="constant">:=</span> false)) <span class="keyword">do</span>
13263       throwStuckAtUniverseCnstr
13264     setPostponed postponed
13265     <span class="keyword">return</span> a
13266   <span class="keyword">catch</span> ex <span class="constant">=&gt;</span>
13267     setPostponed postponed
13268     throw ex
13269 
<span class="keyword">13270 end</span> Term
13271 
<span class="keyword">13272 builtin_initialize</span>
13273   registerTraceClass `Elab.postpone
13274   registerTraceClass `Elab.coe
13275   registerTraceClass `Elab.debug
13276 
<span class="keyword">13277 export</span> Term (TermElabM)
13278 
<span class="keyword">13279 end</span> Lean.Elab
13280 ::::::::::::::
13281 Elab<span class="constant">/</span>Util.lean
13282 ::::::::::::::
<span class="comment-delimiter">13283 /-</span><span class="comment">
13284 Copyright (c) 2019 Microsoft Corporation. All rights reserved.
13285 Released under Apache 2.0 license as described in the file LICENSE.
13286 Authors: Leonardo de Moura
13287 -/</span>
<span class="keyword">13288 import</span> Lean.Util.Trace
<span class="keyword">13289 import</span> Lean.Parser.Syntax
<span class="keyword">13290 import</span> Lean.Parser.Extension
<span class="keyword">13291 import</span> Lean.KeyedDeclsAttribute
<span class="keyword">13292 import</span> Lean.Elab.Exception
13293 
<span class="keyword">13294 namespace</span> Lean
13295 
<span class="keyword">13296 def</span> <span class="function-name">Syntax.prettyPrint</span> (stx : Syntax) : Format <span class="constant">:=</span>
13297   <span class="keyword">match</span> stx.unsetTrailing.reprint <span class="keyword">with</span> <span class="comment-delimiter">-- </span><span class="comment">TODO use syntax pretty printer
</span>13298   | some str <span class="constant">=&gt;</span> format str.toFormat
13299   | none     <span class="constant">=&gt;</span> format stx
13300 
<span class="keyword">13301 def</span> <span class="function-name">MacroScopesView.format</span> (view : MacroScopesView) (mainModule : Name) : Format <span class="constant">:=</span>
13302   fmt <span class="constant">$</span>
13303     <span class="keyword">if</span> view.scopes.isEmpty <span class="keyword">then</span>
13304       view.name
13305     <span class="keyword">else</span> <span class="keyword">if</span> view.mainModule <span class="constant">==</span> mainModule <span class="keyword">then</span>
13306       view.scopes.foldl Name.mkNum (view.name <span class="constant">++</span> view.imported)
13307     <span class="keyword">else</span>
13308       view.scopes.foldl Name.mkNum (view.name <span class="constant">++</span> view.imported <span class="constant">++</span> view.mainModule)
13309 
<span class="keyword">13310 namespace</span> Elab
13311 
<span class="keyword">13312 def</span> <span class="function-name">expandOptNamedPrio</span> (stx : Syntax) : MacroM Nat <span class="constant">:=</span>
13313   <span class="keyword">if</span> stx.isNone <span class="keyword">then</span>
13314     <span class="keyword">return</span> eval_prio default
13315   <span class="keyword">else</span> <span class="keyword">match</span> stx[<span class="constant">0</span>] <span class="keyword">with</span>
13316     | `(Parser.Command.namedPrio| (priority <span class="constant">:=</span> <span class="constant">$</span>prio)) <span class="constant">=&gt;</span> evalPrio prio
13317     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> Macro.throwUnsupported
13318 
<span class="keyword">13319 def</span> <span class="function-name">expandOptNamedName</span> (stx : Syntax) : MacroM (Option Name) <span class="constant">:=</span> <span class="keyword">do</span>
13320   <span class="keyword">if</span> stx.isNone <span class="keyword">then</span>
13321     <span class="keyword">return</span> none
13322   <span class="keyword">else</span> <span class="keyword">match</span> stx[<span class="constant">0</span>] <span class="keyword">with</span>
13323     | `(Parser.Command.namedName| (name <span class="constant">:=</span> <span class="constant">$</span>name)) <span class="constant">=&gt;</span> <span class="keyword">return</span> name.getId
13324     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> Macro.throwUnsupported
13325 
<span class="keyword">13326 structure</span> <span class="function-name">MacroStackElem</span> <span class="keyword">where</span>
13327   before : Syntax
13328   after : Syntax
13329 
<span class="keyword">13330 abbrev</span> MacroStack <span class="constant">:=</span> List MacroStackElem
13331 
<span class="comment-delimiter">13332 /- </span><span class="comment">If `ref` does not have position information, then try to use macroStack -/</span>
<span class="keyword">13333 def</span> <span class="function-name">getBetterRef</span> (ref : Syntax) (macroStack : MacroStack) : Syntax <span class="constant">:=</span>
13334   <span class="keyword">match</span> ref.getPos? <span class="keyword">with</span>
13335   | some <span class="preprocessor">_</span> <span class="constant">=&gt;</span> ref
13336   | none   <span class="constant">=&gt;</span>
13337     <span class="keyword">match</span> macroStack.find? (&#183;.before.getPos? <span class="constant">!=</span> none) <span class="keyword">with</span>
13338     | some elem <span class="constant">=&gt;</span> elem.before
13339     | none      <span class="constant">=&gt;</span> ref
13340 
<span class="keyword">13341 register_builtin_option</span> pp.macroStack : Bool <span class="constant">:=</span> {
13342   defValue <span class="constant">:=</span> false
13343   group    <span class="constant">:=</span> <span class="string">"pp"</span>
13344   descr    <span class="constant">:=</span> <span class="string">"dispaly macro expansion stack"</span>
13345 }
13346 
<span class="keyword">13347 def</span> <span class="function-name">addMacroStack</span> {m} [Monad m] [MonadOptions m] (msgData : MessageData) (macroStack : MacroStack) : m MessageData <span class="constant">:=</span> <span class="keyword">do</span>
13348   <span class="keyword">if</span> <span class="constant">!</span>pp.macroStack.get (&#8592; getOptions) <span class="keyword">then</span> pure msgData <span class="keyword">else</span>
13349   <span class="keyword">match</span> macroStack <span class="keyword">with</span>
13350   | []             <span class="constant">=&gt;</span> pure msgData
13351   | stack<span class="constant">@</span>(top::<span class="preprocessor">_</span>) <span class="constant">=&gt;</span>
13352     <span class="keyword">let</span> msgData <span class="constant">:=</span> msgData <span class="constant">++</span> Format.line <span class="constant">++</span> <span class="string">"with resulting expansion"</span> <span class="constant">++</span> indentD top.after
13353     pure <span class="constant">$</span> stack.foldl
13354       (<span class="keyword">fun</span> (msgData : MessageData) (elem : MacroStackElem) <span class="constant">=&gt;</span>
13355         msgData <span class="constant">++</span> Format.line <span class="constant">++</span> <span class="string">"while expanding"</span> <span class="constant">++</span> indentD elem.before)
13356       msgData
13357 
<span class="keyword">13358 def</span> <span class="function-name">checkSyntaxNodeKind</span> (k : Name) : AttrM Name <span class="constant">:=</span> <span class="keyword">do</span>
13359   <span class="keyword">if</span> Parser.isValidSyntaxNodeKind (&#8592; getEnv) k <span class="keyword">then</span> pure k
13360   <span class="keyword">else</span> throwError <span class="string">"failed"</span>
13361 
<span class="keyword">13362 def</span> <span class="function-name">checkSyntaxNodeKindAtNamespacesAux</span> (k : Name) : Name <span class="constant">&#8594;</span> AttrM Name
13363   | n<span class="constant">@</span>(Name.str p <span class="preprocessor">_</span> <span class="preprocessor">_</span>) <span class="constant">=&gt;</span> checkSyntaxNodeKind (n <span class="constant">++</span> k) <span class="constant">&lt;</span>|<span class="constant">&gt;</span> checkSyntaxNodeKindAtNamespacesAux k p
13364   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwError <span class="string">"failed"</span>
13365 
<span class="keyword">13366 def</span> <span class="function-name">checkSyntaxNodeKindAtNamespaces</span> (k : Name) : AttrM Name <span class="constant">:=</span> <span class="keyword">do</span>
13367   <span class="keyword">let</span> ctx &#8592; read
13368   checkSyntaxNodeKindAtNamespacesAux k ctx.currNamespace
13369 
<span class="keyword">13370 def</span> <span class="function-name">syntaxNodeKindOfAttrParam</span> (defaultParserNamespace : Name) (stx : Syntax) : AttrM SyntaxNodeKind <span class="constant">:=</span> <span class="keyword">do</span>
13371   <span class="keyword">let</span> k &#8592; Attribute.Builtin.getId stx
13372   checkSyntaxNodeKind k
13373   <span class="constant">&lt;</span>|<span class="constant">&gt;</span>
13374   checkSyntaxNodeKindAtNamespaces k
13375   <span class="constant">&lt;</span>|<span class="constant">&gt;</span>
13376   checkSyntaxNodeKind (defaultParserNamespace <span class="constant">++</span> k)
13377   <span class="constant">&lt;</span>|<span class="constant">&gt;</span>
13378   throwError <span class="string">"invalid syntax node kind '{k}'"</span>
13379 
<span class="keyword">13380 private</span> <span class="keyword">unsafe</span> <span class="keyword">def</span> <span class="function-name">evalSyntaxConstantUnsafe</span> (env : Environment) (opts : Options) (constName : Name) : ExceptT String Id Syntax <span class="constant">:=</span>
13381   env.evalConstCheck Syntax opts `Lean.Syntax constName
13382 
<span class="doc">13383 @[implementedBy evalSyntaxConstantUnsafe]</span>
<span class="keyword">13384 constant</span> <span class="function-name">evalSyntaxConstant</span> (env : Environment) (opts : Options) (constName : Name) : ExceptT String Id Syntax <span class="constant">:=</span> throw <span class="string">""</span>
13385 
<span class="keyword">13386 unsafe</span> <span class="keyword">def</span> <span class="function-name">mkElabAttribute</span> (&#947;) (attrDeclName attrBuiltinName attrName : Name) (parserNamespace : Name) (typeName : Name) (kind : String)
13387     : IO (KeyedDeclsAttribute &#947;) <span class="constant">:=</span>
13388   KeyedDeclsAttribute.init {
13389     builtinName   <span class="constant">:=</span> attrBuiltinName
13390     name          <span class="constant">:=</span> attrName
13391     descr         <span class="constant">:=</span> kind <span class="constant">++</span> <span class="string">" elaborator"</span>
13392     valueTypeName <span class="constant">:=</span> typeName
13393     evalKey       <span class="constant">:=</span> <span class="keyword">fun</span> <span class="preprocessor">_</span> stx <span class="constant">=&gt;</span> syntaxNodeKindOfAttrParam parserNamespace stx
13394   } attrDeclName
13395 
<span class="keyword">13396 unsafe</span> <span class="keyword">def</span> <span class="function-name">mkMacroAttributeUnsafe</span> : IO (KeyedDeclsAttribute Macro) <span class="constant">:=</span>
13397   mkElabAttribute Macro `Lean.Elab.macroAttribute `builtinMacro `<span class="keyword">macro</span> Name.anonymous `Lean.Macro <span class="string">"macro"</span>
13398 
<span class="doc">13399 @[implementedBy mkMacroAttributeUnsafe]</span>
<span class="keyword">13400 constant</span> <span class="function-name">mkMacroAttribute</span> : IO (KeyedDeclsAttribute Macro)
13401 
<span class="keyword">13402 builtin_initialize</span> macroAttribute : KeyedDeclsAttribute Macro &#8592; mkMacroAttribute
13403 
<span class="keyword">13404 private</span> <span class="keyword">def</span> <span class="function-name">expandMacroFns</span> (stx : Syntax) : List Macro <span class="constant">&#8594;</span> MacroM Syntax
13405   | []    <span class="constant">=&gt;</span> throw Macro.Exception.unsupportedSyntax
13406   | m::ms <span class="constant">=&gt;</span> <span class="keyword">do</span>
13407     <span class="keyword">try</span>
13408       m stx
13409     <span class="keyword">catch</span>
13410       | Macro.Exception.unsupportedSyntax <span class="constant">=&gt;</span> expandMacroFns stx ms
13411       | ex                                <span class="constant">=&gt;</span> throw ex
13412 
<span class="keyword">13413 def</span> <span class="function-name">getMacros</span> (env : Environment) : Macro <span class="constant">:=</span> <span class="keyword">fun</span> stx <span class="constant">=&gt;</span>
13414   <span class="keyword">let</span> k <span class="constant">:=</span> stx.getKind
13415   <span class="keyword">let</span> table <span class="constant">:=</span> (macroAttribute.ext.getState env).table
13416   <span class="keyword">match</span> table.find? k <span class="keyword">with</span>
13417   | some macroFns <span class="constant">=&gt;</span> expandMacroFns stx macroFns
13418   | none          <span class="constant">=&gt;</span> throw Macro.Exception.unsupportedSyntax
13419 
<span class="keyword">13420 class</span> <span class="function-name">MonadMacroAdapter</span> (m : <span class="type">Type</span> <span class="constant">&#8594;</span> <span class="type">Type</span>) <span class="keyword">where</span>
13421   getCurrMacroScope                  : m MacroScope
13422   getNextMacroScope                  : m MacroScope
13423   setNextMacroScope                  : MacroScope <span class="constant">&#8594;</span> m Unit
13424 
<span class="keyword">13425 instance</span> (m n) [MonadLift m n] [MonadMacroAdapter m] : MonadMacroAdapter n <span class="constant">:=</span> {
13426   getCurrMacroScope <span class="constant">:=</span> liftM (MonadMacroAdapter.getCurrMacroScope : m <span class="preprocessor">_</span>),
13427   getNextMacroScope <span class="constant">:=</span> liftM (MonadMacroAdapter.getNextMacroScope : m <span class="preprocessor">_</span>),
13428   setNextMacroScope <span class="constant">:=</span> <span class="keyword">fun</span> s <span class="constant">=&gt;</span> liftM (MonadMacroAdapter.setNextMacroScope s : m <span class="preprocessor">_</span>)
13429 }
13430 
<span class="keyword">13431 private</span> <span class="keyword">def</span> <span class="function-name">expandMacro?</span> (env : Environment) (stx : Syntax) : MacroM (Option Syntax) <span class="constant">:=</span> <span class="keyword">do</span>
13432   <span class="keyword">try</span>
13433     <span class="keyword">let</span> newStx &#8592; getMacros env stx
13434     pure (some newStx)
13435   <span class="keyword">catch</span>
13436     | Macro.Exception.unsupportedSyntax <span class="constant">=&gt;</span> pure none
13437     | ex                                <span class="constant">=&gt;</span> throw ex
13438 
<span class="doc">13439 @[inline]</span> <span class="keyword">def</span> <span class="function-name">liftMacroM</span> {&#945;} {m : <span class="type">Type</span> <span class="constant">&#8594;</span> <span class="type">Type</span>} [Monad m] [MonadMacroAdapter m] [MonadEnv m] [MonadRecDepth m] [MonadError m] (x : MacroM &#945;) : m &#945; <span class="constant">:=</span> <span class="keyword">do</span>
13440   <span class="keyword">let</span> env  &#8592; getEnv
13441   <span class="keyword">match</span> x { macroEnv       <span class="constant">:=</span> Macro.mkMacroEnv (expandMacro? env),
13442             ref            <span class="constant">:=</span> &#8592; getRef,
13443             currMacroScope <span class="constant">:=</span> &#8592; MonadMacroAdapter.getCurrMacroScope,
13444             mainModule     <span class="constant">:=</span> env.mainModule,
13445             currRecDepth   <span class="constant">:=</span> &#8592; MonadRecDepth.getRecDepth,
13446             maxRecDepth    <span class="constant">:=</span> &#8592; MonadRecDepth.getMaxRecDepth } (&#8592; MonadMacroAdapter.getNextMacroScope) <span class="keyword">with</span>
13447   | EStateM.Result.error Macro.Exception.unsupportedSyntax <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwUnsupportedSyntax
13448   | EStateM.Result.error (Macro.Exception.error ref msg) <span class="preprocessor">_</span>   <span class="constant">=&gt;</span> throwErrorAt ref msg
13449   | EStateM.Result.ok a nextMacroScope                       <span class="constant">=&gt;</span> MonadMacroAdapter.setNextMacroScope nextMacroScope; pure a
13450 
<span class="doc">13451 @[inline]</span> <span class="keyword">def</span> <span class="function-name">adaptMacro</span> {m : <span class="type">Type</span> <span class="constant">&#8594;</span> <span class="type">Type</span>} [Monad m] [MonadMacroAdapter m] [MonadEnv m] [MonadRecDepth m] [MonadError m] (x : Macro) (stx : Syntax) : m Syntax <span class="constant">:=</span>
13452   liftMacroM (x stx)
13453 
<span class="keyword">13454 partial</span> <span class="keyword">def</span> <span class="function-name">mkUnusedBaseName</span> [Monad m] [MonadEnv m] [MonadResolveName m] (baseName : Name) : m Name <span class="constant">:=</span> <span class="keyword">do</span>
13455   <span class="keyword">let</span> currNamespace &#8592; getCurrNamespace
13456   <span class="keyword">let</span> env &#8592; getEnv
13457   <span class="keyword">if</span> env.contains (currNamespace <span class="constant">++</span> baseName) <span class="keyword">then</span>
13458     <span class="keyword">let</span> <span class="keyword">rec</span> loop (idx : Nat) <span class="constant">:=</span>
13459        <span class="keyword">let</span> name <span class="constant">:=</span> baseName.appendIndexAfter idx
13460        <span class="keyword">if</span> env.contains (currNamespace <span class="constant">++</span> name) <span class="keyword">then</span>
13461          loop (idx<span class="constant">+1</span>)
13462        <span class="keyword">else</span>
13463          name
13464     <span class="keyword">return</span> loop <span class="constant">1</span>
13465   <span class="keyword">else</span>
13466     <span class="keyword">return</span> baseName
13467 
<span class="keyword">13468 builtin_initialize</span>
13469   registerTraceClass `Elab
13470   registerTraceClass `Elab.step
13471 
<span class="keyword">13472 end</span> Lean.Elab
13473 ::::::::::::::
13474 Parser.lean
13475 ::::::::::::::
<span class="comment-delimiter">13476 /-</span><span class="comment">
13477 Copyright (c) 2019 Microsoft Corporation. All rights reserved.
13478 Released under Apache 2.0 license as described in the file LICENSE.
13479 Authors: Leonardo de Moura, Sebastian Ullrich
13480 -/</span>
<span class="keyword">13481 import</span> Lean.Parser.Basic
<span class="keyword">13482 import</span> Lean.Parser.Level
<span class="keyword">13483 import</span> Lean.Parser.Term
<span class="keyword">13484 import</span> Lean.Parser.Tactic
<span class="keyword">13485 import</span> Lean.Parser.Command
<span class="keyword">13486 import</span> Lean.Parser.Module
<span class="keyword">13487 import</span> Lean.Parser.Syntax
<span class="keyword">13488 import</span> Lean.Parser.Do
13489 
<span class="keyword">13490 namespace</span> Lean
<span class="keyword">13491 namespace</span> Parser
13492 
<span class="keyword">13493 builtin_initialize</span>
13494   registerAlias <span class="string">"ws"</span> checkWsBefore
13495   registerAlias <span class="string">"noWs"</span> checkNoWsBefore
13496   registerAlias <span class="string">"linebreak"</span> checkLinebreakBefore
13497   registerAlias <span class="string">"num"</span> numLit
13498   registerAlias <span class="string">"str"</span> strLit
13499   registerAlias <span class="string">"char"</span> charLit
13500   registerAlias <span class="string">"name"</span> nameLit
13501   registerAlias <span class="string">"ident"</span> ident
13502   registerAlias <span class="string">"colGt"</span> checkColGt
13503   registerAlias <span class="string">"colGe"</span> checkColGe
13504   registerAlias <span class="string">"lookahead"</span> lookahead
13505   registerAlias <span class="string">"atomic"</span> atomic
13506   registerAlias <span class="string">"many"</span> many
13507   registerAlias <span class="string">"many1"</span> many1
13508   registerAlias <span class="string">"notFollowedBy"</span> (notFollowedBy &#183; <span class="string">"element"</span>)
13509   registerAlias <span class="string">"optional"</span> optional
13510   registerAlias <span class="string">"withPosition"</span> withPosition
13511   registerAlias <span class="string">"interpolatedStr"</span> interpolatedStr
13512   registerAlias <span class="string">"orelse"</span> orelse
13513   registerAlias <span class="string">"andthen"</span> andthen
13514 
<span class="keyword">13515 end</span> Parser
13516 
<span class="keyword">13517 namespace</span> PrettyPrinter
<span class="keyword">13518 namespace</span> Parenthesizer
13519 
<span class="comment-delimiter">13520 -- </span><span class="comment">Close the mutual recursion loop; see corresponding `[extern]` in the parenthesizer.
</span><span class="doc">13521 @[export lean_mk_antiquot_parenthesizer]</span>
<span class="keyword">13522 def</span> <span class="function-name">mkAntiquot.parenthesizer</span> (name : String) (kind : Option SyntaxNodeKind) (anonymous <span class="constant">:=</span> true) : Parenthesizer <span class="constant">:=</span>
13523   Parser.mkAntiquot.parenthesizer name kind anonymous
13524 
<span class="comment-delimiter">13525 -- </span><span class="comment">The parenthesizer auto-generated these instances correctly, but tagged them with the wrong kind, since the actual kind
</span><span class="comment-delimiter">13526 -- </span><span class="comment">(e.g. `ident`) is not equal to the parser name `Lean.Parser.Term.ident`.
</span><span class="doc">13527 @[builtinParenthesizer ident]</span> <span class="keyword">def</span> <span class="function-name">ident.parenthesizer</span> : Parenthesizer <span class="constant">:=</span> Parser.Term.ident.parenthesizer
<span class="doc">13528 @[builtinParenthesizer numLit]</span> <span class="keyword">def</span> <span class="function-name">numLit.parenthesizer</span> : Parenthesizer <span class="constant">:=</span> Parser.Term.num.parenthesizer
<span class="doc">13529 @[builtinParenthesizer scientificLit]</span> <span class="keyword">def</span> <span class="function-name">scientificLit.parenthesizer</span> : Parenthesizer <span class="constant">:=</span> Parser.Term.scientific.parenthesizer
<span class="doc">13530 @[builtinParenthesizer charLit]</span> <span class="keyword">def</span> <span class="function-name">charLit.parenthesizer</span> : Parenthesizer <span class="constant">:=</span> Parser.Term.char.parenthesizer
<span class="doc">13531 @[builtinParenthesizer strLit]</span> <span class="keyword">def</span> <span class="function-name">strLit.parenthesizer</span> : Parenthesizer <span class="constant">:=</span> Parser.Term.str.parenthesizer
13532 
<span class="keyword">13533 open</span> Lean.Parser
13534 
<span class="doc">13535 @[export lean_pretty_printer_parenthesizer_interpret_parser_descr]</span>
<span class="keyword">13536 unsafe</span> <span class="keyword">def</span> <span class="function-name">interpretParserDescr</span> : ParserDescr <span class="constant">&#8594;</span> CoreM Parenthesizer
13537   | ParserDescr.const n                             <span class="constant">=&gt;</span> getConstAlias parenthesizerAliasesRef n
13538   | ParserDescr.unary n d                           <span class="constant">=&gt;</span> <span class="keyword">return</span> (&#8592; getUnaryAlias parenthesizerAliasesRef n) (&#8592; interpretParserDescr d)
13539   | ParserDescr.binary n d&#8321; d&#8322;                      <span class="constant">=&gt;</span> <span class="keyword">return</span> (&#8592; getBinaryAlias parenthesizerAliasesRef n) (&#8592; interpretParserDescr d&#8321;) (&#8592; interpretParserDescr d&#8322;)
13540   | ParserDescr.node k prec d                       <span class="constant">=&gt;</span> <span class="keyword">return</span> leadingNode.parenthesizer k prec (&#8592; interpretParserDescr d)
13541   | ParserDescr.nodeWithAntiquot <span class="preprocessor">_</span> k d              <span class="constant">=&gt;</span> <span class="keyword">return</span> node.parenthesizer k (&#8592; interpretParserDescr d)
13542   | ParserDescr.sepBy p sep psep trail              <span class="constant">=&gt;</span> <span class="keyword">return</span> sepBy.parenthesizer (&#8592; interpretParserDescr p) sep (&#8592; interpretParserDescr psep) trail
13543   | ParserDescr.sepBy1 p sep psep trail             <span class="constant">=&gt;</span> <span class="keyword">return</span> sepBy1.parenthesizer (&#8592; interpretParserDescr p) sep (&#8592; interpretParserDescr psep) trail
13544   | ParserDescr.trailingNode k prec lhsPrec d       <span class="constant">=&gt;</span> <span class="keyword">return</span> trailingNode.parenthesizer k prec lhsPrec (&#8592; interpretParserDescr d)
13545   | ParserDescr.symbol tk                           <span class="constant">=&gt;</span> <span class="keyword">return</span> symbol.parenthesizer tk
13546   | ParserDescr.nonReservedSymbol tk includeIdent   <span class="constant">=&gt;</span> <span class="keyword">return</span> nonReservedSymbol.parenthesizer tk includeIdent
13547   | ParserDescr.parser constName                    <span class="constant">=&gt;</span> combinatorParenthesizerAttribute.runDeclFor constName
13548   | ParserDescr.cat catName prec                    <span class="constant">=&gt;</span> <span class="keyword">return</span> categoryParser.parenthesizer catName prec
13549 
<span class="keyword">13550 end</span> Parenthesizer
13551 
<span class="keyword">13552 namespace</span> Formatter
13553 
<span class="doc">13554 @[export lean_mk_antiquot_formatter]</span>
<span class="keyword">13555 def</span> <span class="function-name">mkAntiquot.formatter</span> (name : String) (kind : Option SyntaxNodeKind) (anonymous <span class="constant">:=</span> true) : Formatter <span class="constant">:=</span>
13556   Parser.mkAntiquot.formatter name kind anonymous
13557 
<span class="doc">13558 @[builtinFormatter ident]</span> <span class="keyword">def</span> <span class="function-name">ident.formatter</span> : Formatter <span class="constant">:=</span> Parser.Term.ident.formatter
<span class="doc">13559 @[builtinFormatter numLit]</span> <span class="keyword">def</span> <span class="function-name">numLit.formatter</span> : Formatter <span class="constant">:=</span> Parser.Term.num.formatter
<span class="doc">13560 @[builtinFormatter scientificLit]</span> <span class="keyword">def</span> <span class="function-name">scientificLit.formatter</span> : Formatter <span class="constant">:=</span> Parser.Term.scientific.formatter
<span class="doc">13561 @[builtinFormatter charLit]</span> <span class="keyword">def</span> <span class="function-name">charLit.formatter</span> : Formatter <span class="constant">:=</span> Parser.Term.char.formatter
<span class="doc">13562 @[builtinFormatter strLit]</span> <span class="keyword">def</span> <span class="function-name">strLit.formatter</span> : Formatter <span class="constant">:=</span> Parser.Term.str.formatter
13563 
<span class="keyword">13564 open</span> Lean.Parser
13565 
<span class="doc">13566 @[export lean_pretty_printer_formatter_interpret_parser_descr]</span>
<span class="keyword">13567 unsafe</span> <span class="keyword">def</span> <span class="function-name">interpretParserDescr</span> : ParserDescr <span class="constant">&#8594;</span> CoreM Formatter
13568   | ParserDescr.const n                             <span class="constant">=&gt;</span> getConstAlias formatterAliasesRef n
13569   | ParserDescr.unary n d                           <span class="constant">=&gt;</span> <span class="keyword">return</span> (&#8592; getUnaryAlias formatterAliasesRef n) (&#8592; interpretParserDescr d)
13570   | ParserDescr.binary n d&#8321; d&#8322;                      <span class="constant">=&gt;</span> <span class="keyword">return</span> (&#8592; getBinaryAlias formatterAliasesRef n) (&#8592; interpretParserDescr d&#8321;) (&#8592; interpretParserDescr d&#8322;)
13571   | ParserDescr.node k prec d                       <span class="constant">=&gt;</span> <span class="keyword">return</span> node.formatter k (&#8592; interpretParserDescr d)
13572   | ParserDescr.nodeWithAntiquot <span class="preprocessor">_</span> k d              <span class="constant">=&gt;</span> <span class="keyword">return</span> node.formatter k (&#8592; interpretParserDescr d)
13573   | ParserDescr.sepBy p sep psep trail              <span class="constant">=&gt;</span> <span class="keyword">return</span> sepBy.formatter (&#8592; interpretParserDescr p) sep (&#8592; interpretParserDescr psep) trail
13574   | ParserDescr.sepBy1 p sep psep trail             <span class="constant">=&gt;</span> <span class="keyword">return</span> sepBy1.formatter (&#8592; interpretParserDescr p) sep (&#8592; interpretParserDescr psep) trail
13575   | ParserDescr.trailingNode k prec lhsPrec d       <span class="constant">=&gt;</span> <span class="keyword">return</span> trailingNode.formatter k prec lhsPrec (&#8592; interpretParserDescr d)
13576   | ParserDescr.symbol tk                           <span class="constant">=&gt;</span> <span class="keyword">return</span> symbol.formatter tk
13577   | ParserDescr.nonReservedSymbol tk includeIdent   <span class="constant">=&gt;</span> <span class="keyword">return</span> nonReservedSymbol.formatter tk
13578   | ParserDescr.parser constName                    <span class="constant">=&gt;</span> combinatorFormatterAttribute.runDeclFor constName
13579   | ParserDescr.cat catName prec                    <span class="constant">=&gt;</span> <span class="keyword">return</span> categoryParser.formatter catName
13580 
<span class="keyword">13581 end</span> Formatter
<span class="keyword">13582 end</span> PrettyPrinter
<span class="keyword">13583 end</span> Lean
13584 ::::::::::::::
13585 Parser<span class="constant">/</span>Attr.lean
13586 ::::::::::::::
<span class="comment-delimiter">13587 /-</span><span class="comment">
13588 Copyright (c) 2020 Microsoft Corporation. All rights reserved.
13589 Released under Apache 2.0 license as described in the file LICENSE.
13590 Authors: Leonardo de Moura
13591 -/</span>
<span class="keyword">13592 import</span> Lean.Parser.Basic
<span class="keyword">13593 import</span> Lean.Parser.Extra
13594 
<span class="keyword">13595 namespace</span> Lean.Parser
13596 
<span class="keyword">13597 builtin_initialize</span>
13598   registerBuiltinParserAttribute `builtinPrioParser `prio LeadingIdentBehavior.both
13599   registerBuiltinDynamicParserAttribute `prioParser `prio
13600 
<span class="keyword">13601 builtin_initialize</span>
13602   registerBuiltinParserAttribute `builtinAttrParser `attr LeadingIdentBehavior.symbol
13603   registerBuiltinDynamicParserAttribute `attrParser `attr
13604 
<span class="doc">13605 @[inline]</span> <span class="keyword">def</span> <span class="function-name">priorityParser</span> (rbp : Nat <span class="constant">:=</span> <span class="constant">0</span>) : Parser <span class="constant">:=</span>
13606   categoryParser `prio rbp
13607 
<span class="doc">13608 @[inline]</span> <span class="keyword">def</span> <span class="function-name">attrParser</span> (rbp : Nat <span class="constant">:=</span> <span class="constant">0</span>) : Parser <span class="constant">:=</span>
13609   categoryParser `attr rbp
13610 
<span class="keyword">13611 attribute</span> <span class="doc">[runBuiltinParserAttributeHooks]</span>
13612   priorityParser attrParser
13613 
<span class="keyword">13614 namespace</span> Priority
<span class="doc">13615 @[builtinPrioParser]</span> <span class="keyword">def</span> <span class="function-name">numPrio</span>  <span class="constant">:=</span> checkPrec maxPrec <span class="constant">&gt;&gt;</span> numLit
<span class="keyword">13616 attribute</span> <span class="doc">[runBuiltinParserAttributeHooks] </span>numPrio
<span class="keyword">13617 end</span> Priority
13618 
<span class="keyword">13619 namespace</span> Attr
13620 
<span class="doc">13621 @[builtinAttrParser]</span> <span class="keyword">def</span> <span class="function-name">simple</span>     <span class="constant">:=</span> leading_parser ident <span class="constant">&gt;&gt;</span> optional (priorityParser <span class="constant">&lt;</span>|<span class="constant">&gt;</span> ident)
<span class="comment-delimiter">13622 /- </span><span class="comment">Remark, We can't use `simple` for `class`, `instance`, `export`, and `macro` because they are  keywords. -/</span>
<span class="doc">13623 @[builtinAttrParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>macro<span class="comment">&#187;</span>    <span class="constant">:=</span> leading_parser <span class="string">"macro "</span> <span class="constant">&gt;&gt;</span> ident
<span class="doc">13624 @[builtinAttrParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>export<span class="comment">&#187;</span>   <span class="constant">:=</span> leading_parser <span class="string">"export "</span> <span class="constant">&gt;&gt;</span> ident
13625 
<span class="comment-delimiter">13626 /- </span><span class="comment">We don't use `simple` for recursor because the argument is not a priority-/</span>
<span class="doc">13627 @[builtinAttrParser]</span> <span class="keyword">def</span> <span class="function-name">recursor</span>        <span class="constant">:=</span> leading_parser nonReservedSymbol <span class="string">"recursor "</span> <span class="constant">&gt;&gt;</span> numLit
<span class="doc">13628 @[builtinAttrParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>class<span class="comment">&#187;</span>         <span class="constant">:=</span> leading_parser <span class="string">"class"</span>
<span class="doc">13629 @[builtinAttrParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>instance<span class="comment">&#187;</span>      <span class="constant">:=</span> leading_parser <span class="string">"instance"</span> <span class="constant">&gt;&gt;</span> optional priorityParser
<span class="doc">13630 @[builtinAttrParser]</span> <span class="keyword">def</span> <span class="function-name">defaultInstance</span> <span class="constant">:=</span> leading_parser nonReservedSymbol <span class="string">"defaultInstance "</span> <span class="constant">&gt;&gt;</span> optional priorityParser
13631 
<span class="keyword">13632 def</span> <span class="function-name">externEntry</span> <span class="constant">:=</span> leading_parser optional ident <span class="constant">&gt;&gt;</span> optional (nonReservedSymbol <span class="string">"inline "</span>) <span class="constant">&gt;&gt;</span> strLit
<span class="doc">13633 @[builtinAttrParser]</span> <span class="keyword">def</span> <span class="function-name">extern</span>     <span class="constant">:=</span> leading_parser nonReservedSymbol <span class="string">"extern "</span> <span class="constant">&gt;&gt;</span> optional numLit <span class="constant">&gt;&gt;</span> many externEntry
13634 
<span class="keyword">13635 end</span> Attr
13636 
<span class="keyword">13637 end</span> Lean.Parser
13638 ::::::::::::::
13639 Parser<span class="constant">/</span>Basic.lean
13640 ::::::::::::::
<span class="comment-delimiter">13641 /-</span><span class="comment">
13642 Copyright (c) 2019 Microsoft Corporation. All rights reserved.
13643 Released under Apache 2.0 license as described in the file LICENSE.
13644 Authors: Leonardo de Moura, Sebastian Ullrich
13645 -/</span>
13646 
<span class="comment-delimiter">13647 /-</span><span class="comment">!
13648 # Basic Lean parser infrastructure
13649 
13650 The Lean parser was developed with the following primary goals in mind:
13651 
13652 * flexibility: Lean's grammar is complex and includes indentation and other whitespace sensitivity. It should be
13653   possible to introduce such custom "tweaks" locally without having to adjust the fundamental parsing approach.
13654 * extensibility: Lean's grammar can be extended on the fly within a Lean file, and with Lean 4 we want to extend this
13655   to cover embedding domain-specific languages that may look nothing like Lean, down to using a separate set of tokens.
13656 * losslessness: The parser should produce a concrete syntax tree that preserves all whitespace and other "sub-token"
13657   information for the use in tooling.
13658 * performance: The overhead of the parser building blocks, and the overall parser performance on average-complexity
13659   input, should be comparable with that of the previous parser hand-written in C++. No fancy optimizations should be
13660   necessary for this.
13661 
13662 Given these constraints, we decided to implement a combinatoric, non-monadic, lexer-less, memoizing recursive-descent
13663 parser. Using combinators instead of some more formal and introspectible grammar representation ensures ultimate
13664 flexibility as well as efficient extensibility: there is (almost) no pre-processing necessary when extending the grammar
13665 with a new parser. However, because the all results the combinators produce are of the homogeneous `Syntax` type, the
13666 basic parser type is not actually a monad but a monomorphic linear function `ParserState &#8594; ParserState`, avoiding
13667 constructing and deconstructing countless monadic return values. Instead of explicitly returning syntax objects, parsers
13668 push (zero or more of) them onto a syntax stack inside the linear state. Chaining parsers via `&gt;&gt;` accumulates their
13669 output on the stack. Combinators such as `node` then pop off all syntax objects produced during their invocation and
13670 wrap them in a single `Syntax.node` object that is again pushed on this stack. Instead of calling `node` directly, we
13671 usually use the macro `leading_parser p`, which unfolds to `node k p` where the new syntax node kind `k` is the name of the
13672 declaration being defined.
13673 
13674 The lack of a dedicated lexer ensures we can modify and replace the lexical grammar at any point, and simplifies
13675 detecting and propagating whitespace. The parser still has a concept of "tokens", however, and caches the most recent
13676 one for performance: when `tokenFn` is called twice at the same position in the input, it will reuse the result of the
13677 first call. `tokenFn` recognizes some built-in variable-length tokens such as identifiers as well as any fixed token in
13678 the `ParserContext`'s `TokenTable` (a trie); however, the same cache field and strategy could be reused by custom token
13679 parsers. Tokens also play a central role in the `prattParser` combinator, which selects a *leading* parser followed by
13680 zero or more *trailing* parsers based on the current token (via `peekToken`); see the documentation of `prattParser`
13681 for more details. Tokens are specified via the `symbol` parser, or with `symbolNoWs` for tokens that should not be preceded by whitespace.
13682 
13683 The `Parser` type is extended with additional metadata over the mere parsing function to propagate token information:
13684 `collectTokens` collects all tokens within a parser for registering. `firstTokens` holds information about the "FIRST"
13685 token set used to speed up parser selection in `prattParser`. This approach of combining static and dynamic information
13686 in the parser type is inspired by the paper "Deterministic, Error-Correcting Combinator Parsers" by Swierstra and Duponcheel.
13687 If multiple parsers accept the same current token, `prattParser` tries all of them using the backtracking `longestMatchFn` combinator.
13688 This is the only case where standard parsers might execute arbitrary backtracking. At the moment there is no memoization shared by these
13689 parallel parsers apart from the first token, though we might change this in the future if the need arises.
13690 
13691 Finally, error reporting follows the standard combinatoric approach of collecting a single unexpected token/... and zero
13692 or more expected tokens (see `Error` below). Expected tokens are e.g. set by `symbol` and merged by `&lt;|&gt;`. Combinators
13693 running multiple parsers should check if an error message is set in the parser state (`hasError`) and act accordingly.
13694 Error recovery is left to the designer of the specific language; for example, Lean's top-level `parseCommand` loop skips
13695 tokens until the next command keyword on error.
13696 -/</span>
<span class="keyword">13697 import</span> Lean.Data.Trie
<span class="keyword">13698 import</span> Lean.Data.Position
<span class="keyword">13699 import</span> Lean.Syntax
<span class="keyword">13700 import</span> Lean.ToExpr
<span class="keyword">13701 import</span> Lean.Environment
<span class="keyword">13702 import</span> Lean.Attributes
<span class="keyword">13703 import</span> Lean.Message
<span class="keyword">13704 import</span> Lean.Compiler.InitAttr
<span class="keyword">13705 import</span> Lean.ResolveName
13706 
<span class="keyword">13707 namespace</span> Lean
13708 
<span class="keyword">13709 namespace</span> Parser
13710 
<span class="keyword">13711 def</span> <span class="function-name">isLitKind</span> (k : SyntaxNodeKind) : Bool <span class="constant">:=</span>
13712   k <span class="constant">==</span> strLitKind <span class="constant">||</span> k <span class="constant">==</span> numLitKind <span class="constant">||</span> k <span class="constant">==</span> charLitKind <span class="constant">||</span> k <span class="constant">==</span> nameLitKind <span class="constant">||</span> k <span class="constant">==</span> scientificLitKind
13713 
<span class="keyword">13714 abbrev</span> mkAtom (info : SourceInfo) (val : String) : Syntax <span class="constant">:=</span>
13715   Syntax.atom info val
13716 
<span class="keyword">13717 abbrev</span> mkIdent (info : SourceInfo) (rawVal : Substring) (val : Name) : Syntax <span class="constant">:=</span>
13718   Syntax.ident info rawVal val []
13719 
<span class="comment-delimiter">13720 /- </span><span class="comment">Return character after position `pos` -/</span>
<span class="keyword">13721 def</span> <span class="function-name">getNext</span> (input : String) (pos : Nat) : Char <span class="constant">:=</span>
13722   input.get (input.next pos)
13723 
<span class="comment-delimiter">13724 /- </span><span class="comment">Maximal (and function application) precedence.
13725    In the standard lean language, no parser has precedence higher than `maxPrec`.
13726 
13727    Note that nothing prevents users from using a higher precedence, but we strongly
13728    discourage them from doing it. -/</span>
<span class="keyword">13729 def</span> <span class="function-name">maxPrec</span>  : Nat <span class="constant">:=</span> eval_prec max
<span class="keyword">13730 def</span> <span class="function-name">argPrec</span>  : Nat <span class="constant">:=</span> eval_prec arg
<span class="keyword">13731 def</span> <span class="function-name">leadPrec</span> : Nat <span class="constant">:=</span> eval_prec lead
<span class="keyword">13732 def</span> <span class="function-name">minPrec</span>  : Nat <span class="constant">:=</span> eval_prec min
13733 
<span class="keyword">13734 abbrev</span> Token <span class="constant">:=</span> String
13735 
<span class="keyword">13736 structure</span> <span class="function-name">TokenCacheEntry</span> <span class="keyword">where</span>
13737   startPos : String.Pos <span class="constant">:=</span> <span class="constant">0</span>
13738   stopPos  : String.Pos <span class="constant">:=</span> <span class="constant">0</span>
13739   token    : Syntax <span class="constant">:=</span> Syntax.missing
13740 
<span class="keyword">13741 structure</span> <span class="function-name">ParserCache</span> <span class="keyword">where</span>
13742   tokenCache : TokenCacheEntry
13743 
<span class="keyword">13744 def</span> <span class="function-name">initCacheForInput</span> (input : String) : ParserCache <span class="constant">:=</span> {
13745   tokenCache <span class="constant">:=</span> { startPos <span class="constant">:=</span> input.bsize <span class="constant">+</span> <span class="constant">1</span> <span class="comment-delimiter">/- </span><span class="comment">make sure it is not a valid position -/</span>}
13746 }
13747 
<span class="keyword">13748 abbrev</span> TokenTable <span class="constant">:=</span> Trie Token
13749 
<span class="keyword">13750 abbrev</span> SyntaxNodeKindSet <span class="constant">:=</span> Std.PersistentHashMap SyntaxNodeKind Unit
13751 
<span class="keyword">13752 def</span> <span class="function-name">SyntaxNodeKindSet.insert</span> (s : SyntaxNodeKindSet) (k : SyntaxNodeKind) : SyntaxNodeKindSet <span class="constant">:=</span>
13753   Std.PersistentHashMap.insert s k ()
13754 
<span class="comment-delimiter">13755 /-</span><span class="comment">
13756   Input string and related data. Recall that the `FileMap` is a helper structure for mapping
13757   `String.Pos` in the input string to line/column information.  -/</span>
<span class="keyword">13758 structure</span> <span class="function-name">InputContext</span> <span class="keyword">where</span>
13759   input    : String
13760   fileName : String
13761   fileMap  : FileMap
13762   <span class="keyword">deriving</span> Inhabited
13763 
<span class="comment-delimiter">13764 /-</span><span class="comment">- Input context derived from elaboration of previous commands. -/</span>
<span class="keyword">13765 structure</span> <span class="function-name">ParserModuleContext</span> <span class="keyword">where</span>
13766   env           : Environment
13767   options       : Options
13768   <span class="comment-delimiter">-- </span><span class="comment">for name lookup
</span>13769   currNamespace : Name <span class="constant">:=</span> Name.anonymous
13770   openDecls     : List OpenDecl <span class="constant">:=</span> []
13771 
<span class="keyword">13772 structure</span> <span class="function-name">ParserContext</span> <span class="keyword">extends</span> InputContext, ParserModuleContext <span class="keyword">where</span>
13773   prec               : Nat
13774   tokens             : TokenTable
13775   insideQuot         : Bool <span class="constant">:=</span> false
13776   suppressInsideQuot : Bool <span class="constant">:=</span> false
13777   savedPos?          : Option String.Pos <span class="constant">:=</span> none
13778   forbiddenTk?       : Option Token <span class="constant">:=</span> none
13779 
<span class="keyword">13780 def</span> <span class="function-name">ParserContext.resolveName</span> (ctx : ParserContext) (id : Name) : List (Name <span class="constant">&#215;</span> List String) <span class="constant">:=</span>
13781   ResolveName.resolveGlobalName ctx.env ctx.currNamespace ctx.openDecls id
13782 
<span class="keyword">13783 structure</span> <span class="function-name">Error</span> <span class="keyword">where</span>
13784   unexpected : String <span class="constant">:=</span> <span class="string">""</span>
13785   expected : List String <span class="constant">:=</span> []
13786   <span class="keyword">deriving</span> Inhabited, BEq
13787 
<span class="keyword">13788 namespace</span> Error
13789 
<span class="keyword">13790 private</span> <span class="keyword">def</span> <span class="function-name">expectedToString</span> : List String <span class="constant">&#8594;</span> String
13791   | []       <span class="constant">=&gt;</span> <span class="string">""</span>
13792   | [e]      <span class="constant">=&gt;</span> e
13793   | [e1, e2] <span class="constant">=&gt;</span> e1 <span class="constant">++</span> <span class="string">" or "</span> <span class="constant">++</span> e2
13794   | e::es    <span class="constant">=&gt;</span> e <span class="constant">++</span> <span class="string">", "</span> <span class="constant">++</span> expectedToString es
13795 
<span class="keyword">13796 protected</span> <span class="keyword">def</span> <span class="function-name">toString</span> (e : Error) : String <span class="constant">:=</span>
13797   <span class="keyword">let</span> unexpected <span class="constant">:=</span> <span class="keyword">if</span> e.unexpected <span class="constant">==</span> <span class="string">""</span> <span class="keyword">then</span> [] <span class="keyword">else</span> [e.unexpected]
13798   <span class="keyword">let</span> expected   <span class="constant">:=</span> <span class="keyword">if</span> e.expected <span class="constant">==</span> [] <span class="keyword">then</span> [] <span class="keyword">else</span>
13799     <span class="keyword">let</span> expected <span class="constant">:=</span> e.expected.toArray.qsort (<span class="keyword">fun</span> e e' <span class="constant">=&gt;</span> e <span class="constant">&lt;</span> e')
13800     <span class="keyword">let</span> expected <span class="constant">:=</span> expected.toList.eraseReps
13801     [<span class="string">"expected "</span> <span class="constant">++</span> expectedToString expected]
13802   <span class="string">"; "</span>.intercalate <span class="constant">$</span> unexpected <span class="constant">++</span> expected
13803 
<span class="keyword">13804 instance</span> <span class="function-name">:</span> ToString Error <span class="constant">:=</span> &#10216;Error.toString&#10217;
13805 
<span class="keyword">13806 def</span> <span class="function-name">merge</span> (e&#8321; e&#8322; : Error) : Error <span class="constant">:=</span>
13807   <span class="keyword">match</span> e&#8322; <span class="keyword">with</span>
13808   | { unexpected <span class="constant">:=</span> u, .. } <span class="constant">=&gt;</span> { unexpected <span class="constant">:=</span> <span class="keyword">if</span> u <span class="constant">==</span> <span class="string">""</span> <span class="keyword">then</span> e&#8321;.unexpected <span class="keyword">else</span> u, expected <span class="constant">:=</span> e&#8321;.expected <span class="constant">++</span> e&#8322;.expected }
13809 
<span class="keyword">13810 end</span> Error
13811 
<span class="keyword">13812 structure</span> <span class="function-name">ParserState</span> <span class="keyword">where</span>
13813   stxStack : Array Syntax <span class="constant">:=</span> <span class="constant">#</span>[]
13814   <span class="comment-delimiter">/-</span><span class="comment">-
13815     Set to the precedence of the preceding (not surrounding) parser by `runLongestMatchParser`
13816     for the use of `checkLhsPrec` in trailing parsers.
13817     Note that with chaining, the preceding parser can be another trailing parser:
13818     in `1 * 2 + 3`, the preceding parser is '*' when '+' is executed. -/</span>
13819   lhsPrec  : Nat <span class="constant">:=</span> <span class="constant">0</span>
13820   pos      : String.Pos <span class="constant">:=</span> <span class="constant">0</span>
13821   cache    : ParserCache
13822   errorMsg : Option Error <span class="constant">:=</span> none
13823 
<span class="keyword">13824 namespace</span> ParserState
13825 
<span class="doc">13826 @[inline]</span> <span class="keyword">def</span> <span class="function-name">hasError</span> (s : ParserState) : Bool <span class="constant">:=</span>
13827   s.errorMsg <span class="constant">!=</span> none
13828 
<span class="doc">13829 @[inline]</span> <span class="keyword">def</span> <span class="function-name">stackSize</span> (s : ParserState) : Nat <span class="constant">:=</span>
13830   s.stxStack.size
13831 
<span class="keyword">13832 def</span> <span class="function-name">restore</span> (s : ParserState) (iniStackSz : Nat) (iniPos : Nat) : ParserState <span class="constant">:=</span>
13833   { s <span class="keyword">with</span> stxStack <span class="constant">:=</span> s.stxStack.shrink iniStackSz, errorMsg <span class="constant">:=</span> none, pos <span class="constant">:=</span> iniPos }
13834 
<span class="keyword">13835 def</span> <span class="function-name">setPos</span> (s : ParserState) (pos : Nat) : ParserState <span class="constant">:=</span>
13836   { s <span class="keyword">with</span> pos <span class="constant">:=</span> pos }
13837 
<span class="keyword">13838 def</span> <span class="function-name">setCache</span> (s : ParserState) (cache : ParserCache) : ParserState <span class="constant">:=</span>
13839   { s <span class="keyword">with</span> cache <span class="constant">:=</span> cache }
13840 
<span class="keyword">13841 def</span> <span class="function-name">pushSyntax</span> (s : ParserState) (n : Syntax) : ParserState <span class="constant">:=</span>
13842   { s <span class="keyword">with</span> stxStack <span class="constant">:=</span> s.stxStack.push n }
13843 
<span class="keyword">13844 def</span> <span class="function-name">popSyntax</span> (s : ParserState) : ParserState <span class="constant">:=</span>
13845   { s <span class="keyword">with</span> stxStack <span class="constant">:=</span> s.stxStack.pop }
13846 
<span class="keyword">13847 def</span> <span class="function-name">shrinkStack</span> (s : ParserState) (iniStackSz : Nat) : ParserState <span class="constant">:=</span>
13848   { s <span class="keyword">with</span> stxStack <span class="constant">:=</span> s.stxStack.shrink iniStackSz }
13849 
<span class="keyword">13850 def</span> <span class="function-name">next</span> (s : ParserState) (input : String) (pos : Nat) : ParserState <span class="constant">:=</span>
13851   { s <span class="keyword">with</span> pos <span class="constant">:=</span> input.next pos }
13852 
<span class="keyword">13853 def</span> <span class="function-name">toErrorMsg</span> (ctx : ParserContext) (s : ParserState) : String <span class="constant">:=</span>
13854   <span class="keyword">match</span> s.errorMsg <span class="keyword">with</span>
13855   | none     <span class="constant">=&gt;</span> <span class="string">""</span>
13856   | some msg <span class="constant">=&gt;</span>
13857     <span class="keyword">let</span> pos <span class="constant">:=</span> ctx.fileMap.toPosition s.pos
13858     mkErrorStringWithPos ctx.fileName pos (toString msg)
13859 
<span class="keyword">13860 def</span> <span class="function-name">mkNode</span> (s : ParserState) (k : SyntaxNodeKind) (iniStackSz : Nat) : ParserState <span class="constant">:=</span>
13861   <span class="keyword">match</span> s <span class="keyword">with</span>
13862   | &#10216;stack, lhsPrec, pos, cache, err&#10217; <span class="constant">=&gt;</span>
13863     <span class="keyword">if</span> err <span class="constant">!=</span> none <span class="constant">&amp;&amp;</span> stack.size <span class="constant">==</span> iniStackSz <span class="keyword">then</span>
13864       <span class="comment-delimiter">-- </span><span class="comment">If there is an error but there are no new nodes on the stack, use `missing` instead.
</span>13865       <span class="comment-delimiter">-- </span><span class="comment">Thus we ensure the property that an syntax tree contains (at least) one `missing` node
</span>13866       <span class="comment-delimiter">-- </span><span class="comment">if (and only if) there was a parse error.
</span>13867       <span class="comment-delimiter">-- </span><span class="comment">We should not create an actual node of kind `k` in this case because it would mean we
</span>13868       <span class="comment-delimiter">-- </span><span class="comment">choose an "arbitrary" node (in practice the last one) in an alternative of the form
</span>13869       <span class="comment-delimiter">-- </span><span class="comment">`node k1 p1 &lt;|&gt; ... &lt;|&gt; node kn pn` when all parsers fail. With the code below we
</span>13870       <span class="comment-delimiter">-- </span><span class="comment">instead return a less misleading single `missing` node without randomly selecting any `ki`.
</span>13871       <span class="keyword">let</span> stack   <span class="constant">:=</span> stack.push Syntax.missing
13872       &#10216;stack, lhsPrec, pos, cache, err&#10217;
13873     <span class="keyword">else</span>
13874       <span class="keyword">let</span> newNode <span class="constant">:=</span> Syntax.node k (stack.extract iniStackSz stack.size)
13875       <span class="keyword">let</span> stack   <span class="constant">:=</span> stack.shrink iniStackSz
13876       <span class="keyword">let</span> stack   <span class="constant">:=</span> stack.push newNode
13877       &#10216;stack, lhsPrec, pos, cache, err&#10217;
13878 
<span class="keyword">13879 def</span> <span class="function-name">mkTrailingNode</span> (s : ParserState) (k : SyntaxNodeKind) (iniStackSz : Nat) : ParserState <span class="constant">:=</span>
13880   <span class="keyword">match</span> s <span class="keyword">with</span>
13881   | &#10216;stack, lhsPrec, pos, cache, err&#10217; <span class="constant">=&gt;</span>
13882     <span class="keyword">let</span> newNode <span class="constant">:=</span> Syntax.node k (stack.extract (iniStackSz <span class="constant">-</span> <span class="constant">1</span>) stack.size)
13883     <span class="keyword">let</span> stack   <span class="constant">:=</span> stack.shrink (iniStackSz <span class="constant">-</span> <span class="constant">1</span>)
13884     <span class="keyword">let</span> stack   <span class="constant">:=</span> stack.push newNode
13885     &#10216;stack, lhsPrec, pos, cache, err&#10217;
13886 
<span class="keyword">13887 def</span> <span class="function-name">mkError</span> (s : ParserState) (msg : String) : ParserState <span class="constant">:=</span>
13888   <span class="keyword">match</span> s <span class="keyword">with</span>
13889   | &#10216;stack, lhsPrec, pos, cache, <span class="preprocessor">_</span>&#10217; <span class="constant">=&gt;</span> &#10216;stack.push Syntax.missing, lhsPrec, pos, cache, some { expected <span class="constant">:=</span> [ msg ] }&#10217;
13890 
<span class="keyword">13891 def</span> <span class="function-name">mkUnexpectedError</span> (s : ParserState) (msg : String) (expected : List String <span class="constant">:=</span> []) : ParserState <span class="constant">:=</span>
13892   <span class="keyword">match</span> s <span class="keyword">with</span>
13893   | &#10216;stack, lhsPrec, pos, cache, <span class="preprocessor">_</span>&#10217; <span class="constant">=&gt;</span> &#10216;stack.push Syntax.missing, lhsPrec, pos, cache, some { unexpected <span class="constant">:=</span> msg, expected <span class="constant">:=</span> expected }&#10217;
13894 
<span class="keyword">13895 def</span> <span class="function-name">mkEOIError</span> (s : ParserState) (expected : List String <span class="constant">:=</span> []) : ParserState <span class="constant">:=</span>
13896   s.mkUnexpectedError <span class="string">"unexpected end of input"</span> expected
13897 
<span class="keyword">13898 def</span> <span class="function-name">mkErrorAt</span> (s : ParserState) (msg : String) (pos : String.Pos) (initStackSz? : Option Nat <span class="constant">:=</span> none) : ParserState <span class="constant">:=</span>
13899   <span class="keyword">match</span> s,  initStackSz? <span class="keyword">with</span>
13900   | &#10216;stack, lhsPrec, <span class="preprocessor">_</span>, cache, <span class="preprocessor">_</span>&#10217;, none    <span class="constant">=&gt;</span> &#10216;stack.push Syntax.missing, lhsPrec, pos, cache, some { expected <span class="constant">:=</span> [ msg ] }&#10217;
13901   | &#10216;stack, lhsPrec, <span class="preprocessor">_</span>, cache, <span class="preprocessor">_</span>&#10217;, some sz <span class="constant">=&gt;</span> &#10216;stack.shrink sz |<span class="constant">&gt;</span>.push Syntax.missing, lhsPrec, pos, cache, some { expected <span class="constant">:=</span> [ msg ] }&#10217;
13902 
<span class="keyword">13903 def</span> <span class="function-name">mkErrorsAt</span> (s : ParserState) (ex : List String) (pos : String.Pos) (initStackSz? : Option Nat <span class="constant">:=</span> none) : ParserState <span class="constant">:=</span>
13904   <span class="keyword">match</span> s, initStackSz? <span class="keyword">with</span>
13905   | &#10216;stack, lhsPrec, <span class="preprocessor">_</span>, cache, <span class="preprocessor">_</span>&#10217;, none    <span class="constant">=&gt;</span> &#10216;stack.push Syntax.missing, lhsPrec, pos, cache, some { expected <span class="constant">:=</span> ex }&#10217;
13906   | &#10216;stack, lhsPrec, <span class="preprocessor">_</span>, cache, <span class="preprocessor">_</span>&#10217;, some sz <span class="constant">=&gt;</span> &#10216;stack.shrink sz |<span class="constant">&gt;</span>.push Syntax.missing, lhsPrec, pos, cache, some { expected <span class="constant">:=</span> ex }&#10217;
13907 
<span class="keyword">13908 def</span> <span class="function-name">mkUnexpectedErrorAt</span> (s : ParserState) (msg : String) (pos : String.Pos) : ParserState <span class="constant">:=</span>
13909   <span class="keyword">match</span> s <span class="keyword">with</span>
13910   | &#10216;stack, lhsPrec, <span class="preprocessor">_</span>, cache, <span class="preprocessor">_</span>&#10217; <span class="constant">=&gt;</span> &#10216;stack.push Syntax.missing, lhsPrec, pos, cache, some { unexpected <span class="constant">:=</span> msg }&#10217;
13911 
<span class="keyword">13912 end</span> ParserState
13913 
<span class="keyword">13914 def</span> <span class="function-name">ParserFn</span> <span class="constant">:=</span> ParserContext <span class="constant">&#8594;</span> ParserState <span class="constant">&#8594;</span> ParserState
13915 
<span class="keyword">13916 instance</span> <span class="function-name">:</span> Inhabited ParserFn <span class="keyword">where</span>
13917   default <span class="constant">:=</span> <span class="keyword">fun</span> ctx s <span class="constant">=&gt;</span> s
13918 
<span class="keyword">13919 inductive</span> <span class="function-name">FirstTokens</span> <span class="keyword">where</span>
13920   | epsilon   : FirstTokens
13921   | unknown   : FirstTokens
13922   | tokens    : List Token <span class="constant">&#8594;</span> FirstTokens
13923   | optTokens : List Token <span class="constant">&#8594;</span> FirstTokens
13924   <span class="keyword">deriving</span> Inhabited
13925 
<span class="keyword">13926 namespace</span> FirstTokens
13927 
<span class="keyword">13928 def</span> <span class="function-name">seq</span> : FirstTokens <span class="constant">&#8594;</span> FirstTokens <span class="constant">&#8594;</span> FirstTokens
13929   | epsilon,      tks          <span class="constant">=&gt;</span> tks
13930   | optTokens s&#8321;, optTokens s&#8322; <span class="constant">=&gt;</span> optTokens (s&#8321; <span class="constant">++</span> s&#8322;)
13931   | optTokens s&#8321;, tokens s&#8322;    <span class="constant">=&gt;</span> tokens (s&#8321; <span class="constant">++</span> s&#8322;)
13932   | tks,          <span class="preprocessor">_</span>            <span class="constant">=&gt;</span> tks
13933 
<span class="keyword">13934 def</span> <span class="function-name">toOptional</span> : FirstTokens <span class="constant">&#8594;</span> FirstTokens
13935   | tokens tks <span class="constant">=&gt;</span> optTokens tks
13936   | tks        <span class="constant">=&gt;</span> tks
13937 
<span class="keyword">13938 def</span> <span class="function-name">merge</span> : FirstTokens <span class="constant">&#8594;</span> FirstTokens <span class="constant">&#8594;</span> FirstTokens
13939   | epsilon,      tks          <span class="constant">=&gt;</span> toOptional tks
13940   | tks,          epsilon      <span class="constant">=&gt;</span> toOptional tks
13941   | tokens s&#8321;,    tokens s&#8322;    <span class="constant">=&gt;</span> tokens (s&#8321; <span class="constant">++</span> s&#8322;)
13942   | optTokens s&#8321;, optTokens s&#8322; <span class="constant">=&gt;</span> optTokens (s&#8321; <span class="constant">++</span> s&#8322;)
13943   | tokens s&#8321;,    optTokens s&#8322; <span class="constant">=&gt;</span> optTokens (s&#8321; <span class="constant">++</span> s&#8322;)
13944   | optTokens s&#8321;, tokens s&#8322;    <span class="constant">=&gt;</span> optTokens (s&#8321; <span class="constant">++</span> s&#8322;)
13945   | <span class="preprocessor">_</span>,            <span class="preprocessor">_</span>            <span class="constant">=&gt;</span> unknown
13946 
<span class="keyword">13947 def</span> <span class="function-name">toStr</span> : FirstTokens <span class="constant">&#8594;</span> String
13948   | epsilon       <span class="constant">=&gt;</span> <span class="string">"epsilon"</span>
13949   | unknown       <span class="constant">=&gt;</span> <span class="string">"unknown"</span>
13950   | tokens tks    <span class="constant">=&gt;</span> toString tks
13951   | optTokens tks <span class="constant">=&gt;</span> <span class="string">"?"</span> <span class="constant">++</span> toString tks
13952 
<span class="keyword">13953 instance</span> <span class="function-name">:</span> ToString FirstTokens <span class="constant">:=</span> &#10216;toStr&#10217;
13954 
<span class="keyword">13955 end</span> FirstTokens
13956 
<span class="keyword">13957 structure</span> <span class="function-name">ParserInfo</span> <span class="keyword">where</span>
13958   collectTokens : List Token <span class="constant">&#8594;</span> List Token <span class="constant">:=</span> id
13959   collectKinds  : SyntaxNodeKindSet <span class="constant">&#8594;</span> SyntaxNodeKindSet <span class="constant">:=</span> id
13960   firstTokens   : FirstTokens <span class="constant">:=</span> FirstTokens.unknown
13961   <span class="keyword">deriving</span> Inhabited
13962 
<span class="keyword">13963 structure</span> <span class="function-name">Parser</span> <span class="keyword">where</span>
13964   info : ParserInfo <span class="constant">:=</span> {}
13965   fn   : ParserFn
13966   <span class="keyword">deriving</span> Inhabited
13967 
<span class="keyword">13968 abbrev</span> TrailingParser <span class="constant">:=</span> Parser
13969 
<span class="keyword">13970 def</span> <span class="function-name">dbgTraceStateFn</span> (label : String) (p : ParserFn) : ParserFn <span class="constant">:=</span>
13971   <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
13972     <span class="keyword">let</span> sz <span class="constant">:=</span> s.stxStack.size
13973     <span class="keyword">let</span> s' <span class="constant">:=</span> p c s
13974     dbg_trace <span class="string">"{label}
13975   pos: {s'.pos}
13976   err: {s'.errorMsg}
13977   out: {s'.stxStack.extract sz s'.stxStack.size}"</span> s'
13978 
<span class="keyword">13979 def</span> <span class="function-name">dbgTraceState</span> (label : String) (p : Parser) : Parser <span class="keyword">where</span>
13980   fn   <span class="constant">:=</span> <span class="warning">dbgTrace</span>StateFn label p.fn
13981   info <span class="constant">:=</span> p.info
13982 
<span class="doc">13983 @[noinline]</span> <span class="keyword">def</span> <span class="function-name">epsilonInfo</span> : ParserInfo <span class="constant">:=</span>
13984   { firstTokens <span class="constant">:=</span> FirstTokens.epsilon }
13985 
<span class="doc">13986 @[inline]</span> <span class="keyword">def</span> <span class="function-name">checkStackTopFn</span> (p : Syntax <span class="constant">&#8594;</span> Bool) (msg : String) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
13987   <span class="keyword">if</span> p s.stxStack.back <span class="keyword">then</span> s
13988   <span class="keyword">else</span> s.mkUnexpectedError msg
13989 
<span class="doc">13990 @[inline]</span> <span class="keyword">def</span> <span class="function-name">checkStackTop</span> (p : Syntax <span class="constant">&#8594;</span> Bool) (msg : String) : Parser <span class="constant">:=</span> {
13991   info <span class="constant">:=</span> epsilonInfo,
13992   fn   <span class="constant">:=</span> checkStackTopFn p msg
13993 }
13994 
<span class="doc">13995 @[inline]</span> <span class="keyword">def</span> <span class="function-name">andthenFn</span> (p q : ParserFn) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
13996   <span class="keyword">let</span> s <span class="constant">:=</span> p c s
13997   <span class="keyword">if</span> s.hasError <span class="keyword">then</span> s <span class="keyword">else</span> q c s
13998 
<span class="doc">13999 @[noinline]</span> <span class="keyword">def</span> <span class="function-name">andthenInfo</span> (p q : ParserInfo) : ParserInfo <span class="constant">:=</span> {
14000   collectTokens <span class="constant">:=</span> p.collectTokens <span class="constant">&#8728;</span> q.collectTokens,
14001   collectKinds  <span class="constant">:=</span> p.collectKinds <span class="constant">&#8728;</span> q.collectKinds,
14002   firstTokens   <span class="constant">:=</span> p.firstTokens.seq q.firstTokens
14003 }
14004 
<span class="doc">14005 @[inline]</span> <span class="keyword">def</span> <span class="function-name">andthen</span> (p q : Parser) : Parser <span class="constant">:=</span> {
14006   info <span class="constant">:=</span> andthenInfo p.info q.info,
14007   fn   <span class="constant">:=</span> andthenFn p.fn q.fn
14008 }
14009 
<span class="keyword">14010 instance</span> <span class="function-name">:</span> AndThen Parser <span class="constant">:=</span> &#10216;andthen&#10217;
14011 
<span class="doc">14012 @[inline]</span> <span class="keyword">def</span> <span class="function-name">nodeFn</span> (n : SyntaxNodeKind) (p : ParserFn) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14013   <span class="keyword">let</span> iniSz <span class="constant">:=</span> s.stackSize
14014   <span class="keyword">let</span> s     <span class="constant">:=</span> p c s
14015   s.mkNode n iniSz
14016 
<span class="doc">14017 @[inline]</span> <span class="keyword">def</span> <span class="function-name">trailingNodeFn</span> (n : SyntaxNodeKind) (p : ParserFn) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14018   <span class="keyword">let</span> iniSz <span class="constant">:=</span> s.stackSize
14019   <span class="keyword">let</span> s     <span class="constant">:=</span> p c s
14020   s.mkTrailingNode n iniSz
14021 
<span class="doc">14022 @[noinline]</span> <span class="keyword">def</span> <span class="function-name">nodeInfo</span> (n : SyntaxNodeKind) (p : ParserInfo) : ParserInfo <span class="constant">:=</span> {
14023   collectTokens <span class="constant">:=</span> p.collectTokens,
14024   collectKinds  <span class="constant">:=</span> <span class="keyword">fun</span> s <span class="constant">=&gt;</span> (p.collectKinds s).insert n,
14025   firstTokens   <span class="constant">:=</span> p.firstTokens
14026 }
14027 
<span class="doc">14028 @[inline]</span> <span class="keyword">def</span> <span class="function-name">node</span> (n : SyntaxNodeKind) (p : Parser) : Parser <span class="constant">:=</span> {
14029   info <span class="constant">:=</span> nodeInfo n p.info,
14030   fn   <span class="constant">:=</span> nodeFn n p.fn
14031 }
14032 
<span class="keyword">14033 def</span> <span class="function-name">errorFn</span> (msg : String) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> <span class="preprocessor">_</span> s <span class="constant">=&gt;</span>
14034   s.mkUnexpectedError msg
14035 
<span class="doc">14036 @[inline]</span> <span class="keyword">def</span> <span class="function-name">error</span> (msg : String) : Parser <span class="constant">:=</span> {
14037   info <span class="constant">:=</span> epsilonInfo,
14038   fn   <span class="constant">:=</span> errorFn msg
14039 }
14040 
<span class="keyword">14041 def</span> <span class="function-name">errorAtSavedPosFn</span> (msg : String) (delta : Bool) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14042   <span class="keyword">match</span> c.savedPos? <span class="keyword">with</span>
14043   | none     <span class="constant">=&gt;</span> s
14044   | some pos <span class="constant">=&gt;</span>
14045     <span class="keyword">let</span> pos <span class="constant">:=</span> <span class="keyword">if</span> delta <span class="keyword">then</span> c.input.next pos <span class="keyword">else</span> pos
14046     <span class="keyword">match</span> s <span class="keyword">with</span>
14047     | &#10216;stack, lhsPrec, <span class="preprocessor">_</span>, cache, <span class="preprocessor">_</span>&#10217; <span class="constant">=&gt;</span> &#10216;stack.push Syntax.missing, lhsPrec, pos, cache, some { unexpected <span class="constant">:=</span> msg }&#10217;
14048 
<span class="comment-delimiter">14049 /- </span><span class="comment">Generate an error at the position saved with the `withPosition` combinator.
14050    If `delta == true`, then it reports at saved position+1.
14051    This useful to make sure a parser consumed at least one character.  -/</span>
<span class="doc">14052 @[inline]</span> <span class="keyword">def</span> <span class="function-name">errorAtSavedPos</span> (msg : String) (delta : Bool) : Parser <span class="constant">:=</span> {
14053   fn <span class="constant">:=</span> errorAtSavedPosFn msg delta
14054 }
14055 
<span class="comment-delimiter">14056 /- </span><span class="comment">Succeeds if `c.prec &lt;= prec` -/</span>
<span class="keyword">14057 def</span> <span class="function-name">checkPrecFn</span> (prec : Nat) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14058   <span class="keyword">if</span> c.prec <span class="constant">&lt;=</span> prec <span class="keyword">then</span> s
14059   <span class="keyword">else</span> s.mkUnexpectedError <span class="string">"unexpected token at this precedence level; consider parenthesizing the term"</span>
14060 
<span class="doc">14061 @[inline]</span> <span class="keyword">def</span> <span class="function-name">checkPrec</span> (prec : Nat) : Parser <span class="constant">:=</span> {
14062   info <span class="constant">:=</span> epsilonInfo,
14063   fn   <span class="constant">:=</span> checkPrecFn prec
14064 }
14065 
<span class="comment-delimiter">14066 /- </span><span class="comment">Succeeds if `c.lhsPrec &gt;= prec` -/</span>
<span class="keyword">14067 def</span> <span class="function-name">checkLhsPrecFn</span> (prec : Nat) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14068   <span class="keyword">if</span> s.lhsPrec <span class="constant">&gt;=</span> prec <span class="keyword">then</span> s
14069   <span class="keyword">else</span> s.mkUnexpectedError <span class="string">"unexpected token at this precedence level; consider parenthesizing the term"</span>
14070 
<span class="doc">14071 @[inline]</span> <span class="keyword">def</span> <span class="function-name">checkLhsPrec</span> (prec : Nat) : Parser <span class="constant">:=</span> {
14072   info <span class="constant">:=</span> epsilonInfo,
14073   fn   <span class="constant">:=</span> checkLhsPrecFn prec
14074 }
14075 
<span class="keyword">14076 def</span> <span class="function-name">setLhsPrecFn</span> (prec : Nat) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14077   <span class="keyword">if</span> s.hasError <span class="keyword">then</span> s
14078   <span class="keyword">else</span> { s <span class="keyword">with</span> lhsPrec <span class="constant">:=</span> prec }
14079 
<span class="doc">14080 @[inline]</span> <span class="keyword">def</span> <span class="function-name">setLhsPrec</span> (prec : Nat) : Parser <span class="constant">:=</span> {
14081   info <span class="constant">:=</span> epsilonInfo,
14082   fn   <span class="constant">:=</span> setLhsPrecFn prec
14083 }
14084 
<span class="keyword">14085 def</span> <span class="function-name">checkInsideQuotFn</span> : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14086   <span class="keyword">if</span> c.insideQuot <span class="keyword">then</span> s
14087   <span class="keyword">else</span> s.mkUnexpectedError <span class="string">"unexpected syntax outside syntax quotation"</span>
14088 
<span class="doc">14089 @[inline]</span> <span class="keyword">def</span> <span class="function-name">checkInsideQuot</span> : Parser <span class="constant">:=</span> {
14090   info <span class="constant">:=</span> epsilonInfo,
14091   fn   <span class="constant">:=</span> checkInsideQuotFn
14092 }
14093 
<span class="keyword">14094 def</span> <span class="function-name">checkOutsideQuotFn</span> : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14095   <span class="keyword">if</span> <span class="constant">!</span>c.insideQuot <span class="keyword">then</span> s
14096   <span class="keyword">else</span> s.mkUnexpectedError <span class="string">"unexpected syntax inside syntax quotation"</span>
14097 
<span class="doc">14098 @[inline]</span> <span class="keyword">def</span> <span class="function-name">checkOutsideQuot</span> : Parser <span class="constant">:=</span> {
14099   info <span class="constant">:=</span> epsilonInfo,
14100   fn   <span class="constant">:=</span> checkOutsideQuotFn
14101 }
14102 
<span class="keyword">14103 def</span> <span class="function-name">toggleInsideQuotFn</span> (p : ParserFn) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14104   <span class="keyword">if</span> c.suppressInsideQuot <span class="keyword">then</span> p c s
14105   <span class="keyword">else</span> p { c <span class="keyword">with</span> insideQuot <span class="constant">:=</span> <span class="constant">!</span>c.insideQuot } s
14106 
<span class="doc">14107 @[inline]</span> <span class="keyword">def</span> <span class="function-name">toggleInsideQuot</span> (p : Parser) : Parser <span class="constant">:=</span> {
14108   info <span class="constant">:=</span> p.info,
14109   fn   <span class="constant">:=</span> toggleInsideQuotFn p.fn
14110 }
14111 
<span class="keyword">14112 def</span> <span class="function-name">suppressInsideQuotFn</span> (p : ParserFn) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14113   p { c <span class="keyword">with</span> suppressInsideQuot <span class="constant">:=</span> true } s
14114 
<span class="doc">14115 @[inline]</span> <span class="keyword">def</span> <span class="function-name">suppressInsideQuot</span> (p : Parser) : Parser <span class="constant">:=</span> {
14116   info <span class="constant">:=</span> p.info,
14117   fn   <span class="constant">:=</span> suppressInsideQuotFn p.fn
14118 }
14119 
<span class="doc">14120 @[inline]</span> <span class="keyword">def</span> <span class="function-name">leadingNode</span> (n : SyntaxNodeKind) (prec : Nat) (p : Parser) : Parser <span class="constant">:=</span>
14121   checkPrec prec <span class="constant">&gt;&gt;</span> node n p <span class="constant">&gt;&gt;</span> setLhsPrec prec
14122 
<span class="doc">14123 @[inline]</span> <span class="keyword">def</span> <span class="function-name">trailingNodeAux</span> (n : SyntaxNodeKind) (p : Parser) : TrailingParser <span class="constant">:=</span> {
14124   info <span class="constant">:=</span> nodeInfo n p.info,
14125   fn   <span class="constant">:=</span> trailingNodeFn n p.fn
14126 }
14127 
<span class="doc">14128 @[inline]</span> <span class="keyword">def</span> <span class="function-name">trailingNode</span> (n : SyntaxNodeKind) (prec lhsPrec : Nat) (p : Parser) : TrailingParser <span class="constant">:=</span>
14129   checkPrec prec <span class="constant">&gt;&gt;</span> checkLhsPrec lhsPrec <span class="constant">&gt;&gt;</span> trailingNodeAux n p <span class="constant">&gt;&gt;</span> setLhsPrec prec
14130 
<span class="keyword">14131 def</span> <span class="function-name">mergeOrElseErrors</span> (s : ParserState) (error1 : Error) (iniPos : Nat) (mergeErrors : Bool) : ParserState <span class="constant">:=</span>
14132   <span class="keyword">match</span> s <span class="keyword">with</span>
14133   | &#10216;stack, lhsPrec, pos, cache, some error2&#10217; <span class="constant">=&gt;</span>
14134     <span class="keyword">if</span> pos <span class="constant">==</span> iniPos <span class="keyword">then</span> &#10216;stack, lhsPrec, pos, cache, some (<span class="keyword">if</span> mergeErrors <span class="keyword">then</span> error1.merge error2 <span class="keyword">else</span> error2)&#10217;
14135     <span class="keyword">else</span> s
14136   | other <span class="constant">=&gt;</span> other
14137 
<span class="keyword">14138 def</span> <span class="function-name">orelseFnCore</span> (p q : ParserFn) (mergeErrors : Bool) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14139   <span class="keyword">let</span> iniSz  <span class="constant">:=</span> s.stackSize
14140   <span class="keyword">let</span> iniPos <span class="constant">:=</span> s.pos
14141   <span class="keyword">let</span> s      <span class="constant">:=</span> p c s
14142   <span class="keyword">match</span> s.errorMsg <span class="keyword">with</span>
14143   | some errorMsg <span class="constant">=&gt;</span>
14144     <span class="keyword">if</span> s.pos <span class="constant">==</span> iniPos <span class="keyword">then</span>
14145       mergeOrElseErrors (q c (s.restore iniSz iniPos)) errorMsg iniPos mergeErrors
14146     <span class="keyword">else</span>
14147       s
14148   | none <span class="constant">=&gt;</span> s
14149 
<span class="doc">14150 @[inline]</span> <span class="keyword">def</span> <span class="function-name">orelseFn</span> (p q : ParserFn) : ParserFn <span class="constant">:=</span>
14151   orelseFnCore p q true
14152 
<span class="doc">14153 @[noinline]</span> <span class="keyword">def</span> <span class="function-name">orelseInfo</span> (p q : ParserInfo) : ParserInfo <span class="constant">:=</span> {
14154   collectTokens <span class="constant">:=</span> p.collectTokens <span class="constant">&#8728;</span> q.collectTokens,
14155   collectKinds  <span class="constant">:=</span> p.collectKinds <span class="constant">&#8728;</span> q.collectKinds,
14156   firstTokens   <span class="constant">:=</span> p.firstTokens.merge q.firstTokens
14157 }
14158 
<span class="comment-delimiter">14159 /-</span><span class="comment">-
14160   Run `p`, falling back to `q` if `p` failed without consuming any input.
14161 
14162   NOTE: In order for the pretty printer to retrace an `orelse`, `p` must be a call to `node` or some other parser
14163   producing a single node kind. Nested `orelse` calls are flattened for this, i.e. `(node k1 p1 &lt;|&gt; node k2 p2) &lt;|&gt; ...`
14164   is fine as well. -/</span>
<span class="doc">14165 @[inline]</span> <span class="keyword">def</span> <span class="function-name">orelse</span> (p q : Parser) : Parser <span class="constant">:=</span> {
14166   info <span class="constant">:=</span> orelseInfo p.info q.info,
14167   fn   <span class="constant">:=</span> orelseFn p.fn q.fn
14168 }
14169 
<span class="keyword">14170 instance</span> <span class="function-name">:</span> OrElse Parser <span class="constant">:=</span> &#10216;orelse&#10217;
14171 
<span class="doc">14172 @[noinline]</span> <span class="keyword">def</span> <span class="function-name">noFirstTokenInfo</span> (info : ParserInfo) : ParserInfo <span class="constant">:=</span> {
14173   collectTokens <span class="constant">:=</span> info.collectTokens,
14174   collectKinds  <span class="constant">:=</span> info.collectKinds
14175 }
14176 
<span class="keyword">14177 def</span> <span class="function-name">atomicFn</span> (p : ParserFn) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14178   <span class="keyword">let</span> iniPos <span class="constant">:=</span> s.pos
14179   <span class="keyword">match</span> p c s <span class="keyword">with</span>
14180   | &#10216;stack, lhsPrec, <span class="preprocessor">_</span>, cache, some msg&#10217; <span class="constant">=&gt;</span> &#10216;stack, lhsPrec, iniPos, cache, some msg&#10217;
14181   | other                       <span class="constant">=&gt;</span> other
14182 
<span class="doc">14183 @[inline]</span> <span class="keyword">def</span> <span class="function-name">atomic</span> (p : Parser) : Parser <span class="constant">:=</span> {
14184   info <span class="constant">:=</span> p.info,
14185   fn   <span class="constant">:=</span> atomicFn p.fn
14186 }
14187 
<span class="keyword">14188 def</span> <span class="function-name">optionalFn</span> (p : ParserFn) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14189   <span class="keyword">let</span> iniSz  <span class="constant">:=</span> s.stackSize
14190   <span class="keyword">let</span> iniPos <span class="constant">:=</span> s.pos
14191   <span class="keyword">let</span> s      <span class="constant">:=</span> p c s
14192   <span class="keyword">let</span> s      <span class="constant">:=</span> <span class="keyword">if</span> s.hasError <span class="constant">&amp;&amp;</span> s.pos <span class="constant">==</span> iniPos <span class="keyword">then</span> s.restore iniSz iniPos <span class="keyword">else</span> s
14193   s.mkNode nullKind iniSz
14194 
<span class="doc">14195 @[noinline]</span> <span class="keyword">def</span> <span class="function-name">optionaInfo</span> (p : ParserInfo) : ParserInfo <span class="constant">:=</span> {
14196   collectTokens <span class="constant">:=</span> p.collectTokens,
14197   collectKinds  <span class="constant">:=</span> p.collectKinds,
14198   firstTokens   <span class="constant">:=</span> p.firstTokens.toOptional
14199 }
14200 
<span class="doc">14201 @[inline]</span> <span class="keyword">def</span> <span class="function-name">optionalNoAntiquot</span> (p : Parser) : Parser <span class="constant">:=</span> {
14202   info <span class="constant">:=</span> optionaInfo p.info,
14203   fn   <span class="constant">:=</span> optionalFn p.fn
14204 }
14205 
<span class="keyword">14206 def</span> <span class="function-name">lookaheadFn</span> (p : ParserFn) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14207   <span class="keyword">let</span> iniSz  <span class="constant">:=</span> s.stackSize
14208   <span class="keyword">let</span> iniPos <span class="constant">:=</span> s.pos
14209   <span class="keyword">let</span> s      <span class="constant">:=</span> p c s
14210   <span class="keyword">if</span> s.hasError <span class="keyword">then</span> s <span class="keyword">else</span> s.restore iniSz iniPos
14211 
<span class="doc">14212 @[inline]</span> <span class="keyword">def</span> <span class="function-name">lookahead</span> (p : Parser) : Parser <span class="constant">:=</span> {
14213   info <span class="constant">:=</span> p.info,
14214   fn   <span class="constant">:=</span> lookaheadFn p.fn
14215 }
14216 
<span class="keyword">14217 def</span> <span class="function-name">notFollowedByFn</span> (p : ParserFn) (msg : String) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14218   <span class="keyword">let</span> iniSz  <span class="constant">:=</span> s.stackSize
14219   <span class="keyword">let</span> iniPos <span class="constant">:=</span> s.pos
14220   <span class="keyword">let</span> s      <span class="constant">:=</span> p c s
14221   <span class="keyword">if</span> s.hasError <span class="keyword">then</span>
14222     s.restore iniSz iniPos
14223   <span class="keyword">else</span>
14224     <span class="keyword">let</span> s <span class="constant">:=</span> s.restore iniSz iniPos
14225     s.mkUnexpectedError s<span class="constant">!</span><span class="string">"unexpected {msg}"</span>
14226 
<span class="doc">14227 @[inline]</span> <span class="keyword">def</span> <span class="function-name">notFollowedBy</span> (p : Parser) (msg : String) : Parser <span class="constant">:=</span> {
14228   fn <span class="constant">:=</span> notFollowedByFn p.fn msg
14229 }
14230 
<span class="keyword">14231 partial</span> <span class="keyword">def</span> <span class="function-name">manyAux</span> (p : ParserFn) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span> <span class="keyword">do</span>
14232   <span class="keyword">let</span> iniSz  <span class="constant">:=</span> s.stackSize
14233   <span class="keyword">let</span> iniPos <span class="constant">:=</span> s.pos
14234   <span class="keyword">let</span> <span class="keyword">mut</span> s  <span class="constant">:=</span> p c s
14235   <span class="keyword">if</span> s.hasError <span class="keyword">then</span>
14236     <span class="keyword">return</span> <span class="keyword">if</span> iniPos <span class="constant">==</span> s.pos <span class="keyword">then</span> s.restore iniSz iniPos <span class="keyword">else</span> s
14237   <span class="keyword">if</span> iniPos <span class="constant">==</span> s.pos <span class="keyword">then</span>
14238     <span class="keyword">return</span> s.mkUnexpectedError <span class="string">"invalid 'many' parser combinator application, parser did not consume anything"</span>
14239   <span class="keyword">if</span> s.stackSize <span class="constant">&gt;</span> iniSz <span class="constant">+</span> <span class="constant">1</span> <span class="keyword">then</span>
14240     s <span class="constant">:=</span> s.mkNode nullKind iniSz
14241   manyAux p c s
14242 
<span class="doc">14243 @[inline]</span> <span class="keyword">def</span> <span class="function-name">manyFn</span> (p : ParserFn) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14244   <span class="keyword">let</span> iniSz  <span class="constant">:=</span> s.stackSize
14245   <span class="keyword">let</span> s <span class="constant">:=</span> manyAux p c s
14246   s.mkNode nullKind iniSz
14247 
<span class="doc">14248 @[inline]</span> <span class="keyword">def</span> <span class="function-name">manyNoAntiquot</span> (p : Parser) : Parser <span class="constant">:=</span> {
14249   info <span class="constant">:=</span> noFirstTokenInfo p.info,
14250   fn   <span class="constant">:=</span> manyFn p.fn
14251 }
14252 
<span class="doc">14253 @[inline]</span> <span class="keyword">def</span> <span class="function-name">many1Fn</span> (p : ParserFn) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14254   <span class="keyword">let</span> iniSz  <span class="constant">:=</span> s.stackSize
14255   <span class="keyword">let</span> s <span class="constant">:=</span> andthenFn p (manyAux p) c s
14256   s.mkNode nullKind iniSz
14257 
<span class="doc">14258 @[inline]</span> <span class="keyword">def</span> <span class="function-name">many1NoAntiquot</span> (p : Parser) : Parser <span class="constant">:=</span> {
14259   info <span class="constant">:=</span> p.info,
14260   fn   <span class="constant">:=</span> many1Fn p.fn
14261 }
14262 
<span class="keyword">14263 private</span> <span class="keyword">partial</span> <span class="keyword">def</span> <span class="function-name">sepByFnAux</span> (p : ParserFn) (sep : ParserFn) (allowTrailingSep : Bool) (iniSz : Nat) (pOpt : Bool) : ParserFn <span class="constant">:=</span>
14264   <span class="keyword">let</span> <span class="keyword">rec</span> parse (pOpt : Bool) (c s) <span class="constant">:=</span> <span class="keyword">do</span>
14265     <span class="keyword">let</span> sz  <span class="constant">:=</span> s.stackSize
14266     <span class="keyword">let</span> pos <span class="constant">:=</span> s.pos
14267     <span class="keyword">let</span> <span class="keyword">mut</span> s <span class="constant">:=</span> p c s
14268     <span class="keyword">if</span> s.hasError <span class="keyword">then</span>
14269       <span class="keyword">if</span> s.pos <span class="constant">&gt;</span> pos <span class="keyword">then</span>
14270         <span class="keyword">return</span> s.mkNode nullKind iniSz
14271       <span class="keyword">else</span> <span class="keyword">if</span> pOpt <span class="keyword">then</span>
14272         <span class="keyword">let</span> s <span class="constant">:=</span> s.restore sz pos
14273         <span class="keyword">return</span> s.mkNode nullKind iniSz
14274       <span class="keyword">else</span>
14275         <span class="comment-delimiter">-- </span><span class="comment">append `Syntax.missing` to make clear that List is incomplete
</span>14276         <span class="keyword">let</span> s <span class="constant">:=</span> s.pushSyntax Syntax.missing
14277         <span class="keyword">return</span> s.mkNode nullKind iniSz
14278     <span class="keyword">if</span> s.stackSize <span class="constant">&gt;</span> sz <span class="constant">+</span> <span class="constant">1</span> <span class="keyword">then</span>
14279       s <span class="constant">:=</span> s.mkNode nullKind sz
14280     <span class="keyword">let</span> sz  <span class="constant">:=</span> s.stackSize
14281     <span class="keyword">let</span> pos <span class="constant">:=</span> s.pos
14282     <span class="keyword">let</span> s   <span class="constant">:=</span> sep c s
14283     <span class="keyword">if</span> s.hasError <span class="keyword">then</span>
14284       <span class="keyword">let</span> s <span class="constant">:=</span> s.restore sz pos
14285       <span class="keyword">return</span> s.mkNode nullKind iniSz
14286     <span class="keyword">if</span> s.stackSize <span class="constant">&gt;</span> sz <span class="constant">+</span> <span class="constant">1</span> <span class="keyword">then</span>
14287       s <span class="constant">:=</span> s.mkNode nullKind sz
14288     parse allowTrailingSep c s
14289   parse pOpt
14290 
<span class="keyword">14291 def</span> <span class="function-name">sepByFn</span> (allowTrailingSep : Bool) (p : ParserFn) (sep : ParserFn) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14292   <span class="keyword">let</span> iniSz <span class="constant">:=</span> s.stackSize
14293   sepByFnAux p sep allowTrailingSep iniSz true c s
14294 
<span class="keyword">14295 def</span> <span class="function-name">sepBy1Fn</span> (allowTrailingSep : Bool) (p : ParserFn) (sep : ParserFn) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14296   <span class="keyword">let</span> iniSz <span class="constant">:=</span> s.stackSize
14297   sepByFnAux p sep allowTrailingSep iniSz false c s
14298 
<span class="doc">14299 @[noinline]</span> <span class="keyword">def</span> <span class="function-name">sepByInfo</span> (p sep : ParserInfo) : ParserInfo <span class="constant">:=</span> {
14300   collectTokens <span class="constant">:=</span> p.collectTokens <span class="constant">&#8728;</span> sep.collectTokens,
14301   collectKinds  <span class="constant">:=</span> p.collectKinds <span class="constant">&#8728;</span> sep.collectKinds
14302 }
14303 
<span class="doc">14304 @[noinline]</span> <span class="keyword">def</span> <span class="function-name">sepBy1Info</span> (p sep : ParserInfo) : ParserInfo <span class="constant">:=</span> {
14305   collectTokens <span class="constant">:=</span> p.collectTokens <span class="constant">&#8728;</span> sep.collectTokens,
14306   collectKinds  <span class="constant">:=</span> p.collectKinds <span class="constant">&#8728;</span> sep.collectKinds,
14307   firstTokens   <span class="constant">:=</span> p.firstTokens
14308 }
14309 
<span class="doc">14310 @[inline]</span> <span class="keyword">def</span> <span class="function-name">sepByNoAntiquot</span> (p sep : Parser) (allowTrailingSep : Bool <span class="constant">:=</span> false) : Parser <span class="constant">:=</span> {
14311   info <span class="constant">:=</span> sepByInfo p.info sep.info,
14312   fn   <span class="constant">:=</span> sepByFn allowTrailingSep p.fn sep.fn
14313 }
14314 
<span class="doc">14315 @[inline]</span> <span class="keyword">def</span> <span class="function-name">sepBy1NoAntiquot</span> (p sep : Parser) (allowTrailingSep : Bool <span class="constant">:=</span> false) : Parser <span class="constant">:=</span> {
14316   info <span class="constant">:=</span> sepBy1Info p.info sep.info,
14317   fn   <span class="constant">:=</span> sepBy1Fn allowTrailingSep p.fn sep.fn
14318 }
14319 
<span class="comment-delimiter">14320 /- </span><span class="comment">Apply `f` to the syntax object produced by `p` -/</span>
<span class="keyword">14321 def</span> <span class="function-name">withResultOfFn</span> (p : ParserFn) (f : Syntax <span class="constant">&#8594;</span> Syntax) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14322   <span class="keyword">let</span> s <span class="constant">:=</span> p c s
14323   <span class="keyword">if</span> s.hasError <span class="keyword">then</span> s
14324   <span class="keyword">else</span>
14325     <span class="keyword">let</span> stx <span class="constant">:=</span> s.stxStack.back
14326     s.popSyntax.pushSyntax (f stx)
14327 
<span class="doc">14328 @[noinline]</span> <span class="keyword">def</span> <span class="function-name">withResultOfInfo</span> (p : ParserInfo) : ParserInfo <span class="constant">:=</span> {
14329   collectTokens <span class="constant">:=</span> p.collectTokens,
14330   collectKinds  <span class="constant">:=</span> p.collectKinds
14331 }
14332 
<span class="doc">14333 @[inline]</span> <span class="keyword">def</span> <span class="function-name">withResultOf</span> (p : Parser) (f : Syntax <span class="constant">&#8594;</span> Syntax) : Parser <span class="constant">:=</span> {
14334   info <span class="constant">:=</span> withResultOfInfo p.info,
14335   fn   <span class="constant">:=</span> withResultOfFn p.fn f
14336 }
14337 
<span class="doc">14338 @[inline]</span> <span class="keyword">def</span> <span class="function-name">many1Unbox</span> (p : Parser) : Parser <span class="constant">:=</span>
14339   withResultOf (many1NoAntiquot p) <span class="keyword">fun</span> stx <span class="constant">=&gt;</span> <span class="keyword">if</span> stx.getNumArgs <span class="constant">==</span> <span class="constant">1</span> <span class="keyword">then</span> stx.getArg <span class="constant">0</span> <span class="keyword">else</span> stx
14340 
<span class="keyword">14341 partial</span> <span class="keyword">def</span> <span class="function-name">satisfyFn</span> (p : Char <span class="constant">&#8594;</span> Bool) (errorMsg : String <span class="constant">:=</span> <span class="string">"unexpected character"</span>) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14342   <span class="keyword">let</span> i <span class="constant">:=</span> s.pos
14343   <span class="keyword">if</span> c.input.atEnd i <span class="keyword">then</span> s.mkEOIError
14344   <span class="keyword">else</span> <span class="keyword">if</span> p (c.input.get i) <span class="keyword">then</span> s.next c.input i
14345   <span class="keyword">else</span> s.mkUnexpectedError errorMsg
14346 
<span class="keyword">14347 partial</span> <span class="keyword">def</span> <span class="function-name">takeUntilFn</span> (p : Char <span class="constant">&#8594;</span> Bool) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14348   <span class="keyword">let</span> i <span class="constant">:=</span> s.pos
14349   <span class="keyword">if</span> c.input.atEnd i <span class="keyword">then</span> s
14350   <span class="keyword">else</span> <span class="keyword">if</span> p (c.input.get i) <span class="keyword">then</span> s
14351   <span class="keyword">else</span> takeUntilFn p c (s.next c.input i)
14352 
<span class="keyword">14353 def</span> <span class="function-name">takeWhileFn</span> (p : Char <span class="constant">&#8594;</span> Bool) : ParserFn <span class="constant">:=</span>
14354   takeUntilFn (<span class="keyword">fun</span> c <span class="constant">=&gt;</span> <span class="constant">!</span>p c)
14355 
<span class="doc">14356 @[inline]</span> <span class="keyword">def</span> <span class="function-name">takeWhile1Fn</span> (p : Char <span class="constant">&#8594;</span> Bool) (errorMsg : String) : ParserFn <span class="constant">:=</span>
14357   andthenFn (satisfyFn p errorMsg) (takeWhileFn p)
14358 
<span class="keyword">14359 variable</span> (startPos : String.Pos) <span class="keyword">in</span>
<span class="keyword">14360 partial</span> <span class="keyword">def</span> <span class="function-name">finishCommentBlock</span> (nesting : Nat) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14361   <span class="keyword">let</span> input <span class="constant">:=</span> c.input
14362   <span class="keyword">let</span> i     <span class="constant">:=</span> s.pos
14363   <span class="keyword">if</span> input.atEnd i <span class="keyword">then</span> eoi s
14364   <span class="keyword">else</span>
14365     <span class="keyword">let</span> curr <span class="constant">:=</span> input.get i
14366     <span class="keyword">let</span> i    <span class="constant">:=</span> input.next i
14367     <span class="keyword">if</span> curr <span class="constant">==</span> '<span class="constant">-</span>' <span class="keyword">then</span>
14368       <span class="keyword">if</span> input.atEnd i <span class="keyword">then</span> eoi s
14369       <span class="keyword">else</span>
14370         <span class="keyword">let</span> curr <span class="constant">:=</span> input.get i
14371         <span class="keyword">if</span> curr <span class="constant">==</span> '<span class="constant">/</span>' <span class="keyword">then</span> <span class="comment-delimiter">-- </span><span class="comment">"-/" end of comment
</span>14372           <span class="keyword">if</span> nesting <span class="constant">==</span> <span class="constant">1</span> <span class="keyword">then</span> s.next input i
14373           <span class="keyword">else</span> finishCommentBlock (nesting<span class="constant">-1</span>) c (s.next input i)
14374         <span class="keyword">else</span>
14375           finishCommentBlock nesting c (s.next input i)
14376     <span class="keyword">else</span> <span class="keyword">if</span> curr <span class="constant">==</span> '<span class="constant">/</span>' <span class="keyword">then</span>
14377       <span class="keyword">if</span> input.atEnd i <span class="keyword">then</span> eoi s
14378       <span class="keyword">else</span>
14379         <span class="keyword">let</span> curr <span class="constant">:=</span> input.get i
14380         <span class="keyword">if</span> curr <span class="constant">==</span> '<span class="constant">-</span>' <span class="keyword">then</span> finishCommentBlock (nesting<span class="constant">+1</span>) c (s.next input i)
14381         <span class="keyword">else</span> finishCommentBlock nesting c (s.setPos i)
14382     <span class="keyword">else</span> finishCommentBlock nesting c (s.setPos i)
<span class="keyword">14383 where</span>
14384   eoi s <span class="constant">:=</span> s.mkUnexpectedErrorAt <span class="string">"unterminated comment"</span> startPos
14385 
<span class="comment-delimiter">14386 /- </span><span class="comment">Consume whitespace and comments -/</span>
<span class="keyword">14387 partial</span> <span class="keyword">def</span> <span class="function-name">whitespace</span> : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14388   <span class="keyword">let</span> input <span class="constant">:=</span> c.input
14389   <span class="keyword">let</span> i     <span class="constant">:=</span> s.pos
14390   <span class="keyword">if</span> input.atEnd i <span class="keyword">then</span> s
14391   <span class="keyword">else</span>
14392     <span class="keyword">let</span> curr <span class="constant">:=</span> input.get i
14393     <span class="keyword">if</span> curr.isWhitespace <span class="keyword">then</span> whitespace c (s.next input i)
14394     <span class="keyword">else</span> <span class="keyword">if</span> curr <span class="constant">==</span> '<span class="constant">-</span>' <span class="keyword">then</span>
14395       <span class="keyword">let</span> i    <span class="constant">:=</span> input.next i
14396       <span class="keyword">let</span> curr <span class="constant">:=</span> input.get i
14397       <span class="keyword">if</span> curr <span class="constant">==</span> '<span class="constant">-</span>' <span class="keyword">then</span> andthenFn (takeUntilFn (<span class="keyword">fun</span> c <span class="constant">=&gt;</span> c <span class="constant">=</span> '\n')) whitespace c (s.next input i)
14398       <span class="keyword">else</span> s
14399     <span class="keyword">else</span> <span class="keyword">if</span> curr <span class="constant">==</span> '<span class="constant">/</span>' <span class="keyword">then</span>
14400       <span class="keyword">let</span> startPos <span class="constant">:=</span> i
14401       <span class="keyword">let</span> i        <span class="constant">:=</span> input.next i
14402       <span class="keyword">let</span> curr     <span class="constant">:=</span> input.get i
14403       <span class="keyword">if</span> curr <span class="constant">==</span> '<span class="constant">-</span>' <span class="keyword">then</span>
14404         <span class="keyword">let</span> i    <span class="constant">:=</span> input.next i
14405         <span class="keyword">let</span> curr <span class="constant">:=</span> input.get i
14406         <span class="keyword">if</span> curr <span class="constant">==</span> '<span class="constant">-</span>' <span class="keyword">then</span> s <span class="comment-delimiter">-- </span><span class="comment">"/--" doc comment is an actual token
</span>14407         <span class="keyword">else</span> andthenFn (finishCommentBlock startPos <span class="constant">1</span>) whitespace c (s.next input i)
14408       <span class="keyword">else</span> s
14409     <span class="keyword">else</span> s
14410 
<span class="keyword">14411 def</span> <span class="function-name">mkEmptySubstringAt</span> (s : String) (p : Nat) : Substring <span class="constant">:=</span>
14412   { str <span class="constant">:=</span> s, startPos <span class="constant">:=</span> p, stopPos <span class="constant">:=</span> p }
14413 
<span class="keyword">14414 private</span> <span class="keyword">def</span> <span class="function-name">rawAux</span> (startPos : Nat) (trailingWs : Bool) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14415   <span class="keyword">let</span> input   <span class="constant">:=</span> c.input
14416   <span class="keyword">let</span> stopPos <span class="constant">:=</span> s.pos
14417   <span class="keyword">let</span> leading <span class="constant">:=</span> mkEmptySubstringAt input startPos
14418   <span class="keyword">let</span> val     <span class="constant">:=</span> input.extract startPos stopPos
14419   <span class="keyword">if</span> trailingWs <span class="keyword">then</span>
14420     <span class="keyword">let</span> s        <span class="constant">:=</span> whitespace c s
14421     <span class="keyword">let</span> stopPos' <span class="constant">:=</span> s.pos
14422     <span class="keyword">let</span> trailing <span class="constant">:=</span> { str <span class="constant">:=</span> input, startPos <span class="constant">:=</span> stopPos, stopPos <span class="constant">:=</span> stopPos' : Substring }
14423     <span class="keyword">let</span> atom     <span class="constant">:=</span> mkAtom (SourceInfo.original leading startPos trailing) val
14424     s.pushSyntax atom
14425   <span class="keyword">else</span>
14426     <span class="keyword">let</span> trailing <span class="constant">:=</span> mkEmptySubstringAt input stopPos
14427     <span class="keyword">let</span> atom     <span class="constant">:=</span> mkAtom (SourceInfo.original leading startPos trailing) val
14428     s.pushSyntax atom
14429 
<span class="comment-delimiter">14430 /-</span><span class="comment">- Match an arbitrary Parser and return the consumed String in a `Syntax.atom`. -/</span>
<span class="doc">14431 @[inline]</span> <span class="keyword">def</span> <span class="function-name">rawFn</span> (p : ParserFn) (trailingWs <span class="constant">:=</span> false) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14432   <span class="keyword">let</span> startPos <span class="constant">:=</span> s.pos
14433   <span class="keyword">let</span> s <span class="constant">:=</span> p c s
14434   <span class="keyword">if</span> s.hasError <span class="keyword">then</span> s <span class="keyword">else</span> rawAux startPos trailingWs c s
14435 
<span class="doc">14436 @[inline]</span> <span class="keyword">def</span> <span class="function-name">chFn</span> (c : Char) (trailingWs <span class="constant">:=</span> false) : ParserFn <span class="constant">:=</span>
14437   rawFn (satisfyFn (<span class="keyword">fun</span> d <span class="constant">=&gt;</span> c <span class="constant">==</span> d) (<span class="string">"'"</span> <span class="constant">++</span> toString c <span class="constant">++</span> <span class="string">"'"</span>)) trailingWs
14438 
<span class="keyword">14439 def</span> <span class="function-name">rawCh</span> (c : Char) (trailingWs <span class="constant">:=</span> false) : Parser <span class="constant">:=</span>
14440   { fn <span class="constant">:=</span> chFn c trailingWs }
14441 
<span class="keyword">14442 def</span> <span class="function-name">hexDigitFn</span> : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14443   <span class="keyword">let</span> input <span class="constant">:=</span> c.input
14444   <span class="keyword">let</span> i     <span class="constant">:=</span> s.pos
14445   <span class="keyword">if</span> input.atEnd i <span class="keyword">then</span> s.mkEOIError
14446   <span class="keyword">else</span>
14447     <span class="keyword">let</span> curr <span class="constant">:=</span> input.get i
14448     <span class="keyword">let</span> i    <span class="constant">:=</span> input.next i
14449     <span class="keyword">if</span> curr.isDigit <span class="constant">||</span> ('a' <span class="constant">&lt;=</span> curr <span class="constant">&amp;&amp;</span> curr <span class="constant">&lt;=</span> 'f') <span class="constant">||</span> ('A' <span class="constant">&lt;=</span> curr <span class="constant">&amp;&amp;</span> curr <span class="constant">&lt;=</span> 'F') <span class="keyword">then</span> s.setPos i
14450     <span class="keyword">else</span> s.mkUnexpectedError <span class="string">"invalid hexadecimal numeral"</span>
14451 
<span class="keyword">14452 def</span> <span class="function-name">quotedCharCoreFn</span> (isQuotable : Char <span class="constant">&#8594;</span> Bool) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14453   <span class="keyword">let</span> input <span class="constant">:=</span> c.input
14454   <span class="keyword">let</span> i     <span class="constant">:=</span> s.pos
14455   <span class="keyword">if</span> input.atEnd i <span class="keyword">then</span> s.mkEOIError
14456   <span class="keyword">else</span>
14457     <span class="keyword">let</span> curr <span class="constant">:=</span> input.get i
14458     <span class="keyword">if</span> isQuotable curr <span class="keyword">then</span>
14459       s.next input i
14460     <span class="keyword">else</span> <span class="keyword">if</span> curr <span class="constant">==</span> 'x' <span class="keyword">then</span>
14461       andthenFn hexDigitFn hexDigitFn c (s.next input i)
14462     <span class="keyword">else</span> <span class="keyword">if</span> curr <span class="constant">==</span> 'u' <span class="keyword">then</span>
14463       andthenFn hexDigitFn (andthenFn hexDigitFn (andthenFn hexDigitFn hexDigitFn)) c (s.next input i)
14464     <span class="keyword">else</span>
14465       s.mkUnexpectedError <span class="string">"invalid escape sequence"</span>
14466 
<span class="keyword">14467 def</span> <span class="function-name">isQuotableCharDefault</span> (c : Char) : Bool <span class="constant">:=</span>
14468   c <span class="constant">==</span> '\\' <span class="constant">||</span> c <span class="constant">==</span> '\"' <span class="constant">||</span> c <span class="constant">==</span> '\'' <span class="constant">||</span> c <span class="constant">==</span> 'r' <span class="constant">||</span> c <span class="constant">==</span> 'n' <span class="constant">||</span> c <span class="constant">==</span> 't'
14469 
<span class="keyword">14470 def</span> <span class="function-name">quotedCharFn</span> : ParserFn <span class="constant">:=</span>
14471   quotedCharCoreFn isQuotableCharDefault
14472 
<span class="comment-delimiter">14473 /-</span><span class="comment">- Push `(Syntax.node tk &lt;new-atom&gt;)` into syntax stack -/</span>
<span class="keyword">14474 def</span> <span class="function-name">mkNodeToken</span> (n : SyntaxNodeKind) (startPos : Nat) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14475   <span class="keyword">let</span> input     <span class="constant">:=</span> c.input
14476   <span class="keyword">let</span> stopPos   <span class="constant">:=</span> s.pos
14477   <span class="keyword">let</span> leading   <span class="constant">:=</span> mkEmptySubstringAt input startPos
14478   <span class="keyword">let</span> val       <span class="constant">:=</span> input.extract startPos stopPos
14479   <span class="keyword">let</span> s         <span class="constant">:=</span> whitespace c s
14480   <span class="keyword">let</span> wsStopPos <span class="constant">:=</span> s.pos
14481   <span class="keyword">let</span> trailing  <span class="constant">:=</span> { str <span class="constant">:=</span> input, startPos <span class="constant">:=</span> stopPos, stopPos <span class="constant">:=</span> wsStopPos : Substring }
14482   <span class="keyword">let</span> info      <span class="constant">:=</span> SourceInfo.original leading startPos trailing
14483   s.pushSyntax (Syntax.mkLit n val info)
14484 
<span class="keyword">14485 def</span> <span class="function-name">charLitFnAux</span> (startPos : Nat) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14486   <span class="keyword">let</span> input <span class="constant">:=</span> c.input
14487   <span class="keyword">let</span> i     <span class="constant">:=</span> s.pos
14488   <span class="keyword">if</span> input.atEnd i <span class="keyword">then</span> s.mkEOIError
14489   <span class="keyword">else</span>
14490     <span class="keyword">let</span> curr <span class="constant">:=</span> input.get i
14491     <span class="keyword">let</span> s    <span class="constant">:=</span> s.setPos (input.next i)
14492     <span class="keyword">let</span> s    <span class="constant">:=</span> <span class="keyword">if</span> curr <span class="constant">==</span> '\\' <span class="keyword">then</span> quotedCharFn c s <span class="keyword">else</span> s
14493     <span class="keyword">if</span> s.hasError <span class="keyword">then</span> s
14494     <span class="keyword">else</span>
14495       <span class="keyword">let</span> i    <span class="constant">:=</span> s.pos
14496       <span class="keyword">let</span> curr <span class="constant">:=</span> input.get i
14497       <span class="keyword">let</span> s    <span class="constant">:=</span> s.setPos (input.next i)
14498       <span class="keyword">if</span> curr <span class="constant">==</span> '\'' <span class="keyword">then</span> mkNodeToken charLitKind startPos c s
14499       <span class="keyword">else</span> s.mkUnexpectedError <span class="string">"missing end of character literal"</span>
14500 
<span class="keyword">14501 partial</span> <span class="keyword">def</span> <span class="function-name">strLitFnAux</span> (startPos : Nat) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14502   <span class="keyword">let</span> input <span class="constant">:=</span> c.input
14503   <span class="keyword">let</span> i     <span class="constant">:=</span> s.pos
14504   <span class="keyword">if</span> input.atEnd i <span class="keyword">then</span> s.mkUnexpectedErrorAt <span class="string">"unterminated string literal"</span> startPos
14505   <span class="keyword">else</span>
14506     <span class="keyword">let</span> curr <span class="constant">:=</span> input.get i
14507     <span class="keyword">let</span> s    <span class="constant">:=</span> s.setPos (input.next i)
14508     <span class="keyword">if</span> curr <span class="constant">==</span> '\"' <span class="keyword">then</span>
14509       mkNodeToken strLitKind startPos c s
14510     <span class="keyword">else</span> <span class="keyword">if</span> curr <span class="constant">==</span> '\\' <span class="keyword">then</span> andthenFn quotedCharFn (strLitFnAux startPos) c s
14511     <span class="keyword">else</span> strLitFnAux startPos c s
14512 
<span class="keyword">14513 def</span> <span class="function-name">decimalNumberFn</span> (startPos : Nat) (c : ParserContext) : ParserState <span class="constant">&#8594;</span> ParserState <span class="constant">:=</span> <span class="keyword">fun</span> s <span class="constant">=&gt;</span>
14514   <span class="keyword">let</span> s     <span class="constant">:=</span> takeWhileFn (<span class="keyword">fun</span> c <span class="constant">=&gt;</span> c.isDigit) c s
14515   <span class="keyword">let</span> input <span class="constant">:=</span> c.input
14516   <span class="keyword">let</span> i     <span class="constant">:=</span> s.pos
14517   <span class="keyword">let</span> curr  <span class="constant">:=</span> input.get i
14518   <span class="keyword">if</span> curr <span class="constant">==</span> '.' <span class="constant">||</span> curr <span class="constant">==</span> 'e' <span class="constant">||</span> curr <span class="constant">==</span> 'E' <span class="keyword">then</span>
14519     <span class="keyword">let</span> s <span class="constant">:=</span> parseOptDot s
14520     <span class="keyword">let</span> s <span class="constant">:=</span> parseOptExp s
14521     mkNodeToken scientificLitKind startPos c s
14522   <span class="keyword">else</span>
14523     mkNodeToken numLitKind startPos c s
<span class="keyword">14524 where</span>
14525   parseOptDot s <span class="constant">:=</span>
14526     <span class="keyword">let</span> input <span class="constant">:=</span> c.input
14527     <span class="keyword">let</span> i     <span class="constant">:=</span> s.pos
14528     <span class="keyword">let</span> curr  <span class="constant">:=</span> input.get i
14529     <span class="keyword">if</span> curr <span class="constant">==</span> '.' <span class="keyword">then</span>
14530       <span class="keyword">let</span> i    <span class="constant">:=</span> input.next i
14531       <span class="keyword">let</span> curr <span class="constant">:=</span> input.get i
14532       <span class="keyword">if</span> curr.isDigit <span class="keyword">then</span>
14533         takeWhileFn (<span class="keyword">fun</span> c <span class="constant">=&gt;</span> c.isDigit) c (s.setPos i)
14534       <span class="keyword">else</span>
14535         s.setPos i
14536     <span class="keyword">else</span>
14537       s
14538 
14539   parseOptExp s <span class="constant">:=</span>
14540     <span class="keyword">let</span> input <span class="constant">:=</span> c.input
14541     <span class="keyword">let</span> i     <span class="constant">:=</span> s.pos
14542     <span class="keyword">let</span> curr  <span class="constant">:=</span> input.get i
14543     <span class="keyword">if</span> curr <span class="constant">==</span> 'e' <span class="constant">||</span> curr <span class="constant">==</span> 'E' <span class="keyword">then</span>
14544       <span class="keyword">let</span> i    <span class="constant">:=</span> input.next i
14545       <span class="keyword">let</span> i    <span class="constant">:=</span> <span class="keyword">if</span> input.get i <span class="constant">==</span> '<span class="constant">-</span>' <span class="keyword">then</span> input.next i <span class="keyword">else</span> i
14546       <span class="keyword">let</span> curr <span class="constant">:=</span> input.get i
14547       <span class="keyword">if</span> curr.isDigit <span class="keyword">then</span>
14548         takeWhileFn (<span class="keyword">fun</span> c <span class="constant">=&gt;</span> c.isDigit) c (s.setPos i)
14549       <span class="keyword">else</span>
14550         s.setPos i
14551     <span class="keyword">else</span>
14552       s
14553 
<span class="keyword">14554 def</span> <span class="function-name">binNumberFn</span> (startPos : Nat) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14555   <span class="keyword">let</span> s <span class="constant">:=</span> takeWhile1Fn (<span class="keyword">fun</span> c <span class="constant">=&gt;</span> c <span class="constant">==</span> '0' <span class="constant">||</span> c <span class="constant">==</span> '1') <span class="string">"binary number"</span> c s
14556   mkNodeToken numLitKind startPos c s
14557 
<span class="keyword">14558 def</span> <span class="function-name">octalNumberFn</span> (startPos : Nat) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14559   <span class="keyword">let</span> s <span class="constant">:=</span> takeWhile1Fn (<span class="keyword">fun</span> c <span class="constant">=&gt;</span> '0' <span class="constant">&#8804;</span> c <span class="constant">&amp;&amp;</span> c <span class="constant">&#8804;</span> '7') <span class="string">"octal number"</span> c s
14560   mkNodeToken numLitKind startPos c s
14561 
<span class="keyword">14562 def</span> <span class="function-name">hexNumberFn</span> (startPos : Nat) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14563   <span class="keyword">let</span> s <span class="constant">:=</span> takeWhile1Fn (<span class="keyword">fun</span> c <span class="constant">=&gt;</span> ('0' <span class="constant">&#8804;</span> c <span class="constant">&amp;&amp;</span> c <span class="constant">&#8804;</span> '9') <span class="constant">||</span> ('a' <span class="constant">&#8804;</span> c <span class="constant">&amp;&amp;</span> c <span class="constant">&#8804;</span> 'f') <span class="constant">||</span> ('A' <span class="constant">&#8804;</span> c <span class="constant">&amp;&amp;</span> c <span class="constant">&#8804;</span> 'F')) <span class="string">"hexadecimal number"</span> c s
14564   mkNodeToken numLitKind startPos c s
14565 
<span class="keyword">14566 def</span> <span class="function-name">numberFnAux</span> : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14567   <span class="keyword">let</span> input    <span class="constant">:=</span> c.input
14568   <span class="keyword">let</span> startPos <span class="constant">:=</span> s.pos
14569   <span class="keyword">if</span> input.atEnd startPos <span class="keyword">then</span> s.mkEOIError
14570   <span class="keyword">else</span>
14571     <span class="keyword">let</span> curr <span class="constant">:=</span> input.get startPos
14572     <span class="keyword">if</span> curr <span class="constant">==</span> '0' <span class="keyword">then</span>
14573       <span class="keyword">let</span> i    <span class="constant">:=</span> input.next startPos
14574       <span class="keyword">let</span> curr <span class="constant">:=</span> input.get i
14575       <span class="keyword">if</span> curr <span class="constant">==</span> 'b' <span class="constant">||</span> curr <span class="constant">==</span> 'B' <span class="keyword">then</span>
14576         binNumberFn startPos c (s.next input i)
14577       <span class="keyword">else</span> <span class="keyword">if</span> curr <span class="constant">==</span> 'o' <span class="constant">||</span> curr <span class="constant">==</span> 'O' <span class="keyword">then</span>
14578         octalNumberFn startPos c (s.next input i)
14579       <span class="keyword">else</span> <span class="keyword">if</span> curr <span class="constant">==</span> 'x' <span class="constant">||</span> curr <span class="constant">==</span> 'X' <span class="keyword">then</span>
14580         hexNumberFn startPos c (s.next input i)
14581       <span class="keyword">else</span>
14582         decimalNumberFn startPos c (s.setPos i)
14583     <span class="keyword">else</span> <span class="keyword">if</span> curr.isDigit <span class="keyword">then</span>
14584       decimalNumberFn startPos c (s.next input startPos)
14585     <span class="keyword">else</span>
14586       s.mkError <span class="string">"numeral"</span>
14587 
<span class="keyword">14588 def</span> <span class="function-name">isIdCont</span> : String <span class="constant">&#8594;</span> ParserState <span class="constant">&#8594;</span> Bool <span class="constant">:=</span> <span class="keyword">fun</span> input s <span class="constant">=&gt;</span>
14589   <span class="keyword">let</span> i    <span class="constant">:=</span> s.pos
14590   <span class="keyword">let</span> curr <span class="constant">:=</span> input.get i
14591   <span class="keyword">if</span> curr <span class="constant">==</span> '.' <span class="keyword">then</span>
14592     <span class="keyword">let</span> i <span class="constant">:=</span> input.next i
14593     <span class="keyword">if</span> input.atEnd i <span class="keyword">then</span>
14594       false
14595     <span class="keyword">else</span>
14596       <span class="keyword">let</span> curr <span class="constant">:=</span> input.get i
14597       isIdFirst curr <span class="constant">||</span> isIdBeginEscape curr
14598   <span class="keyword">else</span>
14599     false
14600 
<span class="keyword">14601 private</span> <span class="keyword">def</span> <span class="function-name">isToken</span> (idStartPos idStopPos : Nat) (tk : Option Token) : Bool <span class="constant">:=</span>
14602   <span class="keyword">match</span> tk <span class="keyword">with</span>
14603   | none    <span class="constant">=&gt;</span> false
14604   | some tk <span class="constant">=&gt;</span>
14605      <span class="comment-delimiter">-- </span><span class="comment">if a token is both a symbol and a valid identifier (i.e. a keyword),
</span>14606      <span class="comment-delimiter">-- </span><span class="comment">we want it to be recognized as a symbol
</span>14607     tk.bsize <span class="constant">&#8805;</span> idStopPos <span class="constant">-</span> idStartPos
14608 
14609 
<span class="keyword">14610 def</span> <span class="function-name">mkTokenAndFixPos</span> (startPos : Nat) (tk : Option Token) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14611   <span class="keyword">match</span> tk <span class="keyword">with</span>
14612   | none    <span class="constant">=&gt;</span> s.mkErrorAt <span class="string">"token"</span> startPos
14613   | some tk <span class="constant">=&gt;</span>
14614     <span class="keyword">if</span> c.forbiddenTk? <span class="constant">==</span> some tk <span class="keyword">then</span>
14615       s.mkErrorAt <span class="string">"forbidden token"</span> startPos
14616     <span class="keyword">else</span>
14617       <span class="keyword">let</span> input     <span class="constant">:=</span> c.input
14618       <span class="keyword">let</span> leading   <span class="constant">:=</span> mkEmptySubstringAt input startPos
14619       <span class="keyword">let</span> stopPos   <span class="constant">:=</span> startPos <span class="constant">+</span> tk.bsize
14620       <span class="keyword">let</span> s         <span class="constant">:=</span> s.setPos stopPos
14621       <span class="keyword">let</span> s         <span class="constant">:=</span> whitespace c s
14622       <span class="keyword">let</span> wsStopPos <span class="constant">:=</span> s.pos
14623       <span class="keyword">let</span> trailing  <span class="constant">:=</span> { str <span class="constant">:=</span> input, startPos <span class="constant">:=</span> stopPos, stopPos <span class="constant">:=</span> wsStopPos : Substring }
14624       <span class="keyword">let</span> atom      <span class="constant">:=</span> mkAtom (SourceInfo.original leading startPos trailing) tk
14625       s.pushSyntax atom
14626 
<span class="keyword">14627 def</span> <span class="function-name">mkIdResult</span> (startPos : Nat) (tk : Option Token) (val : Name) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14628   <span class="keyword">let</span> stopPos           <span class="constant">:=</span> s.pos
14629   <span class="keyword">if</span> isToken startPos stopPos tk <span class="keyword">then</span>
14630     mkTokenAndFixPos startPos tk c s
14631   <span class="keyword">else</span>
14632     <span class="keyword">let</span> input           <span class="constant">:=</span> c.input
14633     <span class="keyword">let</span> rawVal          <span class="constant">:=</span> { str <span class="constant">:=</span> input, startPos <span class="constant">:=</span> startPos, stopPos <span class="constant">:=</span> stopPos  : Substring }
14634     <span class="keyword">let</span> s               <span class="constant">:=</span> whitespace c s
14635     <span class="keyword">let</span> trailingStopPos <span class="constant">:=</span> s.pos
14636     <span class="keyword">let</span> leading         <span class="constant">:=</span> mkEmptySubstringAt input startPos
14637     <span class="keyword">let</span> trailing        <span class="constant">:=</span> { str <span class="constant">:=</span> input, startPos <span class="constant">:=</span> stopPos, stopPos <span class="constant">:=</span> trailingStopPos : Substring }
14638     <span class="keyword">let</span> info            <span class="constant">:=</span> SourceInfo.original leading startPos trailing
14639     <span class="keyword">let</span> atom            <span class="constant">:=</span> mkIdent info rawVal val
14640     s.pushSyntax atom
14641 
<span class="keyword">14642 partial</span> <span class="keyword">def</span> <span class="function-name">identFnAux</span> (startPos : Nat) (tk : Option Token) (r : Name) : ParserFn <span class="constant">:=</span>
14643   <span class="keyword">let</span> <span class="keyword">rec</span> parse (r : Name) (c s) <span class="constant">:=</span> <span class="keyword">do</span>
14644     <span class="keyword">let</span> input <span class="constant">:=</span> c.input
14645     <span class="keyword">let</span> i     <span class="constant">:=</span> s.pos
14646     <span class="keyword">if</span> input.atEnd i <span class="keyword">then</span>
14647       <span class="keyword">return</span> s.mkEOIError
14648     <span class="keyword">let</span> curr <span class="constant">:=</span> input.get i
14649     <span class="keyword">if</span> isIdBeginEscape curr <span class="keyword">then</span>
14650       <span class="keyword">let</span> startPart <span class="constant">:=</span> input.next i
14651       <span class="keyword">let</span> s         <span class="constant">:=</span> takeUntilFn isIdEndEscape c (s.setPos startPart)
14652       <span class="keyword">if</span> input.atEnd s.pos <span class="keyword">then</span>
14653         <span class="keyword">return</span> s.mkUnexpectedErrorAt <span class="string">"unterminated identifier escape"</span> startPart
14654       <span class="keyword">let</span> stopPart  <span class="constant">:=</span> s.pos
14655       <span class="keyword">let</span> s         <span class="constant">:=</span> s.next c.input s.pos
14656       <span class="keyword">let</span> r <span class="constant">:=</span> Name.mkStr r (input.extract startPart stopPart)
14657       <span class="keyword">if</span> isIdCont input s <span class="keyword">then</span>
14658         <span class="keyword">let</span> s <span class="constant">:=</span> s.next input s.pos
14659         parse r c s
14660       <span class="keyword">else</span>
14661         mkIdResult startPos tk r c s
14662     <span class="keyword">else</span> <span class="keyword">if</span> isIdFirst curr <span class="keyword">then</span>
14663       <span class="keyword">let</span> startPart <span class="constant">:=</span> i
14664       <span class="keyword">let</span> s         <span class="constant">:=</span> takeWhileFn isIdRest c (s.next input i)
14665       <span class="keyword">let</span> stopPart  <span class="constant">:=</span> s.pos
14666       <span class="keyword">let</span> r <span class="constant">:=</span> Name.mkStr r (input.extract startPart stopPart)
14667       <span class="keyword">if</span> isIdCont input s <span class="keyword">then</span>
14668         <span class="keyword">let</span> s <span class="constant">:=</span> s.next input s.pos
14669         parse r c s
14670       <span class="keyword">else</span>
14671         mkIdResult startPos tk r c s
14672     <span class="keyword">else</span>
14673       mkTokenAndFixPos startPos tk c s
14674   parse r
14675 
<span class="keyword">14676 private</span> <span class="keyword">def</span> <span class="function-name">isIdFirstOrBeginEscape</span> (c : Char) : Bool <span class="constant">:=</span>
14677   isIdFirst c <span class="constant">||</span> isIdBeginEscape c
14678 
<span class="keyword">14679 private</span> <span class="keyword">def</span> <span class="function-name">nameLitAux</span> (startPos : Nat) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14680   <span class="keyword">let</span> input <span class="constant">:=</span> c.input
14681   <span class="keyword">let</span> s     <span class="constant">:=</span> identFnAux startPos none Name.anonymous c (s.next input startPos)
14682   <span class="keyword">if</span> s.hasError <span class="keyword">then</span>
14683     s
14684   <span class="keyword">else</span>
14685     <span class="keyword">let</span> stx <span class="constant">:=</span> s.stxStack.back
14686     <span class="keyword">match</span> stx <span class="keyword">with</span>
14687     | Syntax.ident <span class="preprocessor">_</span> rawStr <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
14688       <span class="keyword">let</span> s <span class="constant">:=</span> s.popSyntax
14689       s.pushSyntax (Syntax.node nameLitKind <span class="constant">#</span>[mkAtomFrom stx rawStr.toString])
14690     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> s.mkError <span class="string">"invalid Name literal"</span>
14691 
<span class="keyword">14692 private</span> <span class="keyword">def</span> <span class="function-name">tokenFnAux</span> : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14693   <span class="keyword">let</span> input <span class="constant">:=</span> c.input
14694   <span class="keyword">let</span> i     <span class="constant">:=</span> s.pos
14695   <span class="keyword">let</span> curr  <span class="constant">:=</span> input.get i
14696   <span class="keyword">if</span> curr <span class="constant">==</span> '\"' <span class="keyword">then</span>
14697     strLitFnAux i c (s.next input i)
14698   <span class="keyword">else</span> <span class="keyword">if</span> curr <span class="constant">==</span> '\'' <span class="keyword">then</span>
14699     charLitFnAux i c (s.next input i)
14700   <span class="keyword">else</span> <span class="keyword">if</span> curr.isDigit <span class="keyword">then</span>
14701     numberFnAux c s
14702   <span class="keyword">else</span> <span class="keyword">if</span> curr <span class="constant">==</span> '`' <span class="constant">&amp;&amp;</span> isIdFirstOrBeginEscape (getNext input i) <span class="keyword">then</span>
14703     nameLitAux i c s
14704   <span class="keyword">else</span>
14705     <span class="keyword">let</span> (<span class="preprocessor">_</span>, tk) <span class="constant">:=</span> c.tokens.matchPrefix input i
14706     identFnAux i tk Name.anonymous c s
14707 
<span class="keyword">14708 private</span> <span class="keyword">def</span> <span class="function-name">updateCache</span> (startPos : Nat) (s : ParserState) : ParserState <span class="constant">:=</span>
14709   <span class="comment-delimiter">-- </span><span class="comment">do not cache token parsing errors, which are rare and usually fatal and thus not worth an extra field in `TokenCache`
</span>14710   <span class="keyword">match</span> s <span class="keyword">with</span>
14711   | &#10216;stack, lhsPrec, pos, cache, none&#10217; <span class="constant">=&gt;</span>
14712     <span class="keyword">if</span> stack.size <span class="constant">==</span> <span class="constant">0</span> <span class="keyword">then</span> s
14713     <span class="keyword">else</span>
14714       <span class="keyword">let</span> tk <span class="constant">:=</span> stack.back
14715       &#10216;stack, lhsPrec, pos, { tokenCache <span class="constant">:=</span> { startPos <span class="constant">:=</span> startPos, stopPos <span class="constant">:=</span> pos, token <span class="constant">:=</span> tk } }, none&#10217;
14716   | other <span class="constant">=&gt;</span> other
14717 
<span class="keyword">14718 def</span> <span class="function-name">tokenFn</span> (expected : List String <span class="constant">:=</span> []) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14719   <span class="keyword">let</span> input <span class="constant">:=</span> c.input
14720   <span class="keyword">let</span> i     <span class="constant">:=</span> s.pos
14721   <span class="keyword">if</span> input.atEnd i <span class="keyword">then</span> s.mkEOIError expected
14722   <span class="keyword">else</span>
14723     <span class="keyword">let</span> tkc <span class="constant">:=</span> s.cache.tokenCache
14724     <span class="keyword">if</span> tkc.startPos <span class="constant">==</span> i <span class="keyword">then</span>
14725       <span class="keyword">let</span> s <span class="constant">:=</span> s.pushSyntax tkc.token
14726       s.setPos tkc.stopPos
14727     <span class="keyword">else</span>
14728       <span class="keyword">let</span> s <span class="constant">:=</span> tokenFnAux c s
14729       updateCache i s
14730 
<span class="keyword">14731 def</span> <span class="function-name">peekTokenAux</span> (c : ParserContext) (s : ParserState) : ParserState <span class="constant">&#215;</span> Except ParserState Syntax <span class="constant">:=</span>
14732   <span class="keyword">let</span> iniSz  <span class="constant">:=</span> s.stackSize
14733   <span class="keyword">let</span> iniPos <span class="constant">:=</span> s.pos
14734   <span class="keyword">let</span> s      <span class="constant">:=</span> tokenFn [] c s
14735   <span class="keyword">if</span> <span class="keyword">let</span> some e <span class="constant">:=</span> s.errorMsg <span class="keyword">then</span> (s.restore iniSz iniPos, Except.error s)
14736   <span class="keyword">else</span>
14737     <span class="keyword">let</span> stx <span class="constant">:=</span> s.stxStack.back
14738     (s.restore iniSz iniPos, Except.ok stx)
14739 
<span class="keyword">14740 def</span> <span class="function-name">peekToken</span> (c : ParserContext) (s : ParserState) : ParserState <span class="constant">&#215;</span> Except ParserState Syntax <span class="constant">:=</span>
14741   <span class="keyword">let</span> tkc <span class="constant">:=</span> s.cache.tokenCache
14742   <span class="keyword">if</span> tkc.startPos <span class="constant">==</span> s.pos <span class="keyword">then</span>
14743     (s, Except.ok tkc.token)
14744   <span class="keyword">else</span>
14745     peekTokenAux c s
14746 
<span class="comment-delimiter">14747 /- </span><span class="comment">Treat keywords as identifiers. -/</span>
<span class="keyword">14748 def</span> <span class="function-name">rawIdentFn</span> : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14749   <span class="keyword">let</span> input <span class="constant">:=</span> c.input
14750   <span class="keyword">let</span> i     <span class="constant">:=</span> s.pos
14751   <span class="keyword">if</span> input.atEnd i <span class="keyword">then</span> s.mkEOIError
14752   <span class="keyword">else</span> identFnAux i none Name.anonymous c s
14753 
<span class="doc">14754 @[inline]</span> <span class="keyword">def</span> <span class="function-name">satisfySymbolFn</span> (p : String <span class="constant">&#8594;</span> Bool) (expected : List String) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14755   <span class="keyword">let</span> initStackSz <span class="constant">:=</span> s.stackSize
14756   <span class="keyword">let</span> startPos <span class="constant">:=</span> s.pos
14757   <span class="keyword">let</span> s        <span class="constant">:=</span> tokenFn expected c s
14758   <span class="keyword">if</span> s.hasError <span class="keyword">then</span>
14759     s
14760   <span class="keyword">else</span>
14761     <span class="keyword">match</span> s.stxStack.back <span class="keyword">with</span>
14762     | Syntax.atom <span class="preprocessor">_</span> sym <span class="constant">=&gt;</span> <span class="keyword">if</span> p sym <span class="keyword">then</span> s <span class="keyword">else</span> s.mkErrorsAt expected startPos initStackSz
14763     | <span class="preprocessor">_</span>                 <span class="constant">=&gt;</span> s.mkErrorsAt expected startPos initStackSz
14764 
<span class="keyword">14765 def</span> <span class="function-name">symbolFnAux</span> (sym : String) (errorMsg : String) : ParserFn <span class="constant">:=</span>
14766   satisfySymbolFn (<span class="keyword">fun</span> s <span class="constant">=&gt;</span> s <span class="constant">==</span> sym) [errorMsg]
14767 
<span class="keyword">14768 def</span> <span class="function-name">symbolInfo</span> (sym : String) : ParserInfo <span class="constant">:=</span> {
14769   collectTokens <span class="constant">:=</span> <span class="keyword">fun</span> tks <span class="constant">=&gt;</span> sym :: tks,
14770   firstTokens   <span class="constant">:=</span> FirstTokens.tokens [ sym ]
14771 }
14772 
<span class="doc">14773 @[inline]</span> <span class="keyword">def</span> <span class="function-name">symbolFn</span> (sym : String) : ParserFn <span class="constant">:=</span>
14774   symbolFnAux sym (<span class="string">"'"</span> <span class="constant">++</span> sym <span class="constant">++</span> <span class="string">"'"</span>)
14775 
<span class="doc">14776 @[inline]</span> <span class="keyword">def</span> <span class="function-name">symbolNoAntiquot</span> (sym : String) : Parser <span class="constant">:=</span>
14777   <span class="keyword">let</span> sym <span class="constant">:=</span> sym.trim
14778   { info <span class="constant">:=</span> symbolInfo sym,
14779     fn   <span class="constant">:=</span> symbolFn sym }
14780 
<span class="keyword">14781 def</span> <span class="function-name">checkTailNoWs</span> (prev : Syntax) : Bool <span class="constant">:=</span>
14782   <span class="keyword">match</span> prev.getTailInfo <span class="keyword">with</span>
14783   | SourceInfo.original <span class="preprocessor">_</span> <span class="preprocessor">_</span> trailing <span class="constant">=&gt;</span> trailing.stopPos <span class="constant">==</span> trailing.startPos
14784   | <span class="preprocessor">_</span>                                <span class="constant">=&gt;</span> false
14785 
<span class="comment-delimiter">14786 /-</span><span class="comment">- Check if the following token is the symbol _or_ identifier `sym`. Useful for
14787     parsing local tokens that have not been added to the token table (but may have
14788     been so by some unrelated code).
14789 
14790     For example, the universe `max` Function is parsed using this combinator so that
14791     it can still be used as an identifier outside of universes (but registering it
14792     as a token in a Term Syntax would not break the universe Parser). -/</span>
<span class="keyword">14793 def</span> <span class="function-name">nonReservedSymbolFnAux</span> (sym : String) (errorMsg : String) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14794   <span class="keyword">let</span> initStackSz <span class="constant">:=</span> s.stackSize
14795   <span class="keyword">let</span> startPos <span class="constant">:=</span> s.pos
14796   <span class="keyword">let</span> s <span class="constant">:=</span> tokenFn [errorMsg] c s
14797   <span class="keyword">if</span> s.hasError <span class="keyword">then</span> s
14798   <span class="keyword">else</span>
14799     <span class="keyword">match</span> s.stxStack.back <span class="keyword">with</span>
14800     | Syntax.atom <span class="preprocessor">_</span> sym' <span class="constant">=&gt;</span>
14801       <span class="keyword">if</span> sym <span class="constant">==</span> sym' <span class="keyword">then</span> s <span class="keyword">else</span> s.mkErrorAt errorMsg startPos initStackSz
14802     | Syntax.ident info rawVal <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
14803       <span class="keyword">if</span> sym <span class="constant">==</span> rawVal.toString <span class="keyword">then</span>
14804         <span class="keyword">let</span> s <span class="constant">:=</span> s.popSyntax
14805         s.pushSyntax (Syntax.atom info sym)
14806       <span class="keyword">else</span>
14807         s.mkErrorAt errorMsg startPos initStackSz
14808     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> s.mkErrorAt errorMsg startPos initStackSz
14809 
<span class="doc">14810 @[inline]</span> <span class="keyword">def</span> <span class="function-name">nonReservedSymbolFn</span> (sym : String) : ParserFn <span class="constant">:=</span>
14811   nonReservedSymbolFnAux sym (<span class="string">"'"</span> <span class="constant">++</span> sym <span class="constant">++</span> <span class="string">"'"</span>)
14812 
<span class="keyword">14813 def</span> <span class="function-name">nonReservedSymbolInfo</span> (sym : String) (includeIdent : Bool) : ParserInfo <span class="constant">:=</span> {
14814   firstTokens  <span class="constant">:=</span>
14815     <span class="keyword">if</span> includeIdent <span class="keyword">then</span>
14816       FirstTokens.tokens [ sym, <span class="string">"ident"</span> ]
14817     <span class="keyword">else</span>
14818       FirstTokens.tokens [ sym ]
14819 }
14820 
<span class="doc">14821 @[inline]</span> <span class="keyword">def</span> <span class="function-name">nonReservedSymbolNoAntiquot</span> (sym : String) (includeIdent <span class="constant">:=</span> false) : Parser <span class="constant">:=</span>
14822   <span class="keyword">let</span> sym <span class="constant">:=</span> sym.trim
14823   { info <span class="constant">:=</span> nonReservedSymbolInfo sym includeIdent,
14824     fn   <span class="constant">:=</span> nonReservedSymbolFn sym }
14825 
<span class="keyword">14826 partial</span> <span class="keyword">def</span> <span class="function-name">strAux</span> (sym : String) (errorMsg : String) (j : Nat) :ParserFn <span class="constant">:=</span>
14827   <span class="keyword">let</span> <span class="keyword">rec</span> parse (j c s) <span class="constant">:=</span>
14828     <span class="keyword">if</span> sym.atEnd j <span class="keyword">then</span> s
14829     <span class="keyword">else</span>
14830       <span class="keyword">let</span> i <span class="constant">:=</span> s.pos
14831       <span class="keyword">let</span> input <span class="constant">:=</span> c.input
14832       <span class="keyword">if</span> input.atEnd i <span class="constant">||</span> sym.get j <span class="constant">!=</span> input.get i <span class="keyword">then</span> s.mkError errorMsg
14833       <span class="keyword">else</span> parse (sym.next j) c (s.next input i)
14834   parse j
14835 
<span class="keyword">14836 def</span> <span class="function-name">checkTailWs</span> (prev : Syntax) : Bool <span class="constant">:=</span>
14837   <span class="keyword">match</span> prev.getTailInfo <span class="keyword">with</span>
14838   | SourceInfo.original <span class="preprocessor">_</span> <span class="preprocessor">_</span> trailing <span class="constant">=&gt;</span> trailing.stopPos <span class="constant">&gt;</span> trailing.startPos
14839   | <span class="preprocessor">_</span>                                <span class="constant">=&gt;</span> false
14840 
<span class="keyword">14841 def</span> <span class="function-name">checkWsBeforeFn</span> (errorMsg : String) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14842   <span class="keyword">let</span> prev <span class="constant">:=</span> s.stxStack.back
14843   <span class="keyword">if</span> checkTailWs prev <span class="keyword">then</span> s <span class="keyword">else</span> s.mkError errorMsg
14844 
<span class="keyword">14845 def</span> <span class="function-name">checkWsBefore</span> (errorMsg : String <span class="constant">:=</span> <span class="string">"space before"</span>) : Parser <span class="constant">:=</span> {
14846   info <span class="constant">:=</span> epsilonInfo,
14847   fn   <span class="constant">:=</span> checkWsBeforeFn errorMsg
14848 }
14849 
<span class="keyword">14850 def</span> <span class="function-name">checkTailLinebreak</span> (prev : Syntax) : Bool <span class="constant">:=</span>
14851   <span class="keyword">match</span> prev.getTailInfo <span class="keyword">with</span>
14852   | SourceInfo.original <span class="preprocessor">_</span> <span class="preprocessor">_</span> trailing <span class="constant">=&gt;</span> trailing.contains '\n'
14853   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> false
14854 
<span class="keyword">14855 def</span> <span class="function-name">checkLinebreakBeforeFn</span> (errorMsg : String) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14856   <span class="keyword">let</span> prev <span class="constant">:=</span> s.stxStack.back
14857   <span class="keyword">if</span> checkTailLinebreak prev <span class="keyword">then</span> s <span class="keyword">else</span> s.mkError errorMsg
14858 
<span class="keyword">14859 def</span> <span class="function-name">checkLinebreakBefore</span> (errorMsg : String <span class="constant">:=</span> <span class="string">"line break"</span>) : Parser <span class="constant">:=</span> {
14860   info <span class="constant">:=</span> epsilonInfo
14861   fn   <span class="constant">:=</span> checkLinebreakBeforeFn errorMsg
14862 }
14863 
<span class="keyword">14864 private</span> <span class="keyword">def</span> <span class="function-name">pickNonNone</span> (stack : Array Syntax) : Syntax <span class="constant">:=</span>
14865   <span class="keyword">match</span> stack.findRev? <span class="constant">$</span> <span class="keyword">fun</span> stx <span class="constant">=&gt;</span> <span class="constant">!</span>stx.isNone <span class="keyword">with</span>
14866   | none <span class="constant">=&gt;</span> Syntax.missing
14867   | some stx <span class="constant">=&gt;</span> stx
14868 
<span class="keyword">14869 def</span> <span class="function-name">checkNoWsBeforeFn</span> (errorMsg : String) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14870   <span class="keyword">let</span> prev <span class="constant">:=</span> pickNonNone s.stxStack
14871   <span class="keyword">if</span> checkTailNoWs prev <span class="keyword">then</span> s <span class="keyword">else</span> s.mkError errorMsg
14872 
<span class="keyword">14873 def</span> <span class="function-name">checkNoWsBefore</span> (errorMsg : String <span class="constant">:=</span> <span class="string">"no space before"</span>) : Parser <span class="constant">:=</span> {
14874   info <span class="constant">:=</span> epsilonInfo,
14875   fn   <span class="constant">:=</span> checkNoWsBeforeFn errorMsg
14876 }
14877 
<span class="keyword">14878 def</span> <span class="function-name">unicodeSymbolFnAux</span> (sym asciiSym : String) (expected : List String) : ParserFn <span class="constant">:=</span>
14879   satisfySymbolFn (<span class="keyword">fun</span> s <span class="constant">=&gt;</span> s <span class="constant">==</span> sym <span class="constant">||</span> s <span class="constant">==</span> asciiSym) expected
14880 
<span class="keyword">14881 def</span> <span class="function-name">unicodeSymbolInfo</span> (sym asciiSym : String) : ParserInfo <span class="constant">:=</span> {
14882   collectTokens <span class="constant">:=</span> <span class="keyword">fun</span> tks <span class="constant">=&gt;</span> sym :: asciiSym :: tks,
14883   firstTokens   <span class="constant">:=</span> FirstTokens.tokens [ sym, asciiSym ]
14884 }
14885 
<span class="doc">14886 @[inline]</span> <span class="keyword">def</span> <span class="function-name">unicodeSymbolFn</span> (sym asciiSym : String) : ParserFn <span class="constant">:=</span>
14887   unicodeSymbolFnAux sym asciiSym [<span class="string">"'"</span> <span class="constant">++</span> sym <span class="constant">++</span> <span class="string">"', '"</span> <span class="constant">++</span> asciiSym <span class="constant">++</span> <span class="string">"'"</span>]
14888 
<span class="doc">14889 @[inline]</span> <span class="keyword">def</span> <span class="function-name">unicodeSymbolNoAntiquot</span> (sym asciiSym : String) : Parser <span class="constant">:=</span>
14890   <span class="keyword">let</span> sym <span class="constant">:=</span> sym.trim
14891   <span class="keyword">let</span> asciiSym <span class="constant">:=</span> asciiSym.trim
14892   { info <span class="constant">:=</span> unicodeSymbolInfo sym asciiSym,
14893     fn   <span class="constant">:=</span> unicodeSymbolFn sym asciiSym }
14894 
<span class="keyword">14895 def</span> <span class="function-name">mkAtomicInfo</span> (k : String) : ParserInfo <span class="constant">:=</span>
14896   { firstTokens <span class="constant">:=</span> FirstTokens.tokens [ k ] }
14897 
<span class="keyword">14898 def</span> <span class="function-name">numLitFn</span> : ParserFn <span class="constant">:=</span>
14899   <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14900     <span class="keyword">let</span> initStackSz <span class="constant">:=</span> s.stackSize
14901     <span class="keyword">let</span> iniPos <span class="constant">:=</span> s.pos
14902     <span class="keyword">let</span> s      <span class="constant">:=</span> tokenFn [<span class="string">"numeral"</span>] c s
14903     <span class="keyword">if</span> <span class="constant">!</span>s.hasError <span class="constant">&amp;&amp;</span> <span class="constant">!</span>(s.stxStack.back.isOfKind numLitKind) <span class="keyword">then</span> s.mkErrorAt <span class="string">"numeral"</span> iniPos initStackSz <span class="keyword">else</span> s
14904 
<span class="doc">14905 @[inline]</span> <span class="keyword">def</span> <span class="function-name">numLitNoAntiquot</span> : Parser <span class="constant">:=</span> {
14906   fn   <span class="constant">:=</span> numLitFn,
14907   info <span class="constant">:=</span> mkAtomicInfo <span class="string">"numLit"</span>
14908 }
14909 
<span class="keyword">14910 def</span> <span class="function-name">scientificLitFn</span> : ParserFn <span class="constant">:=</span>
14911   <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14912     <span class="keyword">let</span> initStackSz <span class="constant">:=</span> s.stackSize
14913     <span class="keyword">let</span> iniPos <span class="constant">:=</span> s.pos
14914     <span class="keyword">let</span> s      <span class="constant">:=</span> tokenFn [<span class="string">"scientific number"</span>] c s
14915     <span class="keyword">if</span> <span class="constant">!</span>s.hasError <span class="constant">&amp;&amp;</span> <span class="constant">!</span>(s.stxStack.back.isOfKind scientificLitKind) <span class="keyword">then</span> s.mkErrorAt <span class="string">"scientific number"</span> iniPos initStackSz <span class="keyword">else</span> s
14916 
<span class="doc">14917 @[inline]</span> <span class="keyword">def</span> <span class="function-name">scientificLitNoAntiquot</span> : Parser <span class="constant">:=</span> {
14918   fn   <span class="constant">:=</span> scientificLitFn,
14919   info <span class="constant">:=</span> mkAtomicInfo <span class="string">"scientificLit"</span>
14920 }
14921 
<span class="keyword">14922 def</span> <span class="function-name">strLitFn</span> : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14923   <span class="keyword">let</span> initStackSz <span class="constant">:=</span> s.stackSize
14924   <span class="keyword">let</span> iniPos <span class="constant">:=</span> s.pos
14925   <span class="keyword">let</span> s <span class="constant">:=</span> tokenFn [<span class="string">"string literal"</span>] c s
14926   <span class="keyword">if</span> <span class="constant">!</span>s.hasError <span class="constant">&amp;&amp;</span> <span class="constant">!</span>(s.stxStack.back.isOfKind strLitKind) <span class="keyword">then</span> s.mkErrorAt <span class="string">"string literal"</span> iniPos initStackSz <span class="keyword">else</span> s
14927 
<span class="doc">14928 @[inline]</span> <span class="keyword">def</span> <span class="function-name">strLitNoAntiquot</span> : Parser <span class="constant">:=</span> {
14929   fn   <span class="constant">:=</span> strLitFn,
14930   info <span class="constant">:=</span> mkAtomicInfo <span class="string">"strLit"</span>
14931 }
14932 
<span class="keyword">14933 def</span> <span class="function-name">charLitFn</span> : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14934   <span class="keyword">let</span> initStackSz <span class="constant">:=</span> s.stackSize
14935   <span class="keyword">let</span> iniPos <span class="constant">:=</span> s.pos
14936   <span class="keyword">let</span> s <span class="constant">:=</span> tokenFn [<span class="string">"char literal"</span>] c s
14937   <span class="keyword">if</span> <span class="constant">!</span>s.hasError <span class="constant">&amp;&amp;</span> <span class="constant">!</span>(s.stxStack.back.isOfKind charLitKind) <span class="keyword">then</span> s.mkErrorAt <span class="string">"character literal"</span> iniPos initStackSz <span class="keyword">else</span> s
14938 
<span class="doc">14939 @[inline]</span> <span class="keyword">def</span> <span class="function-name">charLitNoAntiquot</span> : Parser <span class="constant">:=</span> {
14940   fn   <span class="constant">:=</span> charLitFn,
14941   info <span class="constant">:=</span> mkAtomicInfo <span class="string">"charLit"</span>
14942 }
14943 
<span class="keyword">14944 def</span> <span class="function-name">nameLitFn</span> : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14945   <span class="keyword">let</span> initStackSz <span class="constant">:=</span> s.stackSize
14946   <span class="keyword">let</span> iniPos <span class="constant">:=</span> s.pos
14947   <span class="keyword">let</span> s <span class="constant">:=</span> tokenFn [<span class="string">"Name literal"</span>] c s
14948   <span class="keyword">if</span> <span class="constant">!</span>s.hasError <span class="constant">&amp;&amp;</span> <span class="constant">!</span>(s.stxStack.back.isOfKind nameLitKind) <span class="keyword">then</span> s.mkErrorAt <span class="string">"Name literal"</span> iniPos initStackSz <span class="keyword">else</span> s
14949 
<span class="doc">14950 @[inline]</span> <span class="keyword">def</span> <span class="function-name">nameLitNoAntiquot</span> : Parser <span class="constant">:=</span> {
14951   fn   <span class="constant">:=</span> nameLitFn,
14952   info <span class="constant">:=</span> mkAtomicInfo <span class="string">"nameLit"</span>
14953 }
14954 
<span class="keyword">14955 def</span> <span class="function-name">identFn</span> : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14956   <span class="keyword">let</span> initStackSz <span class="constant">:=</span> s.stackSize
14957   <span class="keyword">let</span> iniPos <span class="constant">:=</span> s.pos
14958   <span class="keyword">let</span> s      <span class="constant">:=</span> tokenFn [<span class="string">"identifier"</span>] c s
14959   <span class="keyword">if</span> <span class="constant">!</span>s.hasError <span class="constant">&amp;&amp;</span> <span class="constant">!</span>(s.stxStack.back.isIdent) <span class="keyword">then</span> s.mkErrorAt <span class="string">"identifier"</span> iniPos initStackSz <span class="keyword">else</span> s
14960 
<span class="doc">14961 @[inline]</span> <span class="keyword">def</span> <span class="function-name">identNoAntiquot</span> : Parser <span class="constant">:=</span> {
14962   fn   <span class="constant">:=</span> identFn,
14963   info <span class="constant">:=</span> mkAtomicInfo <span class="string">"ident"</span>
14964 }
14965 
<span class="doc">14966 @[inline]</span> <span class="keyword">def</span> <span class="function-name">rawIdentNoAntiquot</span> : Parser <span class="constant">:=</span> {
14967   fn <span class="constant">:=</span> rawIdentFn
14968 }
14969 
<span class="keyword">14970 def</span> <span class="function-name">identEqFn</span> (id : Name) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
14971   <span class="keyword">let</span> initStackSz <span class="constant">:=</span> s.stackSize
14972   <span class="keyword">let</span> iniPos <span class="constant">:=</span> s.pos
14973   <span class="keyword">let</span> s      <span class="constant">:=</span> tokenFn [<span class="string">"identifier"</span>] c s
14974   <span class="keyword">if</span> s.hasError <span class="keyword">then</span>
14975     s
14976   <span class="keyword">else</span> <span class="keyword">match</span> s.stxStack.back <span class="keyword">with</span>
14977     | Syntax.ident <span class="preprocessor">_</span> <span class="preprocessor">_</span> val <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">if</span> val <span class="constant">!=</span> id <span class="keyword">then</span> s.mkErrorAt (<span class="string">"expected identifier '"</span> <span class="constant">++</span> toString id <span class="constant">++</span> <span class="string">"'"</span>) iniPos initStackSz <span class="keyword">else</span> s
14978     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> s.mkErrorAt <span class="string">"identifier"</span> iniPos initStackSz
14979 
<span class="doc">14980 @[inline]</span> <span class="keyword">def</span> <span class="function-name">identEq</span> (id : Name) : Parser <span class="constant">:=</span> {
14981   fn   <span class="constant">:=</span> identEqFn id,
14982   info <span class="constant">:=</span> mkAtomicInfo <span class="string">"ident"</span>
14983 }
14984 
<span class="keyword">14985 namespace</span> ParserState
14986 
<span class="keyword">14987 def</span> <span class="function-name">keepTop</span> (s : Array Syntax) (startStackSize : Nat) : Array Syntax <span class="constant">:=</span>
14988   <span class="keyword">let</span> node  <span class="constant">:=</span> s.back
14989   s.shrink startStackSize |<span class="constant">&gt;</span>.push node
14990 
<span class="keyword">14991 def</span> <span class="function-name">keepNewError</span> (s : ParserState) (oldStackSize : Nat) : ParserState <span class="constant">:=</span>
14992   <span class="keyword">match</span> s <span class="keyword">with</span>
14993   | &#10216;stack, lhsPrec, pos, cache, err&#10217; <span class="constant">=&gt;</span> &#10216;keepTop stack oldStackSize, lhsPrec, pos, cache, err&#10217;
14994 
<span class="keyword">14995 def</span> <span class="function-name">keepPrevError</span> (s : ParserState) (oldStackSize : Nat) (oldStopPos : String.Pos) (oldError : Option Error) : ParserState <span class="constant">:=</span>
14996   <span class="keyword">match</span> s <span class="keyword">with</span>
14997   | &#10216;stack, lhsPrec, <span class="preprocessor">_</span>, cache, <span class="preprocessor">_</span>&#10217; <span class="constant">=&gt;</span> &#10216;stack.shrink oldStackSize, lhsPrec, oldStopPos, cache, oldError&#10217;
14998 
<span class="keyword">14999 def</span> <span class="function-name">mergeErrors</span> (s : ParserState) (oldStackSize : Nat) (oldError : Error) : ParserState <span class="constant">:=</span>
15000   <span class="keyword">match</span> s <span class="keyword">with</span>
15001   | &#10216;stack, lhsPrec, pos, cache, some err&#10217; <span class="constant">=&gt;</span>
15002     <span class="keyword">if</span> oldError <span class="constant">==</span> err <span class="keyword">then</span> s
15003     <span class="keyword">else</span> &#10216;stack.shrink oldStackSize, lhsPrec, pos, cache, some (oldError.merge err)&#10217;
15004   | other                         <span class="constant">=&gt;</span> other
15005 
<span class="keyword">15006 def</span> <span class="function-name">keepLatest</span> (s : ParserState) (startStackSize : Nat) : ParserState <span class="constant">:=</span>
15007   <span class="keyword">match</span> s <span class="keyword">with</span>
15008   | &#10216;stack, lhsPrec, pos, cache, <span class="preprocessor">_</span>&#10217; <span class="constant">=&gt;</span> &#10216;keepTop stack startStackSize, lhsPrec, pos, cache, none&#10217;
15009 
<span class="keyword">15010 def</span> <span class="function-name">replaceLongest</span> (s : ParserState) (startStackSize : Nat) : ParserState <span class="constant">:=</span>
15011   s.keepLatest startStackSize
15012 
<span class="keyword">15013 end</span> ParserState
15014 
<span class="keyword">15015 def</span> <span class="function-name">invalidLongestMatchParser</span> (s : ParserState) : ParserState <span class="constant">:=</span>
15016   s.mkError <span class="string">"longestMatch parsers must generate exactly one Syntax node"</span>
15017 
<span class="comment-delimiter">15018 /-</span><span class="comment">-
15019  Auxiliary function used to execute parsers provided to `longestMatchFn`.
15020  Push `left?` into the stack if it is not `none`, and execute `p`.
15021 
15022  Remark: `p` must produce exactly one syntax node.
15023  Remark: the `left?` is not none when we are processing trailing parsers. -/</span>
<span class="keyword">15024 def</span> <span class="function-name">runLongestMatchParser</span> (left? : Option Syntax) (startLhsPrec : Nat) (p : ParserFn) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span> <span class="keyword">do</span>
15025   <span class="comment-delimiter">/-</span><span class="comment">
15026     We assume any registered parser `p` has one of two forms:
15027     * a direct call to `leadingParser` or `trailingParser`
15028     * a direct call to a (leading) token parser
15029     In the first case, we can extract the precedence of the parser by having `leadingParser/trailingParser`
15030     set `ParserState.lhsPrec` to it in the very end so that no nested parser can interfere.
15031     In the second case, the precedence is effectively `max` (there is a `checkPrec` merely for the convenience
15032     of the pretty printer) and there are no nested `leadingParser/trailingParser` calls, so the value of `lhsPrec`
15033     will not be changed by the parser (nor will it be read by any leading parser). Thus we initialize the field
15034     to `maxPrec` in the leading case. -/</span>
15035   <span class="keyword">let</span> <span class="keyword">mut</span> s <span class="constant">:=</span> { s <span class="keyword">with</span> lhsPrec <span class="constant">:=</span> <span class="keyword">if</span> left?.isSome <span class="keyword">then</span> startLhsPrec <span class="keyword">else</span> maxPrec }
15036   <span class="keyword">let</span> startSize <span class="constant">:=</span> s.stackSize
15037   <span class="keyword">if</span> <span class="keyword">let</span> some left <span class="constant">:=</span> left? <span class="keyword">then</span>
15038     s <span class="constant">:=</span> s.pushSyntax left
15039   s <span class="constant">:=</span> p c s
15040   <span class="comment-delimiter">-- </span><span class="comment">stack contains `[..., result ]`
</span>15041   <span class="keyword">if</span> s.stackSize <span class="constant">==</span> startSize <span class="constant">+</span> <span class="constant">1</span> <span class="keyword">then</span>
15042     s <span class="comment-delimiter">-- </span><span class="comment">success or error with the expected number of nodes
</span>15043   <span class="keyword">else</span> <span class="keyword">if</span> s.hasError <span class="keyword">then</span>
15044     <span class="comment-delimiter">-- </span><span class="comment">error with an unexpected number of nodes.
</span>15045     s.shrinkStack startSize |<span class="constant">&gt;</span>.pushSyntax Syntax.missing
15046   <span class="keyword">else</span>
15047     <span class="comment-delimiter">-- </span><span class="comment">parser succeded with incorrect number of nodes
</span>15048     invalidLongestMatchParser s
15049 
<span class="keyword">15050 def</span> <span class="function-name">longestMatchStep</span> (left? : Option Syntax) (startSize startLhsPrec : Nat) (startPos : String.Pos) (prevPrio : Nat) (prio : Nat) (p : ParserFn)
15051     : ParserContext <span class="constant">&#8594;</span> ParserState <span class="constant">&#8594;</span> ParserState <span class="constant">&#215;</span> Nat <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
15052   <span class="keyword">let</span> prevErrorMsg  <span class="constant">:=</span> s.errorMsg
15053   <span class="keyword">let</span> prevStopPos   <span class="constant">:=</span> s.pos
15054   <span class="keyword">let</span> prevSize      <span class="constant">:=</span> s.stackSize
15055   <span class="keyword">let</span> prevLhsPrec   <span class="constant">:=</span> s.lhsPrec
15056   <span class="keyword">let</span> s             <span class="constant">:=</span> s.restore prevSize startPos
15057   <span class="keyword">let</span> s             <span class="constant">:=</span> runLongestMatchParser left? startLhsPrec p c s
15058   <span class="keyword">match</span> prevErrorMsg, s.errorMsg <span class="keyword">with</span>
15059   | none, none   <span class="constant">=&gt;</span> <span class="comment-delimiter">-- </span><span class="comment">both succeeded
</span>15060     <span class="keyword">if</span> s.pos <span class="constant">&gt;</span> prevStopPos <span class="constant">||</span> (s.pos <span class="constant">==</span> prevStopPos <span class="constant">&amp;&amp;</span> prio <span class="constant">&gt;</span> prevPrio)      <span class="keyword">then</span> (s.replaceLongest startSize, prio)
15061     <span class="keyword">else</span> <span class="keyword">if</span> s.pos <span class="constant">&lt;</span> prevStopPos <span class="constant">||</span> (s.pos <span class="constant">==</span> prevStopPos <span class="constant">&amp;&amp;</span> prio <span class="constant">&lt;</span> prevPrio) <span class="keyword">then</span> ({ s.restore prevSize prevStopPos <span class="keyword">with</span> lhsPrec <span class="constant">:=</span> prevLhsPrec }, prevPrio) <span class="comment-delimiter">-- </span><span class="comment">keep prev
</span>15062     <span class="comment-delimiter">-- </span><span class="comment">it is not clear what the precedence of a choice node should be, so we conservatively take the minimum
</span>15063     <span class="keyword">else</span> ({s <span class="keyword">with</span> lhsPrec <span class="constant">:=</span> s.lhsPrec.min prevLhsPrec }, prio)
15064   | none, some <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="comment-delimiter">-- </span><span class="comment">prev succeeded, current failed
</span>15065     ({ s.restore prevSize prevStopPos <span class="keyword">with</span> lhsPrec <span class="constant">:=</span> prevLhsPrec }, prevPrio)
15066   | some oldError, some <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="comment-delimiter">-- </span><span class="comment">both failed
</span>15067     <span class="keyword">if</span> s.pos <span class="constant">&gt;</span> prevStopPos <span class="constant">||</span> (s.pos <span class="constant">==</span> prevStopPos <span class="constant">&amp;&amp;</span> prio <span class="constant">&gt;</span> prevPrio)      <span class="keyword">then</span> (s.keepNewError startSize, prio)
15068     <span class="keyword">else</span> <span class="keyword">if</span> s.pos <span class="constant">&lt;</span> prevStopPos <span class="constant">||</span> (s.pos <span class="constant">==</span> prevStopPos <span class="constant">&amp;&amp;</span> prio <span class="constant">&lt;</span> prevPrio) <span class="keyword">then</span> (s.keepPrevError prevSize prevStopPos prevErrorMsg, prevPrio)
15069     <span class="keyword">else</span> (s.mergeErrors prevSize oldError, prio)
15070   | some <span class="preprocessor">_</span>, none <span class="constant">=&gt;</span> <span class="comment-delimiter">-- </span><span class="comment">prev failed, current succeeded
</span>15071     <span class="keyword">let</span> successNode <span class="constant">:=</span> s.stxStack.back
15072     <span class="keyword">let</span> s           <span class="constant">:=</span> s.shrinkStack startSize <span class="comment-delimiter">-- </span><span class="comment">restore stack to initial size to make sure (failure) nodes are removed from the stack
</span>15073     (s.pushSyntax successNode, prio) <span class="comment-delimiter">-- </span><span class="comment">put successNode back on the stack
</span>15074 
<span class="keyword">15075 def</span> <span class="function-name">longestMatchMkResult</span> (startSize : Nat) (s : ParserState) : ParserState <span class="constant">:=</span>
15076   <span class="keyword">if</span> <span class="constant">!</span>s.hasError <span class="constant">&amp;&amp;</span> s.stackSize <span class="constant">&gt;</span> startSize <span class="constant">+</span> <span class="constant">1</span> <span class="keyword">then</span> s.mkNode choiceKind startSize <span class="keyword">else</span> s
15077 
<span class="keyword">15078 def</span> <span class="function-name">longestMatchFnAux</span> (left? : Option Syntax) (startSize startLhsPrec : Nat) (startPos : String.Pos) (prevPrio : Nat) (ps : List (Parser <span class="constant">&#215;</span> Nat)) : ParserFn <span class="constant">:=</span>
15079   <span class="keyword">let</span> <span class="keyword">rec</span> parse (prevPrio : Nat) (ps : List (Parser <span class="constant">&#215;</span> Nat)) <span class="constant">:=</span>
15080     <span class="keyword">match</span> ps <span class="keyword">with</span>
15081     | []    <span class="constant">=&gt;</span> <span class="keyword">fun</span> <span class="preprocessor">_</span> s <span class="constant">=&gt;</span> longestMatchMkResult startSize s
15082     | p::ps <span class="constant">=&gt;</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
15083       <span class="keyword">let</span> (s, prevPrio) <span class="constant">:=</span> longestMatchStep left? startSize startLhsPrec startPos prevPrio p.<span class="constant">2</span> p.<span class="constant">1</span>.fn c s
15084       parse prevPrio ps c s
15085   parse prevPrio ps
15086 
<span class="keyword">15087 def</span> <span class="function-name">longestMatchFn</span> (left? : Option Syntax) : List (Parser <span class="constant">&#215;</span> Nat) <span class="constant">&#8594;</span> ParserFn
15088   | []    <span class="constant">=&gt;</span> <span class="keyword">fun</span> <span class="preprocessor">_</span> s <span class="constant">=&gt;</span> s.mkError <span class="string">"longestMatch: empty list"</span>
15089   | [p]   <span class="constant">=&gt;</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span> runLongestMatchParser left? s.lhsPrec p.<span class="constant">1</span>.fn c s
15090   | p::ps <span class="constant">=&gt;</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
15091     <span class="keyword">let</span> startSize <span class="constant">:=</span> s.stackSize
15092     <span class="keyword">let</span> startLhsPrec <span class="constant">:=</span> s.lhsPrec
15093     <span class="keyword">let</span> startPos  <span class="constant">:=</span> s.pos
15094     <span class="keyword">let</span> s         <span class="constant">:=</span> runLongestMatchParser left? s.lhsPrec p.<span class="constant">1</span>.fn c s
15095     longestMatchFnAux left? startSize startLhsPrec startPos p.<span class="constant">2</span> ps c s
15096 
<span class="keyword">15097 def</span> <span class="function-name">anyOfFn</span> : List Parser <span class="constant">&#8594;</span> ParserFn
15098   | [],    <span class="preprocessor">_</span>, s <span class="constant">=&gt;</span> s.mkError <span class="string">"anyOf: empty list"</span>
15099   | [p],   c, s <span class="constant">=&gt;</span> p.fn c s
15100   | p::ps, c, s <span class="constant">=&gt;</span> orelseFn p.fn (anyOfFn ps) c s
15101 
<span class="doc">15102 @[inline]</span> <span class="keyword">def</span> <span class="function-name">checkColGeFn</span> (errorMsg : String) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
15103   <span class="keyword">match</span> c.savedPos? <span class="keyword">with</span>
15104   | none <span class="constant">=&gt;</span> s
15105   | some savedPos <span class="constant">=&gt;</span>
15106     <span class="keyword">let</span> savedPos <span class="constant">:=</span> c.fileMap.toPosition savedPos
15107     <span class="keyword">let</span> pos      <span class="constant">:=</span> c.fileMap.toPosition s.pos
15108     <span class="keyword">if</span> pos.column <span class="constant">&#8805;</span> savedPos.column <span class="keyword">then</span> s
15109     <span class="keyword">else</span> s.mkError errorMsg
15110 
<span class="doc">15111 @[inline]</span> <span class="keyword">def</span> <span class="function-name">checkColGe</span> (errorMsg : String <span class="constant">:=</span> <span class="string">"checkColGe"</span>) : Parser <span class="constant">:=</span>
15112   { fn <span class="constant">:=</span> checkColGeFn errorMsg }
15113 
<span class="doc">15114 @[inline]</span> <span class="keyword">def</span> <span class="function-name">checkColGtFn</span> (errorMsg : String) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
15115   <span class="keyword">match</span> c.savedPos? <span class="keyword">with</span>
15116   | none <span class="constant">=&gt;</span> s
15117   | some savedPos <span class="constant">=&gt;</span>
15118     <span class="keyword">let</span> savedPos <span class="constant">:=</span> c.fileMap.toPosition savedPos
15119     <span class="keyword">let</span> pos      <span class="constant">:=</span> c.fileMap.toPosition s.pos
15120     <span class="keyword">if</span> pos.column <span class="constant">&gt;</span> savedPos.column <span class="keyword">then</span> s
15121     <span class="keyword">else</span> s.mkError errorMsg
15122 
<span class="doc">15123 @[inline]</span> <span class="keyword">def</span> <span class="function-name">checkColGt</span> (errorMsg : String <span class="constant">:=</span> <span class="string">"checkColGt"</span>) : Parser <span class="constant">:=</span>
15124   { fn <span class="constant">:=</span> checkColGtFn errorMsg }
15125 
<span class="doc">15126 @[inline]</span> <span class="keyword">def</span> <span class="function-name">checkLineEqFn</span> (errorMsg : String) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
15127   <span class="keyword">match</span> c.savedPos? <span class="keyword">with</span>
15128   | none <span class="constant">=&gt;</span> s
15129   | some savedPos <span class="constant">=&gt;</span>
15130     <span class="keyword">let</span> savedPos <span class="constant">:=</span> c.fileMap.toPosition savedPos
15131     <span class="keyword">let</span> pos      <span class="constant">:=</span> c.fileMap.toPosition s.pos
15132     <span class="keyword">if</span> pos.line <span class="constant">==</span> savedPos.line <span class="keyword">then</span> s
15133     <span class="keyword">else</span> s.mkError errorMsg
15134 
<span class="doc">15135 @[inline]</span> <span class="keyword">def</span> <span class="function-name">checkLineEq</span> (errorMsg : String <span class="constant">:=</span> <span class="string">"checkLineEq"</span>) : Parser <span class="constant">:=</span>
15136   { fn <span class="constant">:=</span> checkLineEqFn errorMsg }
15137 
<span class="doc">15138 @[inline]</span> <span class="keyword">def</span> <span class="function-name">withPosition</span> (p : Parser) : Parser <span class="constant">:=</span> {
15139   info <span class="constant">:=</span> p.info,
15140   fn   <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
15141     p.fn { c <span class="keyword">with</span> savedPos? <span class="constant">:=</span> s.pos } s
15142 }
15143 
<span class="doc">15144 @[inline]</span> <span class="keyword">def</span> <span class="function-name">withoutPosition</span> (p : Parser) : Parser <span class="constant">:=</span> {
15145   info <span class="constant">:=</span> p.info,
15146   fn   <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
15147     <span class="keyword">let</span> pos <span class="constant">:=</span> c.fileMap.toPosition s.pos
15148     p.fn { c <span class="keyword">with</span> savedPos? <span class="constant">:=</span> none } s
15149 }
15150 
<span class="doc">15151 @[inline]</span> <span class="keyword">def</span> <span class="function-name">withForbidden</span> (tk : Token) (p : Parser) : Parser <span class="constant">:=</span> {
15152   info <span class="constant">:=</span> p.info,
15153   fn   <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span> p.fn { c <span class="keyword">with</span> forbiddenTk? <span class="constant">:=</span> tk } s
15154 }
15155 
<span class="doc">15156 @[inline]</span> <span class="keyword">def</span> <span class="function-name">withoutForbidden</span> (p : Parser) : Parser <span class="constant">:=</span> {
15157   info <span class="constant">:=</span> p.info,
15158   fn   <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span> p.fn { c <span class="keyword">with</span> forbiddenTk? <span class="constant">:=</span> none } s
15159 }
15160 
<span class="keyword">15161 def</span> <span class="function-name">eoiFn</span> : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
15162   <span class="keyword">let</span> i <span class="constant">:=</span> s.pos
15163   <span class="keyword">if</span> c.input.atEnd i <span class="keyword">then</span> s
15164   <span class="keyword">else</span> s.mkError <span class="string">"expected end of file"</span>
15165 
<span class="doc">15166 @[inline]</span> <span class="keyword">def</span> <span class="function-name">eoi</span> : Parser <span class="constant">:=</span>
15167   { fn <span class="constant">:=</span> eoiFn }
15168 
<span class="keyword">15169 open</span> Std (RBMap RBMap.empty)
15170 
<span class="comment-delimiter">15171 /-</span><span class="comment">- A multimap indexed by tokens. Used for indexing parsers by their leading token. -/</span>
<span class="keyword">15172 def</span> <span class="function-name">TokenMap</span> (&#945; : <span class="type">Type</span>) <span class="constant">:=</span> RBMap Name (List &#945;) Name.quickLt
15173 
<span class="keyword">15174 namespace</span> TokenMap
15175 
<span class="keyword">15176 def</span> <span class="function-name">insert</span> (map : TokenMap &#945;) (k : Name) (v : &#945;) : TokenMap &#945; <span class="constant">:=</span>
15177   <span class="keyword">match</span> map.find? k <span class="keyword">with</span>
15178   | none    <span class="constant">=&gt;</span> Std.RBMap.insert map k [v]
15179   | some vs <span class="constant">=&gt;</span> Std.RBMap.insert map k (v::vs)
15180 
<span class="keyword">15181 instance</span> <span class="function-name">:</span> Inhabited (TokenMap &#945;) <span class="constant">:=</span> &#10216;RBMap.empty&#10217;
15182 
<span class="keyword">15183 instance</span> <span class="function-name">:</span> EmptyCollection (TokenMap &#945;) <span class="constant">:=</span> &#10216;RBMap.empty&#10217;
15184 
<span class="keyword">15185 end</span> TokenMap
15186 
<span class="keyword">15187 structure</span> <span class="function-name">PrattParsingTables</span> <span class="keyword">where</span>
15188   leadingTable    : TokenMap (Parser <span class="constant">&#215;</span> Nat) <span class="constant">:=</span> {}
15189   leadingParsers  : List (Parser <span class="constant">&#215;</span> Nat) <span class="constant">:=</span> [] <span class="comment-delimiter">-- </span><span class="comment">for supporting parsers we cannot obtain first token
</span>15190   trailingTable   : TokenMap (Parser <span class="constant">&#215;</span> Nat) <span class="constant">:=</span> {}
15191   trailingParsers : List (Parser <span class="constant">&#215;</span> Nat) <span class="constant">:=</span> [] <span class="comment-delimiter">-- </span><span class="comment">for supporting parsers such as function application
</span>15192 
<span class="keyword">15193 instance</span> <span class="function-name">:</span> Inhabited PrattParsingTables <span class="constant">:=</span> &#10216;{}&#10217;
15194 
<span class="comment-delimiter">15195 /-</span><span class="comment">
15196   The type `leadingIdentBehavior` specifies how the parsing table
15197   lookup function behaves for identifiers.  The function `prattParser`
15198   uses two tables `leadingTable` and `trailingTable`. They map tokens
15199   to parsers.
15200 
15201   - `LeadingIdentBehavior.default`: if the leading token
15202     is an identifier, then `prattParser` just executes the parsers
15203     associated with the auxiliary token "ident".
15204 
15205   - `LeadingIdentBehavior.symbol`: if the leading token is
15206     an identifier `&lt;foo&gt;`, and there are parsers `P` associated with
15207     the toek `&lt;foo&gt;`, then it executes `P`. Otherwise, it executes
15208     only the parsers associated with the auxiliary token "ident".
15209 
15210   - `LeadingIdentBehavior.both`: if the leading token
15211     an identifier `&lt;foo&gt;`, the it executes the parsers associated
15212     with token `&lt;foo&gt;` and parsers associated with the auxiliary
15213     token "ident".
15214 
15215   We use `LeadingIdentBehavior.symbol` and `LeadingIdentBehavior.both`
15216   and `nonReservedSymbol` parser to implement the `tactic` parsers.
15217   The idea is to avoid creating a reserved symbol for each
15218   builtin tactic (e.g., `apply`, `assumption`, etc.).  That is, users
15219   may still use these symbols as identifiers (e.g., naming a
15220   function).
15221 -/</span>
15222 
<span class="keyword">15223 inductive</span> <span class="function-name">LeadingIdentBehavior</span> <span class="keyword">where</span>
15224   | default
15225   | symbol
15226   | both
15227   <span class="keyword">deriving</span> Inhabited, BEq
15228 
15229 
<span class="comment-delimiter">15230 /-</span><span class="comment">-
15231   Each parser category is implemented using a Pratt's parser.
15232   The system comes equipped with the following categories: `level`, `term`, `tactic`, and `command`.
15233   Users and plugins may define extra categories.
15234 
15235   The method
15236   ```
15237   categoryParser `term prec
15238   ```
15239   executes the Pratt's parser for category `term` with precedence `prec`.
15240   That is, only parsers with precedence at least `prec` are considered.
15241   The method `termParser prec` is equivalent to the method above.
15242 -/</span>
<span class="keyword">15243 structure</span> <span class="function-name">ParserCategory</span> <span class="keyword">where</span>
15244   tables   : PrattParsingTables
15245   behavior : LeadingIdentBehavior
15246   <span class="keyword">deriving</span> Inhabited
15247 
<span class="keyword">15248 abbrev</span> ParserCategories <span class="constant">:=</span> Std.PersistentHashMap Name ParserCategory
15249 
<span class="keyword">15250 def</span> <span class="function-name">indexed</span> {&#945; : <span class="type">Type</span>} (map : TokenMap &#945;) (c : ParserContext) (s : ParserState) (behavior : LeadingIdentBehavior) : ParserState <span class="constant">&#215;</span> List &#945; <span class="constant">:=</span>
15251   <span class="keyword">let</span> (s, stx) <span class="constant">:=</span> peekToken c s
15252   <span class="keyword">let</span> find (n : Name) : ParserState <span class="constant">&#215;</span> List &#945; <span class="constant">:=</span>
15253     <span class="keyword">match</span> map.find? n <span class="keyword">with</span>
15254     | some as <span class="constant">=&gt;</span> (s, as)
15255     | <span class="preprocessor">_</span>       <span class="constant">=&gt;</span> (s, [])
15256   <span class="keyword">match</span> stx <span class="keyword">with</span>
15257   | Except.ok (Syntax.atom <span class="preprocessor">_</span> sym)      <span class="constant">=&gt;</span> find (Name.mkSimple sym)
15258   | Except.ok (Syntax.ident <span class="preprocessor">_</span> <span class="preprocessor">_</span> val <span class="preprocessor">_</span>) <span class="constant">=&gt;</span>
15259     <span class="keyword">match</span> behavior <span class="keyword">with</span>
15260     | LeadingIdentBehavior.default <span class="constant">=&gt;</span> find identKind
15261     | LeadingIdentBehavior.symbol <span class="constant">=&gt;</span>
15262       <span class="keyword">match</span> map.find? val <span class="keyword">with</span>
15263       | some as <span class="constant">=&gt;</span> (s, as)
15264       | none    <span class="constant">=&gt;</span> find identKind
15265     | LeadingIdentBehavior.both <span class="constant">=&gt;</span>
15266       <span class="keyword">match</span> map.find? val <span class="keyword">with</span>
15267       | some as <span class="constant">=&gt;</span> <span class="keyword">match</span> map.find? identKind <span class="keyword">with</span>
15268         | some as' <span class="constant">=&gt;</span> (s, as <span class="constant">++</span> as')
15269         | <span class="preprocessor">_</span>        <span class="constant">=&gt;</span> (s, as)
15270       | none    <span class="constant">=&gt;</span> find identKind
15271   | Except.ok (Syntax.node k <span class="preprocessor">_</span>)        <span class="constant">=&gt;</span> find k
15272   | Except.ok <span class="preprocessor">_</span>                        <span class="constant">=&gt;</span> (s, [])
15273   | Except.error s'                    <span class="constant">=&gt;</span> (s', [])
15274 
<span class="keyword">15275 abbrev</span> CategoryParserFn <span class="constant">:=</span> Name <span class="constant">&#8594;</span> ParserFn
15276 
<span class="keyword">15277 builtin_initialize</span> categoryParserFnRef : IO.Ref CategoryParserFn &#8592; IO.mkRef <span class="keyword">fun</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> whitespace
15278 
<span class="keyword">15279 builtin_initialize</span> categoryParserFnExtension : EnvExtension CategoryParserFn &#8592; registerEnvExtension <span class="constant">$</span> categoryParserFnRef.get
15280 
<span class="keyword">15281 def</span> <span class="function-name">categoryParserFn</span> (catName : Name) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> ctx s <span class="constant">=&gt;</span>
15282   categoryParserFnExtension.getState ctx.env catName ctx s
15283 
<span class="keyword">15284 def</span> <span class="function-name">categoryParser</span> (catName : Name) (prec : Nat) : Parser <span class="constant">:=</span> {
15285   fn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span> categoryParserFn catName { c <span class="keyword">with</span> prec <span class="constant">:=</span> prec } s
15286 }
15287 
<span class="comment-delimiter">15288 -- </span><span class="comment">Define `termParser` here because we need it for antiquotations
</span><span class="doc">15289 @[inline]</span> <span class="keyword">def</span> <span class="function-name">termParser</span> (prec : Nat <span class="constant">:=</span> <span class="constant">0</span>) : Parser <span class="constant">:=</span>
15290   categoryParser `term prec
15291 
<span class="comment-delimiter">15292 /- </span><span class="comment">============== -/</span>
<span class="comment-delimiter">15293 /- </span><span class="comment">Antiquotations -/</span>
<span class="comment-delimiter">15294 /- </span><span class="comment">============== -/</span>
15295 
<span class="comment-delimiter">15296 /-</span><span class="comment">- Fail if previous token is immediately followed by ':'. -/</span>
<span class="keyword">15297 def</span> <span class="function-name">checkNoImmediateColon</span> : Parser <span class="constant">:=</span> {
15298   fn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
15299     <span class="keyword">let</span> prev <span class="constant">:=</span> s.stxStack.back
15300     <span class="keyword">if</span> checkTailNoWs prev <span class="keyword">then</span>
15301       <span class="keyword">let</span> input <span class="constant">:=</span> c.input
15302       <span class="keyword">let</span> i     <span class="constant">:=</span> s.pos
15303       <span class="keyword">if</span> input.atEnd i <span class="keyword">then</span> s
15304       <span class="keyword">else</span>
15305         <span class="keyword">let</span> curr <span class="constant">:=</span> input.get i
15306         <span class="keyword">if</span> curr <span class="constant">==</span> ':' <span class="keyword">then</span>
15307           s.mkUnexpectedError <span class="string">"unexpected ':'"</span>
15308         <span class="keyword">else</span> s
15309     <span class="keyword">else</span> s
15310 }
15311 
<span class="keyword">15312 def</span> <span class="function-name">setExpectedFn</span> (expected : List String) (p : ParserFn) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
15313   <span class="keyword">match</span> p c s <span class="keyword">with</span>
15314     | s'<span class="constant">@</span>{ errorMsg <span class="constant">:=</span> some msg, .. } <span class="constant">=&gt;</span> { s' <span class="keyword">with</span> errorMsg <span class="constant">:=</span> some { msg <span class="keyword">with</span> expected <span class="constant">:=</span> [] } }
15315     | s'                              <span class="constant">=&gt;</span> s'
15316 
<span class="keyword">15317 def</span> <span class="function-name">setExpected</span> (expected : List String) (p : Parser) : Parser <span class="constant">:=</span>
15318   { fn <span class="constant">:=</span> setExpectedFn expected p.fn, info <span class="constant">:=</span> p.info }
15319 
<span class="keyword">15320 def</span> <span class="function-name">pushNone</span> : Parser <span class="constant">:=</span>
15321   { fn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span> s.pushSyntax mkNullNode }
15322 
<span class="comment-delimiter">15323 -- </span><span class="comment">We support two kinds of antiquotations: `$id` and `$(t)`, where `id` is a term identifier and `t` is a term.
</span><span class="keyword">15324 def</span> <span class="function-name">antiquotNestedExpr</span> : Parser <span class="constant">:=</span> node `antiquotNestedExpr (symbolNoAntiquot <span class="string">"("</span> <span class="constant">&gt;&gt;</span> toggleInsideQuot termParser <span class="constant">&gt;&gt;</span> symbolNoAntiquot <span class="string">")"</span>)
<span class="keyword">15325 def</span> <span class="function-name">antiquotExpr</span> : Parser       <span class="constant">:=</span> identNoAntiquot <span class="constant">&lt;</span>|<span class="constant">&gt;</span> antiquotNestedExpr
15326 
<span class="doc">15327 @[inline]</span> <span class="keyword">def</span> <span class="function-name">tokenWithAntiquotFn</span> (p : ParserFn) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span> <span class="keyword">do</span>
15328   <span class="keyword">let</span> s <span class="constant">:=</span> p c s
15329   <span class="keyword">if</span> s.hasError <span class="keyword">then</span>
15330     <span class="keyword">return</span> s
15331   <span class="keyword">let</span> iniSz  <span class="constant">:=</span> s.stackSize
15332   <span class="keyword">let</span> iniPos <span class="constant">:=</span> s.pos
15333   <span class="keyword">let</span> s      <span class="constant">:=</span> (checkNoWsBefore <span class="constant">&gt;&gt;</span> symbolNoAntiquot <span class="string">"%"</span> <span class="constant">&gt;&gt;</span> symbolNoAntiquot <span class="string">"$"</span> <span class="constant">&gt;&gt;</span> checkNoWsBefore <span class="constant">&gt;&gt;</span> antiquotExpr).fn c s
15334   <span class="keyword">if</span> s.hasError <span class="keyword">then</span>
15335     <span class="keyword">return</span> s.restore iniSz iniPos
15336   s.mkNode (`token_antiquot) (iniSz <span class="constant">-</span> <span class="constant">1</span>)
15337 
<span class="doc">15338 @[inline]</span> <span class="keyword">def</span> <span class="function-name">tokenWithAntiquot</span> (p : Parser) : Parser <span class="keyword">where</span>
15339   fn   <span class="constant">:=</span> tokenWithAntiquotFn p.fn
15340   info <span class="constant">:=</span> p.info
15341 
<span class="doc">15342 @[inline]</span> <span class="keyword">def</span> <span class="function-name">symbol</span> (sym : String) : Parser <span class="constant">:=</span>
15343   tokenWithAntiquot (symbolNoAntiquot sym)
15344 
<span class="keyword">15345 instance</span> <span class="function-name">:</span> Coe String Parser <span class="constant">:=</span> &#10216;<span class="keyword">fun</span> s <span class="constant">=&gt;</span> symbol s &#10217;
15346 
<span class="doc">15347 @[inline]</span> <span class="keyword">def</span> <span class="function-name">nonReservedSymbol</span> (sym : String) (includeIdent <span class="constant">:=</span> false) : Parser <span class="constant">:=</span>
15348   tokenWithAntiquot (nonReservedSymbolNoAntiquot sym includeIdent)
15349 
<span class="doc">15350 @[inline]</span> <span class="keyword">def</span> <span class="function-name">unicodeSymbol</span> (sym asciiSym : String) : Parser <span class="constant">:=</span>
15351   tokenWithAntiquot (unicodeSymbolNoAntiquot sym asciiSym)
15352 
<span class="comment-delimiter">15353 /-</span><span class="comment">-
15354   Define parser for `$e` (if anonymous == true) and `$e:name`. Both
15355   forms can also be used with an appended `*` to turn them into an
15356   antiquotation "splice". If `kind` is given, it will additionally be checked
15357   when evaluating `match_syntax`. Antiquotations can be escaped as in `$$e`, which
15358   produces the syntax tree for `$e`. -/</span>
<span class="keyword">15359 def</span> <span class="function-name">mkAntiquot</span> (name : String) (kind : Option SyntaxNodeKind) (anonymous <span class="constant">:=</span> true) : Parser <span class="constant">:=</span>
15360   <span class="keyword">let</span> kind <span class="constant">:=</span> (kind.getD Name.anonymous) <span class="constant">++</span> `antiquot
15361   <span class="keyword">let</span> nameP <span class="constant">:=</span> node `antiquotName <span class="constant">$</span> checkNoWsBefore (<span class="string">"no space before ':"</span> <span class="constant">++</span> name <span class="constant">++</span> <span class="string">"'"</span>) <span class="constant">&gt;&gt;</span> symbol <span class="string">":"</span> <span class="constant">&gt;&gt;</span> nonReservedSymbol name
15362   <span class="comment-delimiter">-- </span><span class="comment">if parsing the kind fails and `anonymous` is true, check that we're not ignoring a different
</span>15363   <span class="comment-delimiter">-- </span><span class="comment">antiquotation kind via `noImmediateColon`
</span>15364   <span class="keyword">let</span> nameP <span class="constant">:=</span> <span class="keyword">if</span> anonymous <span class="keyword">then</span> nameP <span class="constant">&lt;</span>|<span class="constant">&gt;</span> checkNoImmediateColon <span class="constant">&gt;&gt;</span> pushNone <span class="keyword">else</span> nameP
15365   <span class="comment-delimiter">-- </span><span class="comment">antiquotations are not part of the "standard" syntax, so hide "expected '$'" on error
</span>15366   leadingNode kind maxPrec <span class="constant">$</span> atomic <span class="constant">$</span>
15367     setExpected [] <span class="string">"$"</span> <span class="constant">&gt;&gt;</span>
15368     manyNoAntiquot (checkNoWsBefore <span class="string">""</span> <span class="constant">&gt;&gt;</span> <span class="string">"$"</span>) <span class="constant">&gt;&gt;</span>
15369     checkNoWsBefore <span class="string">"no space before spliced term"</span> <span class="constant">&gt;&gt;</span> antiquotExpr <span class="constant">&gt;&gt;</span>
15370     nameP
15371 
<span class="keyword">15372 def</span> <span class="function-name">tryAnti</span> (c : ParserContext) (s : ParserState) : Bool <span class="constant">:=</span>
15373   <span class="keyword">let</span> (s, stx) <span class="constant">:=</span> peekToken c s
15374   <span class="keyword">match</span> stx <span class="keyword">with</span>
15375   | Except.ok stx<span class="constant">@</span>(Syntax.atom <span class="preprocessor">_</span> sym) <span class="constant">=&gt;</span> sym <span class="constant">==</span> <span class="string">"$"</span>
15376   | <span class="preprocessor">_</span>                                 <span class="constant">=&gt;</span> false
15377 
<span class="doc">15378 @[inline]</span> <span class="keyword">def</span> <span class="function-name">withAntiquotFn</span> (antiquotP p : ParserFn) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
15379   <span class="keyword">if</span> tryAnti c s <span class="keyword">then</span> orelseFn antiquotP p c s <span class="keyword">else</span> p c s
15380 
<span class="comment-delimiter">15381 /-</span><span class="comment">- Optimized version of `mkAntiquot ... &lt;|&gt; p`. -/</span>
<span class="doc">15382 @[inline]</span> <span class="keyword">def</span> <span class="function-name">withAntiquot</span> (antiquotP p : Parser) : Parser <span class="constant">:=</span> {
15383   fn <span class="constant">:=</span> withAntiquotFn antiquotP.fn p.fn,
15384   info <span class="constant">:=</span> orelseInfo antiquotP.info p.info
15385 }
15386 
<span class="keyword">15387 def</span> <span class="function-name">withoutInfo</span> (p : Parser) : Parser <span class="constant">:=</span>
15388   { fn <span class="constant">:=</span> p.fn }
15389 
<span class="comment-delimiter">15390 /-</span><span class="comment">- Parse `$[p]suffix`, e.g. `$[p],*`. -/</span>
<span class="keyword">15391 def</span> <span class="function-name">mkAntiquotSplice</span> (kind : SyntaxNodeKind) (p suffix : Parser) : Parser <span class="constant">:=</span>
15392   <span class="keyword">let</span> kind <span class="constant">:=</span> kind <span class="constant">++</span> `antiquot_scope
15393   leadingNode kind maxPrec <span class="constant">$</span> atomic <span class="constant">$</span>
15394     setExpected [] <span class="string">"$"</span> <span class="constant">&gt;&gt;</span>
15395     manyNoAntiquot (checkNoWsBefore <span class="string">""</span> <span class="constant">&gt;&gt;</span> <span class="string">"$"</span>) <span class="constant">&gt;&gt;</span>
15396     checkNoWsBefore <span class="string">"no space before spliced term"</span> <span class="constant">&gt;&gt;</span> symbol <span class="string">"["</span> <span class="constant">&gt;&gt;</span> node nullKind p <span class="constant">&gt;&gt;</span> symbol <span class="string">"]"</span> <span class="constant">&gt;&gt;</span>
15397     suffix
15398 
<span class="doc">15399 @[inline]</span> <span class="keyword">def</span> <span class="function-name">withAntiquotSuffixSpliceFn</span> (kind : SyntaxNodeKind) (p suffix : ParserFn) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span> <span class="keyword">do</span>
15400   <span class="keyword">let</span> s <span class="constant">:=</span> p c s
15401   <span class="keyword">if</span> s.hasError <span class="constant">||</span> <span class="constant">!</span>s.stxStack.back.isAntiquot <span class="keyword">then</span>
15402     <span class="keyword">return</span> s
15403   <span class="keyword">let</span> iniSz  <span class="constant">:=</span> s.stackSize
15404   <span class="keyword">let</span> iniPos <span class="constant">:=</span> s.pos
15405   <span class="keyword">let</span> s      <span class="constant">:=</span> suffix c s
15406   <span class="keyword">if</span> s.hasError <span class="keyword">then</span>
15407     <span class="keyword">return</span> s.restore iniSz iniPos
15408   s.mkNode (kind <span class="constant">++</span> `antiquot_suffix_splice) (s.stxStack.size <span class="constant">-</span> <span class="constant">2</span>)
15409 
<span class="comment-delimiter">15410 /-</span><span class="comment">- Parse `suffix` after an antiquotation, e.g. `$x,*`, and put both into a new node. -/</span>
<span class="doc">15411 @[inline]</span> <span class="keyword">def</span> <span class="function-name">withAntiquotSuffixSplice</span> (kind : SyntaxNodeKind) (p suffix : Parser) : Parser <span class="constant">:=</span> {
15412   info <span class="constant">:=</span> andthenInfo p.info suffix.info,
15413   fn   <span class="constant">:=</span> withAntiquotSuffixSpliceFn kind p.fn suffix.fn
15414 }
15415 
<span class="keyword">15416 def</span> <span class="function-name">withAntiquotSpliceAndSuffix</span> (kind : SyntaxNodeKind) (p suffix : Parser) <span class="constant">:=</span>
15417   <span class="comment-delimiter">-- </span><span class="comment">prevent `p`'s info from being collected twice
</span>15418   withAntiquot (mkAntiquotSplice kind (withoutInfo p) suffix) (withAntiquotSuffixSplice kind p suffix)
15419 
<span class="keyword">15420 def</span> <span class="function-name">nodeWithAntiquot</span> (name : String) (kind : SyntaxNodeKind) (p : Parser) (anonymous <span class="constant">:=</span> false) : Parser <span class="constant">:=</span>
15421   withAntiquot (mkAntiquot name kind anonymous) <span class="constant">$</span> node kind p
15422 
<span class="comment-delimiter">15423 /- </span><span class="comment">===================== -/</span>
<span class="comment-delimiter">15424 /- </span><span class="comment">End of Antiquotations -/</span>
<span class="comment-delimiter">15425 /- </span><span class="comment">===================== -/</span>
15426 
<span class="keyword">15427 def</span> <span class="function-name">sepByElemParser</span> (p : Parser) (sep : String) : Parser <span class="constant">:=</span>
15428   withAntiquotSpliceAndSuffix `sepBy p (symbol (sep.trim <span class="constant">++</span> <span class="string">"*"</span>))
15429 
<span class="keyword">15430 def</span> <span class="function-name">sepBy</span> (p : Parser) (sep : String) (psep : Parser <span class="constant">:=</span> symbol sep) (allowTrailingSep : Bool <span class="constant">:=</span> false) : Parser <span class="constant">:=</span>
15431   sepByNoAntiquot (sepByElemParser p sep) psep allowTrailingSep
15432 
<span class="keyword">15433 def</span> <span class="function-name">sepBy1</span> (p : Parser) (sep : String) (psep : Parser <span class="constant">:=</span> symbol sep) (allowTrailingSep : Bool <span class="constant">:=</span> false) : Parser <span class="constant">:=</span>
15434   sepBy1NoAntiquot (sepByElemParser p sep) psep allowTrailingSep
15435 
<span class="keyword">15436 def</span> <span class="function-name">categoryParserOfStackFn</span> (offset : Nat) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> ctx s <span class="constant">=&gt;</span>
15437   <span class="keyword">let</span> stack <span class="constant">:=</span> s.stxStack
15438   <span class="keyword">if</span> stack.size <span class="constant">&lt;</span> offset <span class="constant">+</span> <span class="constant">1</span> <span class="keyword">then</span>
15439     s.mkUnexpectedError (<span class="string">"failed to determine parser category using syntax stack, stack is too small"</span>)
15440   <span class="keyword">else</span>
15441     <span class="keyword">match</span> stack.get<span class="constant">!</span> (stack.size <span class="constant">-</span> offset <span class="constant">-</span> <span class="constant">1</span>) <span class="keyword">with</span>
15442     | Syntax.ident <span class="preprocessor">_</span> <span class="preprocessor">_</span> catName <span class="preprocessor">_</span> <span class="constant">=&gt;</span> categoryParserFn catName ctx s
15443     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> s.mkUnexpectedError (<span class="string">"failed to determine parser category using syntax stack, the specified element on the stack is not an identifier"</span>)
15444 
<span class="keyword">15445 def</span> <span class="function-name">categoryParserOfStack</span> (offset : Nat) (prec : Nat <span class="constant">:=</span> <span class="constant">0</span>) : Parser <span class="constant">:=</span>
15446   { fn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span> categoryParserOfStackFn offset { c <span class="keyword">with</span> prec <span class="constant">:=</span> prec } s }
15447 
<span class="keyword">15448 unsafe</span> <span class="keyword">def</span> <span class="function-name">evalParserConstUnsafe</span> (declName : Name) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> ctx s <span class="constant">=&gt;</span>
15449   <span class="keyword">match</span> ctx.env.evalConstCheck Parser ctx.options `Lean.Parser.Parser declName <span class="constant">&lt;</span>|<span class="constant">&gt;</span>
15450         ctx.env.evalConstCheck Parser ctx.options `Lean.Parser.TrailingParser declName <span class="keyword">with</span>
15451   | Except.ok p    <span class="constant">=&gt;</span> p.fn ctx s
15452   | Except.error e <span class="constant">=&gt;</span> s.mkUnexpectedError s<span class="constant">!</span><span class="string">"error running parser {declName}: {e}"</span>
15453 
<span class="doc">15454 @[implementedBy evalParserConstUnsafe]</span>
<span class="keyword">15455 constant</span> <span class="function-name">evalParserConst</span> (declName : Name) : ParserFn
15456 
<span class="keyword">15457 unsafe</span> <span class="keyword">def</span> <span class="function-name">parserOfStackFnUnsafe</span> (offset : Nat) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> ctx s <span class="constant">=&gt;</span>
15458   <span class="keyword">let</span> stack <span class="constant">:=</span> s.stxStack
15459   <span class="keyword">if</span> stack.size <span class="constant">&lt;</span> offset <span class="constant">+</span> <span class="constant">1</span> <span class="keyword">then</span>
15460     s.mkUnexpectedError (<span class="string">"failed to determine parser using syntax stack, stack is too small"</span>)
15461   <span class="keyword">else</span>
15462     <span class="keyword">match</span> stack.get<span class="constant">!</span> (stack.size <span class="constant">-</span> offset <span class="constant">-</span> <span class="constant">1</span>) <span class="keyword">with</span>
15463     | Syntax.ident (val <span class="constant">:=</span> parserName) .. <span class="constant">=&gt;</span>
15464       <span class="keyword">match</span> ctx.resolveName parserName <span class="keyword">with</span>
15465       | [(parserName, [])] <span class="constant">=&gt;</span>
15466         <span class="keyword">let</span> iniSz <span class="constant">:=</span> s.stackSize
15467         <span class="keyword">let</span> s <span class="constant">:=</span> evalParserConst parserName ctx s
15468         <span class="keyword">if</span> <span class="constant">!</span>s.hasError <span class="constant">&amp;&amp;</span> s.stackSize <span class="constant">!=</span> iniSz <span class="constant">+</span> <span class="constant">1</span> <span class="keyword">then</span>
15469           s.mkUnexpectedError <span class="string">"expected parser to return exactly one syntax object"</span>
15470         <span class="keyword">else</span>
15471           s
15472       | <span class="preprocessor">_</span>::<span class="preprocessor">_</span>::<span class="preprocessor">_</span> <span class="constant">=&gt;</span> s.mkUnexpectedError s<span class="constant">!</span><span class="string">"ambiguous parser name {parserName}"</span>
15473       | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> s.mkUnexpectedError s<span class="constant">!</span><span class="string">"unknown parser {parserName}"</span>
15474     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> s.mkUnexpectedError (<span class="string">"failed to determine parser using syntax stack, the specified element on the stack is not an identifier"</span>)
15475 
<span class="doc">15476 @[implementedBy parserOfStackFnUnsafe]</span>
<span class="keyword">15477 constant</span> <span class="function-name">parserOfStackFn</span> (offset : Nat) : ParserFn
15478 
<span class="keyword">15479 def</span> <span class="function-name">parserOfStack</span> (offset : Nat) (prec : Nat <span class="constant">:=</span> <span class="constant">0</span>) : Parser <span class="constant">:=</span>
15480   { fn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span> parserOfStackFn offset { c <span class="keyword">with</span> prec <span class="constant">:=</span> prec } s }
15481 
<span class="comment-delimiter">15482 /-</span><span class="comment">- Run `declName` if possible and inside a quotation, or else `p`. The `ParserInfo` will always be taken from `p`. -/</span>
<span class="keyword">15483 def</span> <span class="function-name">evalInsideQuot</span> (declName : Name) (p : Parser) : Parser <span class="constant">:=</span> { p <span class="keyword">with</span>
15484   fn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
15485     <span class="keyword">if</span> c.insideQuot <span class="constant">&amp;&amp;</span> c.env.contains declName <span class="keyword">then</span>
15486       evalParserConst declName c s
15487     <span class="keyword">else</span>
15488       p.fn c s }
15489 
<span class="keyword">15490 private</span> <span class="keyword">def</span> <span class="function-name">mkResult</span> (s : ParserState) (iniSz : Nat) : ParserState <span class="constant">:=</span>
15491   <span class="keyword">if</span> s.stackSize <span class="constant">==</span> iniSz <span class="constant">+</span> <span class="constant">1</span> <span class="keyword">then</span> s
15492   <span class="keyword">else</span> s.mkNode nullKind iniSz <span class="comment-delimiter">-- </span><span class="comment">throw error instead?
</span>15493 
<span class="keyword">15494 def</span> <span class="function-name">leadingParserAux</span> (kind : Name) (tables : PrattParsingTables) (behavior : LeadingIdentBehavior) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span> <span class="keyword">do</span>
15495   <span class="keyword">let</span> iniSz   <span class="constant">:=</span> s.stackSize
15496   <span class="keyword">let</span> (s, ps) <span class="constant">:=</span> indexed tables.leadingTable c s behavior
15497   <span class="keyword">if</span> s.hasError <span class="keyword">then</span>
15498     <span class="keyword">return</span> s
15499   <span class="keyword">let</span> ps      <span class="constant">:=</span> tables.leadingParsers <span class="constant">++</span> ps
15500   <span class="keyword">if</span> ps.isEmpty <span class="keyword">then</span>
15501     <span class="keyword">return</span> s.mkError (toString kind)
15502   <span class="keyword">let</span> s <span class="constant">:=</span> longestMatchFn none ps c s
15503   mkResult s iniSz
15504 
<span class="doc">15505 @[inline]</span> <span class="keyword">def</span> <span class="function-name">leadingParser</span> (kind : Name) (tables : PrattParsingTables) (behavior : LeadingIdentBehavior) (antiquotParser : ParserFn) : ParserFn <span class="constant">:=</span>
15506   withAntiquotFn antiquotParser (leadingParserAux kind tables behavior)
15507 
<span class="keyword">15508 def</span> <span class="function-name">trailingLoopStep</span> (tables : PrattParsingTables) (left : Syntax) (ps : List (Parser <span class="constant">&#215;</span> Nat)) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
15509   longestMatchFn left (ps <span class="constant">++</span> tables.trailingParsers) c s
15510 
<span class="keyword">15511 partial</span> <span class="keyword">def</span> <span class="function-name">trailingLoop</span> (tables : PrattParsingTables) (c : ParserContext) (s : ParserState) : ParserState <span class="constant">:=</span> <span class="keyword">do</span>
15512   <span class="keyword">let</span> iniSz  <span class="constant">:=</span> s.stackSize
15513   <span class="keyword">let</span> iniPos <span class="constant">:=</span> s.pos
15514   <span class="keyword">let</span> (s, ps)       <span class="constant">:=</span> indexed tables.trailingTable c s LeadingIdentBehavior.default
15515   <span class="keyword">if</span> s.hasError <span class="keyword">then</span>
15516     <span class="comment-delimiter">-- </span><span class="comment">Discard token parse errors and break the trailing loop instead.
</span>15517     <span class="comment-delimiter">-- </span><span class="comment">The error will be flagged when the next leading position is parsed, unless the token
</span>15518     <span class="comment-delimiter">-- </span><span class="comment">is in fact valid there (e.g. EOI at command level, no-longer forbidden token)
</span>15519     <span class="keyword">return</span> s.restore iniSz iniPos
15520   <span class="keyword">if</span> ps.isEmpty <span class="constant">&amp;&amp;</span> tables.trailingParsers.isEmpty <span class="keyword">then</span>
15521     <span class="keyword">return</span> s <span class="comment-delimiter">-- </span><span class="comment">no available trailing parser
</span>15522   <span class="keyword">let</span> left   <span class="constant">:=</span> s.stxStack.back
15523   <span class="keyword">let</span> s      <span class="constant">:=</span> s.popSyntax
15524   <span class="keyword">let</span> s      <span class="constant">:=</span> trailingLoopStep tables left ps c s
15525   <span class="keyword">if</span> s.hasError <span class="keyword">then</span>
15526     <span class="comment-delimiter">-- </span><span class="comment">Discard non-consuming parse errors and break the trailing loop instead, restoring `left`.
</span>15527     <span class="comment-delimiter">-- </span><span class="comment">This is necessary for fallback parsers like `app` that pretend to be always applicable.
</span>15528     <span class="keyword">return</span> <span class="keyword">if</span> s.pos <span class="constant">==</span> iniPos <span class="keyword">then</span> s.restore (iniSz <span class="constant">-</span> <span class="constant">1</span>) iniPos |<span class="constant">&gt;</span>.pushSyntax left <span class="keyword">else</span> s
15529   trailingLoop tables c s
15530 
<span class="comment-delimiter">15531 /-</span><span class="comment">-
15532 
15533   Implements a variant of Pratt's algorithm. In Pratt's algorithms tokens have a right and left binding power.
15534   In our implementation, parsers have precedence instead. This method selects a parser (or more, via
15535   `longestMatchFn`) from `leadingTable` based on the current token. Note that the unindexed `leadingParsers` parsers
15536   are also tried. We have the unidexed `leadingParsers` because some parsers do not have a "first token". Example:
15537   ```
15538   syntax term:51 "&#8804;" ident "&lt;" term "|" term : index
15539   ```
15540   Example, in principle, the set of first tokens for this parser is any token that can start a term, but this set
15541   is always changing. Thus, this parsing rule is stored as an unindexed leading parser at `leadingParsers`.
15542   After processing the leading parser, we chain with parsers from `trailingTable`/`trailingParsers` that have precedence
15543   at least `c.prec` where `c` is the `ParsingContext`. Recall that `c.prec` is set by `categoryParser`.
15544 
15545   Note that in the original Pratt's algorith, precedences are only checked before calling trailing parsers. In our
15546   implementation, leading *and* trailing parsers check the precendece. We claim our algorithm is more flexible,
15547   modular and easier to understand.
15548 
15549   `antiquotParser` should be a `mkAntiquot` parser (or always fail) and is tried before all other parsers.
15550   It should not be added to the regular leading parsers because it would heavily
15551   overlap with antiquotation parsers nested inside them. -/</span>
<span class="doc">15552 @[inline]</span> <span class="keyword">def</span> <span class="function-name">prattParser</span> (kind : Name) (tables : PrattParsingTables) (behavior : LeadingIdentBehavior) (antiquotParser : ParserFn) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
15553   <span class="keyword">let</span> iniSz  <span class="constant">:=</span> s.stackSize
15554   <span class="keyword">let</span> iniPos <span class="constant">:=</span> s.pos
15555   <span class="keyword">let</span> s <span class="constant">:=</span> leadingParser kind tables behavior antiquotParser c s
15556   <span class="keyword">if</span> s.hasError <span class="keyword">then</span>
15557     s
15558   <span class="keyword">else</span>
15559     trailingLoop tables c s
15560 
<span class="keyword">15561 def</span> <span class="function-name">fieldIdxFn</span> : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
15562   <span class="keyword">let</span> initStackSz <span class="constant">:=</span> s.stackSize
15563   <span class="keyword">let</span> iniPos <span class="constant">:=</span> s.pos
15564   <span class="keyword">let</span> curr     <span class="constant">:=</span> c.input.get iniPos
15565   <span class="keyword">if</span> curr.isDigit <span class="constant">&amp;&amp;</span> curr <span class="constant">!=</span> '0' <span class="keyword">then</span>
15566     <span class="keyword">let</span> s     <span class="constant">:=</span> takeWhileFn (<span class="keyword">fun</span> c <span class="constant">=&gt;</span> c.isDigit) c s
15567     mkNodeToken fieldIdxKind iniPos c s
15568   <span class="keyword">else</span>
15569     s.mkErrorAt <span class="string">"field index"</span> iniPos initStackSz
15570 
<span class="doc">15571 @[inline]</span> <span class="keyword">def</span> <span class="function-name">fieldIdx</span> : Parser <span class="constant">:=</span>
15572   withAntiquot (mkAntiquot <span class="string">"fieldIdx"</span> `fieldIdx) {
15573     fn   <span class="constant">:=</span> fieldIdxFn,
15574     info <span class="constant">:=</span> mkAtomicInfo <span class="string">"fieldIdx"</span>
15575   }
15576 
<span class="doc">15577 @[inline]</span> <span class="keyword">def</span> <span class="function-name">skip</span> : Parser <span class="constant">:=</span> {
15578   fn   <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span> s,
15579   info <span class="constant">:=</span> epsilonInfo
15580 }
15581 
<span class="keyword">15582 end</span> Parser
15583 
<span class="keyword">15584 namespace</span> Syntax
15585 
<span class="keyword">15586 section</span>
<span class="keyword">15587 variable</span> {&#946; : <span class="type">Type</span>} {m : <span class="type">Type</span> <span class="constant">&#8594;</span> <span class="type">Type</span>} [Monad m]
15588 
<span class="doc">15589 @[inline]</span> <span class="keyword">def</span> <span class="function-name">foldArgsM</span> (s : Syntax) (f : Syntax <span class="constant">&#8594;</span> &#946; <span class="constant">&#8594;</span> m &#946;) (b : &#946;) : m &#946; <span class="constant">:=</span>
15590   s.getArgs.foldlM (flip f) b
15591 
<span class="doc">15592 @[inline]</span> <span class="keyword">def</span> <span class="function-name">foldArgs</span> (s : Syntax) (f : Syntax <span class="constant">&#8594;</span> &#946; <span class="constant">&#8594;</span> &#946;) (b : &#946;) : &#946; <span class="constant">:=</span>
15593   Id.run (s.foldArgsM f b)
15594 
<span class="doc">15595 @[inline]</span> <span class="keyword">def</span> <span class="function-name">forArgsM</span> (s : Syntax) (f : Syntax <span class="constant">&#8594;</span> m Unit) : m Unit <span class="constant">:=</span>
15596   s.foldArgsM (<span class="keyword">fun</span> s <span class="preprocessor">_</span> <span class="constant">=&gt;</span> f s) ()
<span class="keyword">15597 end</span>
15598 
<span class="keyword">15599 end</span> Syntax
<span class="keyword">15600 end</span> Lean
15601 ::::::::::::::
15602 Parser<span class="constant">/</span>Command.lean
15603 ::::::::::::::
<span class="comment-delimiter">15604 /-</span><span class="comment">
15605 Copyright (c) 2019 Microsoft Corporation. All rights reserved.
15606 Released under Apache 2.0 license as described in the file LICENSE.
15607 Authors: Leonardo de Moura, Sebastian Ullrich
15608 -/</span>
<span class="keyword">15609 import</span> Lean.Parser.Term
<span class="keyword">15610 import</span> Lean.Parser.Do
15611 
<span class="keyword">15612 namespace</span> Lean
<span class="keyword">15613 namespace</span> Parser
15614 
<span class="comment-delimiter">15615 /-</span><span class="comment">-
15616   Syntax quotation for terms and (lists of) commands. We prefer terms, so ambiguous quotations like
15617   `($x $y) will be parsed as an application, not two commands. Use `($x:command $y:command) instead.
15618   Multiple command will be put in a `null node, but a single command will not (so that you can directly
15619   match against a quotation in a command kind's elaborator). -/</span>
<span class="comment-delimiter">15620 -- </span><span class="comment">TODO: use two separate quotation parsers with parser priorities instead
</span><span class="doc">15621 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">Term.quot</span> <span class="constant">:=</span> leading_parser <span class="string">"`("</span> <span class="constant">&gt;&gt;</span> toggleInsideQuot (termParser <span class="constant">&lt;</span>|<span class="constant">&gt;</span> many1Unbox commandParser) <span class="constant">&gt;&gt;</span> <span class="string">")"</span>
15622 
<span class="keyword">15623 namespace</span> Command
15624 
<span class="keyword">15625 def</span> <span class="function-name">namedPrio</span> <span class="constant">:=</span> leading_parser (atomic (<span class="string">"("</span> <span class="constant">&gt;&gt;</span> nonReservedSymbol <span class="string">"priority"</span>) <span class="constant">&gt;&gt;</span> <span class="string">" := "</span> <span class="constant">&gt;&gt;</span> priorityParser <span class="constant">&gt;&gt;</span> <span class="string">")"</span>)
<span class="keyword">15626 def</span> <span class="function-name">optNamedPrio</span> <span class="constant">:=</span> optional namedPrio
15627 
<span class="keyword">15628 def</span> <span class="comment">&#171;</span>private<span class="comment">&#187;</span>        <span class="constant">:=</span> leading_parser <span class="string">"private "</span>
<span class="keyword">15629 def</span> <span class="comment">&#171;</span>protected<span class="comment">&#187;</span>      <span class="constant">:=</span> leading_parser <span class="string">"protected "</span>
<span class="keyword">15630 def</span> <span class="function-name">visibility</span>       <span class="constant">:=</span> <span class="comment">&#171;</span>private<span class="comment">&#187;</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> <span class="comment">&#171;</span>protected<span class="comment">&#187;</span>
<span class="keyword">15631 def</span> <span class="comment">&#171;</span>noncomputable<span class="comment">&#187;</span>  <span class="constant">:=</span> leading_parser <span class="string">"noncomputable "</span>
<span class="keyword">15632 def</span> <span class="comment">&#171;</span>unsafe<span class="comment">&#187;</span>         <span class="constant">:=</span> leading_parser <span class="string">"unsafe "</span>
<span class="keyword">15633 def</span> <span class="comment">&#171;</span>partial<span class="comment">&#187;</span>        <span class="constant">:=</span> leading_parser <span class="string">"partial "</span>
<span class="keyword">15634 def</span> <span class="function-name">declModifiers</span> (inline : Bool) <span class="constant">:=</span> leading_parser optional docComment <span class="constant">&gt;&gt;</span> optional (Term.<span class="comment">&#171;</span>attributes<span class="comment">&#187;</span> <span class="constant">&gt;&gt;</span> <span class="keyword">if</span> inline <span class="keyword">then</span> skip <span class="keyword">else</span> ppDedent ppLine) <span class="constant">&gt;&gt;</span> optional visibility <span class="constant">&gt;&gt;</span> optional <span class="comment">&#171;</span>noncomputable<span class="comment">&#187;</span> <span class="constant">&gt;&gt;</span> optional <span class="comment">&#171;</span>unsafe<span class="comment">&#187;</span> <span class="constant">&gt;&gt;</span> optional <span class="comment">&#171;</span>partial<span class="comment">&#187;</span>
<span class="keyword">15635 def</span> <span class="function-name">declId</span>           <span class="constant">:=</span> leading_parser ident <span class="constant">&gt;&gt;</span> optional (<span class="string">".{"</span> <span class="constant">&gt;&gt;</span> sepBy1 ident <span class="string">", "</span> <span class="constant">&gt;&gt;</span> <span class="string">"}"</span>)
<span class="keyword">15636 def</span> <span class="function-name">declSig</span>          <span class="constant">:=</span> leading_parser many (ppSpace <span class="constant">&gt;&gt;</span> (Term.simpleBinderWithoutType <span class="constant">&lt;</span>|<span class="constant">&gt;</span> Term.bracketedBinder)) <span class="constant">&gt;&gt;</span> Term.typeSpec
<span class="keyword">15637 def</span> <span class="function-name">optDeclSig</span>       <span class="constant">:=</span> leading_parser many (ppSpace <span class="constant">&gt;&gt;</span> (Term.simpleBinderWithoutType <span class="constant">&lt;</span>|<span class="constant">&gt;</span> Term.bracketedBinder)) <span class="constant">&gt;&gt;</span> Term.optType
<span class="keyword">15638 def</span> <span class="function-name">declValSimple</span>    <span class="constant">:=</span> leading_parser <span class="string">" :=\n"</span> <span class="constant">&gt;&gt;</span> termParser <span class="constant">&gt;&gt;</span> optional Term.whereDecls
<span class="keyword">15639 def</span> <span class="function-name">declValEqns</span>      <span class="constant">:=</span> leading_parser Term.matchAltsWhereDecls
<span class="keyword">15640 def</span> <span class="function-name">declVal</span>          <span class="constant">:=</span> declValSimple <span class="constant">&lt;</span>|<span class="constant">&gt;</span> declValEqns <span class="constant">&lt;</span>|<span class="constant">&gt;</span> Term.whereDecls
<span class="keyword">15641 def</span> <span class="comment">&#171;</span>abbrev<span class="comment">&#187;</span>         <span class="constant">:=</span> leading_parser <span class="string">"abbrev "</span> <span class="constant">&gt;&gt;</span> declId <span class="constant">&gt;&gt;</span> optDeclSig <span class="constant">&gt;&gt;</span> declVal
<span class="keyword">15642 def</span> <span class="comment">&#171;</span>def<span class="comment">&#187;</span>            <span class="constant">:=</span> leading_parser <span class="string">"def "</span> <span class="constant">&gt;&gt;</span> declId <span class="constant">&gt;&gt;</span> optDeclSig <span class="constant">&gt;&gt;</span> declVal
<span class="keyword">15643 def</span> <span class="comment">&#171;</span>theorem<span class="comment">&#187;</span>        <span class="constant">:=</span> leading_parser <span class="string">"theorem "</span> <span class="constant">&gt;&gt;</span> declId <span class="constant">&gt;&gt;</span> declSig <span class="constant">&gt;&gt;</span> declVal
<span class="keyword">15644 def</span> <span class="comment">&#171;</span>constant<span class="comment">&#187;</span>       <span class="constant">:=</span> leading_parser <span class="string">"constant "</span> <span class="constant">&gt;&gt;</span> declId <span class="constant">&gt;&gt;</span> declSig <span class="constant">&gt;&gt;</span> optional declValSimple
<span class="keyword">15645 def</span> <span class="comment">&#171;</span>instance<span class="comment">&#187;</span>       <span class="constant">:=</span> leading_parser Term.attrKind <span class="constant">&gt;&gt;</span> <span class="string">"instance "</span> <span class="constant">&gt;&gt;</span> optNamedPrio <span class="constant">&gt;&gt;</span> optional declId <span class="constant">&gt;&gt;</span> declSig <span class="constant">&gt;&gt;</span> declVal
<span class="keyword">15646 def</span> <span class="comment">&#171;</span>axiom<span class="comment">&#187;</span>          <span class="constant">:=</span> leading_parser <span class="string">"axiom "</span> <span class="constant">&gt;&gt;</span> declId <span class="constant">&gt;&gt;</span> declSig
<span class="keyword">15647 def</span> <span class="comment">&#171;</span>example<span class="comment">&#187;</span>        <span class="constant">:=</span> leading_parser <span class="string">"example "</span> <span class="constant">&gt;&gt;</span> declSig <span class="constant">&gt;&gt;</span> declVal
<span class="keyword">15648 def</span> <span class="function-name">inferMod</span>         <span class="constant">:=</span> leading_parser atomic (symbol <span class="string">"{"</span> <span class="constant">&gt;&gt;</span> <span class="string">"}"</span>)
<span class="keyword">15649 def</span> <span class="function-name">ctor</span>             <span class="constant">:=</span> leading_parser <span class="string">"\n| "</span> <span class="constant">&gt;&gt;</span> declModifiers true <span class="constant">&gt;&gt;</span> ident <span class="constant">&gt;&gt;</span> optional inferMod <span class="constant">&gt;&gt;</span> optDeclSig
<span class="keyword">15650 def</span> <span class="function-name">optDeriving</span>      <span class="constant">:=</span> leading_parser optional (atomic (<span class="string">"deriving "</span> <span class="constant">&gt;&gt;</span> notSymbol <span class="string">"instance"</span>) <span class="constant">&gt;&gt;</span> sepBy1 ident <span class="string">", "</span>)
<span class="keyword">15651 def</span> <span class="comment">&#171;</span>inductive<span class="comment">&#187;</span>      <span class="constant">:=</span> leading_parser <span class="string">"inductive "</span> <span class="constant">&gt;&gt;</span> declId <span class="constant">&gt;&gt;</span> optDeclSig <span class="constant">&gt;&gt;</span> optional (symbol <span class="string">":="</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> <span class="string">"where"</span>) <span class="constant">&gt;&gt;</span> many ctor <span class="constant">&gt;&gt;</span> optDeriving
<span class="keyword">15652 def</span> <span class="function-name">classInductive</span>   <span class="constant">:=</span> leading_parser atomic (group (symbol <span class="string">"class "</span> <span class="constant">&gt;&gt;</span> <span class="string">"inductive "</span>)) <span class="constant">&gt;&gt;</span> declId <span class="constant">&gt;&gt;</span> optDeclSig <span class="constant">&gt;&gt;</span> optional (symbol <span class="string">":="</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> <span class="string">"where"</span>) <span class="constant">&gt;&gt;</span> many ctor <span class="constant">&gt;&gt;</span> optDeriving
<span class="keyword">15653 def</span> <span class="function-name">structExplicitBinder</span> <span class="constant">:=</span> leading_parser atomic (declModifiers true <span class="constant">&gt;&gt;</span> <span class="string">"("</span>) <span class="constant">&gt;&gt;</span> many1 ident <span class="constant">&gt;&gt;</span> optional inferMod <span class="constant">&gt;&gt;</span> optDeclSig <span class="constant">&gt;&gt;</span> optional Term.binderDefault <span class="constant">&gt;&gt;</span> <span class="string">")"</span>
<span class="keyword">15654 def</span> <span class="function-name">structImplicitBinder</span> <span class="constant">:=</span> leading_parser atomic (declModifiers true <span class="constant">&gt;&gt;</span> <span class="string">"{"</span>) <span class="constant">&gt;&gt;</span> many1 ident <span class="constant">&gt;&gt;</span> optional inferMod <span class="constant">&gt;&gt;</span> declSig <span class="constant">&gt;&gt;</span> <span class="string">"}"</span>
<span class="keyword">15655 def</span> <span class="function-name">structInstBinder</span>     <span class="constant">:=</span> leading_parser atomic (declModifiers true <span class="constant">&gt;&gt;</span> <span class="string">"["</span>) <span class="constant">&gt;&gt;</span> many1 ident <span class="constant">&gt;&gt;</span> optional inferMod <span class="constant">&gt;&gt;</span> declSig <span class="constant">&gt;&gt;</span> <span class="string">"]"</span>
<span class="keyword">15656 def</span> <span class="function-name">structSimpleBinder</span>   <span class="constant">:=</span> leading_parser atomic (declModifiers true <span class="constant">&gt;&gt;</span> ident) <span class="constant">&gt;&gt;</span> optional inferMod <span class="constant">&gt;&gt;</span> optDeclSig <span class="constant">&gt;&gt;</span> optional Term.binderDefault
<span class="keyword">15657 def</span> <span class="function-name">structFields</span>         <span class="constant">:=</span> leading_parser manyIndent (ppLine <span class="constant">&gt;&gt;</span> checkColGe <span class="constant">&gt;&gt;</span>(structExplicitBinder <span class="constant">&lt;</span>|<span class="constant">&gt;</span> structImplicitBinder <span class="constant">&lt;</span>|<span class="constant">&gt;</span> structInstBinder <span class="constant">&lt;</span>|<span class="constant">&gt;</span> structSimpleBinder))
<span class="keyword">15658 def</span> <span class="function-name">structCtor</span>           <span class="constant">:=</span> leading_parser atomic (declModifiers true <span class="constant">&gt;&gt;</span> ident <span class="constant">&gt;&gt;</span> optional inferMod <span class="constant">&gt;&gt;</span> <span class="string">" :: "</span>)
<span class="keyword">15659 def</span> <span class="function-name">structureTk</span>          <span class="constant">:=</span> leading_parser <span class="string">"structure "</span>
<span class="keyword">15660 def</span> <span class="function-name">classTk</span>              <span class="constant">:=</span> leading_parser <span class="string">"class "</span>
<span class="keyword">15661 def</span> <span class="comment">&#171;</span>extends<span class="comment">&#187;</span>            <span class="constant">:=</span> leading_parser <span class="string">" extends "</span> <span class="constant">&gt;&gt;</span> sepBy1 termParser <span class="string">", "</span>
<span class="keyword">15662 def</span> <span class="comment">&#171;</span>structure<span class="comment">&#187;</span>          <span class="constant">:=</span> leading_parser
15663     (structureTk <span class="constant">&lt;</span>|<span class="constant">&gt;</span> classTk) <span class="constant">&gt;&gt;</span> declId <span class="constant">&gt;&gt;</span> many Term.bracketedBinder <span class="constant">&gt;&gt;</span> optional <span class="comment">&#171;</span>extends<span class="comment">&#187;</span> <span class="constant">&gt;&gt;</span> Term.optType
15664     <span class="constant">&gt;&gt;</span> optional ((symbol <span class="string">" := "</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> <span class="string">" where "</span>) <span class="constant">&gt;&gt;</span> optional structCtor <span class="constant">&gt;&gt;</span> structFields)
15665     <span class="constant">&gt;&gt;</span> optDeriving
<span class="doc">15666 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="function-name">declaration</span> <span class="constant">:=</span> leading_parser
15667 declModifiers false <span class="constant">&gt;&gt;</span> (<span class="comment">&#171;</span>abbrev<span class="comment">&#187;</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> <span class="comment">&#171;</span>def<span class="comment">&#187;</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> <span class="comment">&#171;</span>theorem<span class="comment">&#187;</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> <span class="comment">&#171;</span>constant<span class="comment">&#187;</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> <span class="comment">&#171;</span>instance<span class="comment">&#187;</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> <span class="comment">&#171;</span>axiom<span class="comment">&#187;</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> <span class="comment">&#171;</span>example<span class="comment">&#187;</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> <span class="comment">&#171;</span>inductive<span class="comment">&#187;</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> classInductive <span class="constant">&lt;</span>|<span class="constant">&gt;</span> <span class="comment">&#171;</span>structure<span class="comment">&#187;</span>)
<span class="doc">15668 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>deriving<span class="comment">&#187;</span>     <span class="constant">:=</span> leading_parser <span class="string">"deriving "</span> <span class="constant">&gt;&gt;</span> <span class="string">"instance "</span> <span class="constant">&gt;&gt;</span> sepBy1 ident <span class="string">", "</span> <span class="constant">&gt;&gt;</span> <span class="string">" for "</span> <span class="constant">&gt;&gt;</span> sepBy1 ident <span class="string">", "</span>
<span class="doc">15669 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>section<span class="comment">&#187;</span>      <span class="constant">:=</span> leading_parser <span class="string">"section "</span> <span class="constant">&gt;&gt;</span> optional ident
<span class="doc">15670 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>namespace<span class="comment">&#187;</span>    <span class="constant">:=</span> leading_parser <span class="string">"namespace "</span> <span class="constant">&gt;&gt;</span> ident
<span class="doc">15671 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>end<span class="comment">&#187;</span>          <span class="constant">:=</span> leading_parser <span class="string">"end "</span> <span class="constant">&gt;&gt;</span> optional ident
<span class="doc">15672 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>variable<span class="comment">&#187;</span>     <span class="constant">:=</span> leading_parser <span class="string">"variable"</span> <span class="constant">&gt;&gt;</span> many1 Term.bracketedBinder
<span class="doc">15673 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>universe<span class="comment">&#187;</span>     <span class="constant">:=</span> leading_parser <span class="string">"universe "</span> <span class="constant">&gt;&gt;</span> ident
<span class="doc">15674 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>universes<span class="comment">&#187;</span>    <span class="constant">:=</span> leading_parser <span class="string">"universes "</span> <span class="constant">&gt;&gt;</span> many1 ident
<span class="doc">15675 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="function-name">check</span>          <span class="constant">:=</span> leading_parser <span class="string">"#check "</span> <span class="constant">&gt;&gt;</span> termParser
<span class="doc">15676 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="function-name">check_failure</span>  <span class="constant">:=</span> leading_parser <span class="string">"#check_failure "</span> <span class="constant">&gt;&gt;</span> termParser <span class="comment-delimiter">-- </span><span class="comment">Like `#check`, but succeeds only if term does not type check
</span><span class="doc">15677 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="function-name">reduce</span>         <span class="constant">:=</span> leading_parser <span class="string">"#reduce "</span> <span class="constant">&gt;&gt;</span> termParser
<span class="doc">15678 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="function-name">eval</span>           <span class="constant">:=</span> leading_parser <span class="string">"#eval "</span> <span class="constant">&gt;&gt;</span> termParser
<span class="doc">15679 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="function-name">synth</span>          <span class="constant">:=</span> leading_parser <span class="string">"#synth "</span> <span class="constant">&gt;&gt;</span> termParser
<span class="doc">15680 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="function-name">exit</span>           <span class="constant">:=</span> leading_parser <span class="string">"#exit"</span>
<span class="doc">15681 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="function-name">print</span>          <span class="constant">:=</span> leading_parser <span class="string">"#print "</span> <span class="constant">&gt;&gt;</span> (ident <span class="constant">&lt;</span>|<span class="constant">&gt;</span> strLit)
<span class="doc">15682 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="function-name">printAxioms</span>    <span class="constant">:=</span> leading_parser <span class="string">"#print "</span> <span class="constant">&gt;&gt;</span> nonReservedSymbol <span class="string">"axioms "</span> <span class="constant">&gt;&gt;</span> ident
<span class="doc">15683 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>resolve_name<span class="comment">&#187;</span> <span class="constant">:=</span> leading_parser <span class="string">"#resolve_name "</span> <span class="constant">&gt;&gt;</span> ident
<span class="doc">15684 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>init_quot<span class="comment">&#187;</span>    <span class="constant">:=</span> leading_parser <span class="string">"init_quot"</span>
<span class="keyword">15685 def</span> <span class="function-name">optionValue</span> <span class="constant">:=</span> nonReservedSymbol <span class="string">"true"</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> nonReservedSymbol <span class="string">"false"</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> strLit <span class="constant">&lt;</span>|<span class="constant">&gt;</span> numLit
<span class="doc">15686 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>set_option<span class="comment">&#187;</span>   <span class="constant">:=</span> leading_parser <span class="string">"set_option "</span> <span class="constant">&gt;&gt;</span> ident <span class="constant">&gt;&gt;</span> ppSpace <span class="constant">&gt;&gt;</span> optionValue
<span class="keyword">15687 def</span> <span class="function-name">eraseAttr</span> <span class="constant">:=</span> leading_parser <span class="string">"-"</span> <span class="constant">&gt;&gt;</span> ident
<span class="doc">15688 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>attribute<span class="comment">&#187;</span>    <span class="constant">:=</span> leading_parser <span class="string">"attribute "</span> <span class="constant">&gt;&gt;</span> <span class="string">"["</span> <span class="constant">&gt;&gt;</span> sepBy1 (eraseAttr <span class="constant">&lt;</span>|<span class="constant">&gt;</span> Term.attrInstance) <span class="string">", "</span> <span class="constant">&gt;&gt;</span> <span class="string">"] "</span> <span class="constant">&gt;&gt;</span> many1 ident
<span class="doc">15689 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>export<span class="comment">&#187;</span>       <span class="constant">:=</span> leading_parser <span class="string">"export "</span> <span class="constant">&gt;&gt;</span> ident <span class="constant">&gt;&gt;</span> <span class="string">"("</span> <span class="constant">&gt;&gt;</span> many1 ident <span class="constant">&gt;&gt;</span> <span class="string">")"</span>
<span class="keyword">15690 def</span> <span class="function-name">openHiding</span>       <span class="constant">:=</span> leading_parser atomic (ident <span class="constant">&gt;&gt;</span> <span class="string">"hiding"</span>) <span class="constant">&gt;&gt;</span> many1 ident
<span class="keyword">15691 def</span> <span class="function-name">openRenamingItem</span> <span class="constant">:=</span> leading_parser ident <span class="constant">&gt;&gt;</span> unicodeSymbol <span class="string">"&#8594;"</span> <span class="string">"-&gt;"</span> <span class="constant">&gt;&gt;</span> ident
<span class="keyword">15692 def</span> <span class="function-name">openRenaming</span>     <span class="constant">:=</span> leading_parser atomic (ident <span class="constant">&gt;&gt;</span> <span class="string">"renaming"</span>) <span class="constant">&gt;&gt;</span> sepBy1 openRenamingItem <span class="string">", "</span>
<span class="keyword">15693 def</span> <span class="function-name">openOnly</span>         <span class="constant">:=</span> leading_parser atomic (ident <span class="constant">&gt;&gt;</span> <span class="string">"("</span>) <span class="constant">&gt;&gt;</span> many1 ident <span class="constant">&gt;&gt;</span> <span class="string">")"</span>
<span class="keyword">15694 def</span> <span class="function-name">openSimple</span>       <span class="constant">:=</span> leading_parser many1 ident
<span class="keyword">15695 def</span> <span class="function-name">openDecl</span>         <span class="constant">:=</span> openHiding <span class="constant">&lt;</span>|<span class="constant">&gt;</span> openRenaming <span class="constant">&lt;</span>|<span class="constant">&gt;</span> openOnly <span class="constant">&lt;</span>|<span class="constant">&gt;</span> openSimple
<span class="doc">15696 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>open<span class="comment">&#187;</span>    <span class="constant">:=</span> leading_parser <span class="string">"open "</span> <span class="constant">&gt;&gt;</span> openDecl
15697 
<span class="doc">15698 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>mutual<span class="comment">&#187;</span> <span class="constant">:=</span> leading_parser <span class="string">"mutual "</span> <span class="constant">&gt;&gt;</span> many1 (ppLine <span class="constant">&gt;&gt;</span> notSymbol <span class="string">"end"</span> <span class="constant">&gt;&gt;</span> commandParser) <span class="constant">&gt;&gt;</span> ppDedent (ppLine <span class="constant">&gt;&gt;</span> <span class="string">"end"</span>)
<span class="doc">15699 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>initialize<span class="comment">&#187;</span> <span class="constant">:=</span> leading_parser <span class="string">"initialize "</span> <span class="constant">&gt;&gt;</span> optional (atomic (ident <span class="constant">&gt;&gt;</span> Term.typeSpec <span class="constant">&gt;&gt;</span> Term.leftArrow)) <span class="constant">&gt;&gt;</span> Term.doSeq
<span class="doc">15700 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>builtin_initialize<span class="comment">&#187;</span> <span class="constant">:=</span> leading_parser <span class="string">"builtin_initialize "</span> <span class="constant">&gt;&gt;</span> optional (atomic (ident <span class="constant">&gt;&gt;</span> Term.typeSpec <span class="constant">&gt;&gt;</span> Term.leftArrow)) <span class="constant">&gt;&gt;</span> Term.doSeq
15701 
<span class="doc">15702 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>in<span class="comment">&#187;</span>  <span class="constant">:=</span> trailing_parser <span class="string">" in "</span> <span class="constant">&gt;&gt;</span> commandParser
15703 
<span class="doc">15704 @[runBuiltinParserAttributeHooks]</span> <span class="keyword">abbrev</span> declModifiersF <span class="constant">:=</span> declModifiers false
<span class="doc">15705 @[runBuiltinParserAttributeHooks]</span> <span class="keyword">abbrev</span> declModifiersT <span class="constant">:=</span> declModifiers true
15706 
<span class="keyword">15707 builtin_initialize</span>
15708   register_parser_alias <span class="string">"declModifiers"</span>       declModifiersF
15709   register_parser_alias <span class="string">"nestedDeclModifiers"</span> declModifiersT
15710   register_parser_alias <span class="string">"declId"</span>              declId
15711   register_parser_alias <span class="string">"declSig"</span>             declSig
15712   register_parser_alias <span class="string">"declVal"</span>             declVal
15713   register_parser_alias <span class="string">"optDeclSig"</span>          optDeclSig
15714   register_parser_alias <span class="string">"openDecl"</span>            openDecl
15715 
<span class="keyword">15716 end</span> Command
15717 
<span class="keyword">15718 namespace</span> Term
<span class="doc">15719 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>open<span class="comment">&#187;</span> <span class="constant">:=</span> leading_parser:leadPrec <span class="string">"open "</span> <span class="constant">&gt;&gt;</span> Command.openDecl <span class="constant">&gt;&gt;</span> <span class="string">" in "</span> <span class="constant">&gt;&gt;</span> termParser
<span class="doc">15720 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>set_option<span class="comment">&#187;</span> <span class="constant">:=</span> leading_parser:leadPrec <span class="string">"set_option "</span> <span class="constant">&gt;&gt;</span> ident <span class="constant">&gt;&gt;</span> ppSpace <span class="constant">&gt;&gt;</span> Command.optionValue <span class="constant">&gt;&gt;</span> <span class="string">" in "</span> <span class="constant">&gt;&gt;</span> termParser
<span class="keyword">15721 end</span> Term
15722 
<span class="keyword">15723 namespace</span> Tactic
<span class="doc">15724 @[builtinTacticParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>open<span class="comment">&#187;</span> <span class="constant">:=</span> leading_parser:leadPrec <span class="string">"open "</span> <span class="constant">&gt;&gt;</span> Command.openDecl <span class="constant">&gt;&gt;</span> <span class="string">" in "</span> <span class="constant">&gt;&gt;</span> tacticSeq
<span class="doc">15725 @[builtinTacticParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>set_option<span class="comment">&#187;</span> <span class="constant">:=</span> leading_parser:leadPrec <span class="string">"set_option "</span> <span class="constant">&gt;&gt;</span> ident <span class="constant">&gt;&gt;</span> ppSpace <span class="constant">&gt;&gt;</span> Command.optionValue <span class="constant">&gt;&gt;</span> <span class="string">" in "</span> <span class="constant">&gt;&gt;</span> tacticSeq
<span class="keyword">15726 end</span> Tactic
15727 
<span class="keyword">15728 end</span> Parser
<span class="keyword">15729 end</span> Lean
15730 ::::::::::::::
15731 Parser<span class="constant">/</span>Do.lean
15732 ::::::::::::::
<span class="comment-delimiter">15733 /-</span><span class="comment">
15734 Copyright (c) 2020 Microsoft Corporation. All rights reserved.
15735 Released under Apache 2.0 license as described in the file LICENSE.
15736 Authors: Leonardo de Moura
15737 -/</span>
<span class="keyword">15738 import</span> Lean.Parser.Term
15739 
<span class="keyword">15740 namespace</span> Lean
<span class="keyword">15741 namespace</span> Parser
15742 
<span class="keyword">15743 builtin_initialize</span> registerBuiltinParserAttribute `builtinDoElemParser `doElem
<span class="keyword">15744 builtin_initialize</span> registerBuiltinDynamicParserAttribute `doElemParser `doElem
15745 
<span class="doc">15746 @[inline]</span> <span class="keyword">def</span> <span class="function-name">doElemParser</span> (rbp : Nat <span class="constant">:=</span> <span class="constant">0</span>) : Parser <span class="constant">:=</span>
15747   categoryParser `doElem rbp
15748 
<span class="keyword">15749 namespace</span> Term
<span class="keyword">15750 def</span> <span class="function-name">leftArrow</span> : Parser <span class="constant">:=</span> unicodeSymbol <span class="string">" &#8592; "</span> <span class="string">" &lt;- "</span>
<span class="doc">15751 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">liftMethod</span> <span class="constant">:=</span> leading_parser:minPrec leftArrow <span class="constant">&gt;&gt;</span> termParser
15752 
<span class="keyword">15753 def</span> <span class="function-name">doSeqItem</span>      <span class="constant">:=</span> leading_parser ppLine <span class="constant">&gt;&gt;</span> doElemParser <span class="constant">&gt;&gt;</span> optional <span class="string">"; "</span>
<span class="keyword">15754 def</span> <span class="function-name">doSeqIndent</span>    <span class="constant">:=</span> leading_parser many1Indent doSeqItem
<span class="keyword">15755 def</span> <span class="function-name">doSeqBracketed</span> <span class="constant">:=</span> leading_parser <span class="string">"{"</span> <span class="constant">&gt;&gt;</span> withoutPosition (many1 doSeqItem) <span class="constant">&gt;&gt;</span> ppLine <span class="constant">&gt;&gt;</span> <span class="string">"}"</span>
<span class="keyword">15756 def</span> <span class="function-name">doSeq</span>          <span class="constant">:=</span> doSeqBracketed <span class="constant">&lt;</span>|<span class="constant">&gt;</span> doSeqIndent
15757 
<span class="keyword">15758 def</span> <span class="function-name">termBeforeDo</span> <span class="constant">:=</span> withForbidden <span class="string">"do"</span> termParser
15759 
<span class="keyword">15760 attribute</span> <span class="doc">[runBuiltinParserAttributeHooks] </span>doSeq termBeforeDo
15761 
<span class="keyword">15762 builtin_initialize</span>
15763   register_parser_alias <span class="string">"doSeq"</span> doSeq
15764   register_parser_alias <span class="string">"termBeforeDo"</span> termBeforeDo
15765 
<span class="keyword">15766 def</span> <span class="function-name">notFollowedByRedefinedTermToken</span> <span class="constant">:=</span>
15767   <span class="comment-delimiter">-- </span><span class="comment">Remark: we don't currently support `open` and `set_option` in `do`-blocks, but we include them in the following list to fix the ambiguity
</span>15768   <span class="comment-delimiter">-- </span><span class="comment">"open" command following `do`-block. If we don't add `do`, then users would have to indent `do` blocks or use `{ ... }`.
</span>15769   notFollowedBy (<span class="string">"set_option"</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> <span class="string">"open"</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> <span class="string">"if"</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> <span class="string">"match"</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> <span class="string">"let"</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> <span class="string">"have"</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> <span class="string">"do"</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> <span class="string">"dbg_trace"</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> <span class="string">"assert!"</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> <span class="string">"for"</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> <span class="string">"unless"</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> <span class="string">"return"</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> symbol <span class="string">"try"</span>) <span class="string">"token at 'do' element"</span>
15770 
<span class="doc">15771 @[builtinDoElemParser]</span> <span class="keyword">def</span> <span class="function-name">doLet</span>      <span class="constant">:=</span> leading_parser <span class="string">"let "</span> <span class="constant">&gt;&gt;</span> optional <span class="string">"mut "</span> <span class="constant">&gt;&gt;</span> letDecl
15772 
<span class="doc">15773 @[builtinDoElemParser]</span> <span class="keyword">def</span> <span class="function-name">doLetRec</span>   <span class="constant">:=</span> leading_parser group (<span class="string">"let "</span> <span class="constant">&gt;&gt;</span> nonReservedSymbol <span class="string">"rec "</span>) <span class="constant">&gt;&gt;</span> letRecDecls
<span class="keyword">15774 def</span> <span class="function-name">doIdDecl</span>   <span class="constant">:=</span> leading_parser atomic (ident <span class="constant">&gt;&gt;</span> optType <span class="constant">&gt;&gt;</span> leftArrow) <span class="constant">&gt;&gt;</span> doElemParser
<span class="keyword">15775 def</span> <span class="function-name">doPatDecl</span>  <span class="constant">:=</span> leading_parser atomic (termParser <span class="constant">&gt;&gt;</span> leftArrow) <span class="constant">&gt;&gt;</span> doElemParser <span class="constant">&gt;&gt;</span> optional (checkColGt <span class="constant">&gt;&gt;</span> <span class="string">" | "</span> <span class="constant">&gt;&gt;</span> doElemParser)
<span class="doc">15776 @[builtinDoElemParser]</span> <span class="keyword">def</span> <span class="function-name">doLetArrow</span>      <span class="constant">:=</span> leading_parser withPosition (<span class="string">"let "</span> <span class="constant">&gt;&gt;</span> optional <span class="string">"mut "</span> <span class="constant">&gt;&gt;</span> (doIdDecl <span class="constant">&lt;</span>|<span class="constant">&gt;</span> doPatDecl))
15777 
<span class="comment-delimiter">15778 -- </span><span class="comment">We use `letIdDeclNoBinders` to define `doReassign`.
</span><span class="comment-delimiter">15779 -- </span><span class="comment">Motivation: we do not reassign functions, and avoid parser conflict
</span><span class="keyword">15780 def</span> <span class="function-name">letIdDeclNoBinders</span> <span class="constant">:=</span> node `Lean.Parser.Term.letIdDecl <span class="constant">$</span> atomic (ident <span class="constant">&gt;&gt;</span> pushNone <span class="constant">&gt;&gt;</span> optType <span class="constant">&gt;&gt;</span> <span class="string">" := "</span>) <span class="constant">&gt;&gt;</span> termParser
15781 
<span class="doc">15782 @[builtinDoElemParser]</span> <span class="keyword">def</span> <span class="function-name">doReassign</span>      <span class="constant">:=</span> leading_parser notFollowedByRedefinedTermToken <span class="constant">&gt;&gt;</span> (letIdDeclNoBinders <span class="constant">&lt;</span>|<span class="constant">&gt;</span> letPatDecl)
<span class="doc">15783 @[builtinDoElemParser]</span> <span class="keyword">def</span> <span class="function-name">doReassignArrow</span> <span class="constant">:=</span> leading_parser notFollowedByRedefinedTermToken <span class="constant">&gt;&gt;</span> withPosition (doIdDecl <span class="constant">&lt;</span>|<span class="constant">&gt;</span> doPatDecl)
<span class="doc">15784 @[builtinDoElemParser]</span> <span class="keyword">def</span> <span class="function-name">doHave</span>     <span class="constant">:=</span> leading_parser <span class="string">"have "</span> <span class="constant">&gt;&gt;</span> Term.haveDecl
<span class="comment-delimiter">15785 /-</span><span class="comment">
15786 In `do` blocks, we support `if` without an `else`. Thus, we use indentation to prevent examples such as
15787 ```
15788 if c_1 then
15789   if c_2 then
15790     action_1
15791 else
15792   action_2
15793 ```
15794 from being parsed as
15795 ```
15796 if c_1 then {
15797   if c_2 then {
15798     action_1
15799   } else {
15800     action_2
15801   }
15802 }
15803 ```
15804 We also have special support for `else if` because we don't want to write
15805 ```
15806 if c_1 then
15807   action_1
15808 else if c_2 then
15809        action_2
15810      else
15811        action_3
15812 ```
15813 -/</span>
<span class="keyword">15814 def</span> <span class="function-name">elseIf</span> <span class="constant">:=</span> atomic (group (withPosition (<span class="string">" else "</span> <span class="constant">&gt;&gt;</span> checkLineEq <span class="constant">&gt;&gt;</span> <span class="string">" if "</span>)))
<span class="comment-delimiter">15815 -- </span><span class="comment">ensure `if $e then ...` still binds to `e:term`
</span><span class="keyword">15816 def</span> <span class="function-name">doIfLetPure</span> <span class="constant">:=</span> leading_parser <span class="string">" := "</span> <span class="constant">&gt;&gt;</span> termParser
<span class="keyword">15817 def</span> <span class="function-name">doIfLetBind</span> <span class="constant">:=</span> leading_parser <span class="string">" &#8592; "</span> <span class="constant">&gt;&gt;</span> termParser
<span class="keyword">15818 def</span> <span class="function-name">doIfLet</span>     <span class="constant">:=</span> nodeWithAntiquot <span class="string">"doIfLet"</span>     `Lean.Parser.Term.doIfLet       <span class="constant">&lt;</span>| <span class="string">"let "</span> <span class="constant">&gt;&gt;</span> termParser <span class="constant">&gt;&gt;</span> (doIfLetPure <span class="constant">&lt;</span>|<span class="constant">&gt;</span> doIfLetBind)
<span class="keyword">15819 def</span> <span class="function-name">doIfProp</span>    <span class="constant">:=</span> nodeWithAntiquot <span class="string">"doIfProp"</span>    `Lean.Parser.Term.doIfProp      <span class="constant">&lt;</span>| optIdent <span class="constant">&gt;&gt;</span> termParser
<span class="keyword">15820 def</span> <span class="function-name">doIfCond</span>    <span class="constant">:=</span> withAntiquot (mkAntiquot <span class="string">"doIfCond"</span> none (anonymous <span class="constant">:=</span> false)) <span class="constant">&lt;</span>| doIfLet <span class="constant">&lt;</span>|<span class="constant">&gt;</span> doIfProp
<span class="doc">15821 @[builtinDoElemParser]</span> <span class="keyword">def</span> <span class="function-name">doIf</span> <span class="constant">:=</span> leading_parser withPosition <span class="constant">$</span>
15822   <span class="string">"if "</span> <span class="constant">&gt;&gt;</span> doIfCond <span class="constant">&gt;&gt;</span> <span class="string">" then "</span> <span class="constant">&gt;&gt;</span> doSeq
15823   <span class="constant">&gt;&gt;</span> many (checkColGe <span class="string">"'else if' in 'do' must be indented"</span> <span class="constant">&gt;&gt;</span> group (elseIf <span class="constant">&gt;&gt;</span> doIfCond <span class="constant">&gt;&gt;</span> <span class="string">" then "</span> <span class="constant">&gt;&gt;</span> doSeq))
15824   <span class="constant">&gt;&gt;</span> optional (checkColGe <span class="string">"'else' in 'do' must be indented"</span> <span class="constant">&gt;&gt;</span> <span class="string">" else "</span> <span class="constant">&gt;&gt;</span> doSeq)
<span class="doc">15825 @[builtinDoElemParser]</span> <span class="keyword">def</span> <span class="function-name">doUnless</span> <span class="constant">:=</span> leading_parser <span class="string">"unless "</span> <span class="constant">&gt;&gt;</span> withForbidden <span class="string">"do"</span> termParser <span class="constant">&gt;&gt;</span> <span class="string">"do "</span> <span class="constant">&gt;&gt;</span> doSeq
<span class="keyword">15826 def</span> <span class="function-name">doForDecl</span> <span class="constant">:=</span> leading_parser termParser <span class="constant">&gt;&gt;</span> <span class="string">" in "</span> <span class="constant">&gt;&gt;</span> withForbidden <span class="string">"do"</span> termParser
<span class="doc">15827 @[builtinDoElemParser]</span> <span class="keyword">def</span> <span class="function-name">doFor</span>    <span class="constant">:=</span> leading_parser <span class="string">"for "</span> <span class="constant">&gt;&gt;</span> sepBy1 doForDecl <span class="string">", "</span> <span class="constant">&gt;&gt;</span> <span class="string">"do "</span> <span class="constant">&gt;&gt;</span> doSeq
15828 
<span class="keyword">15829 def</span> <span class="function-name">doMatchAlts</span> <span class="constant">:=</span> matchAlts (rhsParser <span class="constant">:=</span> doSeq)
<span class="doc">15830 @[builtinDoElemParser]</span> <span class="keyword">def</span> <span class="function-name">doMatch</span> <span class="constant">:=</span> leading_parser:leadPrec <span class="string">"match "</span> <span class="constant">&gt;&gt;</span> optional Term.generalizingParam <span class="constant">&gt;&gt;</span> sepBy1 matchDiscr <span class="string">", "</span> <span class="constant">&gt;&gt;</span> optType <span class="constant">&gt;&gt;</span> <span class="string">" with "</span> <span class="constant">&gt;&gt;</span> doMatchAlts
15831 
<span class="keyword">15832 def</span> <span class="function-name">doCatch</span>      <span class="constant">:=</span> leading_parser atomic (<span class="string">"catch "</span> <span class="constant">&gt;&gt;</span> binderIdent) <span class="constant">&gt;&gt;</span> optional (<span class="string">" : "</span> <span class="constant">&gt;&gt;</span> termParser) <span class="constant">&gt;&gt;</span> darrow <span class="constant">&gt;&gt;</span> doSeq
<span class="keyword">15833 def</span> <span class="function-name">doCatchMatch</span> <span class="constant">:=</span> leading_parser <span class="string">"catch "</span> <span class="constant">&gt;&gt;</span> doMatchAlts
<span class="keyword">15834 def</span> <span class="function-name">doFinally</span>    <span class="constant">:=</span> leading_parser <span class="string">"finally "</span> <span class="constant">&gt;&gt;</span> doSeq
<span class="doc">15835 @[builtinDoElemParser]</span> <span class="keyword">def</span> <span class="function-name">doTry</span>    <span class="constant">:=</span> leading_parser <span class="string">"try "</span> <span class="constant">&gt;&gt;</span> doSeq <span class="constant">&gt;&gt;</span> many (doCatch <span class="constant">&lt;</span>|<span class="constant">&gt;</span> doCatchMatch) <span class="constant">&gt;&gt;</span> optional doFinally
15836 
<span class="doc">15837 @[builtinDoElemParser]</span> <span class="keyword">def</span> <span class="function-name">doBreak</span>     <span class="constant">:=</span> leading_parser <span class="string">"break"</span>
<span class="doc">15838 @[builtinDoElemParser]</span> <span class="keyword">def</span> <span class="function-name">doContinue</span>  <span class="constant">:=</span> leading_parser <span class="string">"continue"</span>
<span class="doc">15839 @[builtinDoElemParser]</span> <span class="keyword">def</span> <span class="function-name">doReturn</span>    <span class="constant">:=</span> leading_parser:leadPrec withPosition (<span class="string">"return "</span> <span class="constant">&gt;&gt;</span> optional (checkLineEq <span class="constant">&gt;&gt;</span> termParser))
<span class="doc">15840 @[builtinDoElemParser]</span> <span class="keyword">def</span> <span class="function-name">doDbgTrace</span>  <span class="constant">:=</span> leading_parser:leadPrec <span class="string">"dbg_trace "</span> <span class="constant">&gt;&gt;</span> ((interpolatedStr termParser) <span class="constant">&lt;</span>|<span class="constant">&gt;</span> termParser)
<span class="doc">15841 @[builtinDoElemParser]</span> <span class="keyword">def</span> <span class="function-name">doAssert</span>    <span class="constant">:=</span> leading_parser:leadPrec <span class="string">"assert! "</span> <span class="constant">&gt;&gt;</span> termParser
15842 
<span class="comment-delimiter">15843 /-</span><span class="comment">
15844 We use `notFollowedBy` to avoid counterintuitive behavior.
15845 
15846 For example, the `if`-term parser
15847 doesn't enforce indentation restrictions, but we don't want it to be used when `doIf` fails.
15848 Note that parser priorities would not solve this problem since the `doIf` parser is failing while the `if`
15849 parser is succeeding. The first `notFollowedBy` prevents this problem.
15850 
15851 Consider the `doElem` `x := (a, b&#10217;` it contains an error since we are using `&#10217;` instead of `)`. Thus, `doReassign` parser fails.
15852 However, `doExpr` would succeed consuming just `x`, and cryptic error message is generated after that.
15853 The second `notFollowedBy` prevents this problem.
15854 -/</span>
<span class="doc">15855 @[builtinDoElemParser]</span> <span class="keyword">def</span> <span class="function-name">doExpr</span>   <span class="constant">:=</span> leading_parser notFollowedByRedefinedTermToken <span class="constant">&gt;&gt;</span> termParser <span class="constant">&gt;&gt;</span> notFollowedBy (symbol <span class="string">":="</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> symbol <span class="string">"&#8592;"</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> symbol <span class="string">"&lt;-"</span>) <span class="string">"unexpected token after 'expr' in 'do' block"</span>
<span class="doc">15856 @[builtinDoElemParser]</span> <span class="keyword">def</span> <span class="function-name">doNested</span> <span class="constant">:=</span> leading_parser <span class="string">"do "</span> <span class="constant">&gt;&gt;</span> doSeq
15857 
<span class="doc">15858 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>do<span class="comment">&#187;</span>  <span class="constant">:=</span> leading_parser:argPrec <span class="string">"do "</span> <span class="constant">&gt;&gt;</span> doSeq
15859 
<span class="doc">15860 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">doElem.quot</span> : Parser <span class="constant">:=</span> leading_parser <span class="string">"`(doElem|"</span> <span class="constant">&gt;&gt;</span> toggleInsideQuot doElemParser <span class="constant">&gt;&gt;</span> <span class="string">")"</span>
15861 
<span class="comment-delimiter">15862 /- </span><span class="comment">macros for using `unless`, `for`, `try`, `return` as terms. They expand into `do unless ...`, `do for ...`, `do try ...`, and `do return ...` -/</span>
<span class="doc">15863 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">termUnless</span> <span class="constant">:=</span> leading_parser <span class="string">"unless "</span> <span class="constant">&gt;&gt;</span> withForbidden <span class="string">"do"</span> termParser <span class="constant">&gt;&gt;</span> <span class="string">"do "</span> <span class="constant">&gt;&gt;</span> doSeq
<span class="doc">15864 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">termFor</span>    <span class="constant">:=</span> leading_parser <span class="string">"for "</span> <span class="constant">&gt;&gt;</span> sepBy1 doForDecl <span class="string">", "</span> <span class="constant">&gt;&gt;</span> <span class="string">"do "</span> <span class="constant">&gt;&gt;</span> doSeq
<span class="doc">15865 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">termTry</span>    <span class="constant">:=</span> leading_parser <span class="string">"try "</span> <span class="constant">&gt;&gt;</span> doSeq <span class="constant">&gt;&gt;</span> many (doCatch <span class="constant">&lt;</span>|<span class="constant">&gt;</span> doCatchMatch) <span class="constant">&gt;&gt;</span> optional doFinally
<span class="doc">15866 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">termReturn</span> <span class="constant">:=</span> leading_parser:leadPrec withPosition (<span class="string">"return "</span> <span class="constant">&gt;&gt;</span> optional (checkLineEq <span class="constant">&gt;&gt;</span> termParser))
15867 
<span class="keyword">15868 end</span> Term
<span class="keyword">15869 end</span> Parser
<span class="keyword">15870 end</span> Lean
15871 ::::::::::::::
15872 Parser<span class="constant">/</span>Extension.lean
15873 ::::::::::::::
<span class="comment-delimiter">15874 /-</span><span class="comment">
15875 Copyright (c) 2020 Microsoft Corporation. All rights reserved.
15876 Released under Apache 2.0 license as described in the file LICENSE.
15877 Authors: Leonardo de Moura, Sebastian Ullrich
15878 -/</span>
<span class="keyword">15879 import</span> Lean.ScopedEnvExtension
<span class="keyword">15880 import</span> Lean.Parser.Basic
<span class="keyword">15881 import</span> Lean.Parser.StrInterpolation
<span class="keyword">15882 import</span> Lean.KeyedDeclsAttribute
15883 
<span class="comment-delimiter">15884 /-</span><span class="comment">! Extensible parsing via attributes -/</span>
15885 
<span class="keyword">15886 namespace</span> Lean
<span class="keyword">15887 namespace</span> Parser
15888 
<span class="keyword">15889 builtin_initialize</span> builtinTokenTable : IO.Ref TokenTable &#8592; IO.mkRef {}
15890 
<span class="comment-delimiter">15891 /- </span><span class="comment">Global table with all SyntaxNodeKind's -/</span>
<span class="keyword">15892 builtin_initialize</span> builtinSyntaxNodeKindSetRef : IO.Ref SyntaxNodeKindSet &#8592; IO.mkRef {}
15893 
<span class="keyword">15894 def</span> <span class="function-name">registerBuiltinNodeKind</span> (k : SyntaxNodeKind) : IO Unit <span class="constant">:=</span>
15895   builtinSyntaxNodeKindSetRef.modify <span class="keyword">fun</span> s <span class="constant">=&gt;</span> s.insert k
15896 
<span class="keyword">15897 builtin_initialize</span>
15898   registerBuiltinNodeKind choiceKind
15899   registerBuiltinNodeKind identKind
15900   registerBuiltinNodeKind strLitKind
15901   registerBuiltinNodeKind numLitKind
15902   registerBuiltinNodeKind scientificLitKind
15903   registerBuiltinNodeKind charLitKind
15904   registerBuiltinNodeKind nameLitKind
15905 
<span class="keyword">15906 builtin_initialize</span> builtinParserCategoriesRef : IO.Ref ParserCategories &#8592; IO.mkRef {}
15907 
<span class="keyword">15908 private</span> <span class="keyword">def</span> <span class="function-name">throwParserCategoryAlreadyDefined</span> {&#945;} (catName : Name) : ExceptT String Id &#945; <span class="constant">:=</span>
15909   throw s<span class="constant">!</span><span class="string">"parser category '{catName}' has already been defined"</span>
15910 
<span class="keyword">15911 private</span> <span class="keyword">def</span> <span class="function-name">addParserCategoryCore</span> (categories : ParserCategories) (catName : Name) (initial : ParserCategory) : Except String ParserCategories <span class="constant">:=</span>
15912   <span class="keyword">if</span> categories.contains catName <span class="keyword">then</span>
15913     throwParserCategoryAlreadyDefined catName
15914   <span class="keyword">else</span>
15915     pure <span class="constant">$</span> categories.insert catName initial
15916 
<span class="comment-delimiter">15917 /-</span><span class="comment">- All builtin parser categories are Pratt's parsers -/</span>
15918 
<span class="keyword">15919 private</span> <span class="keyword">def</span> <span class="function-name">addBuiltinParserCategory</span> (catName : Name) (behavior : LeadingIdentBehavior) : IO Unit <span class="constant">:=</span> <span class="keyword">do</span>
15920   <span class="keyword">let</span> categories &#8592; builtinParserCategoriesRef.get
15921   <span class="keyword">let</span> categories &#8592; IO.ofExcept <span class="constant">$</span> addParserCategoryCore categories catName { tables <span class="constant">:=</span> {}, behavior <span class="constant">:=</span> behavior}
15922   builtinParserCategoriesRef.set categories
15923 
<span class="keyword">15924 namespace</span> ParserExtension
15925 
<span class="keyword">15926 inductive</span> <span class="function-name">OLeanEntry</span> <span class="keyword">where</span>
15927   | token     (val : Token) : OLeanEntry
15928   | kind      (val : SyntaxNodeKind) : OLeanEntry
15929   | category  (catName : Name) (behavior : LeadingIdentBehavior)
15930   | parser    (catName : Name) (declName : Name) (prio : Nat) : OLeanEntry
15931   <span class="keyword">deriving</span> Inhabited
15932 
<span class="keyword">15933 inductive</span> <span class="function-name">Entry</span> <span class="keyword">where</span>
15934   | token     (val : Token) : Entry
15935   | kind      (val : SyntaxNodeKind) : Entry
15936   | category  (catName : Name) (behavior : LeadingIdentBehavior)
15937   | parser    (catName : Name) (declName : Name) (leading : Bool) (p : Parser) (prio : Nat) : Entry
15938   <span class="keyword">deriving</span> Inhabited
15939 
<span class="keyword">15940 def</span> <span class="function-name">Entry.toOLeanEntry</span> : Entry <span class="constant">&#8594;</span> OLeanEntry
15941   | token v             <span class="constant">=&gt;</span> OLeanEntry.token v
15942   | kind v              <span class="constant">=&gt;</span> OLeanEntry.kind v
15943   | category c b        <span class="constant">=&gt;</span> OLeanEntry.category c b
15944   | parser c d <span class="preprocessor">_</span> <span class="preprocessor">_</span> prio <span class="constant">=&gt;</span> OLeanEntry.parser c d prio
15945 
<span class="keyword">15946 structure</span> <span class="function-name">State</span> <span class="keyword">where</span>
15947   tokens      : TokenTable <span class="constant">:=</span> {}
15948   kinds       : SyntaxNodeKindSet <span class="constant">:=</span> {}
15949   categories  : ParserCategories <span class="constant">:=</span> {}
15950   <span class="keyword">deriving</span> Inhabited
15951 
<span class="keyword">15952 end</span> ParserExtension
15953 
<span class="keyword">15954 open</span> ParserExtension <span class="keyword">in</span>
<span class="keyword">15955 abbrev</span> ParserExtension <span class="constant">:=</span> ScopedEnvExtension OLeanEntry Entry State
15956 
<span class="keyword">15957 private</span> <span class="keyword">def</span> <span class="function-name">ParserExtension.mkInitial</span> : IO ParserExtension.State <span class="constant">:=</span> <span class="keyword">do</span>
15958   <span class="keyword">let</span> tokens     &#8592; builtinTokenTable.get
15959   <span class="keyword">let</span> kinds      &#8592; builtinSyntaxNodeKindSetRef.get
15960   <span class="keyword">let</span> categories &#8592; builtinParserCategoriesRef.get
15961   pure { tokens <span class="constant">:=</span> tokens, kinds <span class="constant">:=</span> kinds, categories <span class="constant">:=</span> categories }
15962 
<span class="keyword">15963 private</span> <span class="keyword">def</span> <span class="function-name">addTokenConfig</span> (tokens : TokenTable) (tk : Token) : Except String TokenTable <span class="constant">:=</span> <span class="keyword">do</span>
15964   <span class="keyword">if</span> tk <span class="constant">==</span> <span class="string">""</span> <span class="keyword">then</span> throw <span class="string">"invalid empty symbol"</span>
15965   <span class="keyword">else</span> <span class="keyword">match</span> tokens.find? tk <span class="keyword">with</span>
15966     | none   <span class="constant">=&gt;</span> pure <span class="constant">$</span> tokens.insert tk tk
15967     | some <span class="preprocessor">_</span> <span class="constant">=&gt;</span> pure tokens
15968 
<span class="keyword">15969 def</span> <span class="function-name">throwUnknownParserCategory</span> {&#945;} (catName : Name) : ExceptT String Id &#945; <span class="constant">:=</span>
15970   throw s<span class="constant">!</span><span class="string">"unknown parser category '{catName}'"</span>
15971 
<span class="keyword">15972 abbrev</span> getCategory (categories : ParserCategories) (catName : Name) : Option ParserCategory <span class="constant">:=</span>
15973   categories.find? catName
15974 
<span class="keyword">15975 def</span> <span class="function-name">addLeadingParser</span> (categories : ParserCategories) (catName : Name) (parserName : Name) (p : Parser) (prio : Nat) : Except String ParserCategories <span class="constant">:=</span>
15976   <span class="keyword">match</span> getCategory categories catName <span class="keyword">with</span>
15977   | none     <span class="constant">=&gt;</span>
15978     throwUnknownParserCategory catName
15979   | some cat <span class="constant">=&gt;</span>
15980     <span class="keyword">let</span> addTokens (tks : List Token) : Except String ParserCategories <span class="constant">:=</span>
15981       <span class="keyword">let</span> tks    <span class="constant">:=</span> tks.map <span class="constant">$</span> <span class="keyword">fun</span> tk <span class="constant">=&gt;</span> Name.mkSimple tk
15982       <span class="keyword">let</span> tables <span class="constant">:=</span> tks.eraseDups.foldl (<span class="keyword">fun</span> (tables : PrattParsingTables) tk <span class="constant">=&gt;</span> { tables <span class="keyword">with</span> leadingTable <span class="constant">:=</span> tables.leadingTable.insert tk (p, prio) }) cat.tables
15983       pure <span class="constant">$</span> categories.insert catName { cat <span class="keyword">with</span> tables <span class="constant">:=</span> tables }
15984     <span class="keyword">match</span> p.info.firstTokens <span class="keyword">with</span>
15985     | FirstTokens.tokens tks    <span class="constant">=&gt;</span> addTokens tks
15986     | FirstTokens.optTokens tks <span class="constant">=&gt;</span> addTokens tks
15987     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
15988       <span class="keyword">let</span> tables <span class="constant">:=</span> { cat.tables <span class="keyword">with</span> leadingParsers <span class="constant">:=</span> (p, prio) :: cat.tables.leadingParsers }
15989       pure <span class="constant">$</span> categories.insert catName { cat <span class="keyword">with</span> tables <span class="constant">:=</span> tables }
15990 
<span class="keyword">15991 private</span> <span class="keyword">def</span> <span class="function-name">addTrailingParserAux</span> (tables : PrattParsingTables) (p : TrailingParser) (prio : Nat) : PrattParsingTables <span class="constant">:=</span>
15992   <span class="keyword">let</span> addTokens (tks : List Token) : PrattParsingTables <span class="constant">:=</span>
15993     <span class="keyword">let</span> tks <span class="constant">:=</span> tks.map <span class="keyword">fun</span> tk <span class="constant">=&gt;</span> Name.mkSimple tk
15994     tks.eraseDups.foldl (<span class="keyword">fun</span> (tables : PrattParsingTables) tk <span class="constant">=&gt;</span> { tables <span class="keyword">with</span> trailingTable <span class="constant">:=</span> tables.trailingTable.insert tk (p, prio) }) tables
15995   <span class="keyword">match</span> p.info.firstTokens <span class="keyword">with</span>
15996   | FirstTokens.tokens tks    <span class="constant">=&gt;</span> addTokens tks
15997   | FirstTokens.optTokens tks <span class="constant">=&gt;</span> addTokens tks
15998   | <span class="preprocessor">_</span>                         <span class="constant">=&gt;</span> { tables <span class="keyword">with</span> trailingParsers <span class="constant">:=</span> (p, prio) :: tables.trailingParsers }
15999 
<span class="keyword">16000 def</span> <span class="function-name">addTrailingParser</span> (categories : ParserCategories) (catName : Name) (p : TrailingParser) (prio : Nat) : Except String ParserCategories <span class="constant">:=</span>
16001   <span class="keyword">match</span> getCategory categories catName <span class="keyword">with</span>
16002   | none     <span class="constant">=&gt;</span> throwUnknownParserCategory catName
16003   | some cat <span class="constant">=&gt;</span> pure <span class="constant">$</span> categories.insert catName { cat <span class="keyword">with</span> tables <span class="constant">:=</span> addTrailingParserAux cat.tables p prio }
16004 
<span class="keyword">16005 def</span> <span class="function-name">addParser</span> (categories : ParserCategories) (catName : Name) (declName : Name) (leading : Bool) (p : Parser) (prio : Nat) : Except String ParserCategories <span class="constant">:=</span>
16006   <span class="keyword">match</span> leading, p <span class="keyword">with</span>
16007   | true, p  <span class="constant">=&gt;</span> addLeadingParser categories catName declName p prio
16008   | false, p <span class="constant">=&gt;</span> addTrailingParser categories catName p prio
16009 
<span class="keyword">16010 def</span> <span class="function-name">addParserTokens</span> (tokenTable : TokenTable) (info : ParserInfo) : Except String TokenTable <span class="constant">:=</span>
16011   <span class="keyword">let</span> newTokens <span class="constant">:=</span> info.collectTokens []
16012   newTokens.foldlM addTokenConfig tokenTable
16013 
<span class="keyword">16014 private</span> <span class="keyword">def</span> <span class="function-name">updateBuiltinTokens</span> (info : ParserInfo) (declName : Name) : IO Unit <span class="constant">:=</span> <span class="keyword">do</span>
16015   <span class="keyword">let</span> tokenTable &#8592; builtinTokenTable.swap {}
16016   <span class="keyword">match</span> addParserTokens tokenTable info <span class="keyword">with</span>
16017   | Except.ok tokenTable <span class="constant">=&gt;</span> builtinTokenTable.set tokenTable
16018   | Except.error msg     <span class="constant">=&gt;</span> throw (IO.userError s<span class="constant">!</span><span class="string">"invalid builtin parser '{declName}', {msg}"</span>)
16019 
<span class="keyword">16020 def</span> <span class="function-name">addBuiltinParser</span> (catName : Name) (declName : Name) (leading : Bool) (p : Parser) (prio : Nat) : IO Unit <span class="constant">:=</span> <span class="keyword">do</span>
16021   <span class="keyword">let</span> p <span class="constant">:=</span> evalInsideQuot declName p
16022   <span class="keyword">let</span> categories &#8592; builtinParserCategoriesRef.get
16023   <span class="keyword">let</span> categories &#8592; IO.ofExcept <span class="constant">$</span> addParser categories catName declName leading p prio
16024   builtinParserCategoriesRef.set categories
16025   builtinSyntaxNodeKindSetRef.modify p.info.collectKinds
16026   updateBuiltinTokens p.info declName
16027 
<span class="keyword">16028 def</span> <span class="function-name">addBuiltinLeadingParser</span> (catName : Name) (declName : Name) (p : Parser) (prio : Nat) : IO Unit <span class="constant">:=</span>
16029   addBuiltinParser catName declName true p prio
16030 
<span class="keyword">16031 def</span> <span class="function-name">addBuiltinTrailingParser</span> (catName : Name) (declName : Name) (p : TrailingParser) (prio : Nat) : IO Unit <span class="constant">:=</span>
16032   addBuiltinParser catName declName false p prio
16033 
<span class="keyword">16034 def</span> <span class="function-name">ParserExtension.addEntryImpl</span> (s : State) (e : Entry) : State <span class="constant">:=</span>
16035   <span class="keyword">match</span> e <span class="keyword">with</span>
16036   | Entry.token tk <span class="constant">=&gt;</span>
16037     <span class="keyword">match</span> addTokenConfig s.tokens tk <span class="keyword">with</span>
16038     | Except.ok tokens <span class="constant">=&gt;</span> { s <span class="keyword">with</span> tokens <span class="constant">:=</span> tokens }
16039     | <span class="preprocessor">_</span>                <span class="constant">=&gt;</span> <span class="warning">unreachable</span><span class="constant">!</span>
16040   | Entry.kind k <span class="constant">=&gt;</span>
16041     { s <span class="keyword">with</span> kinds <span class="constant">:=</span> s.kinds.insert k }
16042   | Entry.category catName behavior <span class="constant">=&gt;</span>
16043     <span class="keyword">if</span> s.categories.contains catName <span class="keyword">then</span> s
16044     <span class="keyword">else</span> { s <span class="keyword">with</span>
16045            categories <span class="constant">:=</span> s.categories.insert catName { tables <span class="constant">:=</span> {}, behavior <span class="constant">:=</span> behavior } }
16046   | Entry.parser catName declName leading parser prio <span class="constant">=&gt;</span>
16047     <span class="keyword">match</span> addParser s.categories catName declName leading parser prio <span class="keyword">with</span>
16048     | Except.ok categories <span class="constant">=&gt;</span> { s <span class="keyword">with</span> categories <span class="constant">:=</span> categories }
16049     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="warning">unreachable</span><span class="constant">!</span>
16050 
<span class="keyword">16051 unsafe</span> <span class="keyword">def</span> <span class="function-name">mkParserOfConstantUnsafe</span>
16052     (categories : ParserCategories) (constName : Name) (compileParserDescr : ParserDescr <span class="constant">&#8594;</span> ImportM Parser) : ImportM (Bool <span class="constant">&#215;</span> Parser) <span class="constant">:=</span> <span class="keyword">do</span>
16053   <span class="keyword">let</span> env  <span class="constant">:=</span> (&#8592; read).env
16054   <span class="keyword">let</span> opts <span class="constant">:=</span> (&#8592; read).opts
16055   <span class="keyword">match</span> env.find? constName <span class="keyword">with</span>
16056   | none      <span class="constant">=&gt;</span> throw &#8593;s<span class="constant">!</span><span class="string">"unknow constant '{constName}'"</span>
16057   | some info <span class="constant">=&gt;</span>
16058     <span class="keyword">match</span> info.type <span class="keyword">with</span>
16059     | Expr.const `Lean.Parser.TrailingParser <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
16060       <span class="keyword">let</span> p &#8592; IO.ofExcept <span class="constant">$</span> env.evalConst Parser opts constName
16061       pure &#10216;false, p&#10217;
16062     | Expr.const `Lean.Parser.Parser <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
16063       <span class="keyword">let</span> p &#8592; IO.ofExcept <span class="constant">$</span> env.evalConst Parser opts constName
16064       pure &#10216;true, p&#10217;
16065     | Expr.const `Lean.ParserDescr <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
16066       <span class="keyword">let</span> d &#8592; IO.ofExcept <span class="constant">$</span> env.evalConst ParserDescr opts constName
16067       <span class="keyword">let</span> p &#8592; compileParserDescr d
16068       pure &#10216;true, p&#10217;
16069     | Expr.const `Lean.TrailingParserDescr <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span>
16070       <span class="keyword">let</span> d &#8592; IO.ofExcept <span class="constant">$</span> env.evalConst TrailingParserDescr opts constName
16071       <span class="keyword">let</span> p &#8592; compileParserDescr d
16072       pure &#10216;false, p&#10217;
16073     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throw &#8593;s<span class="constant">!</span><span class="string">"unexpected parser type at '{constName}' (`ParserDescr`, `TrailingParserDescr`, `Parser` or `TrailingParser` expected"</span>
16074 
<span class="doc">16075 @[implementedBy mkParserOfConstantUnsafe]</span>
<span class="keyword">16076 constant</span> <span class="function-name">mkParserOfConstantAux</span>
16077     (categories : ParserCategories) (constName : Name) (compileParserDescr : ParserDescr <span class="constant">&#8594;</span> ImportM Parser) : ImportM (Bool <span class="constant">&#215;</span> Parser)
16078 
<span class="comment-delimiter">16079 /- </span><span class="comment">Parser aliases for making `ParserDescr` extensible -/</span>
<span class="keyword">16080 inductive</span> <span class="function-name">AliasValue</span> (&#945; : <span class="type">Type</span>) <span class="keyword">where</span>
16081   | const  (p : &#945;)
16082   | unary  (p : &#945; <span class="constant">&#8594;</span> &#945;)
16083   | binary (p : &#945; <span class="constant">&#8594;</span> &#945; <span class="constant">&#8594;</span> &#945;)
16084 
<span class="keyword">16085 abbrev</span> AliasTable (&#945;) <span class="constant">:=</span> NameMap (AliasValue &#945;)
16086 
<span class="keyword">16087 def</span> <span class="function-name">registerAliasCore</span> {&#945;} (mapRef : IO.Ref (AliasTable &#945;)) (aliasName : Name) (value : AliasValue &#945;) : IO Unit <span class="constant">:=</span> <span class="keyword">do</span>
16088   <span class="keyword">unless</span> (&#8592; IO.initializing) <span class="keyword">do</span> throw &#8593;<span class="string">"aliases can only be registered during initialization"</span>
16089   <span class="keyword">if</span> (&#8592; mapRef.get).contains aliasName <span class="keyword">then</span>
16090     throw &#8593;s<span class="constant">!</span><span class="string">"alias '{aliasName}' has already been declared"</span>
16091   mapRef.modify (&#183;.insert aliasName value)
16092 
<span class="keyword">16093 def</span> <span class="function-name">getAlias</span> {&#945;} (mapRef : IO.Ref (AliasTable &#945;)) (aliasName : Name) : IO (Option (AliasValue &#945;)) <span class="constant">:=</span> <span class="keyword">do</span>
16094   <span class="keyword">return</span> (&#8592; mapRef.get).find? aliasName
16095 
<span class="keyword">16096 def</span> <span class="function-name">getConstAlias</span> {&#945;} (mapRef : IO.Ref (AliasTable &#945;)) (aliasName : Name) : IO &#945; <span class="constant">:=</span> <span class="keyword">do</span>
16097   <span class="keyword">match</span> (&#8592; getAlias mapRef aliasName) <span class="keyword">with</span>
16098   | some (AliasValue.const v)  <span class="constant">=&gt;</span> pure v
16099   | some (AliasValue.unary <span class="preprocessor">_</span>)  <span class="constant">=&gt;</span> throw &#8593;s<span class="constant">!</span><span class="string">"parser '{aliasName}' is not a constant, it takes one argument"</span>
16100   | some (AliasValue.binary <span class="preprocessor">_</span>) <span class="constant">=&gt;</span> throw &#8593;s<span class="constant">!</span><span class="string">"parser '{aliasName}' is not a constant, it takes two arguments"</span>
16101   | none   <span class="constant">=&gt;</span> throw &#8593;s<span class="constant">!</span><span class="string">"parser '{aliasName}' was not found"</span>
16102 
<span class="keyword">16103 def</span> <span class="function-name">getUnaryAlias</span> {&#945;} (mapRef : IO.Ref (AliasTable &#945;)) (aliasName : Name) : IO (&#945; <span class="constant">&#8594;</span> &#945;) <span class="constant">:=</span> <span class="keyword">do</span>
16104   <span class="keyword">match</span> (&#8592; getAlias mapRef aliasName) <span class="keyword">with</span>
16105   | some (AliasValue.unary v) <span class="constant">=&gt;</span> pure v
16106   | some <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throw &#8593;s<span class="constant">!</span><span class="string">"parser '{aliasName}' does not take one argument"</span>
16107   | none   <span class="constant">=&gt;</span> throw &#8593;s<span class="constant">!</span><span class="string">"parser '{aliasName}' was not found"</span>
16108 
<span class="keyword">16109 def</span> <span class="function-name">getBinaryAlias</span> {&#945;} (mapRef : IO.Ref (AliasTable &#945;)) (aliasName : Name) : IO (&#945; <span class="constant">&#8594;</span> &#945; <span class="constant">&#8594;</span> &#945;) <span class="constant">:=</span> <span class="keyword">do</span>
16110   <span class="keyword">match</span> (&#8592; getAlias mapRef aliasName) <span class="keyword">with</span>
16111   | some (AliasValue.binary v) <span class="constant">=&gt;</span> pure v
16112   | some <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throw &#8593;s<span class="constant">!</span><span class="string">"parser '{aliasName}' does not take two arguments"</span>
16113   | none   <span class="constant">=&gt;</span> throw &#8593;s<span class="constant">!</span><span class="string">"parser '{aliasName}' was not found"</span>
16114 
<span class="keyword">16115 abbrev</span> ParserAliasValue <span class="constant">:=</span> AliasValue Parser
16116 
<span class="keyword">16117 builtin_initialize</span> parserAliasesRef : IO.Ref (NameMap ParserAliasValue) &#8592; IO.mkRef {}
16118 
<span class="comment-delimiter">16119 -- </span><span class="comment">Later, we define macro registerParserAlias! which registers a parser, formatter and parenthesizer
</span><span class="keyword">16120 def</span> <span class="function-name">registerAlias</span> (aliasName : Name) (p : ParserAliasValue) : IO Unit <span class="constant">:=</span> <span class="keyword">do</span>
16121   registerAliasCore parserAliasesRef aliasName p
16122 
<span class="keyword">16123 instance</span> <span class="function-name">:</span> Coe Parser ParserAliasValue <span class="constant">:=</span> { coe <span class="constant">:=</span> AliasValue.const }
<span class="keyword">16124 instance</span> <span class="function-name">:</span> Coe (Parser <span class="constant">&#8594;</span> Parser) ParserAliasValue <span class="constant">:=</span> { coe <span class="constant">:=</span> AliasValue.unary }
<span class="keyword">16125 instance</span> <span class="function-name">:</span> Coe (Parser <span class="constant">&#8594;</span> Parser <span class="constant">&#8594;</span> Parser) ParserAliasValue <span class="constant">:=</span> { coe <span class="constant">:=</span> AliasValue.binary }
16126 
<span class="keyword">16127 def</span> <span class="function-name">isParserAlias</span> (aliasName : Name) : IO Bool <span class="constant">:=</span> <span class="keyword">do</span>
16128   <span class="keyword">match</span> (&#8592; getAlias parserAliasesRef aliasName) <span class="keyword">with</span>
16129   | some <span class="preprocessor">_</span> <span class="constant">=&gt;</span> pure true
16130   | <span class="preprocessor">_</span>      <span class="constant">=&gt;</span> pure false
16131 
<span class="keyword">16132 def</span> <span class="function-name">ensureUnaryParserAlias</span> (aliasName : Name) : IO Unit <span class="constant">:=</span>
16133   discard <span class="constant">$</span> getUnaryAlias parserAliasesRef aliasName
16134 
<span class="keyword">16135 def</span> <span class="function-name">ensureBinaryParserAlias</span> (aliasName : Name) : IO Unit <span class="constant">:=</span>
16136   discard <span class="constant">$</span> getBinaryAlias parserAliasesRef aliasName
16137 
<span class="keyword">16138 def</span> <span class="function-name">ensureConstantParserAlias</span> (aliasName : Name) : IO Unit <span class="constant">:=</span>
16139   discard <span class="constant">$</span> getConstAlias parserAliasesRef aliasName
16140 
<span class="keyword">16141 partial</span> <span class="keyword">def</span> <span class="function-name">compileParserDescr</span> (categories : ParserCategories) (d : ParserDescr) : ImportM Parser <span class="constant">:=</span>
16142   <span class="keyword">let</span> <span class="keyword">rec</span> visit : ParserDescr <span class="constant">&#8594;</span> ImportM Parser
16143     | ParserDescr.const n                             <span class="constant">=&gt;</span> getConstAlias parserAliasesRef n
16144     | ParserDescr.unary n d                           <span class="constant">=&gt;</span> <span class="keyword">return</span> (&#8592; getUnaryAlias parserAliasesRef n) (&#8592; visit d)
16145     | ParserDescr.binary n d&#8321; d&#8322;                      <span class="constant">=&gt;</span> <span class="keyword">return</span> (&#8592; getBinaryAlias parserAliasesRef n) (&#8592; visit d&#8321;) (&#8592; visit d&#8322;)
16146     | ParserDescr.node k prec d                       <span class="constant">=&gt;</span> <span class="keyword">return</span> leadingNode k prec (&#8592; visit d)
16147     | ParserDescr.nodeWithAntiquot n k d              <span class="constant">=&gt;</span> <span class="keyword">return</span> nodeWithAntiquot n k (&#8592; visit d) (anonymous <span class="constant">:=</span> true)
16148     | ParserDescr.sepBy p sep psep trail              <span class="constant">=&gt;</span> <span class="keyword">return</span> sepBy (&#8592; visit p) sep (&#8592; visit psep) trail
16149     | ParserDescr.sepBy1 p sep psep trail             <span class="constant">=&gt;</span> <span class="keyword">return</span> sepBy1 (&#8592; visit p) sep (&#8592; visit psep) trail
16150     | ParserDescr.trailingNode k prec lhsPrec d       <span class="constant">=&gt;</span> <span class="keyword">return</span> trailingNode k prec lhsPrec (&#8592; visit d)
16151     | ParserDescr.symbol tk                           <span class="constant">=&gt;</span> <span class="keyword">return</span> symbol tk
16152     | ParserDescr.nonReservedSymbol tk includeIdent   <span class="constant">=&gt;</span> <span class="keyword">return</span> nonReservedSymbol tk includeIdent
16153     | ParserDescr.parser constName                    <span class="constant">=&gt;</span> <span class="keyword">do</span>
16154       <span class="keyword">let</span> (<span class="preprocessor">_</span>, p) &#8592; mkParserOfConstantAux categories constName visit;
16155       pure p
16156     | ParserDescr.cat catName prec                    <span class="constant">=&gt;</span>
16157       <span class="keyword">match</span> getCategory categories catName <span class="keyword">with</span>
16158       | some <span class="preprocessor">_</span> <span class="constant">=&gt;</span> pure <span class="constant">$</span> categoryParser catName prec
16159       | none   <span class="constant">=&gt;</span> IO.ofExcept <span class="constant">$</span> throwUnknownParserCategory catName
16160   visit d
16161 
<span class="keyword">16162 def</span> <span class="function-name">mkParserOfConstant</span> (categories : ParserCategories) (constName : Name) : ImportM (Bool <span class="constant">&#215;</span> Parser) <span class="constant">:=</span>
16163   mkParserOfConstantAux categories constName (compileParserDescr categories)
16164 
<span class="keyword">16165 structure</span> <span class="function-name">ParserAttributeHook</span> <span class="keyword">where</span>
16166   <span class="comment-delimiter">/- </span><span class="comment">Called after a parser attribute is applied to a declaration. -/</span>
16167   postAdd (catName : Name) (declName : Name) (builtin : Bool) : AttrM Unit
16168 
<span class="keyword">16169 builtin_initialize</span> parserAttributeHooks : IO.Ref (List ParserAttributeHook) &#8592; IO.mkRef {}
16170 
<span class="keyword">16171 def</span> <span class="function-name">registerParserAttributeHook</span> (hook : ParserAttributeHook) : IO Unit <span class="constant">:=</span> <span class="keyword">do</span>
16172   parserAttributeHooks.modify <span class="keyword">fun</span> hooks <span class="constant">=&gt;</span> hook::hooks
16173 
<span class="keyword">16174 def</span> <span class="function-name">runParserAttributeHooks</span> (catName : Name) (declName : Name) (builtin : Bool) : AttrM Unit <span class="constant">:=</span> <span class="keyword">do</span>
16175   <span class="keyword">let</span> hooks &#8592; parserAttributeHooks.get
16176   hooks.forM <span class="keyword">fun</span> hook <span class="constant">=&gt;</span> hook.postAdd catName declName builtin
16177 
<span class="keyword">16178 builtin_initialize</span>
16179   registerBuiltinAttribute {
16180     name  <span class="constant">:=</span> `runBuiltinParserAttributeHooks,
16181     descr <span class="constant">:=</span> <span class="string">"explicitly run hooks normally activated by builtin parser attributes"</span>,
16182     add   <span class="constant">:=</span> <span class="keyword">fun</span> decl stx persistent <span class="constant">=&gt;</span> <span class="keyword">do</span>
16183       Attribute.Builtin.ensureNoArgs stx
16184       runParserAttributeHooks Name.anonymous decl (builtin <span class="constant">:=</span> true)
16185   }
16186 
<span class="keyword">16187 builtin_initialize</span>
16188   registerBuiltinAttribute {
16189     name  <span class="constant">:=</span> `runParserAttributeHooks,
16190     descr <span class="constant">:=</span> <span class="string">"explicitly run hooks normally activated by parser attributes"</span>,
16191     add   <span class="constant">:=</span> <span class="keyword">fun</span> decl stx persistent <span class="constant">=&gt;</span> <span class="keyword">do</span>
16192       Attribute.Builtin.ensureNoArgs stx
16193       runParserAttributeHooks Name.anonymous decl (builtin <span class="constant">:=</span> false)
16194   }
16195 
<span class="keyword">16196 private</span> <span class="keyword">def</span> <span class="function-name">ParserExtension.OLeanEntry.toEntry</span> (s : State) : OLeanEntry <span class="constant">&#8594;</span> ImportM Entry
16197   | token tk     <span class="constant">=&gt;</span> <span class="keyword">return</span> Entry.token tk
16198   | kind k       <span class="constant">=&gt;</span> <span class="keyword">return</span> Entry.kind k
16199   | category c l <span class="constant">=&gt;</span> <span class="keyword">return</span> Entry.category c l
16200   | parser catName declName prio <span class="constant">=&gt;</span> <span class="keyword">do</span>
16201     <span class="keyword">let</span> (leading, p) &#8592; mkParserOfConstant s.categories declName
16202     Entry.parser catName declName leading p prio
16203 
<span class="keyword">16204 builtin_initialize</span> parserExtension : ParserExtension &#8592;
16205   registerScopedEnvExtension {
16206     name            <span class="constant">:=</span> `parserExt
16207     mkInitial       <span class="constant">:=</span> ParserExtension.mkInitial
16208     addEntry        <span class="constant">:=</span> ParserExtension.addEntryImpl
16209     toOLeanEntry    <span class="constant">:=</span> ParserExtension.Entry.toOLeanEntry
16210     ofOLeanEntry    <span class="constant">:=</span> ParserExtension.OLeanEntry.toEntry
16211   }
16212 
<span class="keyword">16213 def</span> <span class="function-name">isParserCategory</span> (env : Environment) (catName : Name) : Bool <span class="constant">:=</span>
16214   (parserExtension.getState env).categories.contains catName
16215 
<span class="keyword">16216 def</span> <span class="function-name">addParserCategory</span> (env : Environment) (catName : Name) (behavior : LeadingIdentBehavior) : Except String Environment <span class="constant">:=</span> <span class="keyword">do</span>
16217   <span class="keyword">if</span> isParserCategory env catName <span class="keyword">then</span>
16218     throwParserCategoryAlreadyDefined catName
16219   <span class="keyword">else</span>
16220     <span class="keyword">return</span> parserExtension.addEntry env <span class="constant">&lt;</span>| ParserExtension.Entry.category catName behavior
16221 
<span class="keyword">16222 def</span> <span class="function-name">leadingIdentBehavior</span> (env : Environment) (catName : Name) : LeadingIdentBehavior <span class="constant">:=</span>
16223   <span class="keyword">match</span> getCategory (parserExtension.getState env).categories catName <span class="keyword">with</span>
16224   | none     <span class="constant">=&gt;</span> LeadingIdentBehavior.default
16225   | some cat <span class="constant">=&gt;</span> cat.behavior
16226 
<span class="keyword">16227 def</span> <span class="function-name">mkCategoryAntiquotParser</span> (kind : Name) : Parser <span class="constant">:=</span>
16228   mkAntiquot kind.toString none
16229 
<span class="comment-delimiter">16230 -- </span><span class="comment">helper decl to work around inlining issue https://github.com/leanprover/lean4/commit/3f6de2af06dd9a25f62294129f64bc05a29ea912#r41340377
</span><span class="doc">16231 @[inline]</span> <span class="keyword">private</span> <span class="keyword">def</span> <span class="function-name">mkCategoryAntiquotParserFn</span> (kind : Name) : ParserFn <span class="constant">:=</span>
16232   (mkCategoryAntiquotParser kind).fn
16233 
<span class="keyword">16234 def</span> <span class="function-name">categoryParserFnImpl</span> (catName : Name) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> ctx s <span class="constant">=&gt;</span>
16235   <span class="keyword">let</span> catName <span class="constant">:=</span> <span class="keyword">if</span> catName <span class="constant">==</span> `<span class="keyword">syntax</span> <span class="keyword">then</span> `stx <span class="keyword">else</span> catName <span class="comment-delimiter">-- </span><span class="comment">temporary Hack
</span>16236   <span class="keyword">let</span> categories <span class="constant">:=</span> (parserExtension.getState ctx.env).categories
16237   <span class="keyword">match</span> getCategory categories catName <span class="keyword">with</span>
16238   | some cat <span class="constant">=&gt;</span>
16239     prattParser catName cat.tables cat.behavior (mkCategoryAntiquotParserFn catName) ctx s
16240   | none     <span class="constant">=&gt;</span> s.mkUnexpectedError (<span class="string">"unknown parser category '"</span> <span class="constant">++</span> toString catName <span class="constant">++</span> <span class="string">"'"</span>)
16241 
<span class="doc">16242 @[builtinInit]</span> <span class="keyword">def</span> <span class="function-name">setCategoryParserFnRef</span> : IO Unit <span class="constant">:=</span>
16243   categoryParserFnRef.set categoryParserFnImpl
16244 
<span class="keyword">16245 def</span> <span class="function-name">addToken</span> (tk : Token) (kind : AttributeKind) : AttrM Unit <span class="constant">:=</span> <span class="keyword">do</span>
16246   <span class="comment-delimiter">-- </span><span class="comment">Recall that `ParserExtension.addEntry` is pure, and assumes `addTokenConfig` does not fail.
</span>16247   <span class="comment-delimiter">-- </span><span class="comment">So, we must run it here to handle exception.
</span>16248   discard <span class="constant">&lt;</span>| ofExcept <span class="constant">&lt;</span>| addTokenConfig (parserExtension.getState (&#8592; getEnv)).tokens tk
16249   parserExtension.add (ParserExtension.Entry.token tk) kind
16250 
<span class="keyword">16251 def</span> <span class="function-name">addSyntaxNodeKind</span> (env : Environment) (k : SyntaxNodeKind) : Environment <span class="constant">:=</span>
16252   parserExtension.addEntry env <span class="constant">&lt;</span>| ParserExtension.Entry.kind k
16253 
<span class="keyword">16254 def</span> <span class="function-name">isValidSyntaxNodeKind</span> (env : Environment) (k : SyntaxNodeKind) : Bool <span class="constant">:=</span>
16255   <span class="keyword">let</span> kinds <span class="constant">:=</span> (parserExtension.getState env).kinds
16256   kinds.contains k
16257 
<span class="keyword">16258 def</span> <span class="function-name">getSyntaxNodeKinds</span> (env : Environment) : List SyntaxNodeKind <span class="constant">:=</span> <span class="keyword">do</span>
16259   <span class="keyword">let</span> kinds <span class="constant">:=</span> (parserExtension.getState env).kinds
16260   kinds.foldl (<span class="keyword">fun</span> ks k <span class="preprocessor">_</span> <span class="constant">=&gt;</span> k::ks) []
16261 
<span class="keyword">16262 def</span> <span class="function-name">getTokenTable</span> (env : Environment) : TokenTable <span class="constant">:=</span>
16263   (parserExtension.getState env).tokens
16264 
<span class="keyword">16265 def</span> <span class="function-name">mkInputContext</span> (input : String) (fileName : String) : InputContext <span class="constant">:=</span> {
16266   input    <span class="constant">:=</span> input,
16267   fileName <span class="constant">:=</span> fileName,
16268   fileMap  <span class="constant">:=</span> input.toFileMap
16269 }
16270 
<span class="keyword">16271 def</span> <span class="function-name">mkParserContext</span> (ictx : InputContext) (pmctx : ParserModuleContext) : ParserContext <span class="constant">:=</span> {
16272   prec                  <span class="constant">:=</span> <span class="constant">0</span>,
16273   toInputContext        <span class="constant">:=</span> ictx,
16274   toParserModuleContext <span class="constant">:=</span> pmctx,
16275   tokens                <span class="constant">:=</span> getTokenTable pmctx.env
16276 }
16277 
<span class="keyword">16278 def</span> <span class="function-name">mkParserState</span> (input : String) : ParserState <span class="constant">:=</span>
16279   { cache <span class="constant">:=</span> initCacheForInput input }
16280 
<span class="comment-delimiter">16281 /- </span><span class="comment">convenience function for testing -/</span>
<span class="keyword">16282 def</span> <span class="function-name">runParserCategory</span> (env : Environment) (catName : Name) (input : String) (fileName <span class="constant">:=</span> <span class="string">"&lt;input&gt;"</span>) : Except String Syntax <span class="constant">:=</span>
16283   <span class="keyword">let</span> c <span class="constant">:=</span> mkParserContext (mkInputContext input fileName) { env <span class="constant">:=</span> env, options <span class="constant">:=</span> {} }
16284   <span class="keyword">let</span> s <span class="constant">:=</span> mkParserState input
16285   <span class="keyword">let</span> s <span class="constant">:=</span> whitespace c s
16286   <span class="keyword">let</span> s <span class="constant">:=</span> categoryParserFnImpl catName c s
16287   <span class="keyword">if</span> s.hasError <span class="keyword">then</span>
16288     Except.error (s.toErrorMsg c)
16289   <span class="keyword">else</span> <span class="keyword">if</span> input.atEnd s.pos <span class="keyword">then</span>
16290     Except.ok s.stxStack.back
16291   <span class="keyword">else</span>
16292     Except.error ((s.mkError <span class="string">"end of input"</span>).toErrorMsg c)
16293 
<span class="keyword">16294 def</span> <span class="function-name">declareBuiltinParser</span> (env : Environment) (addFnName : Name) (catName : Name) (declName : Name) (prio : Nat) : IO Environment <span class="constant">:=</span>
16295   <span class="keyword">let</span> name <span class="constant">:=</span> `_regBuiltinParser <span class="constant">++</span> declName
16296   <span class="keyword">let</span> type <span class="constant">:=</span> mkApp (mkConst `IO) (mkConst `Unit)
16297   <span class="keyword">let</span> val  <span class="constant">:=</span> mkAppN (mkConst addFnName) <span class="constant">#</span>[toExpr catName, toExpr declName, mkConst declName, mkNatLit prio]
16298   <span class="keyword">let</span> decl <span class="constant">:=</span> Declaration.defnDecl { name <span class="constant">:=</span> name, levelParams <span class="constant">:=</span> [], type <span class="constant">:=</span> type, value <span class="constant">:=</span> val, hints <span class="constant">:=</span> ReducibilityHints.opaque,
16299                                      safety <span class="constant">:=</span> DefinitionSafety.safe }
16300   <span class="keyword">match</span> env.addAndCompile {} decl <span class="keyword">with</span>
16301   <span class="comment-delimiter">-- </span><span class="comment">TODO: pretty print error
</span>16302   | Except.error <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throw (IO.userError (<span class="string">"failed to emit registration code for builtin parser '"</span> <span class="constant">++</span> toString declName <span class="constant">++</span> <span class="string">"'"</span>))
16303   | Except.ok env  <span class="constant">=&gt;</span> IO.ofExcept (setBuiltinInitAttr env name)
16304 
<span class="keyword">16305 def</span> <span class="function-name">declareLeadingBuiltinParser</span> (env : Environment) (catName : Name) (declName : Name) (prio : Nat) : IO Environment <span class="constant">:=</span> <span class="comment-delimiter">-- </span><span class="comment">TODO: use CoreM?
</span>16306   declareBuiltinParser env `Lean.Parser.addBuiltinLeadingParser catName declName prio
16307 
<span class="keyword">16308 def</span> <span class="function-name">declareTrailingBuiltinParser</span> (env : Environment) (catName : Name) (declName : Name) (prio : Nat) : IO Environment <span class="constant">:=</span> <span class="comment-delimiter">-- </span><span class="comment">TODO: use CoreM?
</span>16309   declareBuiltinParser env `Lean.Parser.addBuiltinTrailingParser catName declName prio
16310 
<span class="keyword">16311 def</span> <span class="function-name">getParserPriority</span> (args : Syntax) : Except String Nat <span class="constant">:=</span>
16312   <span class="keyword">match</span> args.getNumArgs <span class="keyword">with</span>
16313   | <span class="constant">0</span> <span class="constant">=&gt;</span> pure <span class="constant">0</span>
16314   | <span class="constant">1</span> <span class="constant">=&gt;</span> <span class="keyword">match</span> (args.getArg <span class="constant">0</span>).isNatLit? <span class="keyword">with</span>
16315     | some prio <span class="constant">=&gt;</span> pure prio
16316     | none <span class="constant">=&gt;</span> throw <span class="string">"invalid parser attribute, numeral expected"</span>
16317   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throw <span class="string">"invalid parser attribute, no argument or numeral expected"</span>
16318 
<span class="keyword">16319 private</span> <span class="keyword">def</span> <span class="function-name">BuiltinParserAttribute.add</span> (attrName : Name) (catName : Name)
16320     (declName : Name) (stx : Syntax) (kind : AttributeKind) : AttrM Unit <span class="constant">:=</span> <span class="keyword">do</span>
16321   <span class="keyword">let</span> prio &#8592; Attribute.Builtin.getPrio stx
16322   <span class="keyword">unless</span> kind <span class="constant">==</span> AttributeKind.global <span class="keyword">do</span> throwError <span class="string">"invalid attribute '{attrName}', must be global"</span>
16323   <span class="keyword">let</span> decl &#8592; getConstInfo declName
16324   <span class="keyword">let</span> env &#8592; getEnv
16325   <span class="keyword">match</span> decl.type <span class="keyword">with</span>
16326   | Expr.const `Lean.Parser.TrailingParser <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">do</span>
16327     <span class="keyword">let</span> env &#8592; declareTrailingBuiltinParser env catName declName prio
16328     setEnv env
16329   | Expr.const `Lean.Parser.Parser <span class="preprocessor">_</span> <span class="preprocessor">_</span> <span class="constant">=&gt;</span> <span class="keyword">do</span>
16330     <span class="keyword">let</span> env &#8592; declareLeadingBuiltinParser env catName declName prio
16331     setEnv env
16332   | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throwError <span class="string">"unexpected parser type at '{declName}' (`Parser` or `TrailingParser` expected)"</span>
16333   runParserAttributeHooks catName declName (builtin <span class="constant">:=</span> true)
16334 
<span class="comment-delimiter">16335 /-</span><span class="comment">
16336 The parsing tables for builtin parsers are "stored" in the extracted source code.
16337 -/</span>
<span class="keyword">16338 def</span> <span class="function-name">registerBuiltinParserAttribute</span> (attrName : Name) (catName : Name) (behavior <span class="constant">:=</span> LeadingIdentBehavior.default) : IO Unit <span class="constant">:=</span> <span class="keyword">do</span>
16339   addBuiltinParserCategory catName behavior
16340   registerBuiltinAttribute {
16341    name            <span class="constant">:=</span> attrName,
16342    descr           <span class="constant">:=</span> <span class="string">"Builtin parser"</span>,
16343    add             <span class="constant">:=</span> <span class="keyword">fun</span> declName stx kind <span class="constant">=&gt;</span> liftM <span class="constant">$</span> BuiltinParserAttribute.add attrName catName declName stx kind,
16344    applicationTime <span class="constant">:=</span> AttributeApplicationTime.afterCompilation
16345   }
16346 
<span class="keyword">16347 private</span> <span class="keyword">def</span> <span class="function-name">ParserAttribute.add</span> (attrName : Name) (catName : Name) (declName : Name) (stx : Syntax) (attrKind : AttributeKind) : AttrM Unit <span class="constant">:=</span> <span class="keyword">do</span>
16348   <span class="keyword">let</span> prio &#8592; Attribute.Builtin.getPrio stx
16349   <span class="keyword">let</span> env &#8592; getEnv
16350   <span class="keyword">let</span> opts &#8592; getOptions
16351   <span class="keyword">let</span> categories <span class="constant">:=</span> (parserExtension.getState env).categories
16352   <span class="keyword">let</span> p &#8592; mkParserOfConstant categories declName
16353   <span class="keyword">let</span> leading    <span class="constant">:=</span> p.<span class="constant">1</span>
16354   <span class="keyword">let</span> parser     <span class="constant">:=</span> p.<span class="constant">2</span>
16355   <span class="keyword">let</span> tokens     <span class="constant">:=</span> parser.info.collectTokens []
16356   tokens.forM <span class="keyword">fun</span> token <span class="constant">=&gt;</span> <span class="keyword">do</span>
16357     <span class="keyword">try</span>
16358       addToken token attrKind
16359     <span class="keyword">catch</span>
16360       | Exception.error ref msg <span class="constant">=&gt;</span> throwError <span class="string">"invalid parser '{declName}', {msg}"</span>
16361       | ex <span class="constant">=&gt;</span> throw ex
16362   <span class="keyword">let</span> kinds <span class="constant">:=</span> parser.info.collectKinds {}
16363   kinds.forM <span class="keyword">fun</span> kind <span class="preprocessor">_</span> <span class="constant">=&gt;</span> modifyEnv <span class="keyword">fun</span> env <span class="constant">=&gt;</span> addSyntaxNodeKind env kind
16364   <span class="keyword">let</span> entry <span class="constant">:=</span> ParserExtension.Entry.parser catName declName leading parser prio
16365   <span class="keyword">match</span> addParser categories catName declName leading parser prio <span class="keyword">with</span>
16366   | Except.error ex <span class="constant">=&gt;</span> throwError ex
16367   | Except.ok <span class="preprocessor">_</span>     <span class="constant">=&gt;</span> parserExtension.add entry attrKind
16368   runParserAttributeHooks catName declName (builtin <span class="constant">:=</span> false)
16369 
<span class="keyword">16370 def</span> <span class="function-name">mkParserAttributeImpl</span> (attrName : Name) (catName : Name) : AttributeImpl <span class="keyword">where</span>
16371   name                      <span class="constant">:=</span> attrName
16372   descr                     <span class="constant">:=</span> <span class="string">"parser"</span>
16373   add declName stx attrKind <span class="constant">:=</span> ParserAttribute.add attrName catName declName stx attrKind
16374   applicationTime           <span class="constant">:=</span> AttributeApplicationTime.afterCompilation
16375 
<span class="comment-delimiter">16376 /- </span><span class="comment">A builtin parser attribute that can be extended by users. -/</span>
<span class="keyword">16377 def</span> <span class="function-name">registerBuiltinDynamicParserAttribute</span> (attrName : Name) (catName : Name) : IO Unit <span class="constant">:=</span> <span class="keyword">do</span>
16378   registerBuiltinAttribute (mkParserAttributeImpl attrName catName)
16379 
<span class="doc">16380 @[builtinInit]</span> <span class="keyword">private</span> <span class="keyword">def</span> <span class="function-name">registerParserAttributeImplBuilder</span> : IO Unit <span class="constant">:=</span>
16381   registerAttributeImplBuilder `parserAttr <span class="keyword">fun</span> args <span class="constant">=&gt;</span>
16382     <span class="keyword">match</span> args <span class="keyword">with</span>
16383     | [DataValue.ofName attrName, DataValue.ofName catName] <span class="constant">=&gt;</span> pure <span class="constant">$</span> mkParserAttributeImpl attrName catName
16384     | <span class="preprocessor">_</span> <span class="constant">=&gt;</span> throw <span class="string">"invalid parser attribute implementation builder arguments"</span>
16385 
<span class="keyword">16386 def</span> <span class="function-name">registerParserCategory</span> (env : Environment) (attrName : Name) (catName : Name) (behavior <span class="constant">:=</span> LeadingIdentBehavior.default) : IO Environment <span class="constant">:=</span> <span class="keyword">do</span>
16387   <span class="keyword">let</span> env &#8592; IO.ofExcept <span class="constant">$</span> addParserCategory env catName behavior
16388   registerAttributeOfBuilder env `parserAttr [DataValue.ofName attrName, DataValue.ofName catName]
16389 
<span class="comment-delimiter">16390 -- </span><span class="comment">declare `termParser` here since it is used everywhere via antiquotations
</span>16391 
<span class="keyword">16392 builtin_initialize</span> registerBuiltinParserAttribute `builtinTermParser `term
16393 
<span class="keyword">16394 builtin_initialize</span> registerBuiltinDynamicParserAttribute `termParser `term
16395 
<span class="comment-delimiter">16396 -- </span><span class="comment">declare `commandParser` to break cyclic dependency
</span><span class="keyword">16397 builtin_initialize</span> registerBuiltinParserAttribute `builtinCommandParser `command
16398 
<span class="keyword">16399 builtin_initialize</span> registerBuiltinDynamicParserAttribute `commandParser `command
16400 
<span class="doc">16401 @[inline]</span> <span class="keyword">def</span> <span class="function-name">commandParser</span> (rbp : Nat <span class="constant">:=</span> <span class="constant">0</span>) : Parser <span class="constant">:=</span>
16402   categoryParser `command rbp
16403 
<span class="keyword">16404 def</span> <span class="function-name">notFollowedByCategoryTokenFn</span> (catName : Name) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> ctx s <span class="constant">=&gt;</span>
16405   <span class="keyword">let</span> categories <span class="constant">:=</span> (parserExtension.getState ctx.env).categories
16406   <span class="keyword">match</span> getCategory categories catName <span class="keyword">with</span>
16407   | none <span class="constant">=&gt;</span> s.mkUnexpectedError s<span class="constant">!</span><span class="string">"unknown parser category '{catName}'"</span>
16408   | some cat <span class="constant">=&gt;</span>
16409     <span class="keyword">let</span> (s, stx) <span class="constant">:=</span> peekToken ctx s
16410     <span class="keyword">match</span> stx <span class="keyword">with</span>
16411     | Except.ok (Syntax.atom <span class="preprocessor">_</span> sym) <span class="constant">=&gt;</span>
16412       <span class="keyword">if</span> ctx.insideQuot <span class="constant">&amp;&amp;</span> sym <span class="constant">==</span> <span class="string">"$"</span> <span class="keyword">then</span> s
16413       <span class="keyword">else</span> <span class="keyword">match</span> cat.tables.leadingTable.find? (Name.mkSimple sym) <span class="keyword">with</span>
16414       | some <span class="preprocessor">_</span> <span class="constant">=&gt;</span> s.mkUnexpectedError (toString catName)
16415       | <span class="preprocessor">_</span>      <span class="constant">=&gt;</span> s
16416     | Except.ok <span class="preprocessor">_</span>    <span class="constant">=&gt;</span> s
16417     | Except.error <span class="preprocessor">_</span> <span class="constant">=&gt;</span> s
16418 
<span class="doc">16419 @[inline]</span> <span class="keyword">def</span> <span class="function-name">notFollowedByCategoryToken</span> (catName : Name) : Parser <span class="constant">:=</span> {
16420   fn <span class="constant">:=</span> notFollowedByCategoryTokenFn catName
16421 }
16422 
<span class="keyword">16423 abbrev</span> notFollowedByCommandToken : Parser <span class="constant">:=</span>
16424   notFollowedByCategoryToken `command
16425 
<span class="keyword">16426 abbrev</span> notFollowedByTermToken : Parser <span class="constant">:=</span>
16427   notFollowedByCategoryToken `term
16428 
<span class="keyword">16429 end</span> Parser
<span class="keyword">16430 end</span> Lean
16431 ::::::::::::::
16432 Parser<span class="constant">/</span>Extra.lean
16433 ::::::::::::::
<span class="comment-delimiter">16434 /-</span><span class="comment">
16435 Copyright (c) 2019 Microsoft Corporation. All rights reserved.
16436 Released under Apache 2.0 license as described in the file LICENSE.
16437 Authors: Leonardo de Moura, Sebastian Ullrich
16438 -/</span>
<span class="keyword">16439 import</span> Lean.Parser.Extension
<span class="comment-delimiter">16440 -- </span><span class="comment">necessary for auto-generation
</span><span class="keyword">16441 import</span> Lean.PrettyPrinter.Parenthesizer
<span class="keyword">16442 import</span> Lean.PrettyPrinter.Formatter
16443 
<span class="keyword">16444 namespace</span> Lean
<span class="keyword">16445 namespace</span> Parser
16446 
<span class="comment-delimiter">16447 -- </span><span class="comment">synthesize pretty printers for parsers declared prior to `Lean.PrettyPrinter`
</span><span class="comment-delimiter">16448 -- </span><span class="comment">(because `Parser.Extension` depends on them)
</span><span class="keyword">16449 attribute</span> <span class="doc">[runBuiltinParserAttributeHooks]</span>
16450   leadingNode termParser commandParser mkAntiquot nodeWithAntiquot sepBy sepBy1
16451   unicodeSymbol nonReservedSymbol
16452 
<span class="doc">16453 @[runBuiltinParserAttributeHooks]</span> <span class="keyword">def</span> <span class="function-name">optional</span> (p : Parser) : Parser <span class="constant">:=</span>
16454   optionalNoAntiquot (withAntiquotSpliceAndSuffix `optional p (symbol <span class="string">"?"</span>))
16455 
<span class="doc">16456 @[runBuiltinParserAttributeHooks]</span> <span class="keyword">def</span> <span class="function-name">many</span> (p : Parser) : Parser <span class="constant">:=</span>
16457   manyNoAntiquot (withAntiquotSpliceAndSuffix `many p (symbol <span class="string">"*"</span>))
16458 
<span class="doc">16459 @[runBuiltinParserAttributeHooks]</span> <span class="keyword">def</span> <span class="function-name">many1</span> (p : Parser) : Parser <span class="constant">:=</span>
16460   many1NoAntiquot (withAntiquotSpliceAndSuffix `many p (symbol <span class="string">"*"</span>))
16461 
<span class="doc">16462 @[runBuiltinParserAttributeHooks]</span> <span class="keyword">def</span> <span class="function-name">ident</span> : Parser <span class="constant">:=</span>
16463   withAntiquot (mkAntiquot <span class="string">"ident"</span> identKind) identNoAntiquot
16464 
<span class="comment-delimiter">16465 -- </span><span class="comment">`ident` and `rawIdent` produce the same syntax tree, so we reuse the antiquotation kind name
</span><span class="doc">16466 @[runBuiltinParserAttributeHooks]</span> <span class="keyword">def</span> <span class="function-name">rawIdent</span> : Parser <span class="constant">:=</span>
16467   withAntiquot (mkAntiquot <span class="string">"ident"</span> identKind) rawIdentNoAntiquot
16468 
<span class="doc">16469 @[runBuiltinParserAttributeHooks]</span> <span class="keyword">def</span> <span class="function-name">numLit</span> : Parser <span class="constant">:=</span>
16470   withAntiquot (mkAntiquot <span class="string">"numLit"</span> numLitKind) numLitNoAntiquot
16471 
<span class="doc">16472 @[runBuiltinParserAttributeHooks]</span> <span class="keyword">def</span> <span class="function-name">scientificLit</span> : Parser <span class="constant">:=</span>
16473   withAntiquot (mkAntiquot <span class="string">"scientificLit"</span> scientificLitKind) scientificLitNoAntiquot
16474 
<span class="doc">16475 @[runBuiltinParserAttributeHooks]</span> <span class="keyword">def</span> <span class="function-name">strLit</span> : Parser <span class="constant">:=</span>
16476   withAntiquot (mkAntiquot <span class="string">"strLit"</span> strLitKind) strLitNoAntiquot
16477 
<span class="doc">16478 @[runBuiltinParserAttributeHooks]</span> <span class="keyword">def</span> <span class="function-name">charLit</span> : Parser <span class="constant">:=</span>
16479   withAntiquot (mkAntiquot <span class="string">"charLit"</span> charLitKind) charLitNoAntiquot
16480 
<span class="doc">16481 @[runBuiltinParserAttributeHooks]</span> <span class="keyword">def</span> <span class="function-name">nameLit</span> : Parser <span class="constant">:=</span>
16482   withAntiquot (mkAntiquot <span class="string">"nameLit"</span> nameLitKind) nameLitNoAntiquot
16483 
<span class="doc">16484 @[runBuiltinParserAttributeHooks, inline]</span> <span class="keyword">def</span> <span class="function-name">group</span> (p : Parser) : Parser <span class="constant">:=</span>
16485   node groupKind p
16486 
<span class="doc">16487 @[runBuiltinParserAttributeHooks, inline]</span> <span class="keyword">def</span> <span class="function-name">many1Indent</span> (p : Parser) : Parser <span class="constant">:=</span>
16488   withPosition <span class="constant">$</span> many1 (checkColGe <span class="string">"irrelevant"</span> <span class="constant">&gt;&gt;</span> p)
16489 
<span class="doc">16490 @[runBuiltinParserAttributeHooks, inline]</span> <span class="keyword">def</span> <span class="function-name">manyIndent</span> (p : Parser) : Parser <span class="constant">:=</span>
16491   withPosition <span class="constant">$</span> many (checkColGe <span class="string">"irrelevant"</span> <span class="constant">&gt;&gt;</span> p)
16492 
<span class="doc">16493 @[runBuiltinParserAttributeHooks]</span> <span class="keyword">abbrev</span> notSymbol (s : String) : Parser <span class="constant">:=</span>
16494   notFollowedBy (symbol s) s
16495 
<span class="comment-delimiter">16496 /-</span><span class="comment">- No-op parser that advises the pretty printer to emit a non-breaking space. -/</span>
<span class="doc">16497 @[inline]</span> <span class="keyword">def</span> <span class="function-name">ppHardSpace</span> : Parser <span class="constant">:=</span> skip
<span class="comment-delimiter">16498 /-</span><span class="comment">- No-op parser that advises the pretty printer to emit a space/soft line break. -/</span>
<span class="doc">16499 @[inline]</span> <span class="keyword">def</span> <span class="function-name">ppSpace</span> : Parser <span class="constant">:=</span> skip
<span class="comment-delimiter">16500 /-</span><span class="comment">- No-op parser that advises the pretty printer to emit a hard line break. -/</span>
<span class="doc">16501 @[inline]</span> <span class="keyword">def</span> <span class="function-name">ppLine</span> : Parser <span class="constant">:=</span> skip
<span class="comment-delimiter">16502 /-</span><span class="comment">-
16503   No-op parser combinator that advises the pretty printer to group and indent the given syntax.
16504   By default, only syntax categories are grouped. -/</span>
<span class="doc">16505 @[inline]</span> <span class="keyword">def</span> <span class="function-name">ppGroup</span> : Parser <span class="constant">&#8594;</span> Parser <span class="constant">:=</span> id
<span class="comment-delimiter">16506 /-</span><span class="comment">- No-op parser combinator that advises the pretty printer to indent the given syntax without grouping it. -/</span>
<span class="doc">16507 @[inline]</span> <span class="keyword">def</span> <span class="function-name">ppIndent</span> : Parser <span class="constant">&#8594;</span> Parser <span class="constant">:=</span> id
<span class="comment-delimiter">16508 /-</span><span class="comment">-
16509   No-op parser combinator that advises the pretty printer to dedent the given syntax.
16510   Dedenting can in particular be used to counteract automatic indentation. -/</span>
<span class="doc">16511 @[inline]</span> <span class="keyword">def</span> <span class="function-name">ppDedent</span> : Parser <span class="constant">&#8594;</span> Parser <span class="constant">:=</span> id
16512 
<span class="keyword">16513 end</span> Parser
16514 
<span class="keyword">16515 section</span>
<span class="keyword">16516 open</span> PrettyPrinter
16517 
<span class="doc">16518 @[combinatorFormatter Lean.Parser.ppHardSpace]</span> <span class="keyword">def</span> <span class="function-name">ppHardSpace.formatter</span> : Formatter <span class="constant">:=</span> Formatter.push <span class="string">" "</span>
<span class="doc">16519 @[combinatorFormatter Lean.Parser.ppSpace]</span> <span class="keyword">def</span> <span class="function-name">ppSpace.formatter</span> : Formatter <span class="constant">:=</span> Formatter.pushLine
<span class="doc">16520 @[combinatorFormatter Lean.Parser.ppLine]</span> <span class="keyword">def</span> <span class="function-name">ppLine.formatter</span> : Formatter <span class="constant">:=</span> Formatter.push <span class="string">"\n"</span>
<span class="doc">16521 @[combinatorFormatter Lean.Parser.ppGroup]</span> <span class="keyword">def</span> <span class="function-name">ppGroup.formatter</span> (p : Formatter) : Formatter <span class="constant">:=</span> Formatter.group <span class="constant">$</span> Formatter.indent p
<span class="doc">16522 @[combinatorFormatter Lean.Parser.ppIndent]</span> <span class="keyword">def</span> <span class="function-name">ppIndent.formatter</span> (p : Formatter) : Formatter <span class="constant">:=</span> Formatter.indent p
<span class="doc">16523 @[combinatorFormatter Lean.Parser.ppDedent]</span> <span class="keyword">def</span> <span class="function-name">ppDedent.formatter</span> (p : Formatter) : Formatter <span class="constant">:=</span> <span class="keyword">do</span>
16524   <span class="keyword">let</span> opts &#8592; getOptions
16525   Formatter.indent p (some ((<span class="constant">0</span>:Int) <span class="constant">-</span> Std.Format.getIndent opts))
<span class="keyword">16526 end</span>
16527 
<span class="keyword">16528 namespace</span> Parser
16529 
<span class="comment-delimiter">16530 -- </span><span class="comment">now synthesize parenthesizers
</span><span class="keyword">16531 attribute</span> <span class="doc">[runBuiltinParserAttributeHooks]</span>
16532   ppHardSpace ppSpace ppLine ppGroup ppIndent ppDedent
16533 
<span class="keyword">16534 macro</span> <span class="string">"register_parser_alias"</span> aliasName:strLit declName:ident : term <span class="constant">=&gt;</span>
16535   `(<span class="keyword">do</span> Parser.registerAlias <span class="constant">$</span>aliasName <span class="constant">$</span>declName
16536        PrettyPrinter.Formatter.registerAlias <span class="constant">$</span>aliasName <span class="constant">$</span>(mkIdentFrom declName (declName.getId <span class="constant">++</span> `formatter))
16537        PrettyPrinter.Parenthesizer.registerAlias <span class="constant">$</span>aliasName <span class="constant">$</span>(mkIdentFrom declName (declName.getId <span class="constant">++</span> `parenthesizer)))
16538 
<span class="keyword">16539 builtin_initialize</span>
16540   register_parser_alias <span class="string">"group"</span> group
16541   register_parser_alias <span class="string">"ppHardSpace"</span> ppHardSpace
16542   register_parser_alias <span class="string">"ppSpace"</span> ppSpace
16543   register_parser_alias <span class="string">"ppLine"</span> ppLine
16544   register_parser_alias <span class="string">"ppGroup"</span> ppGroup
16545   register_parser_alias <span class="string">"ppIndent"</span> ppIndent
16546   register_parser_alias <span class="string">"ppDedent"</span> ppDedent
16547 
<span class="keyword">16548 end</span> Parser
16549 
<span class="keyword">16550 open</span> Parser
16551 
<span class="keyword">16552 open</span> PrettyPrinter.Parenthesizer (registerAlias) <span class="keyword">in</span>
<span class="keyword">16553 builtin_initialize</span>
16554   registerAlias <span class="string">"num"</span> numLit.parenthesizer
16555   registerAlias <span class="string">"scientific"</span> scientificLit.parenthesizer
16556   registerAlias <span class="string">"str"</span> strLit.parenthesizer
16557   registerAlias <span class="string">"char"</span> charLit.parenthesizer
16558   registerAlias <span class="string">"name"</span> nameLit.parenthesizer
16559   registerAlias <span class="string">"ident"</span> ident.parenthesizer
16560   registerAlias <span class="string">"many"</span> many.parenthesizer
16561   registerAlias <span class="string">"many1"</span> many1.parenthesizer
16562   registerAlias <span class="string">"optional"</span> optional.parenthesizer
16563 
<span class="keyword">16564 open</span> PrettyPrinter.Formatter (registerAlias) <span class="keyword">in</span>
<span class="keyword">16565 builtin_initialize</span>
16566   registerAlias <span class="string">"num"</span> numLit.formatter
16567   registerAlias <span class="string">"scientific"</span> scientificLit.formatter
16568   registerAlias <span class="string">"str"</span> strLit.formatter
16569   registerAlias <span class="string">"char"</span> charLit.formatter
16570   registerAlias <span class="string">"name"</span> nameLit.formatter
16571   registerAlias <span class="string">"ident"</span> ident.formatter
16572   registerAlias <span class="string">"many"</span> many.formatter
16573   registerAlias <span class="string">"many1"</span> many1.formatter
16574   registerAlias <span class="string">"optional"</span> optional.formatter
16575 
<span class="keyword">16576 end</span> Lean
16577 ::::::::::::::
16578 Parser<span class="constant">/</span>Level.lean
16579 ::::::::::::::
<span class="comment-delimiter">16580 /-</span><span class="comment">
16581 Copyright (c) 2019 Microsoft Corporation. All rights reserved.
16582 Released under Apache 2.0 license as described in the file LICENSE.
16583 Authors: Leonardo de Moura, Sebastian Ullrich
16584 -/</span>
<span class="keyword">16585 import</span> Lean.Parser.Extra
16586 
<span class="keyword">16587 namespace</span> Lean
<span class="keyword">16588 namespace</span> Parser
16589 
<span class="keyword">16590 builtin_initialize</span>
16591   registerBuiltinParserAttribute `builtinLevelParser `level
16592 
<span class="doc">16593 @[inline]</span> <span class="keyword">def</span> <span class="function-name">levelParser</span> (rbp : Nat <span class="constant">:=</span> <span class="constant">0</span>) : Parser <span class="constant">:=</span>
16594   categoryParser `level rbp
16595 
<span class="keyword">16596 namespace</span> Level
16597 
<span class="doc">16598 @[builtinLevelParser]</span> <span class="keyword">def</span> <span class="function-name">paren</span>  <span class="constant">:=</span> leading_parser <span class="string">"("</span> <span class="constant">&gt;&gt;</span> levelParser <span class="constant">&gt;&gt;</span> <span class="string">")"</span>
<span class="doc">16599 @[builtinLevelParser]</span> <span class="keyword">def</span> <span class="function-name">max</span>    <span class="constant">:=</span> leading_parser nonReservedSymbol <span class="string">"max"</span> true  <span class="constant">&gt;&gt;</span> many1 (ppSpace <span class="constant">&gt;&gt;</span> levelParser maxPrec)
<span class="doc">16600 @[builtinLevelParser]</span> <span class="keyword">def</span> <span class="function-name">imax</span>   <span class="constant">:=</span> leading_parser nonReservedSymbol <span class="string">"imax"</span> true <span class="constant">&gt;&gt;</span> many1 (ppSpace <span class="constant">&gt;&gt;</span> levelParser maxPrec)
<span class="doc">16601 @[builtinLevelParser]</span> <span class="keyword">def</span> <span class="function-name">hole</span>   <span class="constant">:=</span> leading_parser <span class="string">"_"</span>
<span class="doc">16602 @[builtinLevelParser]</span> <span class="keyword">def</span> <span class="function-name">num</span>    <span class="constant">:=</span> checkPrec maxPrec <span class="constant">&gt;&gt;</span> numLit
<span class="doc">16603 @[builtinLevelParser]</span> <span class="keyword">def</span> <span class="function-name">ident</span>  <span class="constant">:=</span> checkPrec maxPrec <span class="constant">&gt;&gt;</span> Parser.ident
<span class="doc">16604 @[builtinLevelParser]</span> <span class="keyword">def</span> <span class="function-name">addLit</span> <span class="constant">:=</span> trailing_parser:<span class="constant">65</span> <span class="string">" + "</span> <span class="constant">&gt;&gt;</span> numLit
16605 
<span class="keyword">16606 end</span> Level
16607 
<span class="keyword">16608 end</span> Parser
<span class="keyword">16609 end</span> Lean
16610 ::::::::::::::
16611 Parser<span class="constant">/</span>Module.lean
16612 ::::::::::::::
<span class="comment-delimiter">16613 /-</span><span class="comment">
16614 Copyright (c) 2019 Microsoft Corporation. All rights reserved.
16615 Released under Apache 2.0 license as described in the file LICENSE.
16616 Authors: Leonardo de Moura, Sebastian Ullrich
16617 -/</span>
<span class="keyword">16618 import</span> Lean.Message
<span class="keyword">16619 import</span> Lean.Parser.Command
16620 
<span class="keyword">16621 namespace</span> Lean
<span class="keyword">16622 namespace</span> Parser
16623 
<span class="keyword">16624 namespace</span> Module
<span class="keyword">16625 def</span> <span class="comment">&#171;</span>prelude<span class="comment">&#187;</span>  <span class="constant">:=</span> leading_parser <span class="string">"prelude"</span>
<span class="keyword">16626 def</span> <span class="comment">&#171;</span>import<span class="comment">&#187;</span>   <span class="constant">:=</span> leading_parser <span class="string">"import "</span> <span class="constant">&gt;&gt;</span> optional <span class="string">"runtime"</span> <span class="constant">&gt;&gt;</span> ident
<span class="keyword">16627 def</span> <span class="function-name">header</span>     <span class="constant">:=</span> leading_parser optional (<span class="comment">&#171;</span>prelude<span class="comment">&#187;</span> <span class="constant">&gt;&gt;</span> ppLine) <span class="constant">&gt;&gt;</span> many (<span class="comment">&#171;</span>import<span class="comment">&#187;</span> <span class="constant">&gt;&gt;</span> ppLine) <span class="constant">&gt;&gt;</span> ppLine
<span class="comment-delimiter">16628 /-</span><span class="comment">-
16629   Parser for a Lean module. We never actually run this parser but instead use the imperative definitions below that
16630   return the same syntax tree structure, but add error recovery. Still, it is helpful to have a `Parser` definition
16631   for it in order to auto-generate helpers such as the pretty printer. -/</span>
<span class="doc">16632 @[runBuiltinParserAttributeHooks]</span>
<span class="keyword">16633 def</span> <span class="function-name">module</span>     <span class="constant">:=</span> leading_parser header <span class="constant">&gt;&gt;</span> many (commandParser <span class="constant">&gt;&gt;</span> ppLine <span class="constant">&gt;&gt;</span> ppLine)
16634 
<span class="keyword">16635 def</span> <span class="function-name">updateTokens</span> (c : ParserContext) : ParserContext <span class="constant">:=</span>
16636   { c <span class="keyword">with</span>
16637     tokens <span class="constant">:=</span> <span class="keyword">match</span> addParserTokens c.tokens header.info <span class="keyword">with</span>
16638       | Except.ok tables <span class="constant">=&gt;</span> tables
16639       | Except.error <span class="preprocessor">_</span>   <span class="constant">=&gt;</span> <span class="warning">unreachable</span><span class="constant">!</span> }
16640 
<span class="keyword">16641 end</span> Module
16642 
<span class="keyword">16643 structure</span> <span class="function-name">ModuleParserState</span> <span class="keyword">where</span>
16644   pos        : String.Pos <span class="constant">:=</span> <span class="constant">0</span>
16645   recovering : Bool       <span class="constant">:=</span> false
16646   <span class="keyword">deriving</span> Inhabited
16647 
<span class="keyword">16648 private</span> <span class="keyword">def</span> <span class="function-name">mkErrorMessage</span> (c : ParserContext) (pos : String.Pos) (errorMsg : String) : Message <span class="constant">:=</span>
16649   <span class="keyword">let</span> pos <span class="constant">:=</span> c.fileMap.toPosition pos
16650   { fileName <span class="constant">:=</span> c.fileName, pos <span class="constant">:=</span> pos, data <span class="constant">:=</span> errorMsg }
16651 
<span class="keyword">16652 def</span> <span class="function-name">parseHeader</span> (inputCtx : InputContext) : IO (Syntax <span class="constant">&#215;</span> ModuleParserState <span class="constant">&#215;</span> MessageLog) <span class="constant">:=</span> <span class="keyword">do</span>
16653   <span class="keyword">let</span> dummyEnv &#8592; mkEmptyEnvironment
16654   <span class="keyword">let</span> ctx <span class="constant">:=</span> mkParserContext inputCtx { env <span class="constant">:=</span> dummyEnv, options <span class="constant">:=</span> {} }
16655   <span class="keyword">let</span> ctx <span class="constant">:=</span> Module.updateTokens ctx
16656   <span class="keyword">let</span> s   <span class="constant">:=</span> mkParserState ctx.input
16657   <span class="keyword">let</span> s   <span class="constant">:=</span> whitespace ctx s
16658   <span class="keyword">let</span> s   <span class="constant">:=</span> Module.header.fn ctx s
16659   <span class="keyword">let</span> stx <span class="constant">:=</span> s.stxStack.back
16660   <span class="keyword">match</span> s.errorMsg <span class="keyword">with</span>
16661   | some errorMsg <span class="constant">=&gt;</span>
16662     <span class="keyword">let</span> msg <span class="constant">:=</span> mkErrorMessage ctx s.pos (toString errorMsg)
16663     pure (stx, { pos <span class="constant">:=</span> s.pos, recovering <span class="constant">:=</span> true }, { : MessageLog }.add msg)
16664   | none <span class="constant">=&gt;</span>
16665     pure (stx, { pos <span class="constant">:=</span> s.pos }, {})
16666 
<span class="keyword">16667 private</span> <span class="keyword">def</span> <span class="function-name">mkEOI</span> (pos : String.Pos) : Syntax <span class="constant">:=</span>
16668   <span class="keyword">let</span> atom <span class="constant">:=</span> mkAtom (SourceInfo.original <span class="string">""</span>.toSubstring pos <span class="string">""</span>.toSubstring) <span class="string">""</span>
16669   Syntax.node `Lean.Parser.Module.eoi <span class="constant">#</span>[atom]
16670 
<span class="keyword">16671 def</span> <span class="function-name">isEOI</span> (s : Syntax) : Bool <span class="constant">:=</span>
16672   s.isOfKind `Lean.Parser.Module.eoi
16673 
<span class="keyword">16674 def</span> <span class="function-name">isExitCommand</span> (s : Syntax) : Bool <span class="constant">:=</span>
16675   s.isOfKind `Lean.Parser.Command.<span class="warning">exit</span>
16676 
<span class="keyword">16677 private</span> <span class="keyword">def</span> <span class="function-name">consumeInput</span> (c : ParserContext) (pos : String.Pos) : String.Pos <span class="constant">:=</span>
16678   <span class="keyword">let</span> s : ParserState <span class="constant">:=</span> { cache <span class="constant">:=</span> initCacheForInput c.input, pos <span class="constant">:=</span> pos }
16679   <span class="keyword">let</span> s <span class="constant">:=</span> tokenFn [] c s
16680   <span class="keyword">match</span> s.errorMsg <span class="keyword">with</span>
16681   | some <span class="preprocessor">_</span> <span class="constant">=&gt;</span> pos <span class="constant">+</span> <span class="constant">1</span>
16682   | none   <span class="constant">=&gt;</span> s.pos
16683 
<span class="keyword">16684 def</span> <span class="function-name">topLevelCommandParserFn</span> : ParserFn <span class="constant">:=</span>
16685   commandParser.fn
16686 
<span class="keyword">16687 partial</span> <span class="keyword">def</span> <span class="function-name">parseCommand</span> (inputCtx : InputContext) (pmctx : ParserModuleContext) (s : ModuleParserState) (messages : MessageLog) : Syntax <span class="constant">&#215;</span> ModuleParserState <span class="constant">&#215;</span> MessageLog <span class="constant">:=</span>
16688   <span class="keyword">let</span> <span class="keyword">rec</span> parse (s : ModuleParserState) (messages : MessageLog) <span class="constant">:=</span>
16689     <span class="keyword">let</span> { pos <span class="constant">:=</span> pos, recovering <span class="constant">:=</span> recovering } <span class="constant">:=</span> s
16690     <span class="keyword">if</span> inputCtx.input.atEnd pos <span class="keyword">then</span>
16691       (mkEOI pos, s, messages)
16692     <span class="keyword">else</span>
16693       <span class="keyword">let</span> c   <span class="constant">:=</span> mkParserContext inputCtx pmctx
16694       <span class="keyword">let</span> s   <span class="constant">:=</span> { cache <span class="constant">:=</span> initCacheForInput c.input, pos <span class="constant">:=</span> pos : ParserState }
16695       <span class="keyword">let</span> s   <span class="constant">:=</span> whitespace c s
16696       <span class="keyword">let</span> s   <span class="constant">:=</span> topLevelCommandParserFn c s
16697       <span class="keyword">match</span> s.errorMsg <span class="keyword">with</span>
16698       | none <span class="constant">=&gt;</span>
16699          (s.stxStack.back, { pos <span class="constant">:=</span> s.pos }, messages)
16700       | some errorMsg <span class="constant">=&gt;</span>
16701         <span class="comment-delimiter">-- </span><span class="comment">advance at least one token to prevent infinite loops
</span>16702         <span class="keyword">let</span> pos <span class="constant">:=</span> <span class="keyword">if</span> s.pos <span class="constant">==</span> pos <span class="keyword">then</span> consumeInput c s.pos <span class="keyword">else</span> s.pos
16703         <span class="comment-delimiter">/- </span><span class="comment">We ignore commands where `getPos?` is none. This happens only on commands that have a prefix comprised of optional elements.
16704            For example, unification hints start with `optional (&#171;</span>scoped<span class="comment">&#187; &lt;|&gt; &#171;</span>local<span class="comment">&#187;)`.
16705            We claim a syntactically incorrect command containing no token or identifier is irrelevant for intellisense and should be ignored. -/</span>
16706         <span class="keyword">let</span> ignore <span class="constant">:=</span> s.stxStack.isEmpty <span class="constant">||</span> s.stxStack.back.getPos?.isNone
16707         <span class="keyword">let</span> messages <span class="constant">:=</span> <span class="keyword">if</span> recovering <span class="constant">&amp;&amp;</span> ignore <span class="keyword">then</span> messages <span class="keyword">else</span> messages.add <span class="constant">&lt;</span>| mkErrorMessage c s.pos (toString errorMsg)
16708         <span class="keyword">if</span> ignore <span class="keyword">then</span>
16709           parse { pos <span class="constant">:=</span> pos, recovering <span class="constant">:=</span> true } messages
16710         <span class="keyword">else</span>
16711           (s.stxStack.back, { pos <span class="constant">:=</span> pos, recovering <span class="constant">:=</span> true }, messages)
16712   parse s messages
16713 
<span class="comment-delimiter">16714 -- </span><span class="comment">only useful for testing since most Lean files cannot be parsed without elaboration
</span>16715 
<span class="keyword">16716 partial</span> <span class="keyword">def</span> <span class="function-name">testParseModuleAux</span> (env : Environment) (inputCtx : InputContext) (s : ModuleParserState) (msgs : MessageLog) (stxs  : Array Syntax) : IO (Array Syntax) <span class="constant">:=</span>
16717   <span class="keyword">let</span> <span class="keyword">rec</span> parse (state : ModuleParserState) (msgs : MessageLog) (stxs : Array Syntax) <span class="constant">:=</span>
16718     <span class="keyword">match</span> parseCommand inputCtx { env <span class="constant">:=</span> env, options <span class="constant">:=</span> {} } state msgs <span class="keyword">with</span>
16719     | (stx, state, msgs) <span class="constant">=&gt;</span>
16720       <span class="keyword">if</span> isEOI stx <span class="keyword">then</span>
16721         <span class="keyword">if</span> msgs.isEmpty <span class="keyword">then</span>
16722           pure stxs
16723         <span class="keyword">else</span> <span class="keyword">do</span>
16724           msgs.forM <span class="keyword">fun</span> msg <span class="constant">=&gt;</span> msg.toString <span class="constant">&gt;&gt;=</span> IO.println
16725           throw (IO.userError <span class="string">"failed to parse file"</span>)
16726       <span class="keyword">else</span>
16727         parse state msgs (stxs.push stx)
16728   parse s msgs stxs
16729 
<span class="keyword">16730 def</span> <span class="function-name">testParseModule</span> (env : Environment) (fname contents : String) : IO Syntax <span class="constant">:=</span> <span class="keyword">do</span>
16731   <span class="keyword">let</span> fname &#8592; IO.realPath fname
16732   <span class="keyword">let</span> inputCtx <span class="constant">:=</span> mkInputContext contents fname
16733   <span class="keyword">let</span> (header, state, messages) &#8592; parseHeader inputCtx
16734   <span class="keyword">let</span> cmds &#8592; testParseModuleAux env inputCtx state messages <span class="constant">#</span>[]
16735   <span class="keyword">let</span> stx <span class="constant">:=</span> Syntax.node `Lean.Parser.Module.module <span class="constant">#</span>[header, mkListNode cmds]
16736   pure stx.updateLeading
16737 
<span class="keyword">16738 def</span> <span class="function-name">testParseFile</span> (env : Environment) (fname : String) : IO Syntax <span class="constant">:=</span> <span class="keyword">do</span>
16739   <span class="keyword">let</span> contents &#8592; IO.FS.readFile fname
16740   testParseModule env fname contents
16741 
<span class="keyword">16742 end</span> Parser
<span class="keyword">16743 end</span> Lean
16744 ::::::::::::::
16745 Parser<span class="constant">/</span>StrInterpolation.lean
16746 ::::::::::::::
<span class="comment-delimiter">16747 /-</span><span class="comment">
16748 Copyright (c) 2020 Microsoft Corporation. All rights reserved.
16749 Released under Apache 2.0 license as described in the file LICENSE.
16750 Authors: Leonardo de Moura
16751 -/</span>
<span class="keyword">16752 import</span> Lean.Parser.Basic
<span class="keyword">16753 namespace</span> Lean.Parser
16754 
<span class="keyword">16755 def</span> <span class="function-name">isQuotableCharForStrInterpolant</span> (c : Char) : Bool <span class="constant">:=</span>
16756   c <span class="constant">==</span> '{' <span class="constant">||</span> isQuotableCharDefault c
16757 
<span class="keyword">16758 partial</span> <span class="keyword">def</span> <span class="function-name">interpolatedStrFn</span> (p : ParserFn) : ParserFn <span class="constant">:=</span> <span class="keyword">fun</span> c s <span class="constant">=&gt;</span>
16759   <span class="keyword">let</span> input     <span class="constant">:=</span> c.input
16760   <span class="keyword">let</span> stackSize <span class="constant">:=</span> s.stackSize
16761   <span class="keyword">let</span> <span class="keyword">rec</span> parse (startPos : Nat) (c : ParserContext) (s : ParserState) : ParserState <span class="constant">:=</span>
16762     <span class="keyword">let</span> i     <span class="constant">:=</span> s.pos
16763     <span class="keyword">if</span> input.atEnd i <span class="keyword">then</span>
16764       s.mkUnexpectedErrorAt <span class="string">"unterminated string literal"</span> startPos
16765     <span class="keyword">else</span>
16766       <span class="keyword">let</span> curr <span class="constant">:=</span> input.get i
16767       <span class="keyword">let</span> s    <span class="constant">:=</span> s.setPos (input.next i)
16768       <span class="keyword">if</span> curr <span class="constant">==</span> '\"' <span class="keyword">then</span>
16769         <span class="keyword">let</span> s <span class="constant">:=</span> mkNodeToken interpolatedStrLitKind startPos c s
16770         s.mkNode interpolatedStrKind stackSize
16771       <span class="keyword">else</span> <span class="keyword">if</span> curr <span class="constant">==</span> '\\' <span class="keyword">then</span>
16772         andthenFn (quotedCharCoreFn isQuotableCharForStrInterpolant) (parse startPos) c s
16773       <span class="keyword">else</span> <span class="keyword">if</span> curr <span class="constant">==</span> '{' <span class="keyword">then</span>
16774         <span class="keyword">let</span> s <span class="constant">:=</span> mkNodeToken interpolatedStrLitKind startPos c s
16775         <span class="keyword">let</span> s <span class="constant">:=</span> p c s
16776         <span class="keyword">if</span> s.hasError <span class="keyword">then</span> s
16777         <span class="keyword">else</span>
16778           <span class="keyword">let</span> pos <span class="constant">:=</span> s.pos
16779           andthenFn (satisfyFn (&#183; <span class="constant">==</span> '}') <span class="string">"expected '}'"</span>) (parse pos) c s
16780       <span class="keyword">else</span>
16781         parse startPos c s
16782   <span class="keyword">let</span> startPos <span class="constant">:=</span> s.pos
16783   <span class="keyword">if</span> input.atEnd startPos <span class="keyword">then</span>
16784     s.mkEOIError
16785   <span class="keyword">else</span>
16786     <span class="keyword">let</span> curr  <span class="constant">:=</span> input.get s.pos;
16787     <span class="keyword">if</span> curr <span class="constant">!=</span> '\"' <span class="keyword">then</span>
16788       s.mkError <span class="string">"interpolated string"</span>
16789     <span class="keyword">else</span>
16790       <span class="keyword">let</span> s <span class="constant">:=</span> s.next input startPos
16791       parse startPos c s
16792 
<span class="doc">16793 @[inline]</span> <span class="keyword">def</span> <span class="function-name">interpolatedStrNoAntiquot</span> (p : Parser) : Parser <span class="constant">:=</span> {
16794   fn   <span class="constant">:=</span> interpolatedStrFn p.fn,
16795   info <span class="constant">:=</span> mkAtomicInfo <span class="string">"interpolatedStr"</span>
16796 }
16797 
<span class="keyword">16798 def</span> <span class="function-name">interpolatedStr</span> (p : Parser) : Parser <span class="constant">:=</span>
16799   withAntiquot (mkAntiquot <span class="string">"interpolatedStr"</span> interpolatedStrKind) <span class="constant">$</span> interpolatedStrNoAntiquot p
16800 
<span class="keyword">16801 end</span> Lean.Parser
16802 ::::::::::::::
16803 Parser<span class="constant">/</span>Syntax.lean
16804 ::::::::::::::
<span class="comment-delimiter">16805 /-</span><span class="comment">
16806 Copyright (c) 2019 Microsoft Corporation. All rights reserved.
16807 Released under Apache 2.0 license as described in the file LICENSE.
16808 Authors: Leonardo de Moura, Sebastian Ullrich
16809 -/</span>
<span class="keyword">16810 import</span> Lean.Parser.Command
<span class="keyword">16811 import</span> Lean.Parser.Tactic
16812 
<span class="keyword">16813 namespace</span> Lean
<span class="keyword">16814 namespace</span> Parser
16815 
<span class="keyword">16816 builtin_initialize</span>
16817   registerBuiltinParserAttribute `builtinSyntaxParser `stx LeadingIdentBehavior.both
16818   registerBuiltinDynamicParserAttribute `stxParser `stx
16819 
<span class="keyword">16820 builtin_initialize</span>
16821   registerBuiltinParserAttribute `builtinPrecParser `prec LeadingIdentBehavior.both
16822   registerBuiltinDynamicParserAttribute `precParser `prec
16823 
<span class="doc">16824 @[inline]</span> <span class="keyword">def</span> <span class="function-name">precedenceParser</span> (rbp : Nat <span class="constant">:=</span> <span class="constant">0</span>) : Parser <span class="constant">:=</span>
16825   categoryParser `prec rbp
16826 
<span class="doc">16827 @[inline]</span> <span class="keyword">def</span> <span class="function-name">syntaxParser</span> (rbp : Nat <span class="constant">:=</span> <span class="constant">0</span>) : Parser <span class="constant">:=</span>
16828   categoryParser `stx rbp
16829 
<span class="keyword">16830 def</span> <span class="comment">&#171;</span>precedence<span class="comment">&#187;</span> <span class="constant">:=</span> leading_parser <span class="string">":"</span> <span class="constant">&gt;&gt;</span> precedenceParser maxPrec
<span class="keyword">16831 def</span> <span class="function-name">optPrecedence</span> <span class="constant">:=</span> optional (atomic <span class="comment">&#171;</span>precedence<span class="comment">&#187;</span>)
16832 
<span class="keyword">16833 namespace</span> Syntax
<span class="doc">16834 @[builtinPrecParser]</span> <span class="keyword">def</span> <span class="function-name">numPrec</span> <span class="constant">:=</span> checkPrec maxPrec <span class="constant">&gt;&gt;</span> numLit
16835 
<span class="doc">16836 @[builtinSyntaxParser]</span> <span class="keyword">def</span> <span class="function-name">paren</span>           <span class="constant">:=</span> leading_parser <span class="string">"("</span> <span class="constant">&gt;&gt;</span> many1 syntaxParser <span class="constant">&gt;&gt;</span> <span class="string">")"</span>
<span class="doc">16837 @[builtinSyntaxParser]</span> <span class="keyword">def</span> <span class="function-name">cat</span>             <span class="constant">:=</span> leading_parser ident <span class="constant">&gt;&gt;</span> optPrecedence
<span class="doc">16838 @[builtinSyntaxParser]</span> <span class="keyword">def</span> <span class="function-name">unary</span>           <span class="constant">:=</span> leading_parser ident <span class="constant">&gt;&gt;</span> checkNoWsBefore <span class="constant">&gt;&gt;</span> <span class="string">"("</span> <span class="constant">&gt;&gt;</span> many1 syntaxParser <span class="constant">&gt;&gt;</span> <span class="string">")"</span>
<span class="doc">16839 @[builtinSyntaxParser]</span> <span class="keyword">def</span> <span class="function-name">binary</span>          <span class="constant">:=</span> leading_parser ident <span class="constant">&gt;&gt;</span> checkNoWsBefore <span class="constant">&gt;&gt;</span> <span class="string">"("</span> <span class="constant">&gt;&gt;</span> many1 syntaxParser <span class="constant">&gt;&gt;</span> <span class="string">", "</span> <span class="constant">&gt;&gt;</span> many1 syntaxParser <span class="constant">&gt;&gt;</span> <span class="string">")"</span>
<span class="doc">16840 @[builtinSyntaxParser]</span> <span class="keyword">def</span> <span class="function-name">sepBy</span>           <span class="constant">:=</span> leading_parser <span class="string">"sepBy("</span> <span class="constant">&gt;&gt;</span> many1 syntaxParser <span class="constant">&gt;&gt;</span> <span class="string">", "</span> <span class="constant">&gt;&gt;</span> strLit <span class="constant">&gt;&gt;</span> optional (<span class="string">", "</span> <span class="constant">&gt;&gt;</span> many1 syntaxParser) <span class="constant">&gt;&gt;</span> optional (<span class="string">", "</span> <span class="constant">&gt;&gt;</span> nonReservedSymbol <span class="string">"allowTrailingSep"</span>) <span class="constant">&gt;&gt;</span> <span class="string">")"</span>
<span class="doc">16841 @[builtinSyntaxParser]</span> <span class="keyword">def</span> <span class="function-name">sepBy1</span>          <span class="constant">:=</span> leading_parser <span class="string">"sepBy1("</span> <span class="constant">&gt;&gt;</span> many1 syntaxParser <span class="constant">&gt;&gt;</span> <span class="string">", "</span> <span class="constant">&gt;&gt;</span> strLit <span class="constant">&gt;&gt;</span> optional (<span class="string">", "</span> <span class="constant">&gt;&gt;</span> many1 syntaxParser) <span class="constant">&gt;&gt;</span> optional (<span class="string">", "</span> <span class="constant">&gt;&gt;</span> nonReservedSymbol <span class="string">"allowTrailingSep"</span>) <span class="constant">&gt;&gt;</span> <span class="string">")"</span>
<span class="doc">16842 @[builtinSyntaxParser]</span> <span class="keyword">def</span> <span class="function-name">atom</span>            <span class="constant">:=</span> leading_parser strLit
<span class="doc">16843 @[builtinSyntaxParser]</span> <span class="keyword">def</span> <span class="function-name">nonReserved</span>     <span class="constant">:=</span> leading_parser <span class="string">"&amp;"</span> <span class="constant">&gt;&gt;</span> strLit
16844 
<span class="keyword">16845 end</span> Syntax
16846 
<span class="keyword">16847 namespace</span> Term
16848 
<span class="doc">16849 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">stx.quot</span> : Parser <span class="constant">:=</span> leading_parser <span class="string">"`(stx|"</span>  <span class="constant">&gt;&gt;</span> toggleInsideQuot syntaxParser <span class="constant">&gt;&gt;</span> <span class="string">")"</span>
<span class="doc">16850 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">prec.quot</span> : Parser <span class="constant">:=</span> leading_parser <span class="string">"`(prec|"</span>  <span class="constant">&gt;&gt;</span> toggleInsideQuot precedenceParser <span class="constant">&gt;&gt;</span> <span class="string">")"</span>
<span class="doc">16851 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">prio.quot</span> : Parser <span class="constant">:=</span> leading_parser <span class="string">"`(prio|"</span>  <span class="constant">&gt;&gt;</span> toggleInsideQuot priorityParser <span class="constant">&gt;&gt;</span> <span class="string">")"</span>
16852 
<span class="keyword">16853 end</span> Term
16854 
<span class="keyword">16855 namespace</span> Command
16856 
<span class="keyword">16857 def</span> <span class="function-name">namedName</span> <span class="constant">:=</span> leading_parser (atomic (<span class="string">"("</span> <span class="constant">&gt;&gt;</span> nonReservedSymbol <span class="string">"name"</span>) <span class="constant">&gt;&gt;</span> <span class="string">" := "</span> <span class="constant">&gt;&gt;</span> ident <span class="constant">&gt;&gt;</span> <span class="string">")"</span>)
<span class="keyword">16858 def</span> <span class="function-name">optNamedName</span> <span class="constant">:=</span> optional namedName
16859 
<span class="keyword">16860 def</span> <span class="comment">&#171;</span>prefix<span class="comment">&#187;</span>   <span class="constant">:=</span> leading_parser <span class="string">"prefix"</span>
<span class="keyword">16861 def</span> <span class="comment">&#171;</span>infix<span class="comment">&#187;</span>    <span class="constant">:=</span> leading_parser <span class="string">"infix"</span>
<span class="keyword">16862 def</span> <span class="comment">&#171;</span>infixl<span class="comment">&#187;</span>   <span class="constant">:=</span> leading_parser <span class="string">"infixl"</span>
<span class="keyword">16863 def</span> <span class="comment">&#171;</span>infixr<span class="comment">&#187;</span>   <span class="constant">:=</span> leading_parser <span class="string">"infixr"</span>
<span class="keyword">16864 def</span> <span class="comment">&#171;</span>postfix<span class="comment">&#187;</span>  <span class="constant">:=</span> leading_parser <span class="string">"postfix"</span>
<span class="keyword">16865 def</span> <span class="function-name">mixfixKind</span> <span class="constant">:=</span> <span class="comment">&#171;</span>prefix<span class="comment">&#187;</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> <span class="comment">&#171;</span>infix<span class="comment">&#187;</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> <span class="comment">&#171;</span>infixl<span class="comment">&#187;</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> <span class="comment">&#171;</span>infixr<span class="comment">&#187;</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> <span class="comment">&#171;</span>postfix<span class="comment">&#187;</span>
<span class="doc">16866 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>mixfix<span class="comment">&#187;</span>   <span class="constant">:=</span> leading_parser Term.attrKind <span class="constant">&gt;&gt;</span> mixfixKind <span class="constant">&gt;&gt;</span> optPrecedence <span class="constant">&gt;&gt;</span> optNamedName <span class="constant">&gt;&gt;</span> optNamedPrio <span class="constant">&gt;&gt;</span> ppSpace <span class="constant">&gt;&gt;</span> strLit <span class="constant">&gt;&gt;</span> darrow <span class="constant">&gt;&gt;</span> termParser
<span class="comment-delimiter">16867 -- </span><span class="comment">NOTE: We use `suppressInsideQuot` in the following parsers because quotations inside them are evaluated in the same stage and
</span><span class="comment-delimiter">16868 -- </span><span class="comment">thus should be ignored when we use `checkInsideQuot` to prepare the next stage for a builtin syntax change
</span><span class="keyword">16869 def</span> <span class="function-name">identPrec</span>  <span class="constant">:=</span> leading_parser ident <span class="constant">&gt;&gt;</span> optPrecedence
16870 
<span class="keyword">16871 def</span> <span class="function-name">optKind</span> : Parser <span class="constant">:=</span> optional (<span class="string">"("</span> <span class="constant">&gt;&gt;</span> nonReservedSymbol <span class="string">"kind"</span> <span class="constant">&gt;&gt;</span> <span class="string">":="</span> <span class="constant">&gt;&gt;</span> ident <span class="constant">&gt;&gt;</span> <span class="string">")"</span>)
16872 
<span class="keyword">16873 def</span> <span class="function-name">notationItem</span> <span class="constant">:=</span> ppSpace <span class="constant">&gt;&gt;</span> withAntiquot (mkAntiquot <span class="string">"notationItem"</span> `Lean.Parser.Command.notationItem) (strLit <span class="constant">&lt;</span>|<span class="constant">&gt;</span> identPrec)
<span class="doc">16874 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>notation<span class="comment">&#187;</span>    <span class="constant">:=</span> leading_parser Term.attrKind <span class="constant">&gt;&gt;</span> <span class="string">"notation"</span> <span class="constant">&gt;&gt;</span> optPrecedence <span class="constant">&gt;&gt;</span> optNamedName <span class="constant">&gt;&gt;</span> optNamedPrio <span class="constant">&gt;&gt;</span> many notationItem <span class="constant">&gt;&gt;</span> darrow <span class="constant">&gt;&gt;</span> termParser
<span class="doc">16875 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>macro_rules<span class="comment">&#187;</span> <span class="constant">:=</span> suppressInsideQuot (leading_parser <span class="string">"macro_rules"</span> <span class="constant">&gt;&gt;</span>  optKind <span class="constant">&gt;&gt;</span> Term.matchAlts)
<span class="doc">16876 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>syntax<span class="comment">&#187;</span>      <span class="constant">:=</span> leading_parser Term.attrKind <span class="constant">&gt;&gt;</span> <span class="string">"syntax "</span> <span class="constant">&gt;&gt;</span> optPrecedence <span class="constant">&gt;&gt;</span> optNamedName <span class="constant">&gt;&gt;</span> optNamedPrio <span class="constant">&gt;&gt;</span> many1 syntaxParser <span class="constant">&gt;&gt;</span> <span class="string">" : "</span> <span class="constant">&gt;&gt;</span> ident
<span class="doc">16877 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="function-name">syntaxAbbrev</span>  <span class="constant">:=</span> leading_parser <span class="string">"syntax "</span> <span class="constant">&gt;&gt;</span> ident <span class="constant">&gt;&gt;</span> <span class="string">" := "</span> <span class="constant">&gt;&gt;</span> many1 syntaxParser
<span class="doc">16878 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="function-name">syntaxCat</span>     <span class="constant">:=</span> leading_parser <span class="string">"declare_syntax_cat "</span> <span class="constant">&gt;&gt;</span> ident
<span class="keyword">16879 def</span> <span class="function-name">macroArgSimple</span> <span class="constant">:=</span> leading_parser ident <span class="constant">&gt;&gt;</span> checkNoWsBefore <span class="string">"no space before ':'"</span> <span class="constant">&gt;&gt;</span> <span class="string">":"</span> <span class="constant">&gt;&gt;</span> syntaxParser maxPrec
<span class="keyword">16880 def</span> <span class="function-name">macroArgSymbol</span> <span class="constant">:=</span> leading_parser strLit <span class="constant">&gt;&gt;</span> optional (atomic <span class="constant">&lt;</span>| checkNoWsBefore <span class="constant">&gt;&gt;</span> <span class="string">"%"</span> <span class="constant">&gt;&gt;</span> checkNoWsBefore <span class="constant">&gt;&gt;</span> ident)
<span class="keyword">16881 def</span> <span class="function-name">macroArg</span>  <span class="constant">:=</span> macroArgSymbol <span class="constant">&lt;</span>|<span class="constant">&gt;</span> atomic macroArgSimple
<span class="keyword">16882 def</span> <span class="function-name">macroHead</span> <span class="constant">:=</span> macroArg
<span class="keyword">16883 def</span> <span class="function-name">macroTailTactic</span>   : Parser <span class="constant">:=</span> atomic (<span class="string">" : "</span> <span class="constant">&gt;&gt;</span> identEq <span class="string">"tactic"</span>) <span class="constant">&gt;&gt;</span> darrow <span class="constant">&gt;&gt;</span> (<span class="string">"`("</span> <span class="constant">&gt;&gt;</span> toggleInsideQuot Tactic.seq1 <span class="constant">&gt;&gt;</span> <span class="string">")"</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> termParser)
<span class="keyword">16884 def</span> <span class="function-name">macroTailCommand</span>  : Parser <span class="constant">:=</span> atomic (<span class="string">" : "</span> <span class="constant">&gt;&gt;</span> identEq <span class="string">"command"</span>) <span class="constant">&gt;&gt;</span> darrow <span class="constant">&gt;&gt;</span> (<span class="string">"`("</span> <span class="constant">&gt;&gt;</span> toggleInsideQuot (many1Unbox commandParser) <span class="constant">&gt;&gt;</span> <span class="string">")"</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> termParser)
<span class="keyword">16885 def</span> <span class="function-name">macroTailDefault</span>  : Parser <span class="constant">:=</span> atomic (<span class="string">" : "</span> <span class="constant">&gt;&gt;</span> ident) <span class="constant">&gt;&gt;</span> darrow <span class="constant">&gt;&gt;</span> ((<span class="string">"`("</span> <span class="constant">&gt;&gt;</span> toggleInsideQuot (categoryParserOfStack <span class="constant">2</span>) <span class="constant">&gt;&gt;</span> <span class="string">")"</span>) <span class="constant">&lt;</span>|<span class="constant">&gt;</span> termParser)
<span class="keyword">16886 def</span> <span class="function-name">macroTail</span> <span class="constant">:=</span> macroTailTactic <span class="constant">&lt;</span>|<span class="constant">&gt;</span> macroTailCommand <span class="constant">&lt;</span>|<span class="constant">&gt;</span> macroTailDefault
<span class="doc">16887 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>macro<span class="comment">&#187;</span>       <span class="constant">:=</span> leading_parser suppressInsideQuot (Term.attrKind <span class="constant">&gt;&gt;</span> <span class="string">"macro "</span> <span class="constant">&gt;&gt;</span> optPrecedence <span class="constant">&gt;&gt;</span> optNamedName <span class="constant">&gt;&gt;</span> optNamedPrio <span class="constant">&gt;&gt;</span> macroHead <span class="constant">&gt;&gt;</span> many macroArg <span class="constant">&gt;&gt;</span> macroTail)
16888 
<span class="doc">16889 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>elab_rules<span class="comment">&#187;</span> <span class="constant">:=</span> leading_parser suppressInsideQuot (<span class="string">"elab_rules"</span> <span class="constant">&gt;&gt;</span> optKind <span class="constant">&gt;&gt;</span> optional (<span class="string">" : "</span> <span class="constant">&gt;&gt;</span> ident) <span class="constant">&gt;&gt;</span> Term.matchAlts)
<span class="keyword">16890 def</span> <span class="function-name">elabHead</span> <span class="constant">:=</span> macroHead
<span class="keyword">16891 def</span> <span class="function-name">elabArg</span>  <span class="constant">:=</span> macroArg
<span class="keyword">16892 def</span> <span class="function-name">elabTail</span> <span class="constant">:=</span> atomic (<span class="string">" : "</span> <span class="constant">&gt;&gt;</span> ident <span class="constant">&gt;&gt;</span> optional (<span class="string">" &lt;= "</span> <span class="constant">&gt;&gt;</span> ident)) <span class="constant">&gt;&gt;</span> darrow <span class="constant">&gt;&gt;</span> termParser
<span class="doc">16893 @[builtinCommandParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>elab<span class="comment">&#187;</span>       <span class="constant">:=</span> leading_parser suppressInsideQuot (Term.attrKind <span class="constant">&gt;&gt;</span> <span class="string">"elab "</span> <span class="constant">&gt;&gt;</span> optPrecedence <span class="constant">&gt;&gt;</span> optNamedName <span class="constant">&gt;&gt;</span> optNamedPrio <span class="constant">&gt;&gt;</span> elabHead <span class="constant">&gt;&gt;</span> many elabArg <span class="constant">&gt;&gt;</span> elabTail)
16894 
<span class="keyword">16895 end</span> Command
16896 
<span class="keyword">16897 end</span> Parser
<span class="keyword">16898 end</span> Lean
16899 ::::::::::::::
16900 Parser<span class="constant">/</span>Tactic.lean
16901 ::::::::::::::
<span class="comment-delimiter">16902 /-</span><span class="comment">
16903 Copyright (c) 2020 Microsoft Corporation. All rights reserved.
16904 Released under Apache 2.0 license as described in the file LICENSE.
16905 Authors: Leonardo de Moura, Sebastian Ullrich
16906 -/</span>
<span class="keyword">16907 import</span> Lean.Parser.Term
16908 
<span class="keyword">16909 namespace</span> Lean
<span class="keyword">16910 namespace</span> Parser
<span class="keyword">16911 namespace</span> Tactic
16912 
<span class="keyword">16913 builtin_initialize</span>
16914   register_parser_alias <span class="string">"tacticSeq"</span>    tacticSeq
16915 
<span class="doc">16916 @[builtinTacticParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>unknown<span class="comment">&#187;</span>    <span class="constant">:=</span> leading_parser withPosition (ident <span class="constant">&gt;&gt;</span> errorAtSavedPos <span class="string">"unknown tactic"</span> true)
<span class="doc">16917 @[builtinTacticParser]</span> <span class="keyword">def</span> <span class="function-name">nestedTactic</span> <span class="constant">:=</span> tacticSeqBracketed
16918 
<span class="comment-delimiter">16919 /- </span><span class="comment">Auxiliary parser for expanding `match` tactic -/</span>
<span class="doc">16920 @[builtinTacticParser]</span> <span class="keyword">def</span> <span class="function-name">eraseAuxDiscrs</span> <span class="constant">:=</span> leading_parser:maxPrec <span class="string">"eraseAuxDiscrs!"</span>
16921 
<span class="keyword">16922 def</span> <span class="function-name">matchRhs</span>  <span class="constant">:=</span> Term.hole <span class="constant">&lt;</span>|<span class="constant">&gt;</span> Term.syntheticHole <span class="constant">&lt;</span>|<span class="constant">&gt;</span> tacticSeq
<span class="keyword">16923 def</span> <span class="function-name">matchAlts</span> <span class="constant">:=</span> Term.matchAlts (rhsParser <span class="constant">:=</span> matchRhs)
<span class="doc">16924 @[builtinTacticParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>match<span class="comment">&#187;</span> <span class="constant">:=</span> leading_parser:leadPrec <span class="string">"match "</span> <span class="constant">&gt;&gt;</span> optional Term.generalizingParam <span class="constant">&gt;&gt;</span> sepBy1 Term.matchDiscr <span class="string">", "</span> <span class="constant">&gt;&gt;</span> Term.optType <span class="constant">&gt;&gt;</span> <span class="string">" with "</span> <span class="constant">&gt;&gt;</span> matchAlts
<span class="doc">16925 @[builtinTacticParser]</span> <span class="keyword">def</span> <span class="function-name">introMatch</span> <span class="constant">:=</span> leading_parser nonReservedSymbol <span class="string">"intro "</span> <span class="constant">&gt;&gt;</span> matchAlts
16926 
<span class="doc">16927 @[builtinTacticParser]</span> <span class="keyword">def</span> <span class="function-name">decide</span> <span class="constant">:=</span> leading_parser nonReservedSymbol <span class="string">"decide"</span>
<span class="doc">16928 @[builtinTacticParser]</span> <span class="keyword">def</span> <span class="function-name">nativeDecide</span> <span class="constant">:=</span> leading_parser nonReservedSymbol <span class="string">"nativeDecide"</span>
16929 
<span class="keyword">16930 end</span> Tactic
<span class="keyword">16931 end</span> Parser
<span class="keyword">16932 end</span> Lean
16933 ::::::::::::::
16934 Parser<span class="constant">/</span>Term.lean
16935 ::::::::::::::
<span class="comment-delimiter">16936 /-</span><span class="comment">
16937 Copyright (c) 2019 Microsoft Corporation. All rights reserved.
16938 Released under Apache 2.0 license as described in the file LICENSE.
16939 Authors: Leonardo de Moura, Sebastian Ullrich
16940 -/</span>
<span class="keyword">16941 import</span> Lean.Parser.Attr
<span class="keyword">16942 import</span> Lean.Parser.Level
16943 
<span class="keyword">16944 namespace</span> Lean
<span class="keyword">16945 namespace</span> Parser
16946 
<span class="keyword">16947 namespace</span> Command
<span class="keyword">16948 def</span> <span class="function-name">commentBody</span> : Parser <span class="constant">:=</span>
16949 { fn <span class="constant">:=</span> rawFn (<span class="keyword">fun</span> c s <span class="constant">=&gt;</span> finishCommentBlock s.pos <span class="constant">1</span> c s) (trailingWs <span class="constant">:=</span> true) }
16950 
<span class="doc">16951 @[combinatorParenthesizer Lean.Parser.Command.commentBody]</span> <span class="keyword">def</span> <span class="function-name">commentBody.parenthesizer</span> <span class="constant">:=</span> PrettyPrinter.Parenthesizer.visitToken
<span class="doc">16952 @[combinatorFormatter Lean.Parser.Command.commentBody]</span> <span class="keyword">def</span> <span class="function-name">commentBody.formatter</span> <span class="constant">:=</span> PrettyPrinter.Formatter.visitAtom Name.anonymous
16953 
<span class="keyword">16954 def</span> <span class="function-name">docComment</span>       <span class="constant">:=</span> leading_parser ppDedent <span class="constant">$</span> <span class="string">"/--"</span> <span class="constant">&gt;&gt;</span> commentBody <span class="constant">&gt;&gt;</span> ppLine
<span class="keyword">16955 end</span> Command
16956 
<span class="keyword">16957 builtin_initialize</span>
16958   registerBuiltinParserAttribute `builtinTacticParser `tactic LeadingIdentBehavior.both
16959   registerBuiltinDynamicParserAttribute `tacticParser `tactic
16960 
<span class="doc">16961 @[inline]</span> <span class="keyword">def</span> <span class="function-name">tacticParser</span> (rbp : Nat <span class="constant">:=</span> <span class="constant">0</span>) : Parser <span class="constant">:=</span>
16962   categoryParser `tactic rbp
16963 
<span class="keyword">16964 namespace</span> Tactic
16965 
<span class="keyword">16966 def</span> <span class="function-name">tacticSeq1Indented</span> : Parser <span class="constant">:=</span>
16967   leading_parser many1Indent (group (ppLine <span class="constant">&gt;&gt;</span> tacticParser <span class="constant">&gt;&gt;</span> optional <span class="string">";"</span>))
<span class="keyword">16968 def</span> <span class="function-name">tacticSeqBracketed</span> : Parser <span class="constant">:=</span>
16969   leading_parser <span class="string">"{"</span> <span class="constant">&gt;&gt;</span> many (group (ppLine <span class="constant">&gt;&gt;</span> tacticParser <span class="constant">&gt;&gt;</span> optional <span class="string">";"</span>)) <span class="constant">&gt;&gt;</span> ppDedent (ppLine <span class="constant">&gt;&gt;</span> <span class="string">"}"</span>)
<span class="keyword">16970 def</span> <span class="function-name">tacticSeq</span> <span class="constant">:=</span>
16971   nodeWithAntiquot <span class="string">"tacticSeq"</span> `Lean.Parser.Tactic.tacticSeq (tacticSeqBracketed <span class="constant">&lt;</span>|<span class="constant">&gt;</span> tacticSeq1Indented)
16972 
<span class="comment-delimiter">16973 /- </span><span class="comment">Raw sequence for quotation and grouping -/</span>
<span class="keyword">16974 def</span> <span class="function-name">seq1</span> <span class="constant">:=</span>
16975   node `Lean.Parser.Tactic.seq1 <span class="constant">$</span> sepBy1 tacticParser <span class="string">";\n"</span> (allowTrailingSep <span class="constant">:=</span> true)
16976 
<span class="keyword">16977 end</span> Tactic
16978 
<span class="keyword">16979 def</span> <span class="function-name">darrow</span> : Parser <span class="constant">:=</span> <span class="string">" =&gt; "</span>
16980 
<span class="keyword">16981 namespace</span> Term
16982 
<span class="comment-delimiter">16983 /- </span><span class="comment">Built-in parsers -/</span>
16984 
<span class="doc">16985 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">byTactic</span> <span class="constant">:=</span> leading_parser:leadPrec <span class="string">"by "</span> <span class="constant">&gt;&gt;</span> Tactic.tacticSeq
16986 
<span class="keyword">16987 def</span> <span class="function-name">optSemicolon</span> (p : Parser) : Parser <span class="constant">:=</span> ppDedent <span class="constant">$</span> optional <span class="string">";"</span> <span class="constant">&gt;&gt;</span> ppLine <span class="constant">&gt;&gt;</span> p
16988 
<span class="comment-delimiter">16989 -- </span><span class="comment">`checkPrec` necessary for the pretty printer
</span><span class="doc">16990 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">ident</span> <span class="constant">:=</span> checkPrec maxPrec <span class="constant">&gt;&gt;</span> Parser.ident
<span class="doc">16991 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">num</span> : Parser <span class="constant">:=</span> checkPrec maxPrec <span class="constant">&gt;&gt;</span> numLit
<span class="doc">16992 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">scientific</span> : Parser <span class="constant">:=</span> checkPrec maxPrec <span class="constant">&gt;&gt;</span> scientificLit
<span class="doc">16993 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">str</span> : Parser <span class="constant">:=</span> checkPrec maxPrec <span class="constant">&gt;&gt;</span> strLit
<span class="doc">16994 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">char</span> : Parser <span class="constant">:=</span> checkPrec maxPrec <span class="constant">&gt;&gt;</span> charLit
<span class="doc">16995 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">type</span> <span class="constant">:=</span> leading_parser <span class="string">"Type"</span> <span class="constant">&gt;&gt;</span> optional (checkWsBefore <span class="string">""</span> <span class="constant">&gt;&gt;</span> checkPrec leadPrec <span class="constant">&gt;&gt;</span> checkColGt <span class="constant">&gt;&gt;</span> levelParser maxPrec)
<span class="doc">16996 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">sort</span> <span class="constant">:=</span> leading_parser <span class="string">"Sort"</span> <span class="constant">&gt;&gt;</span> optional (checkWsBefore <span class="string">""</span> <span class="constant">&gt;&gt;</span> checkPrec leadPrec <span class="constant">&gt;&gt;</span> checkColGt <span class="constant">&gt;&gt;</span> levelParser maxPrec)
<span class="doc">16997 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">prop</span> <span class="constant">:=</span> leading_parser <span class="string">"Prop"</span>
<span class="doc">16998 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">hole</span> <span class="constant">:=</span> leading_parser <span class="string">"_"</span>
<span class="doc">16999 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">syntheticHole</span> <span class="constant">:=</span> leading_parser <span class="string">"?"</span> <span class="constant">&gt;&gt;</span> (ident <span class="constant">&lt;</span>|<span class="constant">&gt;</span> hole)
<span class="doc">17000 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>sorry<span class="comment">&#187;</span> <span class="constant">:=</span> leading_parser <span class="string">"sorry"</span>
<span class="doc">17001 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">cdot</span>   <span class="constant">:=</span> leading_parser symbol <span class="string">"&#183;"</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> <span class="string">"."</span>
<span class="doc">17002 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">emptyC</span> <span class="constant">:=</span> leading_parser <span class="string">"&#8709;"</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> (symbol <span class="string">"{"</span> <span class="constant">&gt;&gt;</span> <span class="string">"}"</span>)
<span class="keyword">17003 def</span> <span class="function-name">typeAscription</span> <span class="constant">:=</span> leading_parser <span class="string">" : "</span> <span class="constant">&gt;&gt;</span> termParser
<span class="keyword">17004 def</span> <span class="function-name">tupleTail</span>      <span class="constant">:=</span> leading_parser <span class="string">", "</span> <span class="constant">&gt;&gt;</span> sepBy1 termParser <span class="string">", "</span>
<span class="keyword">17005 def</span> <span class="function-name">parenSpecial</span> : Parser <span class="constant">:=</span> optional (tupleTail <span class="constant">&lt;</span>|<span class="constant">&gt;</span> typeAscription)
<span class="doc">17006 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">paren</span> <span class="constant">:=</span> leading_parser <span class="string">"("</span> <span class="constant">&gt;&gt;</span> ppDedent (withoutPosition (withoutForbidden (optional (termParser <span class="constant">&gt;&gt;</span> parenSpecial)))) <span class="constant">&gt;&gt;</span> <span class="string">")"</span>
<span class="doc">17007 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">anonymousCtor</span> <span class="constant">:=</span> leading_parser <span class="string">"&#10216;"</span> <span class="constant">&gt;&gt;</span> sepBy termParser <span class="string">", "</span> <span class="constant">&gt;&gt;</span> <span class="string">"&#10217;"</span>
<span class="keyword">17008 def</span> <span class="function-name">optIdent</span> : Parser <span class="constant">:=</span> optional (atomic (ident <span class="constant">&gt;&gt;</span> <span class="string">" : "</span>))
<span class="keyword">17009 def</span> <span class="function-name">fromTerm</span>   <span class="constant">:=</span> leading_parser <span class="string">" from "</span> <span class="constant">&gt;&gt;</span> termParser
<span class="keyword">17010 def</span> <span class="function-name">haveAssign</span> <span class="constant">:=</span> leading_parser <span class="string">" := "</span> <span class="constant">&gt;&gt;</span> termParser
<span class="keyword">17011 def</span> <span class="function-name">haveDecl</span>   <span class="constant">:=</span> leading_parser optIdent <span class="constant">&gt;&gt;</span> termParser <span class="constant">&gt;&gt;</span> (haveAssign <span class="constant">&lt;</span>|<span class="constant">&gt;</span> fromTerm <span class="constant">&lt;</span>|<span class="constant">&gt;</span> byTactic)
<span class="doc">17012 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>have<span class="comment">&#187;</span> <span class="constant">:=</span> leading_parser:leadPrec withPosition (<span class="string">"have "</span> <span class="constant">&gt;&gt;</span> haveDecl) <span class="constant">&gt;&gt;</span> optSemicolon termParser
<span class="keyword">17013 def</span> <span class="function-name">sufficesDecl</span> <span class="constant">:=</span> leading_parser optIdent <span class="constant">&gt;&gt;</span> termParser <span class="constant">&gt;&gt;</span> (fromTerm <span class="constant">&lt;</span>|<span class="constant">&gt;</span> byTactic)
<span class="doc">17014 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>suffices<span class="comment">&#187;</span> <span class="constant">:=</span> leading_parser:leadPrec withPosition (<span class="string">"suffices "</span> <span class="constant">&gt;&gt;</span> sufficesDecl) <span class="constant">&gt;&gt;</span> optSemicolon termParser
<span class="doc">17015 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>show<span class="comment">&#187;</span>     <span class="constant">:=</span> leading_parser:leadPrec <span class="string">"show "</span> <span class="constant">&gt;&gt;</span> termParser <span class="constant">&gt;&gt;</span> (fromTerm <span class="constant">&lt;</span>|<span class="constant">&gt;</span> byTactic)
<span class="keyword">17016 def</span> <span class="function-name">structInstArrayRef</span> <span class="constant">:=</span> leading_parser <span class="string">"["</span> <span class="constant">&gt;&gt;</span> termParser <span class="constant">&gt;&gt;</span><span class="string">"]"</span>
<span class="keyword">17017 def</span> <span class="function-name">structInstLVal</span>   <span class="constant">:=</span> leading_parser (ident <span class="constant">&lt;</span>|<span class="constant">&gt;</span> fieldIdx <span class="constant">&lt;</span>|<span class="constant">&gt;</span> structInstArrayRef) <span class="constant">&gt;&gt;</span> many (group (<span class="string">"."</span> <span class="constant">&gt;&gt;</span> (ident <span class="constant">&lt;</span>|<span class="constant">&gt;</span> fieldIdx)) <span class="constant">&lt;</span>|<span class="constant">&gt;</span> structInstArrayRef)
<span class="keyword">17018 def</span> <span class="function-name">structInstField</span>  <span class="constant">:=</span> ppGroup <span class="constant">$</span> leading_parser structInstLVal <span class="constant">&gt;&gt;</span> <span class="string">" := "</span> <span class="constant">&gt;&gt;</span> termParser
<span class="keyword">17019 def</span> <span class="function-name">optEllipsis</span>      <span class="constant">:=</span> leading_parser optional <span class="string">".."</span>
<span class="doc">17020 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">structInst</span> <span class="constant">:=</span> leading_parser <span class="string">"{"</span> <span class="constant">&gt;&gt;</span> ppHardSpace <span class="constant">&gt;&gt;</span> optional (atomic (termParser <span class="constant">&gt;&gt;</span> <span class="string">" with "</span>))
17021   <span class="constant">&gt;&gt;</span> manyIndent (group (structInstField <span class="constant">&gt;&gt;</span> optional <span class="string">", "</span>))
17022   <span class="constant">&gt;&gt;</span> optEllipsis
17023   <span class="constant">&gt;&gt;</span> optional (<span class="string">" : "</span> <span class="constant">&gt;&gt;</span> termParser) <span class="constant">&gt;&gt;</span> <span class="string">" }"</span>
<span class="keyword">17024 def</span> <span class="function-name">typeSpec</span> <span class="constant">:=</span> leading_parser <span class="string">" : "</span> <span class="constant">&gt;&gt;</span> termParser
<span class="keyword">17025 def</span> <span class="function-name">optType</span> : Parser <span class="constant">:=</span> optional typeSpec
<span class="doc">17026 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">explicit</span> <span class="constant">:=</span> leading_parser <span class="string">"@"</span> <span class="constant">&gt;&gt;</span> termParser maxPrec
<span class="doc">17027 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">inaccessible</span> <span class="constant">:=</span> leading_parser <span class="string">".("</span> <span class="constant">&gt;&gt;</span> termParser <span class="constant">&gt;&gt;</span> <span class="string">")"</span>
<span class="keyword">17028 def</span> <span class="function-name">binderIdent</span> : Parser  <span class="constant">:=</span> ident <span class="constant">&lt;</span>|<span class="constant">&gt;</span> hole
<span class="keyword">17029 def</span> <span class="function-name">binderType</span> (requireType <span class="constant">:=</span> false) : Parser <span class="constant">:=</span> <span class="keyword">if</span> requireType <span class="keyword">then</span> node nullKind (<span class="string">" : "</span> <span class="constant">&gt;&gt;</span> termParser) <span class="keyword">else</span> optional (<span class="string">" : "</span> <span class="constant">&gt;&gt;</span> termParser)
<span class="keyword">17030 def</span> <span class="function-name">binderTactic</span>  <span class="constant">:=</span> leading_parser atomic (symbol <span class="string">" := "</span> <span class="constant">&gt;&gt;</span> <span class="string">" by "</span>) <span class="constant">&gt;&gt;</span> Tactic.tacticSeq
<span class="keyword">17031 def</span> <span class="function-name">binderDefault</span> <span class="constant">:=</span> leading_parser <span class="string">" := "</span> <span class="constant">&gt;&gt;</span> termParser
<span class="keyword">17032 def</span> <span class="function-name">explicitBinder</span> (requireType <span class="constant">:=</span> false) <span class="constant">:=</span> ppGroup <span class="constant">$</span> leading_parser <span class="string">"("</span> <span class="constant">&gt;&gt;</span> many1 binderIdent <span class="constant">&gt;&gt;</span> binderType requireType <span class="constant">&gt;&gt;</span> optional (binderTactic <span class="constant">&lt;</span>|<span class="constant">&gt;</span> binderDefault) <span class="constant">&gt;&gt;</span> <span class="string">")"</span>
<span class="keyword">17033 def</span> <span class="function-name">implicitBinder</span> (requireType <span class="constant">:=</span> false) <span class="constant">:=</span> ppGroup <span class="constant">$</span> leading_parser <span class="string">"{"</span> <span class="constant">&gt;&gt;</span> many1 binderIdent <span class="constant">&gt;&gt;</span> binderType requireType <span class="constant">&gt;&gt;</span> <span class="string">"}"</span>
<span class="keyword">17034 def</span> <span class="function-name">instBinder</span> <span class="constant">:=</span> ppGroup <span class="constant">$</span> leading_parser <span class="string">"["</span> <span class="constant">&gt;&gt;</span> optIdent <span class="constant">&gt;&gt;</span> termParser <span class="constant">&gt;&gt;</span> <span class="string">"]"</span>
<span class="keyword">17035 def</span> <span class="function-name">bracketedBinder</span> (requireType <span class="constant">:=</span> false) <span class="constant">:=</span> withAntiquot (mkAntiquot <span class="string">"bracketedBinder"</span> none (anonymous <span class="constant">:=</span> false)) <span class="constant">&lt;</span>|
17036   explicitBinder requireType <span class="constant">&lt;</span>|<span class="constant">&gt;</span> implicitBinder requireType <span class="constant">&lt;</span>|<span class="constant">&gt;</span> instBinder
17037 
<span class="comment-delimiter">17038 /-</span><span class="comment">
17039 It is feasible to support dependent arrows such as `{&#945;} &#8594; &#945; &#8594; &#945;` without sacrificing the quality of the error messages for the longer case.
17040 `{&#945;} &#8594; &#945; &#8594; &#945;` would be short for `{&#945; : Type} &#8594; &#945; &#8594; &#945;`
17041 Here is the encoding:
17042 ```
17043 def implicitShortBinder := node `Lean.Parser.Term.implicitBinder $ "{" &gt;&gt; many1 binderIdent &gt;&gt; pushNone &gt;&gt; "}"
17044 def depArrowShortPrefix := try (implicitShortBinder &gt;&gt; unicodeSymbol " &#8594; " " -&gt; ")
17045 def depArrowLongPrefix  := bracketedBinder true &gt;&gt; unicodeSymbol " &#8594; " " -&gt; "
17046 def depArrowPrefix      := depArrowShortPrefix &lt;|&gt; depArrowLongPrefix
17047 @[builtinTermParser] def depArrow := leading_parser depArrowPrefix &gt;&gt; termParser
17048 ```
17049 Note that no changes in the elaborator are needed.
17050 We decided to not use it because terms such as `{&#945;} &#8594; &#945; &#8594; &#945;` may look too cryptic.
17051 Note that we did not add a `explicitShortBinder` parser since `(&#945;) &#8594; &#945; &#8594; &#945;` is really cryptic as a short for `(&#945; : Type) &#8594; &#945; &#8594; &#945;`.
17052 -/</span>
<span class="doc">17053 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">depArrow</span> <span class="constant">:=</span> leading_parser:<span class="constant">25</span> bracketedBinder true <span class="constant">&gt;&gt;</span> unicodeSymbol <span class="string">" &#8594; "</span> <span class="string">" -&gt; "</span> <span class="constant">&gt;&gt;</span> termParser
17054 
<span class="keyword">17055 def</span> <span class="function-name">simpleBinder</span> <span class="constant">:=</span> leading_parser many1 binderIdent <span class="constant">&gt;&gt;</span> optType
<span class="doc">17056 @[builtinTermParser]</span>
<span class="keyword">17057 def</span> <span class="comment">&#171;</span>forall<span class="comment">&#187;</span> <span class="constant">:=</span> leading_parser:leadPrec unicodeSymbol <span class="string">"&#8704;"</span> <span class="string">"forall"</span> <span class="constant">&gt;&gt;</span> many1 (ppSpace <span class="constant">&gt;&gt;</span> (simpleBinder <span class="constant">&lt;</span>|<span class="constant">&gt;</span> bracketedBinder)) <span class="constant">&gt;&gt;</span> <span class="string">", "</span> <span class="constant">&gt;&gt;</span> termParser
17058 
<span class="keyword">17059 def</span> <span class="function-name">matchAlt</span> (rhsParser : Parser <span class="constant">:=</span> termParser) : Parser <span class="constant">:=</span>
17060   nodeWithAntiquot <span class="string">"matchAlt"</span> `Lean.Parser.Term.matchAlt <span class="constant">$</span>
17061     <span class="string">"| "</span> <span class="constant">&gt;&gt;</span> ppIndent (sepBy1 termParser <span class="string">", "</span> <span class="constant">&gt;&gt;</span> darrow <span class="constant">&gt;&gt;</span> checkColGe <span class="string">"alternative right-hand-side to start in a column greater than or equal to the corresponding '|'"</span> <span class="constant">&gt;&gt;</span> rhsParser)
<span class="comment-delimiter">17062 /-</span><span class="comment">-
17063   Useful for syntax quotations. Note that generic patterns such as `` `(matchAltExpr| | ... =&gt; $rhs) `` should also
17064   work with other `rhsParser`s (of arity 1). -/</span>
<span class="keyword">17065 def</span> <span class="function-name">matchAltExpr</span> <span class="constant">:=</span> matchAlt
17066 
<span class="keyword">17067 def</span> <span class="function-name">matchAlts</span> (rhsParser : Parser <span class="constant">:=</span> termParser) : Parser <span class="constant">:=</span>
17068   leading_parser ppDedent <span class="constant">$</span> withPosition <span class="constant">$</span> many1Indent (ppLine <span class="constant">&gt;&gt;</span> matchAlt rhsParser)
17069 
<span class="keyword">17070 def</span> <span class="function-name">matchDiscr</span> <span class="constant">:=</span> leading_parser optional (atomic (ident <span class="constant">&gt;&gt;</span> checkNoWsBefore <span class="string">"no space before ':'"</span> <span class="constant">&gt;&gt;</span> <span class="string">":"</span>)) <span class="constant">&gt;&gt;</span> termParser
17071 
<span class="keyword">17072 def</span> <span class="function-name">trueVal</span>  <span class="constant">:=</span> leading_parser nonReservedSymbol <span class="string">"true"</span>
<span class="keyword">17073 def</span> <span class="function-name">falseVal</span> <span class="constant">:=</span> leading_parser nonReservedSymbol <span class="string">"false"</span>
<span class="keyword">17074 def</span> <span class="function-name">generalizingParam</span> <span class="constant">:=</span> leading_parser atomic (<span class="string">"("</span> <span class="constant">&gt;&gt;</span> nonReservedSymbol <span class="string">"generalizing"</span>) <span class="constant">&gt;&gt;</span> <span class="string">" := "</span> <span class="constant">&gt;&gt;</span> (trueVal <span class="constant">&lt;</span>|<span class="constant">&gt;</span> falseVal)  <span class="constant">&gt;&gt;</span> <span class="string">")"</span>
17075 
<span class="doc">17076 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>match<span class="comment">&#187;</span> <span class="constant">:=</span> leading_parser:leadPrec <span class="string">"match "</span> <span class="constant">&gt;&gt;</span> optional generalizingParam <span class="constant">&gt;&gt;</span> sepBy1 matchDiscr <span class="string">", "</span> <span class="constant">&gt;&gt;</span> optType <span class="constant">&gt;&gt;</span> <span class="string">" with "</span> <span class="constant">&gt;&gt;</span> matchAlts
<span class="doc">17077 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>nomatch<span class="comment">&#187;</span> <span class="constant">:=</span> leading_parser:leadPrec <span class="string">"nomatch "</span> <span class="constant">&gt;&gt;</span> termParser
17078 
<span class="keyword">17079 def</span> <span class="function-name">funImplicitBinder</span> <span class="constant">:=</span> atomic (lookahead (<span class="string">"{"</span> <span class="constant">&gt;&gt;</span> many1 binderIdent <span class="constant">&gt;&gt;</span> (symbol <span class="string">" : "</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> <span class="string">"}"</span>))) <span class="constant">&gt;&gt;</span> implicitBinder
<span class="keyword">17080 def</span> <span class="function-name">funSimpleBinder</span>   <span class="constant">:=</span> atomic (lookahead (many1 binderIdent <span class="constant">&gt;&gt;</span> <span class="string">" : "</span>)) <span class="constant">&gt;&gt;</span> simpleBinder
<span class="keyword">17081 def</span> <span class="function-name">funBinder</span> : Parser <span class="constant">:=</span> funImplicitBinder <span class="constant">&lt;</span>|<span class="constant">&gt;</span> instBinder <span class="constant">&lt;</span>|<span class="constant">&gt;</span> funSimpleBinder <span class="constant">&lt;</span>|<span class="constant">&gt;</span> termParser maxPrec
<span class="comment-delimiter">17082 -- </span><span class="comment">NOTE: we use `nodeWithAntiquot` to ensure that `fun $b =&gt; ...` remains a `term` antiquotation
</span><span class="keyword">17083 def</span> <span class="function-name">basicFun</span> : Parser <span class="constant">:=</span> nodeWithAntiquot <span class="string">"basicFun"</span> `Lean.Parser.Term.basicFun (many1 (ppSpace <span class="constant">&gt;&gt;</span> funBinder) <span class="constant">&gt;&gt;</span> darrow <span class="constant">&gt;&gt;</span> termParser)
<span class="doc">17084 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>fun<span class="comment">&#187;</span> <span class="constant">:=</span> leading_parser:maxPrec unicodeSymbol <span class="string">"&#955;"</span> <span class="string">"fun"</span> <span class="constant">&gt;&gt;</span> (basicFun <span class="constant">&lt;</span>|<span class="constant">&gt;</span> matchAlts)
17085 
<span class="keyword">17086 def</span> <span class="function-name">optExprPrecedence</span> <span class="constant">:=</span> optional (atomic <span class="string">":"</span> <span class="constant">&gt;&gt;</span> termParser maxPrec)
<span class="doc">17087 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>leading_parser<span class="comment">&#187;</span>  <span class="constant">:=</span> leading_parser:leadPrec <span class="string">"leading_parser "</span> <span class="constant">&gt;&gt;</span> optExprPrecedence <span class="constant">&gt;&gt;</span> termParser
<span class="doc">17088 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>trailing_parser<span class="comment">&#187;</span> <span class="constant">:=</span> leading_parser:leadPrec <span class="string">"trailing_parser "</span> <span class="constant">&gt;&gt;</span> optExprPrecedence <span class="constant">&gt;&gt;</span> optExprPrecedence <span class="constant">&gt;&gt;</span> termParser
17089 
<span class="doc">17090 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">borrowed</span>   <span class="constant">:=</span> leading_parser <span class="string">"@&amp;"</span> <span class="constant">&gt;&gt;</span> termParser leadPrec
<span class="doc">17091 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">quotedName</span> <span class="constant">:=</span> leading_parser nameLit
<span class="doc">17092 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">doubleQuotedName</span> <span class="constant">:=</span> leading_parser <span class="string">"`"</span> <span class="constant">&gt;&gt;</span> checkNoWsBefore <span class="constant">&gt;&gt;</span> nameLit
17093 
<span class="keyword">17094 def</span> <span class="function-name">simpleBinderWithoutType</span> <span class="constant">:=</span> nodeWithAntiquot <span class="string">"simpleBinder"</span> `Lean.Parser.Term.simpleBinder (anonymous <span class="constant">:=</span> true)
17095   (many1 binderIdent <span class="constant">&gt;&gt;</span> pushNone)
17096 
<span class="comment-delimiter">17097 /- </span><span class="comment">Remark: we use `checkWsBefore` to ensure `let x[i] := e; b` is not parsed as `let x [i] := e; b` where `[i]` is an `instBinder`. -/</span>
<span class="keyword">17098 def</span> <span class="function-name">letIdLhs</span>    : Parser <span class="constant">:=</span> ident <span class="constant">&gt;&gt;</span> checkWsBefore <span class="string">"expected space before binders"</span> <span class="constant">&gt;&gt;</span> many (ppSpace <span class="constant">&gt;&gt;</span> (simpleBinderWithoutType <span class="constant">&lt;</span>|<span class="constant">&gt;</span> bracketedBinder)) <span class="constant">&gt;&gt;</span> optType
<span class="keyword">17099 def</span> <span class="function-name">letIdDecl</span>   <span class="constant">:=</span> nodeWithAntiquot <span class="string">"letIdDecl"</span>   `Lean.Parser.Term.letIdDecl   <span class="constant">$</span> atomic (letIdLhs <span class="constant">&gt;&gt;</span> <span class="string">" := "</span>) <span class="constant">&gt;&gt;</span> termParser
<span class="keyword">17100 def</span> <span class="function-name">letPatDecl</span>  <span class="constant">:=</span> nodeWithAntiquot <span class="string">"letPatDecl"</span>  `Lean.Parser.Term.letPatDecl  <span class="constant">$</span> atomic (termParser <span class="constant">&gt;&gt;</span> pushNone <span class="constant">&gt;&gt;</span> optType <span class="constant">&gt;&gt;</span> <span class="string">" := "</span>) <span class="constant">&gt;&gt;</span> termParser
<span class="keyword">17101 def</span> <span class="function-name">letEqnsDecl</span> <span class="constant">:=</span> nodeWithAntiquot <span class="string">"letEqnsDecl"</span> `Lean.Parser.Term.letEqnsDecl <span class="constant">$</span> letIdLhs <span class="constant">&gt;&gt;</span> matchAlts
<span class="comment-delimiter">17102 -- </span><span class="comment">Remark: we use `nodeWithAntiquot` here to make sure anonymous antiquotations (e.g., `$x`) are not `letDecl`
</span><span class="keyword">17103 def</span> <span class="function-name">letDecl</span>     <span class="constant">:=</span> nodeWithAntiquot <span class="string">"letDecl"</span> `Lean.Parser.Term.letDecl (notFollowedBy (nonReservedSymbol <span class="string">"rec"</span>) <span class="string">"rec"</span> <span class="constant">&gt;&gt;</span> (letIdDecl <span class="constant">&lt;</span>|<span class="constant">&gt;</span> letPatDecl <span class="constant">&lt;</span>|<span class="constant">&gt;</span> letEqnsDecl))
<span class="doc">17104 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>let<span class="comment">&#187;</span> <span class="constant">:=</span> leading_parser:leadPrec  withPosition (<span class="string">"let "</span> <span class="constant">&gt;&gt;</span> letDecl) <span class="constant">&gt;&gt;</span> optSemicolon termParser
<span class="doc">17105 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>let_fun<span class="comment">&#187;</span>     <span class="constant">:=</span> leading_parser:leadPrec withPosition ((symbol <span class="string">"let_fun "</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> <span class="string">"let_&#955;"</span>) <span class="constant">&gt;&gt;</span> letDecl) <span class="constant">&gt;&gt;</span> optSemicolon termParser
<span class="doc">17106 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="comment">&#171;</span>let_delayed<span class="comment">&#187;</span> <span class="constant">:=</span> leading_parser:leadPrec withPosition (<span class="string">"let_delayed "</span> <span class="constant">&gt;&gt;</span> letDecl) <span class="constant">&gt;&gt;</span> optSemicolon termParser
17107 
<span class="keyword">17108 def</span> <span class="comment">&#171;</span>scoped<span class="comment">&#187;</span> <span class="constant">:=</span> leading_parser <span class="string">"scoped "</span>
<span class="keyword">17109 def</span> <span class="comment">&#171;</span>local<span class="comment">&#187;</span>  <span class="constant">:=</span> leading_parser <span class="string">"local "</span>
<span class="keyword">17110 def</span> <span class="function-name">attrKind</span> <span class="constant">:=</span> leading_parser optional (<span class="comment">&#171;</span>scoped<span class="comment">&#187;</span> <span class="constant">&lt;</span>|<span class="constant">&gt;</span> <span class="comment">&#171;</span>local<span class="comment">&#187;</span>)
<span class="keyword">17111 def</span> <span class="function-name">attrInstance</span>     <span class="constant">:=</span> ppGroup <span class="constant">$</span> leading_parser attrKind <span class="constant">&gt;&gt;</span> attrParser
17112 
<span class="keyword">17113 def</span> <span class="function-name">attributes</span>       <span class="constant">:=</span> leading_parser <span class="string">"@["</span> <span class="constant">&gt;&gt;</span> sepBy1 attrInstance <span class="string">", "</span> <span class="constant">&gt;&gt;</span> <span class="string">"]"</span>
<span class="keyword">17114 def</span> <span class="function-name">letRecDecl</span>       <span class="constant">:=</span> leading_parser optional Command.docComment <span class="constant">&gt;&gt;</span> optional <span class="comment">&#171;</span>attributes<span class="comment">&#187;</span> <span class="constant">&gt;&gt;</span> letDecl
<span class="keyword">17115 def</span> <span class="function-name">letRecDecls</span>      <span class="constant">:=</span> leading_parser sepBy1 letRecDecl <span class="string">", "</span>
<span class="doc">17116 @[builtinTermParser]</span>
<span class="keyword">17117 def</span> <span class="comment">&#171;</span>letrec<span class="comment">&#187;</span> <span class="constant">:=</span> leading_parser:leadPrec withPosition (group (<span class="string">"let "</span> <span class="constant">&gt;&gt;</span> nonReservedSymbol <span class="string">"rec "</span>) <span class="constant">&gt;&gt;</span> letRecDecls) <span class="constant">&gt;&gt;</span> optSemicolon termParser
17118 
<span class="doc">17119 @[runBuiltinParserAttributeHooks]</span>
<span class="keyword">17120 def</span> <span class="function-name">whereDecls</span> <span class="constant">:=</span> leading_parser <span class="string">"where "</span> <span class="constant">&gt;&gt;</span> many1Indent (group (letRecDecl <span class="constant">&gt;&gt;</span> optional <span class="string">";"</span>))
<span class="doc">17121 @[runBuiltinParserAttributeHooks]</span>
<span class="keyword">17122 def</span> <span class="function-name">matchAltsWhereDecls</span> <span class="constant">:=</span> leading_parser matchAlts <span class="constant">&gt;&gt;</span> optional whereDecls
17123 
<span class="doc">17124 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">noindex</span> <span class="constant">:=</span> leading_parser <span class="string">"no_index "</span> <span class="constant">&gt;&gt;</span> termParser maxPrec
17125 
<span class="doc">17126 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">binrel</span>  <span class="constant">:=</span> leading_parser <span class="string">"binrel% "</span> <span class="constant">&gt;&gt;</span> ident <span class="constant">&gt;&gt;</span> ppSpace <span class="constant">&gt;&gt;</span> termParser maxPrec <span class="constant">&gt;&gt;</span> termParser maxPrec
17127 
<span class="doc">17128 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">forInMacro</span> <span class="constant">:=</span> leading_parser <span class="string">"forIn% "</span> <span class="constant">&gt;&gt;</span> termParser maxPrec <span class="constant">&gt;&gt;</span> termParser maxPrec <span class="constant">&gt;&gt;</span> termParser maxPrec
17129 
<span class="doc">17130 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">typeOf</span>             <span class="constant">:=</span> leading_parser <span class="string">"typeOf% "</span> <span class="constant">&gt;&gt;</span> termParser maxPrec
<span class="doc">17131 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">ensureTypeOf</span>       <span class="constant">:=</span> leading_parser <span class="string">"ensureTypeOf% "</span> <span class="constant">&gt;&gt;</span> termParser maxPrec <span class="constant">&gt;&gt;</span> strLit <span class="constant">&gt;&gt;</span> termParser
<span class="doc">17132 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">ensureExpectedType</span> <span class="constant">:=</span> leading_parser <span class="string">"ensureExpectedType% "</span> <span class="constant">&gt;&gt;</span> strLit <span class="constant">&gt;&gt;</span> termParser maxPrec
<span class="doc">17133 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">noImplicitLambda</span>   <span class="constant">:=</span> leading_parser <span class="string">"noImplicitLambda% "</span> <span class="constant">&gt;&gt;</span> termParser maxPrec
17134 
<span class="keyword">17135 def</span> <span class="function-name">namedArgument</span>  <span class="constant">:=</span> leading_parser atomic (<span class="string">"("</span> <span class="constant">&gt;&gt;</span> ident <span class="constant">&gt;&gt;</span> <span class="string">" := "</span>) <span class="constant">&gt;&gt;</span> termParser <span class="constant">&gt;&gt;</span> <span class="string">")"</span>
<span class="keyword">17136 def</span> <span class="function-name">ellipsis</span>       <span class="constant">:=</span> leading_parser <span class="string">".."</span>
<span class="keyword">17137 def</span> <span class="function-name">argument</span>       <span class="constant">:=</span>
17138   checkWsBefore <span class="string">"expected space"</span> <span class="constant">&gt;&gt;</span>
17139   checkColGt <span class="string">"expected to be indented"</span> <span class="constant">&gt;&gt;</span>
17140   (namedArgument <span class="constant">&lt;</span>|<span class="constant">&gt;</span> ellipsis <span class="constant">&lt;</span>|<span class="constant">&gt;</span> termParser argPrec)
<span class="comment-delimiter">17141 -- </span><span class="comment">`app` precedence is `lead` (cannot be used as argument)
</span><span class="comment-delimiter">17142 -- </span><span class="comment">`lhs` precedence is `max` (i.e. does not accept `arg` precedence)
</span><span class="comment-delimiter">17143 -- </span><span class="comment">argument precedence is `arg` (i.e. does not accept `lead` precedence)
</span><span class="doc">17144 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">app</span>      <span class="constant">:=</span> trailing_parser:leadPrec:maxPrec many1 argument
17145 
<span class="doc">17146 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">proj</span>     <span class="constant">:=</span> trailing_parser checkNoWsBefore <span class="constant">&gt;&gt;</span> <span class="string">"."</span> <span class="constant">&gt;&gt;</span> checkNoWsBefore <span class="constant">&gt;&gt;</span> (fieldIdx <span class="constant">&lt;</span>|<span class="constant">&gt;</span> ident)
<span class="doc">17147 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">completion</span> <span class="constant">:=</span> trailing_parser checkNoWsBefore <span class="constant">&gt;&gt;</span> <span class="string">"."</span>
<span class="doc">17148 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">arrayRef</span> <span class="constant">:=</span> trailing_parser checkNoWsBefore <span class="constant">&gt;&gt;</span> <span class="string">"["</span> <span class="constant">&gt;&gt;</span> termParser <span class="constant">&gt;&gt;</span><span class="string">"]"</span>
<span class="doc">17149 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">arrow</span>    <span class="constant">:=</span> trailing_parser checkPrec <span class="constant">25</span> <span class="constant">&gt;&gt;</span> unicodeSymbol <span class="string">" &#8594; "</span> <span class="string">" -&gt; "</span> <span class="constant">&gt;&gt;</span> termParser <span class="constant">25</span>
17150 
<span class="keyword">17151 def</span> <span class="function-name">isIdent</span> (stx : Syntax) : Bool <span class="constant">:=</span>
17152   <span class="comment-delimiter">-- </span><span class="comment">antiquotations should also be allowed where an identifier is expected
</span>17153   stx.isAntiquot <span class="constant">||</span> stx.isIdent
17154 
<span class="doc">17155 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">explicitUniv</span> : TrailingParser <span class="constant">:=</span> trailing_parser checkStackTop isIdent <span class="string">"expected preceding identifier"</span> <span class="constant">&gt;&gt;</span> checkNoWsBefore <span class="string">"no space before '.{'"</span> <span class="constant">&gt;&gt;</span> <span class="string">".{"</span> <span class="constant">&gt;&gt;</span> sepBy1 levelParser <span class="string">", "</span> <span class="constant">&gt;&gt;</span> <span class="string">"}"</span>
<span class="doc">17156 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">namedPattern</span> : TrailingParser <span class="constant">:=</span> trailing_parser checkStackTop isIdent <span class="string">"expected preceding identifier"</span> <span class="constant">&gt;&gt;</span> checkNoWsBefore <span class="string">"no space before '@'"</span> <span class="constant">&gt;&gt;</span> <span class="string">"@"</span> <span class="constant">&gt;&gt;</span> termParser maxPrec
17157 
<span class="doc">17158 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">pipeProj</span>   <span class="constant">:=</span> trailing_parser:minPrec <span class="string">" |&gt;."</span> <span class="constant">&gt;&gt;</span> checkNoWsBefore <span class="constant">&gt;&gt;</span> (fieldIdx <span class="constant">&lt;</span>|<span class="constant">&gt;</span> ident) <span class="constant">&gt;&gt;</span> many argument
<span class="doc">17159 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">pipeCompletion</span> <span class="constant">:=</span> trailing_parser:minPrec <span class="string">" |&gt;."</span>
17160 
<span class="doc">17161 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">subst</span> <span class="constant">:=</span> trailing_parser:<span class="constant">75</span> <span class="string">" &#9656; "</span> <span class="constant">&gt;&gt;</span> sepBy1 (termParser <span class="constant">75</span>) <span class="string">" &#9656; "</span>
17162 
<span class="comment-delimiter">17163 -- </span><span class="comment">NOTE: Doesn't call `categoryParser` directly in contrast to most other "static" quotations, so call `evalInsideQuot` explicitly
</span><span class="doc">17164 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">funBinder.quot</span> : Parser <span class="constant">:=</span> leading_parser <span class="string">"`(funBinder|"</span>  <span class="constant">&gt;&gt;</span> toggleInsideQuot (evalInsideQuot ``funBinder funBinder) <span class="constant">&gt;&gt;</span> <span class="string">")"</span>
<span class="keyword">17165 def</span> <span class="function-name">bracketedBinderF</span> <span class="constant">:=</span> bracketedBinder  <span class="comment-delimiter">-- </span><span class="comment">no default arg
</span><span class="doc">17166 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">bracketedBinder.quot</span> : Parser <span class="constant">:=</span> leading_parser <span class="string">"`(bracketedBinder|"</span>  <span class="constant">&gt;&gt;</span> toggleInsideQuot (evalInsideQuot ``bracketedBinderF bracketedBinder) <span class="constant">&gt;&gt;</span> <span class="string">")"</span>
<span class="doc">17167 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">matchDiscr.quot</span> : Parser <span class="constant">:=</span> leading_parser <span class="string">"`(matchDiscr|"</span>  <span class="constant">&gt;&gt;</span> toggleInsideQuot (evalInsideQuot ``matchDiscr matchDiscr) <span class="constant">&gt;&gt;</span> <span class="string">")"</span>
<span class="doc">17168 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">attr.quot</span> : Parser <span class="constant">:=</span> leading_parser <span class="string">"`(attr|"</span>  <span class="constant">&gt;&gt;</span> toggleInsideQuot attrParser <span class="constant">&gt;&gt;</span> <span class="string">")"</span>
17169 
<span class="doc">17170 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">panic</span>       <span class="constant">:=</span> leading_parser:leadPrec <span class="string">"panic! "</span> <span class="constant">&gt;&gt;</span> termParser
<span class="doc">17171 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">unreachable</span> <span class="constant">:=</span> leading_parser:leadPrec <span class="string">"unreachable!"</span>
<span class="doc">17172 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">dbgTrace</span>    <span class="constant">:=</span> leading_parser:leadPrec withPosition (<span class="string">"dbg_trace"</span> <span class="constant">&gt;&gt;</span> ((interpolatedStr termParser) <span class="constant">&lt;</span>|<span class="constant">&gt;</span> termParser)) <span class="constant">&gt;&gt;</span> optSemicolon termParser
<span class="doc">17173 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">assert</span>      <span class="constant">:=</span> leading_parser:leadPrec withPosition (<span class="string">"assert! "</span> <span class="constant">&gt;&gt;</span> termParser) <span class="constant">&gt;&gt;</span> optSemicolon termParser
17174 
17175 
<span class="keyword">17176 def</span> <span class="function-name">macroArg</span>       <span class="constant">:=</span> termParser maxPrec
<span class="keyword">17177 def</span> <span class="function-name">macroDollarArg</span> <span class="constant">:=</span> leading_parser <span class="string">"$"</span> <span class="constant">&gt;&gt;</span> termParser <span class="constant">10</span>
<span class="keyword">17178 def</span> <span class="function-name">macroLastArg</span>   <span class="constant">:=</span> macroDollarArg <span class="constant">&lt;</span>|<span class="constant">&gt;</span> macroArg
17179 
<span class="comment-delimiter">17180 -- </span><span class="comment">Macro for avoiding exponentially big terms when using `STWorld`
</span><span class="doc">17181 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">stateRefT</span>   <span class="constant">:=</span> leading_parser <span class="string">"StateRefT"</span> <span class="constant">&gt;&gt;</span> macroArg <span class="constant">&gt;&gt;</span> macroLastArg
17182 
<span class="doc">17183 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">dynamicQuot</span> <span class="constant">:=</span> leading_parser <span class="string">"`("</span> <span class="constant">&gt;&gt;</span> ident <span class="constant">&gt;&gt;</span> <span class="string">"|"</span> <span class="constant">&gt;&gt;</span> toggleInsideQuot (parserOfStack <span class="constant">1</span>) <span class="constant">&gt;&gt;</span> <span class="string">")"</span>
17184 
<span class="keyword">17185 end</span> Term
17186 
<span class="doc">17187 @[builtinTermParser default+1]</span> <span class="keyword">def</span> <span class="function-name">Tactic.quot</span>    : Parser <span class="constant">:=</span> leading_parser <span class="string">"`(tactic|"</span> <span class="constant">&gt;&gt;</span> toggleInsideQuot tacticParser <span class="constant">&gt;&gt;</span> <span class="string">")"</span>
<span class="doc">17188 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">Tactic.quotSeq</span> : Parser <span class="constant">:=</span> leading_parser <span class="string">"`(tactic|"</span> <span class="constant">&gt;&gt;</span> toggleInsideQuot Tactic.seq1 <span class="constant">&gt;&gt;</span> <span class="string">")"</span>
17189 
<span class="doc">17190 @[builtinTermParser]</span> <span class="keyword">def</span> <span class="function-name">Level.quot</span>  : Parser <span class="constant">:=</span> leading_parser <span class="string">"`(level|"</span> <span class="constant">&gt;&gt;</span> toggleInsideQuot levelParser <span class="constant">&gt;&gt;</span> <span class="string">")"</span>
17191 
<span class="keyword">17192 builtin_initialize</span>
17193   register_parser_alias <span class="string">"letDecl"</span>         Term.letDecl
17194   register_parser_alias <span class="string">"haveDecl"</span>        Term.haveDecl
17195   register_parser_alias <span class="string">"sufficesDecl"</span>    Term.sufficesDecl
17196   register_parser_alias <span class="string">"letRecDecls"</span>     Term.letRecDecls
17197   register_parser_alias <span class="string">"hole"</span>            Term.hole
17198   register_parser_alias <span class="string">"syntheticHole"</span>   Term.syntheticHole
17199   register_parser_alias <span class="string">"matchDiscr"</span>      Term.matchDiscr
17200   register_parser_alias <span class="string">"bracketedBinder"</span> Term.bracketedBinder
17201   register_parser_alias <span class="string">"attrKind"</span>        Term.attrKind
17202 
<span class="keyword">17203 end</span> Parser
<span class="keyword">17204 end</span> Lean
</pre>
  </body>
</html>
